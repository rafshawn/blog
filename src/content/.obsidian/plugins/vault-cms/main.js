/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/GitManager.ts
var GitManager_exports = {};
__export(GitManager_exports, {
  GitManager: () => GitManager
});
var import_obsidian17, import_child_process, import_util, path7, fs6, execAsync, GitManager;
var init_GitManager = __esm({
  "src/utils/GitManager.ts"() {
    import_obsidian17 = require("obsidian");
    import_child_process = require("child_process");
    import_util = require("util");
    path7 = __toESM(require("path"), 1);
    fs6 = __toESM(require("fs"), 1);
    execAsync = (0, import_util.promisify)(import_child_process.exec);
    GitManager = class {
      /**
       * Checks if a directory is a Git repository.
       */
      static async isRepo(projectRoot) {
        if (!projectRoot) return false;
        try {
          const absolutePath = path7.resolve(projectRoot);
          const dotGitPath = path7.join(absolutePath, ".git");
          const exists = fs6.existsSync(dotGitPath);
          console.debug("GitManager.isRepo check:", {
            projectRoot,
            absolutePath,
            dotGitPath,
            exists
          });
          if (!fs6.existsSync(absolutePath)) return false;
          return exists;
        } catch (error) {
          console.error("GitManager.isRepo error:", error);
          return false;
        }
      }
      /**
       * Initializes a new Git repository at the given path.
       */
      static async initRepo(projectRoot) {
        await execAsync("git init", { cwd: projectRoot });
      }
      /**
       * Sets the remote URL for the repository.
       */
      static async setRemote(projectRoot, url, remoteName = "origin") {
        try {
          await execAsync(`git remote add ${remoteName} ${url}`, { cwd: projectRoot });
        } catch (error) {
          if (error instanceof Error && error.message.includes("already exists")) {
            await execAsync(`git remote set-url ${remoteName} ${url}`, { cwd: projectRoot });
          } else {
            throw error;
          }
        }
      }
      /**
       * Gets the remote URL for the repository, scrubbing any tokens for security.
       */
      static async getRemoteUrl(projectRoot, remoteName = "origin") {
        try {
          const { stdout } = await execAsync(`git remote get-url ${remoteName}`, { cwd: projectRoot });
          let url = stdout.trim() || null;
          if (url && url.includes("@github.com")) {
            url = url.replace(/https:\/\/.*@github\.com/, "https://github.com");
          }
          return url;
        } catch (e) {
          return null;
        }
      }
      /**
       * Gets the current local branch name.
       */
      static async getCurrentBranch(projectRoot) {
        try {
          const { stdout } = await execAsync("git branch --show-current", { cwd: projectRoot });
          return stdout.trim() || "main";
        } catch (e) {
          return "main";
        }
      }
      /**
       * Creates an initial commit and pushes to the remote, setting the upstream.
       */
      static async initialCommitAndPush(projectRoot, branch, remoteName = "origin", token) {
        try {
          console.debug("GitManager.initialCommitAndPush: starting", { projectRoot, branch, remoteName, hasToken: !!token });
          try {
            await execAsync("git config user.name", { cwd: projectRoot });
          } catch (e) {
            console.debug("GitManager: Setting local git user.name");
            await execAsync('git config user.name "Vault CMS User"', { cwd: projectRoot });
            await execAsync('git config user.email "vault-cms@example.com"', { cwd: projectRoot });
          }
          await execAsync("git add .", { cwd: projectRoot });
          try {
            await execAsync('git commit -m "Initial commit from Vault CMS"', { cwd: projectRoot });
          } catch (commitError) {
            const errorMessage = commitError instanceof Error ? commitError.message : String(commitError);
            if (errorMessage.includes("nothing to commit") || errorMessage.includes("working tree clean")) {
              console.debug("GitManager: Nothing to commit");
            } else {
              throw commitError;
            }
          }
          await execAsync(`git branch -M ${branch}`, { cwd: projectRoot });
          if (token) {
            const remoteUrl = await this.getRemoteUrl(projectRoot, remoteName);
            if (remoteUrl && remoteUrl.startsWith("https://")) {
              const authenticatedUrl = remoteUrl.replace("https://", `https://${token}@`);
              console.debug("GitManager: Pushing with temporary token auth");
              await execAsync(`git remote set-url ${remoteName} ${authenticatedUrl}`, { cwd: projectRoot });
              try {
                await execAsync(`git push -u ${remoteName} ${branch}`, { cwd: projectRoot });
              } finally {
                await execAsync(`git remote set-url ${remoteName} ${remoteUrl}`, { cwd: projectRoot });
              }
            } else {
              await execAsync(`git push -u ${remoteName} ${branch}`, { cwd: projectRoot });
            }
          } else {
            await execAsync(`git push -u ${remoteName} ${branch}`, { cwd: projectRoot });
          }
        } catch (error) {
          console.error("GitManager.initialCommitAndPush failed:", error);
          throw error;
        }
      }
      /**
       * Creates a new repository on GitHub.
       */
      static async createGitHubRepo(token, name, description, isPrivate) {
        var _a, _b;
        const params = {
          url: "https://api.github.com/user/repos",
          method: "POST",
          headers: {
            "Authorization": `token ${token}`,
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            name,
            description,
            private: isPrivate
          })
        };
        try {
          const response = await (0, import_obsidian17.requestUrl)(params);
          if (response.status === 422) {
            throw new Error("Repository name already exists on your GitHub account.");
          }
          if (response.status !== 201) {
            let errorMessage = `GitHub API Error: ${response.status}`;
            try {
              const errorData = typeof response.json === "string" ? JSON.parse(response.json) : response.json;
              if (errorData == null ? void 0 : errorData.message) {
                errorMessage = `GitHub API Error: ${errorData.message}`;
                if ((_b = (_a = errorData.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) {
                  errorMessage += ` (${errorData.errors[0].message})`;
                }
              }
            } catch (e) {
            }
            throw new Error(errorMessage);
          }
          return response.json;
        } catch (error) {
          if (error instanceof Error && (error.message.includes("already exists") || error.message.includes("GitHub API Error"))) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          if (message.includes("422") || message.includes("already exists")) {
            throw new Error("Repository name already exists on your GitHub account.");
          }
          throw error;
        }
      }
      /**
       * Verifies if the GitHub PAT is valid and returns the username.
       */
      static async verifyToken(token) {
        var _a;
        try {
          const params = {
            url: "https://api.github.com/user",
            method: "GET",
            headers: {
              "Authorization": `token ${token}`,
              "Accept": "application/vnd.github.v3+json"
            }
          };
          const response = await (0, import_obsidian17.requestUrl)(params);
          if (response.status === 200) {
            return ((_a = response.json) == null ? void 0 : _a.login) || null;
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultCMSPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian30 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  projectRoot: "",
  configFilePath: "",
  contentTypes: [],
  frontmatterProperties: {},
  attachmentHandlingMode: "subfolder",
  attachmentFolderName: void 0,
  preset: "vanilla",
  presetName: "",
  presetsRepo: "davidvkimball/vault-cms-presets",
  enableEditingToolbar: false,
  enableExtendedFileTypes: false,
  enabledPlugins: [],
  disabledPlugins: [],
  theme: "",
  basesCMSConfig: {
    views: []
  },
  astroComposerConfig: {
    customContentTypes: [],
    defaultTemplate: "",
    configFilePath: "",
    terminalProjectRootPath: ""
  },
  seoConfig: {
    titleProperty: "title",
    descriptionProperty: void 0,
    scanDirectories: "",
    useFilenameAsTitle: false,
    useFilenameAsSlug: true,
    enableMDXSupport: false
  },
  propertyOverFileName: {
    propertyKey: "title"
  },
  imageManager: {},
  homeBase: {},
  explorerFocus: {},
  ignoreConfig: {
    gitIgnoreConfigured: false,
    viteIgnoreConfigured: false
  },
  gitConfig: {
    enabled: false,
    isPrivate: true,
    branchName: "main",
    autoConfigureObsidianGit: true
  },
  runWizardOnStartup: true,
  wizardCompleted: false
};

// src/ui/SettingsTab.ts
var import_obsidian29 = require("obsidian");

// src/ui/SetupWizardModal.ts
var import_obsidian24 = require("obsidian");

// src/utils/ImageManagerConfig.ts
var import_obsidian = require("obsidian");
var ImageManagerConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async loadConfig() {
    var _a;
    const pluginId = "image-manager";
    try {
      const plugins = this.app.plugins;
      const imageManagerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (imageManagerPlugin && imageManagerPlugin.settings) {
        return imageManagerPlugin.settings;
      }
    } catch (error) {
      console.warn("Failed to load Image Manager config from plugin API:", error);
    }
    return await this.loadConfigFallback();
  }
  async loadConfigFallback() {
    const pluginId = "image-manager";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      try {
        const existingData = JSON.parse(await this.app.vault.read(dataFile));
        return existingData;
      } catch (error) {
        console.warn("Failed to parse existing Image Manager data.json:", error);
        return {};
      }
    }
    return {};
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "image-manager";
    try {
      const plugins = this.app.plugins;
      const imageManagerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (imageManagerPlugin && imageManagerPlugin.settings) {
        const pluginSettings = imageManagerPlugin.settings;
        Object.assign(pluginSettings, config);
        if (typeof imageManagerPlugin.saveSettings === "function") {
          await imageManagerPlugin.saveSettings();
          console.debug("ImageManagerConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Image Manager config:", error);
      try {
        await this.saveConfigFallback(config);
      } catch (fallbackError) {
        console.error("Failed to save Image Manager config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "image-manager";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Image Manager data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(mergedData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
  /**
   * Resolves the image property from the wizard state and syncs it to Image Manager settings
   */
  async resolveAndSyncImageProperty(state) {
    var _a, _b;
    const contentTypes = state.contentTypes || [];
    const frontmatterProperties = state.frontmatterProperties || {};
    const defaultTypeId = state.defaultContentTypeId;
    let resolvedImageProperty;
    if (defaultTypeId && ((_a = frontmatterProperties[defaultTypeId]) == null ? void 0 : _a.imageProperty)) {
      resolvedImageProperty = frontmatterProperties[defaultTypeId].imageProperty;
    }
    if (!resolvedImageProperty) {
      for (const type of contentTypes) {
        if ((_b = frontmatterProperties[type.id]) == null ? void 0 : _b.imageProperty) {
          resolvedImageProperty = frontmatterProperties[type.id].imageProperty;
          break;
        }
      }
    }
    if (resolvedImageProperty) {
      const config = await this.loadConfig();
      config.defaultPropertyName = resolvedImageProperty;
      if (config.banner) {
        if (typeof config.banner === "object") {
          if (!config.banner.properties) {
            config.banner.properties = {};
          }
          config.banner.properties.imageProperty = resolvedImageProperty;
        }
      } else {
        config.banner = {
          properties: {
            imageProperty: resolvedImageProperty
          }
        };
      }
      await this.saveConfig(config);
      if (state.imageManager) {
        state.imageManager.defaultPropertyName = resolvedImageProperty;
        if (state.imageManager.banner) {
          if (typeof state.imageManager.banner === "object") {
            if (!state.imageManager.banner.properties) {
              state.imageManager.banner.properties = {};
            }
            state.imageManager.banner.properties.imageProperty = resolvedImageProperty;
          }
        } else {
          state.imageManager.banner = {
            properties: {
              imageProperty: resolvedImageProperty
            }
          };
        }
      }
      console.debug(`ImageManagerConfigurator: Synced image property "${resolvedImageProperty}" to Image Manager and state`);
    }
  }
};

// src/utils/HomeBaseConfig.ts
var import_obsidian2 = require("obsidian");
var HomeBaseConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async loadConfig() {
    var _a;
    const pluginId = "home-base";
    try {
      const plugins = this.app.plugins;
      const homeBasePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (homeBasePlugin && homeBasePlugin.settings) {
        return homeBasePlugin.settings;
      }
    } catch (error) {
      console.warn("Failed to load Home Base config from plugin API:", error);
    }
    return await this.loadConfigFallback();
  }
  async loadConfigFallback() {
    const pluginId = "home-base";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      try {
        const existingData = JSON.parse(await this.app.vault.read(dataFile));
        return existingData;
      } catch (error) {
        console.warn("Failed to parse existing Home Base data.json:", error);
        return {};
      }
    }
    return {};
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "home-base";
    try {
      const plugins = this.app.plugins;
      const homeBasePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (homeBasePlugin && homeBasePlugin.settings) {
        const pluginSettings = homeBasePlugin.settings;
        Object.assign(pluginSettings, config);
        if (typeof homeBasePlugin.saveSettings === "function") {
          await homeBasePlugin.saveSettings();
          console.debug("HomeBaseConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Home Base config:", error);
      try {
        await this.saveConfigFallback(config);
      } catch (fallbackError) {
        console.error("Failed to save Home Base config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "home-base";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Home Base data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian2.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(mergedData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
};

// src/utils/ExplorerFocusConfig.ts
var import_obsidian3 = require("obsidian");
var ExplorerFocusConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "explorer-focus";
    try {
      const plugins = this.app.plugins;
      const explorerFocusPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (explorerFocusPlugin && explorerFocusPlugin.settings) {
        console.debug("ExplorerFocusConfig: Using plugin.settings API");
        const settings = explorerFocusPlugin.settings;
        for (const [key, value] of Object.entries(config)) {
          settings[key] = value;
        }
        if (typeof explorerFocusPlugin.saveSettings === "function") {
          await explorerFocusPlugin.saveSettings();
          console.debug("ExplorerFocusConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("ExplorerFocusConfig: Plugin API not available, using fallback file method");
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Explorer Focus config:", error);
      await this.saveConfigFallback(config);
    }
  }
  async loadConfig() {
    const pluginId = "explorer-focus";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.read(dataFile);
        return JSON.parse(content);
      }
    } catch (error) {
      console.warn("Failed to load Explorer Focus config:", error);
    }
    return null;
  }
  async saveConfigFallback(config) {
    const pluginId = "explorer-focus";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian3.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing explorer-focus data.json:", error);
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(mergedData, null, 2);
    if (dataFile instanceof import_obsidian3.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("ExplorerFocusConfig: Successfully saved explorer-focus config via fallback");
  }
};

// src/utils/EditingToolbarConfig.ts
var import_obsidian4 = require("obsidian");
var EditingToolbarConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Enable/disable the editing toolbar visibility
   */
  async toggleVisibility(app, enable) {
    var _a;
    console.debug(`EditingToolbarConfig: toggleVisibility called with enable=${enable}`);
    try {
      const plugins = app.plugins;
      if (!plugins) {
        console.warn("EditingToolbarConfig: Plugins API not available");
        return;
      }
      const editingToolbarPlugin = (_a = plugins.plugins) == null ? void 0 : _a["editing-toolbar"];
      if (!editingToolbarPlugin) {
        console.warn("EditingToolbarConfig: Editing Toolbar plugin not found");
        return;
      }
      console.debug(`EditingToolbarConfig: Editing Toolbar plugin found, enabled=${editingToolbarPlugin.enabled}`);
      console.debug(`EditingToolbarConfig: Plugin settings available:`, !!editingToolbarPlugin.settings);
      if (editingToolbarPlugin.settings) {
        console.debug(`EditingToolbarConfig: Current cMenuVisibility:`, editingToolbarPlugin.settings.cMenuVisibility);
      }
      if (editingToolbarPlugin.settings && typeof editingToolbarPlugin.saveSettings === "function") {
        console.debug("EditingToolbarConfig: Using plugin.saveSettings() method");
        const oldValue = editingToolbarPlugin.settings.cMenuVisibility;
        editingToolbarPlugin.settings.cMenuVisibility = enable;
        console.debug(`EditingToolbarConfig: Set cMenuVisibility from ${oldValue} to ${enable}`);
        await editingToolbarPlugin.saveSettings();
        console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via plugin.saveSettings()");
        console.debug("EditingToolbarConfig: Dispatching editingToolbar-NewCommand event");
        window.dispatchEvent(new Event("editingToolbar-NewCommand"));
        if (enable) {
          console.debug("EditingToolbarConfig: Waiting for settings to persist...");
          await new Promise((resolve9) => setTimeout(resolve9, 500));
          if (typeof editingToolbarPlugin.loadSettings === "function") {
            console.debug("EditingToolbarConfig: Reloading editing toolbar plugin settings");
            await editingToolbarPlugin.loadSettings();
          }
          if (typeof editingToolbarPlugin.refresh === "function") {
            console.debug("EditingToolbarConfig: Refreshing editing toolbar plugin");
            editingToolbarPlugin.refresh();
          }
        }
        return;
      } else {
        console.debug("EditingToolbarConfig: Plugin saveSettings not available, using fallback");
      }
      await this.toggleVisibilityFallback(app, enable);
    } catch (error) {
      console.error("EditingToolbarConfig: Failed to toggle editing toolbar plugin:", error);
      try {
        await this.toggleVisibilityFallback(app, enable);
      } catch (fallbackError) {
        console.error("EditingToolbarConfig: Failed to toggle editing toolbar via fallback:", fallbackError);
      }
    }
  }
  async toggleVisibilityFallback(app, enable) {
    const pluginId = "editing-toolbar";
    const configDir = app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian4.TFile) {
      try {
        existingData = JSON.parse(await app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing editing-toolbar data.json, starting fresh:", error);
        existingData = {};
      }
    }
    existingData.cMenuVisibility = enable;
    if (dataFile instanceof import_obsidian4.TFile) {
      await app.vault.modify(dataFile, JSON.stringify(existingData, null, 2));
      console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via file modify");
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
            throw error;
          }
        }
      }
      try {
        await app.vault.create(pluginDataPath, JSON.stringify(existingData, null, 2));
        console.debug("EditingToolbarConfig: Successfully created editing-toolbar data.json");
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian4.TFile) {
            await app.vault.modify(retryFile, JSON.stringify(existingData, null, 2));
            console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via retry modify");
          } else {
            await new Promise((resolve9) => setTimeout(resolve9, 200));
            const retryFile2 = app.vault.getAbstractFileByPath(pluginDataPath);
            if (retryFile2 instanceof import_obsidian4.TFile) {
              await app.vault.modify(retryFile2, JSON.stringify(existingData, null, 2));
              console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via delayed retry modify");
            } else {
              throw error;
            }
          }
        } else {
          throw error;
        }
      }
    }
  }
  /**
   * Get the current visibility of the editing toolbar
   */
  async getVisibility(app) {
    var _a;
    try {
      const plugins = app.plugins;
      const editingToolbarPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["editing-toolbar"];
      if (editingToolbarPlugin == null ? void 0 : editingToolbarPlugin.settings) {
        return editingToolbarPlugin.settings.cMenuVisibility;
      }
      const configDir = app.vault.configDir;
      const pluginDataPath = `${configDir}/plugins/editing-toolbar/data.json`;
      const dataFile = app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian4.TFile) {
        const existingData = JSON.parse(await app.vault.read(dataFile));
        return existingData.cMenuVisibility;
      }
    } catch (error) {
      console.warn("EditingToolbarConfig: Failed to get editing toolbar visibility:", error);
    }
    return void 0;
  }
};

// src/ui/wizard/WizardStateManager.ts
var WizardStateManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.editingToolbarConfigurator = new EditingToolbarConfigurator(plugin.app);
    const settings = plugin.settings;
    this.state = this.initializeState(settings);
  }
  initializeState(settings) {
    var _a, _b, _c;
    const savedProjectDetection = settings.projectRoot && settings.configFilePath ? {
      projectRoot: settings.projectRoot,
      configFilePath: settings.configFilePath,
      vaultLocation: "content"
    } : void 0;
    let attachmentHandlingMode = settings.attachmentHandlingMode;
    let attachmentFolderName = settings.attachmentFolderName;
    if (!attachmentHandlingMode) {
      const vault = this.plugin.app.vault;
      const obsidianConfig = vault.config;
      if (obsidianConfig == null ? void 0 : obsidianConfig.attachmentFolderPath) {
        const folderPath = obsidianConfig.attachmentFolderPath;
        if (folderPath === "./") {
          attachmentHandlingMode = "same-folder";
        } else if (folderPath.startsWith("./")) {
          attachmentHandlingMode = "subfolder";
          attachmentFolderName = folderPath.substring(2);
        } else {
          attachmentHandlingMode = "specified-folder";
          attachmentFolderName = folderPath;
        }
      }
    }
    return {
      currentStep: 0,
      projectDetection: savedProjectDetection,
      contentTypes: settings.contentTypes || [],
      frontmatterProperties: settings.frontmatterProperties || {},
      defaultContentTypeId: settings.defaultContentTypeId,
      attachmentHandlingMode: attachmentHandlingMode || "subfolder",
      attachmentFolderName,
      preset: settings.preset || "vanilla",
      presetName: settings.presetName || "",
      presetsRepo: settings.presetsRepo || "davidvkimball/vault-cms-presets",
      enableEditingToolbar: (_b = (_a = settings.enableEditingToolbar) != null ? _a : settings.enableWYSIWYG) != null ? _b : false,
      enableMdxSupport: settings.enableMdxSupport,
      enableExtendedFileTypes: settings.enableExtendedFileTypes,
      enabledPlugins: settings.enabledPlugins || [],
      disabledPlugins: settings.disabledPlugins || [],
      theme: settings.theme || "",
      basesCMSConfig: settings.basesCMSConfig || { views: [] },
      astroComposerConfig: settings.astroComposerConfig || {
        customContentTypes: [],
        defaultTemplate: "",
        configFilePath: "",
        terminalProjectRootPath: ""
      },
      seoConfig: settings.seoConfig || {
        titleProperty: "title",
        scanDirectories: "",
        useFilenameAsTitle: false,
        useFilenameAsSlug: true,
        enableMDXSupport: (_c = settings.enableMdxSupport) != null ? _c : false
      },
      propertyOverFileName: settings.propertyOverFileName || { propertyKey: "title" },
      imageManager: settings.imageManager || {},
      homeBase: settings.homeBase || {},
      explorerFocus: settings.explorerFocus || {},
      ignoreConfig: settings.ignoreConfig || { gitIgnoreConfigured: false, viteIgnoreConfigured: false },
      gitConfig: settings.gitConfig || { enabled: false, autoConfigureObsidianGit: true }
    };
  }
  getState() {
    return this.state;
  }
  updateState(updates) {
    this.state = { ...this.state, ...updates };
  }
  setState(updates) {
    this.state = { ...this.state, ...updates };
  }
  nextStep(totalSteps) {
    if (this.state.currentStep < totalSteps - 1) {
      this.state.currentStep++;
    }
  }
  previousStep() {
    if (this.state.currentStep > 0) {
      this.state.currentStep--;
    }
  }
  canGoNext(totalSteps) {
    return this.state.currentStep < totalSteps - 1;
  }
  canGoPrevious() {
    return this.state.currentStep > 0;
  }
  getProgress(totalSteps) {
    if (totalSteps === 0) return 0;
    return (this.state.currentStep + 1) / totalSteps * 100;
  }
  async refreshState() {
    var _a, _b;
    const settings = this.plugin.settings;
    if (settings.projectRoot && settings.configFilePath) {
      this.state.projectDetection = {
        projectRoot: settings.projectRoot,
        configFilePath: settings.configFilePath,
        vaultLocation: "content"
      };
    } else {
      this.state.projectDetection = void 0;
    }
    this.state.contentTypes = settings.contentTypes || [];
    this.state.frontmatterProperties = settings.frontmatterProperties || {};
    this.state.defaultContentTypeId = settings.defaultContentTypeId;
    if (settings.attachmentHandlingMode) {
      this.state.attachmentHandlingMode = settings.attachmentHandlingMode;
      this.state.attachmentFolderName = settings.attachmentFolderName;
    } else {
      const vault = this.plugin.app.vault;
      const obsidianConfig = vault.config;
      if (obsidianConfig == null ? void 0 : obsidianConfig.attachmentFolderPath) {
        const folderPath = obsidianConfig.attachmentFolderPath;
        if (folderPath === "./") {
          this.state.attachmentHandlingMode = "same-folder";
          this.state.attachmentFolderName = void 0;
        } else if (folderPath.startsWith("./")) {
          this.state.attachmentHandlingMode = "subfolder";
          this.state.attachmentFolderName = folderPath.substring(2);
        } else {
          this.state.attachmentHandlingMode = "specified-folder";
          this.state.attachmentFolderName = folderPath;
        }
      } else {
        this.state.attachmentHandlingMode = "subfolder";
        this.state.attachmentFolderName = void 0;
      }
    }
    this.state.preset = settings.preset || "vanilla";
    this.state.presetName = settings.presetName || "";
    this.state.presetsRepo = settings.presetsRepo || "vaultcms/vault-cms-presets";
    const actualVisibility = await this.editingToolbarConfigurator.getVisibility(this.plugin.app);
    if (actualVisibility !== void 0) {
      this.state.enableEditingToolbar = actualVisibility;
    } else {
      this.state.enableEditingToolbar = (_b = (_a = settings.enableEditingToolbar) != null ? _a : settings.enableWYSIWYG) != null ? _b : false;
    }
    this.state.enableMdxSupport = settings.enableMdxSupport;
    this.state.enableExtendedFileTypes = settings.enableExtendedFileTypes;
    this.state.enabledPlugins = settings.enabledPlugins || [];
    this.state.disabledPlugins = settings.disabledPlugins || [];
    this.state.theme = settings.theme || "";
    this.state.basesCMSConfig = settings.basesCMSConfig || { views: [] };
    this.state.astroComposerConfig = settings.astroComposerConfig || {
      customContentTypes: [],
      defaultTemplate: "",
      configFilePath: "",
      terminalProjectRootPath: ""
    };
    this.state.seoConfig = settings.seoConfig || {
      titleProperty: "title",
      scanDirectories: "",
      useFilenameAsTitle: false,
      useFilenameAsSlug: true
    };
    this.state.propertyOverFileName = settings.propertyOverFileName || { propertyKey: "title" };
    this.state.explorerFocus = settings.explorerFocus || {};
    if (!this.state.imageManager || Object.keys(this.state.imageManager).length === 0) {
      try {
        const imageManagerConfigurator = new ImageManagerConfigurator(this.plugin.app);
        const loadedConfig = await imageManagerConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.imageManager = loadedConfig;
        } else {
          this.state.imageManager = settings.imageManager || {};
        }
      } catch (error) {
        console.warn("Failed to load Image Manager config during refresh:", error);
        this.state.imageManager = settings.imageManager || {};
      }
    } else {
      this.state.imageManager = settings.imageManager || {};
    }
    if (!this.state.homeBase || Object.keys(this.state.homeBase).length === 0) {
      try {
        const homeBaseConfigurator = new HomeBaseConfigurator(this.plugin.app);
        const loadedConfig = await homeBaseConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.homeBase = loadedConfig;
        } else {
          this.state.homeBase = settings.homeBase || {};
        }
      } catch (error) {
        console.warn("Failed to load Home Base config during refresh:", error);
        this.state.homeBase = settings.homeBase || {};
      }
    } else {
      this.state.homeBase = settings.homeBase || {};
    }
    if (!this.state.explorerFocus || Object.keys(this.state.explorerFocus).length === 0) {
      try {
        const explorerFocusConfigurator = new ExplorerFocusConfigurator(this.plugin.app);
        const loadedConfig = await explorerFocusConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.explorerFocus = loadedConfig;
        } else {
          this.state.explorerFocus = settings.explorerFocus || {};
        }
      } catch (error) {
        console.warn("Failed to load Explorer Focus config during refresh:", error);
        this.state.explorerFocus = settings.explorerFocus || {};
      }
    } else {
      this.state.explorerFocus = settings.explorerFocus || {};
    }
    this.state.gitConfig = settings.gitConfig || { enabled: false, autoConfigureObsidianGit: true };
    this.state.ignoreConfig = settings.ignoreConfig || { gitIgnoreConfigured: false, viteIgnoreConfigured: false };
  }
  async buildFinalSettings() {
    var _a, _b, _c, _d;
    const settings = this.plugin.settings;
    settings.projectRoot = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) || "";
    settings.configFilePath = ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath) || "";
    settings.contentTypes = this.state.contentTypes;
    settings.frontmatterProperties = this.state.frontmatterProperties;
    settings.defaultContentTypeId = this.state.defaultContentTypeId;
    settings.attachmentHandlingMode = this.state.attachmentHandlingMode;
    settings.attachmentFolderName = this.state.attachmentFolderName;
    settings.preset = this.state.preset;
    settings.presetName = this.state.presetName || "";
    settings.presetsRepo = this.state.presetsRepo || "davidvkimball/vault-cms-presets";
    settings.enableEditingToolbar = this.state.enableEditingToolbar;
    if (settings.enableWYSIWYG !== void 0) {
      delete settings.enableWYSIWYG;
    }
    settings.enableMdxSupport = (_c = this.state.enableMdxSupport) != null ? _c : false;
    settings.enableExtendedFileTypes = (_d = this.state.enableExtendedFileTypes) != null ? _d : false;
    settings.enabledPlugins = this.state.enabledPlugins;
    settings.disabledPlugins = this.state.disabledPlugins;
    settings.theme = this.state.theme;
    settings.basesCMSConfig = this.state.basesCMSConfig;
    settings.astroComposerConfig = this.state.astroComposerConfig;
    settings.seoConfig = this.state.seoConfig;
    settings.propertyOverFileName = this.state.propertyOverFileName;
    const settingsRecord = settings;
    if (settingsRecord.uiTweaker) {
      delete settingsRecord.uiTweaker;
    }
    if (settingsRecord.tabBarCommands) {
      delete settingsRecord.tabBarCommands;
    }
    if (settingsRecord.commanderConfig) {
      delete settingsRecord.commanderConfig;
    }
    if (settingsRecord.imageInserter) {
      delete settingsRecord.imageInserter;
    }
    settings.imageManager = this.state.imageManager;
    settings.homeBase = this.state.homeBase;
    settings.explorerFocus = this.state.explorerFocus;
    settings.ignoreConfig = this.state.ignoreConfig;
    settings.gitConfig = { ...this.state.gitConfig };
    delete settings.gitConfig.pat;
    try {
      const imageManagerConfigurator = new ImageManagerConfigurator(this.plugin.app);
      await imageManagerConfigurator.resolveAndSyncImageProperty(this.state);
    } catch (error) {
      console.warn("WizardStateManager: Failed to sync image property with Image Manager:", error);
    }
  }
};

// src/ui/wizard/BaseWizardStep.ts
var BaseWizardStep = class {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    this.showNextButton = true;
    this.app = app;
    this.containerEl = containerEl;
    this.state = state;
    this.onNext = onNext;
    this.onBack = onBack;
    this.onCancel = onCancel;
  }
  /**
   * Convert absolute path to relative path from vault root
   */
  toRelativePath(absolutePath) {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return absolutePath;
    }
    const vaultNormalized = vaultPath.replace(/\\/g, "/").replace(/\/$/, "");
    const absoluteNormalized = absolutePath.replace(/\\/g, "/").replace(/\/$/, "");
    if (absoluteNormalized.startsWith(vaultNormalized)) {
      const relative5 = absoluteNormalized.slice(vaultNormalized.length);
      const trimmedRelative = relative5.startsWith("/") ? relative5.slice(1) : relative5;
      return trimmedRelative || ".";
    }
    try {
      const vaultParts = vaultNormalized.split("/").filter((p) => p);
      const absoluteParts = absoluteNormalized.split("/").filter((p) => p);
      let commonLength = 0;
      while (commonLength < vaultParts.length && commonLength < absoluteParts.length && vaultParts[commonLength] === absoluteParts[commonLength]) {
        commonLength++;
      }
      const upLevels = vaultParts.length - commonLength;
      const relativeParts = absoluteParts.slice(commonLength);
      const relative5 = (upLevels > 0 ? "../".repeat(upLevels) : "") + relativeParts.join("/");
      return relative5 || absolutePath;
    } catch (e) {
      return absolutePath;
    }
  }
};

// src/ui/wizard/WelcomeStep.ts
function setCssProps(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var WelcomeStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Welcome to Vault CMS" });
    containerEl.createEl("p", {
      text: "This wizard will help you configure Vault CMS for your project. We'll guide you through:"
    });
    const list = containerEl.createEl("ul");
    list.createEl("li", { text: "Detecting your Astro project structure" });
    list.createEl("li", { text: "Identifying your content types" });
    list.createEl("li", { text: "Mapping frontmatter properties" });
    list.createEl("li", { text: "Configuring plugins and themes" });
    list.createEl("li", { text: "Setting up Home Base content views" });
    list.createEl("li", { text: "Configuring Astro Composer and SEO plugins" });
    containerEl.createEl("p", {
      text: "Choose an option to continue:"
    });
    const buttonContainer = containerEl.createDiv("wizard-welcome-buttons");
    setCssProps(buttonContainer, {
      display: "flex",
      gap: "10px",
      marginTop: "20px"
    });
    const getStartedBtn = buttonContainer.createEl("button", {
      text: "Get started",
      cls: "mod-button mod-cta"
    });
    getStartedBtn.addEventListener("click", () => {
      this.onNext();
    });
    const selectPresetBtn = buttonContainer.createEl("button", {
      text: "Select preset",
      cls: "mod-button"
    });
    selectPresetBtn.addEventListener("click", () => {
      this.onCancel();
      const appWithSetting = this.app;
      if (appWithSetting.setting && typeof appWithSetting.setting.open === "function") {
        appWithSetting.setting.open();
        if (typeof appWithSetting.setting.openTabById === "function") {
          appWithSetting.setting.openTabById("vault-cms");
        }
      }
    });
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Welcome";
  }
  getDescription() {
    return "Introduction to Vault CMS setup";
  }
};

// src/ui/wizard/ProjectDetectionStep.ts
var import_obsidian6 = require("obsidian");
var path4 = __toESM(require("path"), 1);
var fs4 = __toESM(require("fs"), 1);

// src/utils/ProjectDetector.ts
var path = __toESM(require("path"), 1);
var fs = __toESM(require("fs"), 1);
var ProjectDetector = class {
  constructor(app) {
    this.app = app;
  }
  detectProject() {
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return null;
    }
    const configResult = this.searchUpwardForConfig(vaultPath);
    if (!configResult) {
      return null;
    }
    const vaultLocation = this.detectVaultLocation(vaultPath, configResult.projectRoot);
    return {
      projectRoot: configResult.projectRoot,
      configFilePath: configResult.configFilePath,
      vaultLocation
    };
  }
  /**
   * Search upward from the vault path to find an Astro config file.
   * This allows the vault to be anywhere within the Astro project structure.
   * Bias towards src/config.ts if it exists alongside a root config file.
   */
  searchUpwardForConfig(startPath) {
    const rootConfigFileNames = [
      "astro.config.mjs",
      "astro.config.ts",
      "astro.config.js",
      "astro.config.mts",
      "astro.config.cjs",
      "astro.config.yml",
      "astro.config.yaml"
    ];
    const srcConfigFileName = "src/config.ts";
    let currentDir = path.resolve(startPath);
    const root = path.parse(currentDir).root;
    while (currentDir !== root) {
      const srcConfigPath = path.join(currentDir, srcConfigFileName);
      try {
        if (fs.existsSync(srcConfigPath) && fs.statSync(srcConfigPath).isFile()) {
          return {
            projectRoot: currentDir,
            configFilePath: srcConfigPath
          };
        }
      } catch (e) {
      }
      for (const fileName of rootConfigFileNames) {
        const configPath = path.join(currentDir, fileName);
        try {
          if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {
            return {
              projectRoot: currentDir,
              configFilePath: configPath
            };
          }
        } catch (e) {
        }
      }
      const parentDir = path.dirname(currentDir);
      if (parentDir === currentDir) {
        break;
      }
      currentDir = parentDir;
    }
    return null;
  }
  /**
   * Determine vault location relative to the detected project root.
   */
  detectVaultLocation(vaultPath, projectRoot) {
    const normalizedVaultPath = path.normalize(vaultPath);
    const normalizedProjectRoot = path.normalize(projectRoot);
    if (!normalizedVaultPath.startsWith(normalizedProjectRoot)) {
      return "root";
    }
    const relativePath = path.relative(normalizedProjectRoot, normalizedVaultPath);
    const pathParts = relativePath.split(path.sep).filter((part) => part.length > 0);
    const contentIndex = pathParts.findIndex((part) => part.toLowerCase() === "content");
    if (contentIndex > 0) {
      const parentIndex = contentIndex - 1;
      if (parentIndex >= 0 && pathParts[parentIndex].toLowerCase() === "src") {
        return "content";
      }
    }
    const srcIndex = pathParts.findIndex((part) => part.toLowerCase() === "src");
    if (srcIndex >= 0 && srcIndex < pathParts.length - 1) {
      const nextPart = pathParts[srcIndex + 1];
      if (nextPart.toLowerCase() === "content") {
        return "nested-content";
      }
    }
    return "root";
  }
};

// src/utils/MdxDetector.ts
var path2 = __toESM(require("path"), 1);
var fs2 = __toESM(require("fs"), 1);
var MdxDetector = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Detect if MDX files are present in the content folders
   * Scans all content type folders (posts, pages, etc.) for .mdx files
   */
  detectMdxUsage(projectDetection, contentTypes) {
    console.debug("MdxDetector.detectMdxUsage: called with", {
      projectRoot: projectDetection == null ? void 0 : projectDetection.projectRoot,
      vaultLocation: projectDetection == null ? void 0 : projectDetection.vaultLocation,
      contentTypesCount: contentTypes == null ? void 0 : contentTypes.length
    });
    if (!projectDetection) {
      console.debug("MdxDetector: No projectDetection, returning false");
      return false;
    }
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    console.debug("MdxDetector: vaultPath =", vaultPath);
    if (!vaultPath) {
      console.debug("MdxDetector: No vaultPath, returning false");
      return false;
    }
    const projectRoot = projectDetection.projectRoot;
    let projectRootPath;
    if (path2.isAbsolute(projectRoot)) {
      projectRootPath = projectRoot;
    } else {
      projectRootPath = path2.resolve(vaultPath, projectRoot);
    }
    console.debug("MdxDetector: projectRootPath =", projectRootPath);
    let contentBasePath;
    if (projectDetection.vaultLocation === "content") {
      contentBasePath = vaultPath;
    } else if (projectDetection.vaultLocation === "nested-content") {
      contentBasePath = path2.resolve(vaultPath, "..");
    } else {
      contentBasePath = path2.join(projectRootPath, "src", "content");
    }
    console.debug("MdxDetector: contentBasePath =", contentBasePath);
    console.debug("MdxDetector: vaultLocation =", projectDetection.vaultLocation);
    console.debug("MdxDetector: contentTypes to scan =", contentTypes.map((ct) => `${ct.name} (${ct.folder})`));
    for (const contentType of contentTypes) {
      let contentTypePath;
      if (contentType.folder.startsWith("src/content/")) {
        contentTypePath = path2.join(projectRootPath, contentType.folder);
      } else {
        contentTypePath = path2.join(contentBasePath, contentType.folder);
      }
      console.debug("MdxDetector: scanning", contentTypePath, "(enabled:", contentType.enabled, ")");
      try {
        if (fs2.existsSync(contentTypePath) && fs2.statSync(contentTypePath).isDirectory()) {
          const foundMdx = this.scanDirectoryForMdx(contentTypePath);
          console.debug("MdxDetector: found MDX in", contentTypePath, "=", foundMdx);
          if (foundMdx) {
            return true;
          }
        } else {
          console.debug("MdxDetector: path does not exist or is not a directory:", contentTypePath, "exists:", fs2.existsSync(contentTypePath));
        }
      } catch (error) {
        console.debug("MdxDetector: error scanning", contentTypePath, error);
        continue;
      }
    }
    console.debug("MdxDetector: no MDX files found");
    return false;
  }
  /**
   * Recursively scan a directory for .mdx files
   */
  scanDirectoryForMdx(dirPath) {
    try {
      const entries = fs2.readdirSync(dirPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path2.join(dirPath, entry.name);
        if (entry.isFile() && entry.name.endsWith(".mdx")) {
          return true;
        }
        if (entry.isDirectory()) {
          if (this.scanDirectoryForMdx(fullPath)) {
            return true;
          }
        }
      }
    } catch (e) {
      return false;
    }
    return false;
  }
};

// src/utils/ContentTypeDetector.ts
var import_obsidian5 = require("obsidian");
var path3 = __toESM(require("path"), 1);
var fs3 = __toESM(require("fs"), 1);
var ContentTypeDetector = class {
  constructor(app) {
    this.app = app;
  }
  detectContentTypes(projectDetection) {
    const contentFolder = this.findContentDirectory(projectDetection);
    if (!contentFolder) {
      return this.detectContentTypesFromVaultRoot();
    }
    const contentTypes = [];
    const folders = this.getTopLevelFolders(contentFolder);
    for (const folder of folders) {
      const contentType = this.detectContentType(folder);
      if (contentType) {
        contentTypes.push(contentType);
      }
    }
    return contentTypes;
  }
  /**
   * Find the src/content directory regardless of where the vault is located.
   * Handles cases where vault is at:
   * - src level (need to go into src/content)
   * - src/content level (already there)
   * - src/content/post level (vault is inside a content type, can't access parent, return null to use fallback)
   */
  findContentDirectory(projectDetection) {
    if (!projectDetection || !projectDetection.projectRoot) {
      return null;
    }
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return null;
    }
    let projectRoot;
    if (path3.isAbsolute(projectDetection.projectRoot)) {
      projectRoot = projectDetection.projectRoot;
    } else {
      projectRoot = path3.resolve(vaultPath, projectDetection.projectRoot);
    }
    const expectedContentPath = path3.join(projectRoot, "src", "content");
    if (!fs3.existsSync(expectedContentPath) || !fs3.statSync(expectedContentPath).isDirectory()) {
      return null;
    }
    const vaultRoot = vault.getRoot();
    if (!(vaultRoot instanceof import_obsidian5.TFolder)) {
      return null;
    }
    const vaultNormalized = path3.resolve(vaultPath).toLowerCase();
    const contentNormalized = path3.resolve(expectedContentPath).toLowerCase();
    if (contentNormalized.startsWith(vaultNormalized)) {
      const relativePath = path3.relative(path3.resolve(vaultPath), path3.resolve(expectedContentPath));
      const normalizedRelativePath = relativePath.split(path3.sep).join("/");
      const pathParts = normalizedRelativePath.split("/").filter((part) => part.length > 0);
      if (pathParts.length === 0) {
        return vaultRoot;
      }
      let currentFolder = vaultRoot;
      for (const part of pathParts) {
        if (!currentFolder.children) {
          return null;
        }
        const child = currentFolder.children.find((c) => c instanceof import_obsidian5.TFolder && c.name === part);
        if (!(child instanceof import_obsidian5.TFolder)) {
          return null;
        }
        currentFolder = child;
      }
      return currentFolder;
    }
    return null;
  }
  /**
   * Fallback: detect content types from vault root (old behavior)
   * This is used when we can't find src/content, e.g., when vault is inside a content type folder
   */
  detectContentTypesFromVaultRoot() {
    const vault = this.app.vault;
    const root = vault.getRoot();
    if (!(root instanceof import_obsidian5.TFolder)) {
      return [];
    }
    const contentTypes = [];
    const folders = this.getTopLevelFolders(root);
    for (const folder of folders) {
      const contentType = this.detectContentType(folder);
      if (contentType) {
        contentTypes.push(contentType);
      }
    }
    return contentTypes;
  }
  getTopLevelFolders(folder) {
    const folders = [];
    if (!folder.children) {
      return folders;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFolder) {
        const configDir = this.app.vault.configDir;
        if (!child.name.startsWith(".") && child.name !== "bases" && child.name !== "_bases" && child.name !== "node_modules" && child.name !== configDir) {
          folders.push(child);
        }
      }
    }
    return folders;
  }
  detectContentType(folder) {
    const name = this.capitalizeFirst(folder.name);
    return {
      id: `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
      name,
      folder: folder.path,
      // Use vault-relative path instead of just the folder name
      fileOrganization: "file",
      enabled: true,
      // Enable all discovered content types by default
      indexFileName: "index"
    };
  }
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
};

// src/ui/wizard/ProjectDetectionStep.ts
function setCssProps2(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var ProjectDetectionStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.detected = false;
    this.projectRootDisplay = null;
    this.configFileDisplay = null;
    this.projectDetector = new ProjectDetector(app);
    this.mdxDetector = new MdxDetector(app);
    this.contentTypeDetector = new ContentTypeDetector(app);
  }
  async display() {
    var _a, _b;
    console.debug("ProjectDetectionStep.display: called");
    const { containerEl } = this;
    containerEl.empty();
    const hasSavedValues = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath);
    console.debug("ProjectDetectionStep.display: hasSavedValues =", hasSavedValues);
    console.debug("ProjectDetectionStep.display: current enableMdxSupport =", this.state.enableMdxSupport);
    if (!hasSavedValues) {
      containerEl.createEl("h2", { text: "Project detection" });
      containerEl.createEl("p", {
        text: "Detecting your Astro project structure..."
      });
      const result = this.projectDetector.detectProject();
      console.debug("ProjectDetectionStep.display: detection result =", result);
      if (result) {
        this.state.projectDetection = {
          projectRoot: result.projectRoot,
          configFilePath: result.configFilePath,
          vaultLocation: result.vaultLocation
        };
        console.debug("ProjectDetectionStep.display: set projectDetection =", this.state.projectDetection);
        this.detected = true;
      } else {
        this.detected = false;
      }
    } else {
      console.debug("ProjectDetectionStep.display: using saved projectDetection =", this.state.projectDetection);
      this.detected = true;
    }
    if (this.state.projectDetection && (this.detected || hasSavedValues)) {
      await new Promise((resolve9) => setTimeout(resolve9, 500));
      containerEl.empty();
      containerEl.createEl("h2", { text: "Project detected" });
      containerEl.createEl("p", {
        text: 'Project structure detected successfully. You can modify the paths below if needed, then click "Next" to continue.'
      });
      const projectRootSetting = new import_obsidian6.Setting(containerEl).setName("Project root").setDesc("Select the folder containing your Astro project root");
      this.projectRootDisplay = projectRootSetting.descEl.createDiv({
        text: this.state.projectDetection.projectRoot ? this.toRelativePath(this.state.projectDetection.projectRoot) : "No folder selected",
        cls: "vault-cms-path-display"
      });
      setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
      projectRootSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          const selectedPath = this.selectFolder();
          if (selectedPath) {
            this.state.projectDetection.projectRoot = selectedPath;
            if (this.projectRootDisplay) {
              this.projectRootDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
            }
            this.detected = false;
          }
        })();
      }));
      const configFileSetting = new import_obsidian6.Setting(containerEl).setName("Config file").setDesc("Select your Astro config file (astro.config.mjs, astro.config.js, src/config.ts, etc.)");
      this.configFileDisplay = configFileSetting.descEl.createDiv({
        text: this.state.projectDetection.configFilePath ? this.toRelativePath(this.state.projectDetection.configFilePath) : "No file selected",
        cls: "vault-cms-path-display"
      });
      setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
      configFileSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          var _a2;
          const defaultPath = ((_a2 = this.state.projectDetection) == null ? void 0 : _a2.projectRoot) || this.getVaultPath();
          const selectedPath = this.selectConfigFile(defaultPath);
          if (selectedPath) {
            this.state.projectDetection.configFilePath = selectedPath;
            if (this.configFileDisplay) {
              this.configFileDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
            }
            this.detected = false;
          }
        })();
      }));
      let autoDetectedMdx = false;
      if (this.state.projectDetection) {
        try {
          console.debug("ProjectDetectionStep: Starting MDX detection");
          console.debug("ProjectDetectionStep: projectDetection =", this.state.projectDetection);
          console.debug("ProjectDetectionStep: existing contentTypes =", this.state.contentTypes.length);
          let contentTypesToUse = this.state.contentTypes;
          if (contentTypesToUse.length === 0) {
            console.debug("ProjectDetectionStep: No content types in state, detecting now...");
            contentTypesToUse = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
            console.debug("ProjectDetectionStep: Detected content types =", contentTypesToUse.length, contentTypesToUse.map((ct) => `${ct.name} (${ct.folder}, enabled: ${ct.enabled})`));
          } else {
            console.debug("ProjectDetectionStep: Using existing content types =", contentTypesToUse.map((ct) => `${ct.name} (${ct.folder}, enabled: ${ct.enabled})`));
          }
          if (contentTypesToUse.length > 0) {
            console.debug("ProjectDetectionStep: Calling mdxDetector.detectMdxUsage...");
            autoDetectedMdx = this.mdxDetector.detectMdxUsage(
              this.state.projectDetection,
              contentTypesToUse
            );
            console.debug("ProjectDetectionStep: MDX detection result =", autoDetectedMdx);
          } else {
            console.debug("ProjectDetectionStep: No content types to scan");
          }
        } catch (error) {
          console.error("ProjectDetectionStep: MDX detection failed:", error);
          autoDetectedMdx = false;
        }
      } else {
        console.debug("ProjectDetectionStep: No projectDetection, skipping MDX detection");
      }
      if (this.state.enableMdxSupport === void 0) {
        this.state.enableMdxSupport = autoDetectedMdx;
        console.debug("ProjectDetectionStep: Set enableMdxSupport to", autoDetectedMdx, "based on auto-detection");
      } else {
        console.debug("ProjectDetectionStep: enableMdxSupport already set to", this.state.enableMdxSupport, ", skipping auto-detection overwrite");
      }
      const mdxSetting = new import_obsidian6.Setting(containerEl).setName("MDX file support").setDesc("Enable MDX file support for Astro Composer, Property Over File Name, SEO, and UI Tweaker plugins.");
      mdxSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableMdxSupport) != null ? _a2 : false).onChange((value) => {
          this.state.enableMdxSupport = value;
        });
        if (autoDetectedMdx && this.state.enableMdxSupport) {
          const autoDetectMsg = mdxSetting.descEl.createDiv({
            text: "MDX files detected in content folders",
            cls: "vault-cms-auto-detect-msg"
          });
          setCssProps2(autoDetectMsg, {
            color: "var(--text-muted)",
            fontSize: "0.9em",
            marginTop: "4px"
          });
        }
      });
      const extendedFileTypesSetting = new import_obsidian6.Setting(containerEl).setName("Extended file types").setDesc("Enable support to view, edit, and create .json and .astro files via the Data Files Editor plugin.");
      extendedFileTypesSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableExtendedFileTypes) != null ? _a2 : false).onChange((value) => {
          this.state.enableExtendedFileTypes = value;
        });
      });
    } else {
      containerEl.empty();
      containerEl.createEl("h2", { text: "Project detection failed" });
      containerEl.createEl("p", {
        text: "Could not detect Astro project structure. Please select your Astro project root and config file manually."
      });
      if (!this.state.projectDetection) {
        this.state.projectDetection = {
          projectRoot: "",
          configFilePath: "",
          vaultLocation: "root"
        };
      }
      const projectRootSetting = new import_obsidian6.Setting(containerEl).setName("Project root").setDesc("Select the folder containing your Astro project root");
      this.projectRootDisplay = projectRootSetting.descEl.createDiv({
        text: this.state.projectDetection.projectRoot ? this.toRelativePath(this.state.projectDetection.projectRoot) : "No folder selected",
        cls: "vault-cms-path-display"
      });
      if (this.state.projectDetection.projectRoot) {
        setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
      } else {
        setCssProps2(this.projectRootDisplay, { color: "var(--text-muted)" });
      }
      projectRootSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          const selectedPath = this.selectFolder();
          if (selectedPath) {
            this.state.projectDetection.projectRoot = selectedPath;
            if (this.projectRootDisplay) {
              this.projectRootDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
            }
          }
        })();
      }));
      const configFileSetting = new import_obsidian6.Setting(containerEl).setName("Config file").setDesc("Select your Astro config file (astro.config.mjs, astro.config.js, src/config.ts, etc.)");
      this.configFileDisplay = configFileSetting.descEl.createDiv({
        text: this.state.projectDetection.configFilePath ? this.toRelativePath(this.state.projectDetection.configFilePath) : "No file selected",
        cls: "vault-cms-path-display"
      });
      if (this.state.projectDetection.configFilePath) {
        setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
      } else {
        setCssProps2(this.configFileDisplay, { color: "var(--text-muted)" });
      }
      configFileSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          var _a2;
          const defaultPath = ((_a2 = this.state.projectDetection) == null ? void 0 : _a2.projectRoot) || this.getVaultPath();
          const selectedPath = this.selectConfigFile(defaultPath);
          if (selectedPath) {
            this.state.projectDetection.configFilePath = selectedPath;
            if (this.configFileDisplay) {
              this.configFileDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
            }
          }
        })();
      }));
      let autoDetectedMdx = false;
      if (this.state.projectDetection && this.state.projectDetection.projectRoot && this.state.projectDetection.configFilePath) {
        try {
          const detectedContentTypes = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
          if (detectedContentTypes.length > 0) {
            autoDetectedMdx = this.mdxDetector.detectMdxUsage(
              this.state.projectDetection,
              detectedContentTypes
            );
          }
        } catch (e) {
          autoDetectedMdx = false;
        }
      }
      if (this.state.enableMdxSupport === void 0) {
        this.state.enableMdxSupport = autoDetectedMdx;
        console.debug("ProjectDetectionStep (manual): Set enableMdxSupport to", autoDetectedMdx, "based on auto-detection");
      } else {
        console.debug("ProjectDetectionStep (manual): enableMdxSupport already set to", this.state.enableMdxSupport, ", skipping auto-detection overwrite");
      }
      const mdxSetting = new import_obsidian6.Setting(containerEl).setName("MDX file support").setDesc("Enable MDX file support for Astro Composer, Property Over File Name, SEO, and UI Tweaker plugins.");
      mdxSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableMdxSupport) != null ? _a2 : false).onChange((value) => {
          this.state.enableMdxSupport = value;
        });
        if (autoDetectedMdx && this.state.enableMdxSupport) {
          const autoDetectMsg = mdxSetting.descEl.createDiv({
            text: "MDX files detected in content folders",
            cls: "vault-cms-auto-detect-msg"
          });
          setCssProps2(autoDetectMsg, {
            color: "var(--text-muted)",
            fontSize: "0.9em",
            marginTop: "4px"
          });
        }
      });
      const extendedFileTypesSetting = new import_obsidian6.Setting(containerEl).setName("Extended file types").setDesc("Enable support to view, edit, and create .json and .astro files via the Data Files Editor plugin.");
      extendedFileTypesSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableExtendedFileTypes) != null ? _a2 : false).onChange((value) => {
          this.state.enableExtendedFileTypes = value;
        });
      });
    }
  }
  /**
   * Open native folder picker dialog
   */
  selectFolder() {
    var _a, _b, _c;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      let defaultPath = ((_c = this.state.projectDetection) == null ? void 0 : _c.projectRoot) || vaultPath;
      if (defaultPath && !path4.isAbsolute(defaultPath)) {
        defaultPath = path4.resolve(vaultPath, defaultPath);
      }
      const result = dialog.showOpenDialogSync({
        title: "Select Astro Project Root Folder",
        defaultPath,
        properties: ["openDirectory"]
      });
      if (result && result.length > 0) {
        return path4.normalize(result[0]);
      }
    } catch (error) {
      console.error("Error opening folder picker:", error);
      new import_obsidian6.Notice("Unable to open folder picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Open native file picker dialog for config file
   */
  selectConfigFile(defaultPath) {
    var _a, _b, _c;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      let startPath = defaultPath || vaultPath;
      if (!defaultPath && ((_c = this.state.projectDetection) == null ? void 0 : _c.configFilePath)) {
        const configPath = this.state.projectDetection.configFilePath;
        if (path4.isAbsolute(configPath)) {
          startPath = path4.dirname(configPath);
        } else {
          startPath = path4.dirname(path4.resolve(vaultPath, configPath));
        }
      } else if (defaultPath && !path4.isAbsolute(defaultPath)) {
        startPath = path4.resolve(vaultPath, defaultPath);
        if (path4.extname(startPath)) {
          startPath = path4.dirname(startPath);
        }
      } else if (defaultPath && path4.isAbsolute(defaultPath)) {
        if (path4.extname(defaultPath)) {
          startPath = path4.dirname(defaultPath);
        } else {
          startPath = defaultPath;
        }
      }
      const result = dialog.showOpenDialogSync({
        title: "Select Astro Config File",
        defaultPath: startPath,
        filters: [
          { name: "Astro Config Files", extensions: ["ts", "mjs", "js", "mts", "cjs", "yml", "yaml"] },
          { name: "All Files", extensions: ["*"] }
        ],
        properties: ["openFile"]
      });
      if (result && result.length > 0) {
        return path4.normalize(result[0]);
      }
    } catch (error) {
      console.error("Error opening file picker:", error);
      new import_obsidian6.Notice("Unable to open file picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (vaultPath) {
      if (vaultPath.startsWith("/") || /^[A-Z]:/.test(vaultPath)) {
        return vaultPath.replace(/\\/g, "/");
      }
      return vaultPath.replace(/\\/g, "/");
    }
    return "/";
  }
  validate() {
    var _a, _b;
    if (this.detected) {
      return true;
    }
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    const configFilePath = (_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath;
    if (!projectRoot || !configFilePath) {
      return false;
    }
    try {
      const vaultPath = this.getVaultPath();
      const resolvedProjectRoot = path4.isAbsolute(projectRoot) ? projectRoot : path4.join(vaultPath, projectRoot);
      const resolvedConfigFilePath = path4.isAbsolute(configFilePath) ? configFilePath : path4.join(vaultPath, configFilePath);
      if (!fs4.existsSync(resolvedProjectRoot) || !fs4.statSync(resolvedProjectRoot).isDirectory()) {
        return false;
      }
      if (!fs4.existsSync(resolvedConfigFilePath) || !fs4.statSync(resolvedConfigFilePath).isFile()) {
        return false;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  getTitle() {
    return "Project detection";
  }
  getDescription() {
    return "Detect Astro project structure";
  }
};

// src/ui/wizard/ContentTypeStep.ts
var import_obsidian8 = require("obsidian");

// src/utils/PathResolver.ts
var path5 = __toESM(require("path"), 1);
var PathResolver = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Get the folder path from vault root to the content type folder.
   * This is used by Bases CMS filters and Astro Composer folder settings.
   * 
   * Examples:
   * - Vault at src level, content type "docs": returns "content/docs"
   * - Vault at src/content level, content type "docs": returns "docs"
   * - Vault at src/content/post level, content type "docs": returns "../docs" (if accessible) or "docs" (if vault is the content type folder)
   * 
   * @param folderName The content type folder name (e.g., "docs", "posts")
   * @param projectDetection Project detection result with project root and vault location
   * @returns Path from vault root to content type folder, or null if cannot be determined
   */
  getFolderPathFromVaultRoot(folderName, projectDetection) {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    const file = this.app.vault.getAbstractFileByPath(folderName);
    if (file) {
      return folderName;
    }
    if (projectDetection && projectDetection.projectRoot && vaultPath) {
      const projectRoot = path5.isAbsolute(projectDetection.projectRoot) ? projectDetection.projectRoot : path5.resolve(vaultPath, projectDetection.projectRoot);
      let contentTypeAbsolutePath;
      if (folderName.startsWith("src/content/") || folderName.includes("/src/content/")) {
        contentTypeAbsolutePath = path5.resolve(projectRoot, folderName);
      } else {
        contentTypeAbsolutePath = path5.resolve(projectRoot, "src", "content", folderName);
      }
      const vaultAbsolutePath = path5.resolve(vaultPath);
      const relativePath = path5.relative(vaultAbsolutePath, contentTypeAbsolutePath);
      if (!relativePath.startsWith("..") && !path5.isAbsolute(relativePath)) {
        return relativePath.split(path5.sep).join("/") || ".";
      }
    }
    return folderName;
  }
  /**
   * Get the folder path from project root to the content type folder.
   * This is always "src/content/{folderName}" relative to project root.
   * 
   * @param folderName The content type folder name (e.g., "docs", "posts")
   * @returns Path from project root (e.g., "src/content/docs")
   */
  getFolderPathFromProjectRoot(folderName) {
    return `src/content/${folderName}`;
  }
  /**
   * Get the folder path for Astro Composer, which needs the path relative to vault root
   * but should work correctly regardless of vault location.
   * 
   * @param folderName The content type folder name
   * @param projectDetection Project detection result
   * @returns Path from vault root to content type folder
   */
  getAstroComposerFolderPath(folderName, projectDetection) {
    return this.getFolderPathFromVaultRoot(folderName, projectDetection);
  }
  /**
   * Get the folder path for Bases CMS filter, which needs to match files
   * in the content type folder regardless of vault location.
   * 
   * @param folderName The content type folder name
   * @param projectDetection Project detection result
   * @returns Path from vault root to content type folder (for use in file.folder.startsWith filter)
   */
  getBasesCMSFolderPath(folderName, projectDetection) {
    return this.getFolderPathFromVaultRoot(folderName, projectDetection);
  }
};

// src/utils/SafeConfigWriter.ts
var import_obsidian7 = require("obsidian");
var SafeConfigWriter = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Validates that a value is a valid JSON object
   */
  validateJSON(data) {
    if (!data || typeof data !== "object" || Array.isArray(data)) {
      return false;
    }
    try {
      JSON.parse(JSON.stringify(data));
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Creates a backup of a plugin's data.json file
   */
  async createBackup(pluginId, originalFile) {
    try {
      const content = await this.app.vault.read(originalFile);
      const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const backupPath = `${this.app.vault.configDir}/plugins/${pluginId}/data.json.backup-${timestamp2}`;
      await this.app.vault.create(backupPath, content);
      console.debug(`SafeConfigWriter: Created backup at ${backupPath}`);
    } catch (error) {
      console.warn(`SafeConfigWriter: Failed to create backup for ${pluginId}:`, error);
    }
  }
  /**
   * Safely reads a plugin's data.json file
   */
  async readConfig(pluginId) {
    const configPath = `${this.app.vault.configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(configPath);
    if (!dataFile || !(dataFile instanceof import_obsidian7.TFile)) {
      console.debug(`SafeConfigWriter: Config file not found for ${pluginId}`);
      return null;
    }
    try {
      const content = await this.app.vault.read(dataFile);
      const parsed = JSON.parse(content);
      if (!this.validateJSON(parsed)) {
        console.error(`SafeConfigWriter: Invalid JSON structure in ${pluginId} config`);
        return null;
      }
      return parsed;
    } catch (error) {
      console.error(`SafeConfigWriter: Failed to read/parse config for ${pluginId}:`, error);
      return null;
    }
  }
  /**
   * Safely writes to a plugin's data.json file with backup and validation
   */
  async writeConfig(pluginId, data, options = {}) {
    const { showNotice = true, createBackup = true } = options;
    if (!this.validateJSON(data)) {
      const message = `Invalid configuration data for ${pluginId}`;
      console.error(`SafeConfigWriter: ${message}`);
      if (showNotice) {
        new import_obsidian7.Notice(`Failed to save ${pluginId} settings: Invalid data`);
      }
      return false;
    }
    const configPath = `${this.app.vault.configDir}/plugins/${pluginId}/data.json`;
    try {
      const dataFile = this.app.vault.getAbstractFileByPath(configPath);
      if (dataFile && dataFile instanceof import_obsidian7.TFile) {
        if (createBackup) {
          await this.createBackup(pluginId, dataFile);
        }
        const content = JSON.stringify(data, null, 2);
        await this.app.vault.modify(dataFile, content);
        console.debug(`SafeConfigWriter: Successfully updated ${pluginId} config`);
      } else {
        const pluginDir = `${this.app.vault.configDir}/plugins/${pluginId}`;
        const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
        if (!pluginDirFile) {
          await this.app.vault.createFolder(pluginDir);
        }
        const content = JSON.stringify(data, null, 2);
        await this.app.vault.create(configPath, content);
        console.debug(`SafeConfigWriter: Successfully created ${pluginId} config`);
      }
      return true;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      console.error(`SafeConfigWriter: Failed to write config for ${pluginId}:`, error);
      if (showNotice) {
        new import_obsidian7.Notice(`Failed to save ${pluginId} settings: ${message}`);
      }
      return false;
    }
  }
  /**
   * Safely merges new settings into existing plugin config
   */
  async mergeConfig(pluginId, updates, options = {}) {
    const existingConfig = await this.readConfig(pluginId) || {};
    const mergedConfig = { ...existingConfig, ...updates };
    return this.writeConfig(pluginId, mergedConfig, options);
  }
};

// src/utils/AstroComposerConfig.ts
var AstroComposerConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
    this.safeWriter = new SafeConfigWriter(app);
  }
  configureAstroComposer(contentTypes, frontmatterProperties, projectRoot, configFilePath, defaultContentTypeId, projectDetection, enableMdxSupport) {
    this.frontmatterProperties = frontmatterProperties;
    this.contentTypes = contentTypes;
    const config = {
      customContentTypes: [],
      defaultTemplate: "",
      configFilePath: this.relativePath(configFilePath),
      terminalProjectRootPath: this.relativePath(projectRoot),
      showMdxFilesInExplorer: enableMdxSupport != null ? enableMdxSupport : false
    };
    const defaultContentType = defaultContentTypeId ? contentTypes.find((ct) => ct.id === defaultContentTypeId && ct.enabled) : null;
    const otherContentTypes = contentTypes.filter((ct) => ct.enabled && (!defaultContentTypeId || ct.id !== defaultContentTypeId));
    if (defaultContentType) {
      const props = frontmatterProperties[defaultContentType.id];
      let linkBasePath = defaultContentType.linkBasePath;
      if (linkBasePath === void 0 || linkBasePath === "") {
        const pathParts = defaultContentType.folder.split("/").filter((p) => p.length > 0);
        const folderName = pathParts[pathParts.length - 1] || defaultContentType.folder;
        linkBasePath = `/${folderName}/`;
      }
      const folderPath = this.pathResolver.getAstroComposerFolderPath(defaultContentType.folder, projectDetection);
      config.customContentTypes.push({
        id: defaultContentType.id,
        name: defaultContentType.name,
        folder: folderPath,
        template: (props == null ? void 0 : props.template) || this.generateTemplate(props),
        enabled: true,
        linkBasePath,
        creationMode: defaultContentType.fileOrganization,
        indexFileName: defaultContentType.indexFileName || "index"
      });
      config.postsFolder = folderPath;
      config.postsCreationMode = defaultContentType.fileOrganization;
      config.postsIndexFileName = defaultContentType.indexFileName || "index";
      config.defaultTemplate = (props == null ? void 0 : props.template) || this.generateTemplate(props);
    }
    for (const contentType of otherContentTypes) {
      const props = frontmatterProperties[contentType.id];
      let linkBasePath = contentType.linkBasePath;
      if (linkBasePath === void 0 || linkBasePath === "") {
        const pathParts = contentType.folder.split("/").filter((p) => p.length > 0);
        const folderName = pathParts[pathParts.length - 1] || contentType.folder;
        linkBasePath = `/${folderName}/`;
      }
      const folderPath = this.pathResolver.getAstroComposerFolderPath(contentType.folder, projectDetection);
      config.customContentTypes.push({
        id: contentType.id,
        name: contentType.name,
        folder: folderPath,
        // Use template from props if available, otherwise generate
        template: (props == null ? void 0 : props.template) || this.generateTemplate(props),
        enabled: true,
        linkBasePath,
        creationMode: contentType.fileOrganization,
        indexFileName: contentType.indexFileName || "index"
      });
    }
    return Promise.resolve(config);
  }
  generateTemplate(props) {
    if (props == null ? void 0 : props.template) {
      return props.template;
    }
    if (!props) {
      return '---\ntitle: "{{title}}"\n---\n';
    }
    let template = "---\n";
    template += `${props.titleProperty || "title"}: "{{title}}"
`;
    if (props.dateProperty) {
      template += `${props.dateProperty}: {{date}}
`;
    }
    if (props.descriptionProperty) {
      template += `${props.descriptionProperty}: ""
`;
    }
    if (props.tagsProperty) {
      template += `${props.tagsProperty}: []
`;
    }
    if (props.draftProperty) {
      const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
      template += `${props.draftProperty}: ${draftValue}
`;
    }
    template += "---\n";
    return template;
  }
  getCreationModeFromAttachmentHandling(mode) {
    return mode === "same-folder" ? "folder" : "file";
  }
  relativePath(inputPath) {
    if (!inputPath.startsWith("/") && !/^[A-Z]:/.test(inputPath)) {
      return inputPath;
    }
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return inputPath;
    }
    const vaultNormalized = vaultPath.replace(/\\/g, "/").replace(/\/$/, "");
    const absoluteNormalized = inputPath.replace(/\\/g, "/").replace(/\/$/, "");
    if (absoluteNormalized.startsWith(vaultNormalized)) {
      const relative5 = absoluteNormalized.slice(vaultNormalized.length);
      return relative5.startsWith("/") ? relative5.slice(1) : relative5;
    }
    return inputPath;
  }
  async saveConfig(config) {
    var _a, _b;
    try {
      const plugins = this.app.plugins;
      const astroComposerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["astro-composer"];
      if (!astroComposerPlugin) {
        console.warn("AstroComposerConfig: Astro Composer plugin not found, using fallback file method");
        await this.saveConfigFallback(config);
        return;
      }
      if (!astroComposerPlugin.settings) {
        console.warn("AstroComposerConfig: Astro Composer plugin settings not available, using fallback file method");
        await this.saveConfigFallback(config);
        return;
      }
      const pluginSettings = astroComposerPlugin.settings;
      if (config.defaultTemplate) {
        pluginSettings.defaultTemplate = config.defaultTemplate;
      }
      if (config.pageTemplate) {
        pluginSettings.pageTemplate = config.pageTemplate;
      }
      if (config.postsFolder) {
        pluginSettings.postsFolder = config.postsFolder;
      }
      if (config.postsCreationMode) {
        pluginSettings.creationMode = config.postsCreationMode;
      }
      if (config.postsIndexFileName) {
        pluginSettings.indexFileName = config.postsIndexFileName;
      }
      if (config.enablePages !== void 0) {
        pluginSettings.enablePages = config.enablePages;
      }
      if (config.pagesFolder) {
        pluginSettings.pagesFolder = config.pagesFolder;
      }
      if (config.pagesCreationMode) {
        pluginSettings.pagesCreationMode = config.pagesCreationMode;
      }
      if (config.pagesIndexFileName) {
        pluginSettings.pagesIndexFileName = config.pagesIndexFileName;
      }
      if (config.configFilePath) {
        pluginSettings.configFilePath = config.configFilePath;
      }
      if (config.terminalProjectRootPath) {
        pluginSettings.terminalProjectRootPath = config.terminalProjectRootPath;
      }
      if (config.configFilePath && config.terminalProjectRootPath) {
        pluginSettings.enableOpenTerminalCommand = true;
        pluginSettings.enableOpenConfigFileCommand = true;
        pluginSettings.enableTerminalRibbonIcon = true;
        pluginSettings.enableConfigRibbonIcon = true;
      }
      if (config.showMdxFilesInExplorer !== void 0) {
        pluginSettings.showMdxFilesInExplorer = config.showMdxFilesInExplorer;
        console.debug("AstroComposerConfig: Set showMdxFilesInExplorer to", config.showMdxFilesInExplorer);
      } else {
        console.debug("AstroComposerConfig: showMdxFilesInExplorer is undefined, not updating");
      }
      if (!Array.isArray(pluginSettings.contentTypes)) {
        pluginSettings.contentTypes = [];
      }
      for (const newType of config.customContentTypes) {
        const contentType = (_b = this.contentTypes) == null ? void 0 : _b.find((ct) => ct.id === newType.id);
        const props = contentType && this.frontmatterProperties ? this.frontmatterProperties[contentType.id] : void 0;
        const shouldEnableUnderscorePrefix = (props == null ? void 0 : props.hasDraftStatus) === true && !(props == null ? void 0 : props.draftProperty);
        const contentTypes = pluginSettings.contentTypes || [];
        let existingIndex = -1;
        let matchedById = false;
        if (newType.id) {
          existingIndex = contentTypes.findIndex((ct) => ct.id === newType.id);
          if (existingIndex >= 0) {
            matchedById = true;
          }
        }
        if (existingIndex < 0) {
          existingIndex = contentTypes.findIndex(
            (ct) => ct.name === newType.name && ct.folder === newType.folder
          );
        }
        if (existingIndex >= 0) {
          const existingEntry = contentTypes[existingIndex];
          contentTypes[existingIndex] = {
            ...existingEntry,
            // Only update ID if we matched by ID, otherwise keep existing ID for consistency
            id: matchedById ? newType.id : existingEntry.id || newType.id,
            name: newType.name,
            folder: newType.folder,
            linkBasePath: newType.linkBasePath,
            template: newType.template,
            enabled: newType.enabled,
            creationMode: newType.creationMode,
            indexFileName: newType.indexFileName,
            enableUnderscorePrefix: shouldEnableUnderscorePrefix
          };
        } else {
          contentTypes.push({
            id: newType.id,
            name: newType.name,
            folder: newType.folder,
            linkBasePath: newType.linkBasePath,
            template: newType.template,
            enabled: newType.enabled,
            creationMode: newType.creationMode,
            indexFileName: newType.indexFileName,
            ignoreSubfolders: false,
            enableUnderscorePrefix: shouldEnableUnderscorePrefix
          });
        }
      }
      pluginSettings.customContentTypes = this.mergeCustomContentTypes(
        pluginSettings.customContentTypes || [],
        config.customContentTypes || []
      );
      if (typeof astroComposerPlugin.saveSettings === "function") {
        await astroComposerPlugin.saveSettings();
        console.debug("AstroComposerConfig: Successfully saved via plugin.saveSettings()");
      } else {
        console.warn("AstroComposerConfig: Plugin saveSettings not available, using fallback");
        await this.saveConfigFallback(config);
      }
    } catch (error) {
      console.error("Failed to save Astro Composer config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    var _a;
    const pluginId = "astro-composer";
    let existingData = await this.safeWriter.readConfig(pluginId);
    if (!existingData) {
      existingData = {};
    }
    if (config.defaultTemplate) existingData.defaultTemplate = config.defaultTemplate;
    if (config.pageTemplate) existingData.pageTemplate = config.pageTemplate;
    if (config.postsFolder) existingData.postsFolder = config.postsFolder;
    if (config.postsCreationMode) existingData.creationMode = config.postsCreationMode;
    if (config.postsIndexFileName) existingData.indexFileName = config.postsIndexFileName;
    if (config.enablePages !== void 0) existingData.enablePages = config.enablePages;
    if (config.pagesFolder) existingData.pagesFolder = config.pagesFolder;
    if (config.pagesCreationMode) existingData.pagesCreationMode = config.pagesCreationMode;
    if (config.pagesIndexFileName) existingData.pagesIndexFileName = config.pagesIndexFileName;
    if (config.configFilePath) existingData.configFilePath = config.configFilePath;
    if (config.terminalProjectRootPath) existingData.terminalProjectRootPath = config.terminalProjectRootPath;
    if (config.showMdxFilesInExplorer !== void 0) existingData.showMdxFilesInExplorer = config.showMdxFilesInExplorer;
    if (config.configFilePath && config.terminalProjectRootPath) {
      existingData.enableOpenTerminalCommand = true;
      existingData.enableOpenConfigFileCommand = true;
      existingData.enableTerminalRibbonIcon = true;
      existingData.enableConfigRibbonIcon = true;
    }
    if (!Array.isArray(existingData.contentTypes)) {
      existingData.contentTypes = [];
    }
    for (const newType of config.customContentTypes) {
      const contentType = (_a = this.contentTypes) == null ? void 0 : _a.find((ct) => ct.id === newType.id);
      const props = contentType && this.frontmatterProperties ? this.frontmatterProperties[contentType.id] : void 0;
      const shouldEnableUnderscorePrefix = (props == null ? void 0 : props.hasDraftStatus) === true && !(props == null ? void 0 : props.draftProperty);
      const contentTypes = existingData.contentTypes || [];
      let existingIndex = -1;
      let matchedById = false;
      if (newType.id) {
        existingIndex = contentTypes.findIndex((ct) => ct.id === newType.id);
        if (existingIndex >= 0) {
          matchedById = true;
        }
      }
      if (existingIndex < 0) {
        existingIndex = contentTypes.findIndex(
          (ct) => ct.name === newType.name && ct.folder === newType.folder
        );
      }
      if (existingIndex >= 0) {
        const existingEntry = contentTypes[existingIndex];
        contentTypes[existingIndex] = {
          ...existingEntry,
          // Only update ID if we matched by ID, otherwise keep existing ID for consistency
          id: matchedById ? newType.id : existingEntry.id || newType.id,
          name: newType.name,
          folder: newType.folder,
          linkBasePath: newType.linkBasePath,
          template: newType.template,
          enabled: newType.enabled,
          creationMode: newType.creationMode,
          indexFileName: newType.indexFileName,
          enableUnderscorePrefix: shouldEnableUnderscorePrefix
        };
      } else {
        contentTypes.push({
          id: newType.id,
          name: newType.name,
          folder: newType.folder,
          linkBasePath: newType.linkBasePath,
          template: newType.template,
          enabled: newType.enabled,
          creationMode: newType.creationMode,
          indexFileName: newType.indexFileName,
          ignoreSubfolders: false,
          enableUnderscorePrefix: shouldEnableUnderscorePrefix
        });
      }
    }
    existingData.customContentTypes = this.mergeCustomContentTypes(
      existingData.customContentTypes || [],
      config.customContentTypes || []
    );
    const success = await this.safeWriter.writeConfig(pluginId, existingData, {
      showNotice: true,
      createBackup: true
    });
    if (!success) {
      throw new Error("Failed to save Astro Composer configuration");
    }
  }
  mergeCustomContentTypes(existing, newTypes) {
    const merged = [...existing];
    for (const newType of newTypes) {
      const existingIndex = merged.findIndex((ct) => ct.id === newType.id);
      if (existingIndex >= 0) {
        merged[existingIndex] = { ...merged[existingIndex], ...newType };
      } else {
        merged.push(newType);
      }
    }
    return merged;
  }
};

// src/ui/wizard/ContentTypeStep.ts
function setCssProps3(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var FolderNameSuggest = class extends import_obsidian8.AbstractInputSuggest {
  constructor(app, inputEl, mode) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.mode = mode;
  }
  getSuggestions(inputStr) {
    const suggestions = [];
    const lowerInput = inputStr.toLowerCase();
    if (this.mode === "subfolder") {
      if ("attachments".toLowerCase().includes(lowerInput)) {
        suggestions.push("attachments");
      }
      const allFiles = this.app.vault.getAllLoadedFiles();
      const folderNames = /* @__PURE__ */ new Set();
      for (const file of allFiles) {
        if (file instanceof import_obsidian8.TFolder) {
          const folderName = file.name;
          if (folderName.toLowerCase().includes(lowerInput) && folderName !== "attachments") {
            folderNames.add(folderName);
          }
        }
      }
      suggestions.push(...Array.from(folderNames).slice(0, 10));
    } else {
      const allFiles = this.app.vault.getAllLoadedFiles();
      const paths = /* @__PURE__ */ new Set();
      for (const file of allFiles) {
        if (file instanceof import_obsidian8.TFolder) {
          const path10 = file.path;
          if (path10.toLowerCase().includes(lowerInput)) {
            paths.add(path10);
          }
        }
      }
      suggestions.push(...Array.from(paths).slice(0, 10));
    }
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    el.setText(suggestion);
  }
  selectSuggestion(suggestion) {
    this.inputEl.value = suggestion;
    this.inputEl.trigger("input");
    this.close();
  }
};
var ContentTypeStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.detected = false;
    this.contentTypeDetector = new ContentTypeDetector(app);
    this.astroComposerConfigurator = new AstroComposerConfigurator(app);
  }
  /**
   * Import content types from Astro Composer data.json if it exists
   * First tries plugin API, then falls back to file reading
   */
  async importFromAstroComposer() {
    var _a;
    try {
      const plugins = this.app.plugins;
      console.debug("ContentTypeStep: Checking plugins API:", !!plugins);
      if (plugins) {
        const astroComposerPlugin = (_a = plugins.plugins) == null ? void 0 : _a["astro-composer"];
        console.debug("ContentTypeStep: Astro Composer plugin found:", !!astroComposerPlugin);
        if (astroComposerPlugin) {
          console.debug("ContentTypeStep: Plugin settings available:", !!astroComposerPlugin.settings);
          console.debug("ContentTypeStep: Plugin settings keys:", astroComposerPlugin.settings ? Object.keys(astroComposerPlugin.settings) : "none");
          if (astroComposerPlugin.settings) {
            const contentTypes = astroComposerPlugin.settings.contentTypes;
            console.debug("ContentTypeStep: contentTypes from plugin:", contentTypes ? `Array with ${contentTypes.length} items` : "not found");
            if (Array.isArray(contentTypes) && contentTypes.length > 0) {
              console.debug("ContentTypeStep: Importing", contentTypes.length, "content types from Astro Composer (via plugin API)");
              const importedTypes2 = contentTypes.map((ct) => ({
                id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
                name: ct.name || this.capitalizeFirst(ct.folder),
                folder: ct.folder,
                fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
                indexFileName: ct.indexFileName || "index",
                linkBasePath: ct.linkBasePath,
                enabled: ct.enabled !== false
                // Default to enabled if not specified
              }));
              return importedTypes2;
            }
          }
        }
      }
      const configDir = this.app.vault.configDir;
      const pluginDataPath = `${configDir}/plugins/astro-composer/data.json`;
      console.debug("ContentTypeStep: Trying to read file:", pluginDataPath);
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      console.debug("ContentTypeStep: File found:", !!dataFile, dataFile ? `Type: ${dataFile.constructor.name}` : "not found");
      if (!dataFile || !(dataFile instanceof import_obsidian8.TFile)) {
        const altPaths = [
          `${configDir}/plugins/astro-composer/data.json`,
          `obsidian/plugins/astro-composer/data.json`
        ];
        for (const altPath of altPaths) {
          const altFile = this.app.vault.getAbstractFileByPath(altPath);
          if (altFile && altFile instanceof import_obsidian8.TFile) {
            console.debug("ContentTypeStep: Found file at alternative path:", altPath);
            const content2 = await this.app.vault.read(altFile);
            const data2 = JSON.parse(content2);
            if (data2.contentTypes && Array.isArray(data2.contentTypes)) {
              console.debug("ContentTypeStep: Importing", data2.contentTypes.length, "content types from Astro Composer (via file at", altPath, ")");
              const importedTypes2 = data2.contentTypes.map((ct) => ({
                id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
                name: ct.name || this.capitalizeFirst(ct.folder),
                folder: ct.folder,
                fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
                indexFileName: ct.indexFileName || "index",
                linkBasePath: ct.linkBasePath,
                enabled: ct.enabled !== false
              }));
              return importedTypes2;
            }
          }
        }
        console.debug("ContentTypeStep: No Astro Composer data.json found, will scan folders");
        return [];
      }
      const content = await this.app.vault.read(dataFile);
      const data = JSON.parse(content);
      if (!data.contentTypes || !Array.isArray(data.contentTypes)) {
        console.debug("ContentTypeStep: Astro Composer data.json has no contentTypes array. Data keys:", Object.keys(data));
        return [];
      }
      console.debug("ContentTypeStep: Importing", data.contentTypes.length, "content types from Astro Composer (via file)");
      const importedTypes = data.contentTypes.map((ct) => ({
        id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        name: ct.name || this.capitalizeFirst(ct.folder),
        folder: ct.folder,
        fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
        indexFileName: ct.indexFileName || "index",
        linkBasePath: ct.linkBasePath,
        enabled: ct.enabled !== false
        // Default to enabled if not specified
      }));
      return importedTypes;
    } catch (error) {
      console.error("ContentTypeStep: Failed to import from Astro Composer:", error);
      return [];
    }
  }
  async display() {
    const { containerEl } = this;
    let stepContentWrapper = containerEl.querySelector(".content-type-step-content");
    if (!stepContentWrapper) {
      containerEl.empty();
      stepContentWrapper = containerEl.createDiv({ cls: "content-type-step-content" });
    } else {
      stepContentWrapper.empty();
    }
    stepContentWrapper.createEl("h2", { text: "Content types" });
    stepContentWrapper.createEl("p", {
      text: "Detecting content types in your vault..."
    });
    if (!this.detected) {
      const savedContentTypes = this.state.contentTypes || [];
      const savedContentTypesMap = new Map(savedContentTypes.map((ct) => [ct.folder, ct]));
      const importedTypes = await this.importFromAstroComposer();
      const scannedTypes = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
      const allDetectedTypes = [];
      const imported = [...importedTypes];
      for (const scanned of scannedTypes) {
        const matchingImportedIndex = imported.findIndex(
          (it) => scanned.folder === it.folder || scanned.folder.endsWith(`/${it.folder}`) || it.folder.endsWith(`/${scanned.folder}`)
        );
        if (matchingImportedIndex >= 0) {
          const importedType = imported[matchingImportedIndex];
          if (scanned.folder.length > importedType.folder.length) {
            console.debug(`ContentTypeStep: Updating imported type "${importedType.name}" folder from "${importedType.folder}" to "${scanned.folder}"`);
            imported[matchingImportedIndex] = {
              ...importedType,
              folder: scanned.folder
            };
          }
        } else {
          allDetectedTypes.push(scanned);
        }
      }
      allDetectedTypes.push(...imported);
      const detectedTypesMap = new Map(allDetectedTypes.map((ct) => [ct.folder, ct]));
      const mergedTypes = [];
      const processedFolders = /* @__PURE__ */ new Set();
      const allFolders = /* @__PURE__ */ new Set([
        ...savedContentTypes.map((ct) => ct.folder),
        ...allDetectedTypes.map((ct) => ct.folder)
      ]);
      for (const folder of allFolders) {
        if (processedFolders.has(folder)) continue;
        let savedType = savedContentTypesMap.get(folder);
        const detectedType = detectedTypesMap.get(folder);
        if (savedType && !detectedType) {
          const matchingDetected = allDetectedTypes.find(
            (dt) => dt.folder.endsWith(`/${folder}`) || dt.folder === folder
          );
          if (matchingDetected && !processedFolders.has(matchingDetected.folder)) {
            console.debug(`ContentTypeStep: Reconciling saved folder "${folder}" with detected folder "${matchingDetected.folder}"`);
            mergedTypes.push({
              ...savedType,
              folder: matchingDetected.folder
            });
            processedFolders.add(folder);
            processedFolders.add(matchingDetected.folder);
            continue;
          }
        }
        if (savedType) {
          if (detectedType) {
            mergedTypes.push({
              ...savedType,
              // Preserve all saved settings (enabled, custom name, linkBasePath, etc.)
              // Always preserve saved folder and name (user may have customized the name)
              folder: savedType.folder,
              name: savedType.name
              // Always use saved name (may be customized)
            });
          } else {
            mergedTypes.push(savedType);
          }
        } else if (detectedType) {
          mergedTypes.push(detectedType);
        }
        processedFolders.add(folder);
      }
      mergedTypes.sort((a, b) => a.name.localeCompare(b.name));
      this.state.contentTypes = mergedTypes;
      this.detected = true;
    }
    stepContentWrapper.empty();
    stepContentWrapper.createEl("h2", { text: "Content types" });
    stepContentWrapper.createEl("p", {
      text: "Select and configure your content types:"
    });
    stepContentWrapper.createEl("h3", { text: "Attachment handling", cls: "vault-cms-section-header" });
    stepContentWrapper.createEl("p", {
      text: "How should attachments be stored globally?",
      cls: "vault-cms-section-desc"
    });
    new import_obsidian8.Setting(stepContentWrapper).setName("How are attachments handled?").setDesc("Choose how attachments are stored for all content types").addDropdown((dropdown) => dropdown.addOption("same-folder", "Same folder as current file").addOption("specified-folder", "In the specified folder").addOption("subfolder", "In subfolder under current folder").setValue(this.state.attachmentHandlingMode || "subfolder").onChange((value) => {
      this.state.attachmentHandlingMode = value;
      if (value === "same-folder") {
        this.state.attachmentFolderName = void 0;
      }
      void this.display();
    }));
    if (this.state.attachmentHandlingMode === "specified-folder" || this.state.attachmentHandlingMode === "subfolder") {
      const descText = this.state.attachmentHandlingMode === "specified-folder" ? 'Enter the exact path to the folder for attachments (e.g., "attachments" or "images/attachments"). Leave blank to use "attachments" as default.' : 'Enter the name of the subfolder for attachments (e.g., "attachments"). Leave blank to use "attachments" as default.';
      const folderNameSetting = new import_obsidian8.Setting(stepContentWrapper).setName("Attachment folder").setDesc(descText);
      folderNameSetting.addText((text) => {
        text.setPlaceholder("attachments").setValue(this.state.attachmentFolderName || "").onChange((value) => {
          this.state.attachmentFolderName = value || void 0;
        });
        if (this.state.attachmentHandlingMode !== "same-folder") {
          new FolderNameSuggest(this.app, text.inputEl, this.state.attachmentHandlingMode);
        }
      });
    }
    stepContentWrapper.createEl("hr", { cls: "vault-cms-divider" });
    stepContentWrapper.createEl("h3", { text: "Content types", cls: "vault-cms-section-header" });
    for (const contentType of this.state.contentTypes) {
      const setting = new import_obsidian8.Setting(stepContentWrapper);
      const nameContainer = setting.nameEl.createDiv({ cls: "vault-cms-editable-name" });
      setCssProps3(nameContainer, { display: "flex", alignItems: "center", gap: "0.5rem" });
      const createNameDisplay = (name) => {
        nameContainer.empty();
        const display = nameContainer.createSpan({
          text: name,
          cls: "vault-cms-name-display"
        });
        const iconContainer = nameContainer.createDiv({ cls: "vault-cms-edit-icon" });
        setCssProps3(iconContainer, { opacity: "0.6" });
        (0, import_obsidian8.setIcon)(iconContainer, "lucide-pencil-line");
        const startEdit = () => {
          const currentName = contentType.name;
          nameContainer.empty();
          const nameInput = nameContainer.createEl("input", {
            type: "text",
            value: currentName
          });
          nameInput.addClass("mod-text-input");
          nameInput.focus();
          nameInput.select();
          const saveName = () => {
            nameInput.removeEventListener("blur", saveName);
            let newName = nameInput.value.trim();
            if (!newName) {
              newName = currentName;
            }
            newName = newName.replace(/[<>:"/\\|?*\x00-\x1F]/g, "");
            if (!newName.trim()) {
              newName = currentName;
            } else {
              newName = newName.trim();
            }
            contentType.name = newName;
            void this.display();
          };
          nameInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              saveName();
            } else if (e.key === "Escape") {
              e.preventDefault();
              createNameDisplay(currentName);
            }
          });
          nameInput.addEventListener("blur", saveName);
        };
        display.addEventListener("click", startEdit);
        iconContainer.addEventListener("click", startEdit);
        iconContainer.addEventListener("mouseenter", () => {
          setCssProps3(iconContainer, { opacity: "1" });
        });
        iconContainer.addEventListener("mouseleave", () => {
          setCssProps3(iconContainer, { opacity: "0.6" });
        });
        return display;
      };
      createNameDisplay(contentType.name);
      setting.setDesc(`Folder: ${contentType.folder}`).addToggle((toggle) => toggle.setValue(contentType.enabled).onChange((value) => {
        contentType.enabled = value;
      }));
      new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - File organization`).setDesc("Choose how content is organized for this content type").addDropdown((dropdown) => dropdown.addOption("file", "File-based").addOption("folder", "Folder-based").setValue(contentType.fileOrganization || "file").onChange((value) => {
        contentType.fileOrganization = value;
        void this.display();
      }));
      if (contentType.fileOrganization === "folder") {
        new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - Index file name`).setDesc("Name of the index file in folder-based organization").addText((text) => text.setValue(contentType.indexFileName || "index").onChange((value) => {
          contentType.indexFileName = value || "index";
        }));
      }
      const pathParts = contentType.folder.split("/").filter((p) => p.length > 0);
      const folderName = pathParts[pathParts.length - 1] || contentType.folder;
      const defaultLinkBasePath = `/${folderName}/`;
      new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - Link base path`).setDesc(`URL path for this content type (e.g., "/posts/" or "/" for root). Leave blank to use default: ${defaultLinkBasePath}`).addText((text) => text.setPlaceholder(defaultLinkBasePath).setValue(contentType.linkBasePath || "").onChange((value) => {
        contentType.linkBasePath = value || void 0;
      }));
    }
    const addButton = stepContentWrapper.createEl("button", {
      text: "Add additional content type",
      cls: "mod-cta"
    });
    setCssProps3(addButton, { marginTop: "20px", marginBottom: "30px" });
    addButton.addEventListener("click", () => {
      void (async () => {
        const selectedFolder = this.selectContentTypeFolder();
        if (selectedFolder) {
          const vaultPath = this.getVaultPath();
          let folderPath = selectedFolder;
          if (selectedFolder.startsWith(vaultPath)) {
            folderPath = selectedFolder.substring(vaultPath.length).replace(/^[/\\]+/, "");
          }
          const pathParts = folderPath.split(/[/\\]/).filter((p) => p.length > 0);
          const leafFolderName = pathParts[pathParts.length - 1] || folderPath;
          const newType = {
            id: `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
            name: this.capitalizeFirst(leafFolderName),
            folder: folderPath,
            fileOrganization: "file",
            enabled: true,
            // Enable by default so it shows up in Step 5
            indexFileName: "index"
          };
          this.state.contentTypes.push(newType);
          await this.display();
        }
      })();
    });
  }
  /**
   * Select folder for additional content type
   */
  selectContentTypeFolder() {
    var _a, _b;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      const result = dialog.showOpenDialogSync({
        title: "Select Content Type Folder",
        defaultPath: vaultPath,
        properties: ["openDirectory"]
      });
      if (result && result.length > 0) {
        return result[0].replace(/\\/g, "/").replace(/\/$/, "");
      }
    } catch (error) {
      console.error("Error opening folder picker:", error);
      new import_obsidian8.Notice("Unable to open folder picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (vaultPath) {
      if (vaultPath.startsWith("/") || /^[A-Z]:/.test(vaultPath)) {
        return vaultPath.replace(/\\/g, "/");
      }
      return vaultPath.replace(/\\/g, "/");
    }
    return "/";
  }
  /**
   * Capitalize first letter
   */
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  validate() {
    return this.state.contentTypes.some((ct) => ct.enabled);
  }
  getTitle() {
    return "Content types";
  }
  getDescription() {
    return "Configure content types";
  }
};

// src/ui/wizard/DefaultContentTypeStep.ts
var import_obsidian9 = require("obsidian");
var DefaultContentTypeStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Default content type" });
    containerEl.createEl("p", {
      text: "Select which content type should be used as the default. This will:"
    });
    const ul = containerEl.createEl("ul");
    ul.createEl("li", { text: "Set as the default Bases CMS view" });
    ul.createEl("li", { text: `Configure Obsidian's "Default location for new notes" to that folder.` });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    if (enabledTypes.length === 0) {
      containerEl.createEl("p", {
        text: "No enabled content types found. Please go back and enable at least one content type."
      });
      return;
    }
    if (!this.state.defaultContentTypeId || enabledTypes.findIndex((ct) => ct.id === this.state.defaultContentTypeId) === -1) {
      this.state.defaultContentTypeId = enabledTypes[0].id;
    }
    const selectedValue = this.state.defaultContentTypeId;
    new import_obsidian9.Setting(containerEl).setName("Default content type").setDesc("Choose the default content type for new notes").addDropdown((dropdown) => {
      enabledTypes.forEach((ct) => {
        dropdown.addOption(ct.id, ct.name);
      });
      dropdown.setValue(selectedValue);
      dropdown.onChange((value) => {
        this.state.defaultContentTypeId = value;
      });
    });
  }
  validate() {
    return !!this.state.defaultContentTypeId;
  }
  getTitle() {
    return "Default content type";
  }
  getDescription() {
    return "Select default content type";
  }
};

// src/ui/wizard/FrontmatterPropertiesStep.ts
var import_obsidian11 = require("obsidian");

// src/utils/FrontmatterAnalyzer.ts
var import_obsidian10 = require("obsidian");

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path10) {
  const ctrl = callVisitor(key, node, visitor, path10);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path10, ctrl);
    return visit_(key, ctrl, visitor, path10);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path10 = Object.freeze(path10.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path10);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path10 = Object.freeze(path10.concat(node));
      const ck = visit_("key", node.key, visitor, path10);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path10);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path10) {
  const ctrl = await callVisitor(key, node, visitor, path10);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path10, ctrl);
    return visitAsync_(key, ctrl, visitor, path10);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path10 = Object.freeze(path10.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path10);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path10 = Object.freeze(path10.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path10);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path10);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path10) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path10);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path10);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path10);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path10);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path10);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path10);
  return void 0;
}
function replaceNode(key, path10, node) {
  const parent = path10[path10.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class _Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      prevAnchors != null ? prevAnchors : prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc, ctx) {
    let nodes;
    if (ctx == null ? void 0 : ctx.aliasResolveCache) {
      nodes = ctx.aliasResolveCache;
    } else {
      nodes = [];
      visit(doc, {
        Node: (_key, node) => {
          if (isAlias(node) || hasAnchor(node))
            nodes.push(node);
        }
      });
      if (ctx)
        ctx.aliasResolveCache = nodes;
    }
    let found = void 0;
    for (const node of nodes) {
      if (node === this)
        break;
      if (node.anchor === this.source)
        found = node;
    }
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc, ctx);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if ((data == null ? void 0 : data.res) === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a;
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = (_a = match.find((t) => !t.format)) != null ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => {
    var _a2;
    return ((_a2 = t.identify) == null ? void 0 : _a2.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b, _c, _d;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      (_c = ref.anchor) != null ? _c : ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_d = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _d.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path10, value) {
  let v = value;
  for (let i = path10.length - 1; i >= 0; --i) {
    const k = path10[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path10) => path10 == null || typeof path10 === "object" && !!path10[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path10, value) {
    if (isEmptyPath(path10))
      this.add(value);
    else {
      const [key, ...rest] = path10;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path10) {
    const [key, ...rest] = path10;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path10, keepScalar) {
    const [key, ...rest] = path10;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path10) {
    const [key, ...rest] = path10;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path10, value) {
    const [key, ...rest] = path10;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch (e) {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t) => t.format === item.format)) != null ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags.filter((t) => {
      var _a2;
      return (_a2 = t.identify) == null ? void 0 : _a2.call(t, obj);
    });
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = (_b = match.find((t) => t.format === item.format)) != null ? _b : match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : obj === null ? "null" : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  var _a;
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = (_a = node.tag) != null ? _a : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  tagObj != null ? tagObj : tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  var _a, _b;
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n" && valueComment)
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = (_b = (_a = ctx.inFlow) != null ? _a : value.flow) != null ? _b : value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
var MERGE_KEY = "<<";
var merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && (ctx == null ? void 0 : ctx.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default));
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class _Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new _Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) != null ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar(node) ? node.value : node) != null ? _a : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    type != null ? type : type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) != null ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class _YAMLSet extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = _YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => {
    var _a;
    return (_a = value == null ? void 0 : value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) != null ? _a : "";
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class _Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/Document.js
var Document = class _Document {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path10, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path10, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path10) {
    if (isEmptyPath(path10)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path10) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path10, keepScalar) {
    if (isEmptyPath(path10))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path10, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path10) {
    if (isEmptyPath(path10))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path10) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path10, value) {
    if (isEmptyPath(path10)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path10), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path10, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if ((end == null ? void 0 : end.line) === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || (next == null ? void 0 : next.type) !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        start != null ? start : start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        start != null ? start : start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow != null ? flow : "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || (next == null ? void 0 : next.type) === "block-map" || (next == null ? void 0 : next.type) === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start != null ? start : end
  };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  var _a, _b;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep: sep4, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep4 == null ? void 0 : sep4[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep4) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_b = keyProps.found) == null ? void 0 : _b.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep4 != null ? sep4 : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep4, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd != null ? commentEnd : offset];
  return map2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  var _a;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if ((value == null ? void 0 : value.type) === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd != null ? commentEnd : offset];
  return seq2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep4 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep4 + cb;
          sep4 = "";
          break;
        }
        case "newline":
          if (comment)
            sep4 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  var _a, _b, _c;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : isMap2 ? YAMLMap : YAMLSeq;
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep: sep4, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep4 == null ? void 0 : sep4[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep4 && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_b = prev.value) != null ? _b : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep4 && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep4, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep4 != null ? sep4 : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep4)
            for (const st of sep4) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && ((_c = value.source) == null ? void 0 : _c[0]) === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep4, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode != null ? valueNode : keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if ((ce == null ? void 0 : ce.source) === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  var _a, _b, _c;
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor != null ? anchor : tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if ((kt == null ? void 0 : kt.collection) === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${(_a = kt.collection) != null ? _a : "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = (_c = (_b = tag.resolve) == null ? void 0 : _b.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) != null ? _c : coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep4 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep4 + indent.slice(trimIndent) + content;
      sep4 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep4 === " ")
        sep4 = "\n";
      else if (!prevMoreIndented && sep4 === "\n")
        sep4 = "\n\n";
      value += sep4 + indent.slice(trimIndent) + content;
      sep4 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep4 === "\n")
        value += "\n";
      else
        sep4 = "\n";
    } else {
      value += sep4 + content;
      sep4 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (e) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep4 = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep4 === "\n")
        res += sep4;
      else
        sep4 = "\n";
    } else {
      res += sep4 + match[1];
      sep4 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep4 + ((_a = match == null ? void 0 : match[1]) != null ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  var _a;
  const tag = schema4.tags.find((tag2) => {
    var _a2;
    return (tag2.default === true || atKey && tag2.default === "key") && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a = schema4.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
    })) != null ? _a : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    pos != null ? pos : pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag != null ? tag : token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value != null ? value : end == null ? void 0 : end[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) == null ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path10) => {
  let item = cst;
  for (const [field, index] of path10) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path10) => {
  const parent = visit2.itemAtPath(cst, path10.slice(0, -1));
  const field = path10[path10.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path10, item, visitor) {
  let ctrl = visitor(item, path10);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path10.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path10);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path10) : ctrl;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) != null ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next = this.buffer[i2 + 1];
          if (!next && !this.atEnd)
            return this.setNext("block-scalar");
          if (next === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (((_a = prev[++i]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (top == null ? void 0 : top.type) !== "doc-end") {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error != null ? error : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep4;
      if (scalar.end) {
        sep4 = scalar.end;
        sep4.push(this.sourceToken);
        delete scalar.end;
      } else
        sep4 = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep: sep4 }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep4 = it.sep;
              sep4.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep: sep4 }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs7 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs7, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs7);
          } else {
            Object.assign(it, { key: fs7, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while ((top == null ? void 0 : top.type) === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs7 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs7, sep: [] });
          else if (it.sep)
            this.stack.push(fs7);
          else
            Object.assign(it, { key: fs7, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep4 = fc.end.splice(1, fc.end.length);
        sep4.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep: sep4 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse2(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}

// src/utils/FrontmatterAnalyzer.ts
var FrontmatterAnalyzer = class {
  constructor(app) {
    this.app = app;
  }
  async findExampleFile(folderPath, includeMdx = false) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      return null;
    }
    if (folder instanceof import_obsidian10.TFile) {
      const ext = folder.extension;
      if (ext === "md" || includeMdx && ext === "mdx") {
        return await this.parseFrontmatter(folder);
      }
      return null;
    }
    if (!(folder instanceof import_obsidian10.TFolder)) {
      return null;
    }
    let files = this.getMarkdownFiles(folder, false, void 0, 0, includeMdx);
    if (files.length === 0) {
      files = this.getMarkdownFiles(folder, true, 1, 0, includeMdx);
      if (files.length === 0) {
        files = this.getMarkdownFiles(folder, true, 2, 0, includeMdx);
      }
      if (files.length === 0) {
        files = this.getMarkdownFiles(folder, true, void 0, 0, includeMdx);
      }
    }
    for (const file of files) {
      const example = await this.parseFrontmatter(file);
      if (example) {
        return example;
      }
    }
    return null;
  }
  /**
   * Scans multiple files in a folder to aggregate all unique frontmatter properties.
   * This ensures properties aren't missed just because they're not in the single "latest" file.
   */
  async getPropertiesInFolder(folderPath, includeMdx = false, limit = 50) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!(folder instanceof import_obsidian10.TFolder)) {
      return /* @__PURE__ */ new Set();
    }
    const files = this.getMarkdownFiles(folder, true, void 0, 0, includeMdx);
    const aggregateProps = /* @__PURE__ */ new Set();
    const filesToScan = files.slice(0, limit);
    for (const file of filesToScan) {
      if (file.extension === "md") {
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache && cache.frontmatter) {
          Object.keys(cache.frontmatter).forEach((key) => aggregateProps.add(key));
        }
      } else if (includeMdx && file.extension === "mdx") {
        const example = await this.parseFrontmatter(file);
        if (example && example.frontmatter) {
          Object.keys(example.frontmatter).forEach((key) => aggregateProps.add(key));
        }
      }
    }
    return aggregateProps;
  }
  hasUnderscoreFiles(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!(folder instanceof import_obsidian10.TFolder)) {
      return Promise.resolve(false);
    }
    const files = this.getMarkdownFiles(folder, true);
    return Promise.resolve(files.some((file) => file.name.startsWith("_")));
  }
  getMarkdownFiles(folder, recursive = true, maxDepth, currentDepth = 0, includeMdx = false) {
    const files = [];
    if (!folder.children) {
      return files;
    }
    if (maxDepth !== void 0 && currentDepth >= maxDepth) {
      return files;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian10.TFile) {
        if (child.extension === "md" || includeMdx && child.extension === "mdx") {
          files.push(child);
        }
      } else if (recursive && child instanceof import_obsidian10.TFolder && child.children) {
        files.push(...this.getMarkdownFiles(child, recursive, maxDepth, currentDepth + 1, includeMdx));
      }
    }
    return files;
  }
  async parseFrontmatter(file) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const yamlContent = match[1];
      const frontmatter = parse2(yamlContent);
      if (!frontmatter || typeof frontmatter !== "object") {
        return null;
      }
      return {
        file: file.path,
        frontmatter,
        rawYaml: yamlContent
      };
    } catch (e) {
      return null;
    }
  }
  autoDetectDateProperty(frontmatter) {
    const dateProperties = ["date", "pubDate", "publishedDate", "publishDate"];
    for (const prop of dateProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
  autoDetectDescriptionProperty(frontmatter) {
    const descriptionProperties = ["description", "summary", "excerpt", "intro", "snippet", "blurb"];
    for (const prop of descriptionProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
  autoDetectTagsProperty(frontmatter) {
    if (frontmatter.hasOwnProperty("tags")) {
      return "tags";
    }
    return null;
  }
  autoDetectDraftProperty(frontmatter) {
    if (frontmatter.hasOwnProperty("draft")) {
      return { property: "draft", logic: "true-draft" };
    }
    if (frontmatter.hasOwnProperty("published")) {
      return { property: "published", logic: "false-draft" };
    }
    return null;
  }
  autoDetectImageProperty(frontmatter) {
    const imageProperties = ["image", "cover", "coverImage", "thumbnail", "featuredImage"];
    for (const prop of imageProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
};

// src/ui/wizard/FrontmatterPropertiesStep.ts
function setCssProps4(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var FrontmatterPropertiesStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.examples = {};
    this.frontmatterAnalyzer = new FrontmatterAnalyzer(app);
  }
  async display() {
    const { containerEl } = this;
    const existingWrapper = containerEl.querySelector(".frontmatter-step-content");
    if (existingWrapper) {
      existingWrapper.remove();
    }
    const stepContentWrapper = containerEl.createDiv({ cls: "frontmatter-step-content" });
    stepContentWrapper.createEl("h2", { text: "Frontmatter properties" });
    stepContentWrapper.createEl("p", {
      text: "Map frontmatter properties for each content type. We'll find example files to help you."
    });
    for (const contentType of this.state.contentTypes) {
      if (!contentType.enabled) {
        continue;
      }
      const contentTypeWrapper = stepContentWrapper.createDiv({ cls: "content-type-settings" });
      const pathResolver = new PathResolver(this.app);
      const folderPath = pathResolver.getFolderPathFromVaultRoot(contentType.folder, this.state.projectDetection);
      if (!this.examples[contentType.id]) {
        const example2 = await this.frontmatterAnalyzer.findExampleFile(folderPath, this.state.enableMdxSupport);
        if (example2) {
          this.examples[contentType.id] = example2;
        }
      }
      const example = this.examples[contentType.id];
      const aggregateProps = await this.frontmatterAnalyzer.getPropertiesInFolder(folderPath, this.state.enableMdxSupport);
      const dummyFrontmatter = {};
      aggregateProps.forEach((key) => dummyFrontmatter[key] = null);
      contentTypeWrapper.createEl("h3", { text: contentType.name });
      if (example) {
        contentTypeWrapper.createEl("p", { text: `Example file: ${example.file}` });
        const preEl = contentTypeWrapper.createEl("pre", {
          text: example.rawYaml,
          cls: "frontmatter-example"
        });
        setCssProps4(preEl, {
          fontFamily: "var(--font-monospace)",
          fontSize: "0.85em",
          whiteSpace: "pre-wrap",
          overflowWrap: "break-word",
          maxWidth: "100%",
          padding: "10px",
          backgroundColor: "var(--background-secondary)",
          borderRadius: "4px",
          border: "1px solid var(--background-modifier-border)"
        });
      }
      if (!this.state.frontmatterProperties[contentType.id]) {
        const detectedDraft = this.frontmatterAnalyzer.autoDetectDraftProperty(dummyFrontmatter);
        const detectedTags = this.frontmatterAnalyzer.autoDetectTagsProperty(dummyFrontmatter);
        const detectedImage = this.frontmatterAnalyzer.autoDetectImageProperty(dummyFrontmatter);
        const detectedDesc = this.frontmatterAnalyzer.autoDetectDescriptionProperty(dummyFrontmatter);
        const detectedTitle = dummyFrontmatter.hasOwnProperty("title") ? "title" : null;
        const detectedDate = this.frontmatterAnalyzer.autoDetectDateProperty(dummyFrontmatter);
        const hasUnderscoreFiles = await this.frontmatterAnalyzer.hasUnderscoreFiles(folderPath);
        this.state.frontmatterProperties[contentType.id] = {
          titleProperty: detectedTitle || void 0,
          // Only set if detected, otherwise blank
          dateProperty: detectedDate || void 0,
          // Only set if detected, otherwise blank
          descriptionProperty: detectedDesc || void 0,
          tagsProperty: detectedTags || void 0,
          draftProperty: detectedDraft == null ? void 0 : detectedDraft.property,
          draftLogic: (detectedDraft == null ? void 0 : detectedDraft.property) === "published" ? "false-draft" : detectedDraft ? "true-draft" : void 0,
          hasDraftStatus: !!(detectedDraft == null ? void 0 : detectedDraft.property) || hasUnderscoreFiles,
          // Track if draft status is enabled
          imageProperty: detectedImage || void 0
        };
      }
      const props = this.state.frontmatterProperties[contentType.id];
      new import_obsidian11.Setting(contentTypeWrapper).setName("Title property").setDesc("The frontmatter property that contains the title (e.g., title, name, heading). Leave blank to use full file name instead.").addText((text) => {
        const detected = "title";
        text.setPlaceholder(detected).setValue(props.titleProperty || "").onChange((value) => {
          props.titleProperty = value.trim() || void 0;
        });
      });
      new import_obsidian11.Setting(contentTypeWrapper).setName("Date property").setDesc("The frontmatter property that contains the date (e.g., date, pubDate, publishedDate, publishDate). Leave blank to use file created date instead.").addText((text) => {
        const detected = example ? this.frontmatterAnalyzer.autoDetectDateProperty(example.frontmatter) : null;
        text.setPlaceholder(detected || "date").setValue(props.dateProperty || "").onChange((value) => {
          props.dateProperty = value.trim() || void 0;
        });
      });
      const descSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has description/summary?").setDesc("Does this content type have a description or summary field?");
      let descTextSetting = null;
      descSetting.addToggle((toggle) => toggle.setValue(!!props.descriptionProperty).onChange((value) => {
        if (value && !props.descriptionProperty) {
          props.descriptionProperty = example ? this.frontmatterAnalyzer.autoDetectDescriptionProperty(example.frontmatter) || "description" : "description";
          if (!descTextSetting) {
            descTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Description property").setDesc("The frontmatter property that contains the description (e.g., description, summary, excerpt, intro, snippet, blurb)").addText((text) => text.setValue(props.descriptionProperty || "").onChange((value2) => {
              props.descriptionProperty = value2.trim() || void 0;
            }));
            descTextSetting.settingEl.remove();
            descSetting.settingEl.insertAdjacentElement("afterend", descTextSetting.settingEl);
          }
        } else if (!value) {
          props.descriptionProperty = void 0;
          if (descTextSetting) {
            descTextSetting.settingEl.remove();
            descTextSetting = null;
          }
        }
      }));
      if (props.descriptionProperty) {
        descTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Description property").setDesc("The frontmatter property that contains the description (e.g., description, summary, excerpt, intro, snippet, blurb)").addText((text) => text.setValue(props.descriptionProperty || "").onChange((value) => {
          props.descriptionProperty = value.trim() || void 0;
        }));
        descTextSetting.settingEl.remove();
        descSetting.settingEl.insertAdjacentElement("afterend", descTextSetting.settingEl);
      }
      const tagsSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has tags?").setDesc("Does this content type have tags?");
      let tagsTextSetting = null;
      tagsSetting.addToggle((toggle) => toggle.setValue(!!props.tagsProperty).onChange((value) => {
        if (value && !props.tagsProperty) {
          const detected = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
          props.tagsProperty = detected || "tags";
          if (!tagsTextSetting) {
            tagsTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Tags property").setDesc("The frontmatter property that contains tags (e.g., tags, tag, categories, category). Leave blank if not applicable.").addText((text) => {
              const detected2 = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
              text.setPlaceholder(detected2 || "tags").setValue(props.tagsProperty || "").onChange((value2) => {
                props.tagsProperty = value2.trim() || void 0;
              });
            });
            tagsTextSetting.settingEl.remove();
            tagsSetting.settingEl.insertAdjacentElement("afterend", tagsTextSetting.settingEl);
          }
        } else if (!value) {
          props.tagsProperty = void 0;
          if (tagsTextSetting) {
            tagsTextSetting.settingEl.remove();
            tagsTextSetting = null;
          }
        }
      }));
      if (props.tagsProperty) {
        tagsTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Tags property").setDesc("The frontmatter property that contains tags (e.g., tags, tag, categories, category). Leave blank if not applicable.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
          text.setPlaceholder(detected || "tags").setValue(props.tagsProperty || "").onChange((value) => {
            props.tagsProperty = value.trim() || void 0;
          });
        });
        tagsTextSetting.settingEl.remove();
        tagsSetting.settingEl.insertAdjacentElement("afterend", tagsTextSetting.settingEl);
      }
      const draftSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has draft status?").setDesc("Does this content type have draft status?");
      let draftPropertySetting = null;
      let draftLogicSetting = null;
      if (props.hasDraftStatus === void 0) {
        props.hasDraftStatus = !!props.draftProperty;
      }
      draftSetting.addToggle((toggle) => {
        var _a;
        return toggle.setValue((_a = props.hasDraftStatus) != null ? _a : !!props.draftProperty).onChange((value) => {
          props.hasDraftStatus = value;
          if (value && !props.draftProperty) {
            const detectedDraft = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
            props.draftProperty = (detectedDraft == null ? void 0 : detectedDraft.property) || "draft";
            if ((detectedDraft == null ? void 0 : detectedDraft.property) === "published") {
              props.draftLogic = "false-draft";
            } else {
              props.draftLogic = "true-draft";
            }
            if (!draftPropertySetting) {
              draftPropertySetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft property").setDesc("The frontmatter property that contains draft status. Leave blank to use an underscore prefix instead.").addText((text) => {
                const detected = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
                text.setPlaceholder((detected == null ? void 0 : detected.property) || "draft").setValue(props.draftProperty || "").onChange((value2) => {
                  props.draftProperty = value2.trim() || void 0;
                  if (value2 === "published") {
                    props.draftLogic = "false-draft";
                  } else if (value2) {
                    props.draftLogic = "true-draft";
                  }
                  if (value2 && !draftLogicSetting) {
                    draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((dropdownValue) => {
                      props.draftLogic = dropdownValue;
                    }));
                    draftLogicSetting.settingEl.remove();
                    if (draftPropertySetting) {
                      draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
                    }
                  } else if (!value2 && draftLogicSetting) {
                    draftLogicSetting.settingEl.remove();
                    draftLogicSetting = null;
                  }
                });
              });
              draftPropertySetting.settingEl.remove();
              draftSetting.settingEl.insertAdjacentElement("afterend", draftPropertySetting.settingEl);
            }
            if (props.draftProperty && !draftLogicSetting) {
              draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((value2) => {
                props.draftLogic = value2;
              }));
              draftLogicSetting.settingEl.remove();
              if (draftPropertySetting !== null) {
                draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
              }
            }
          } else if (!value) {
            props.draftProperty = void 0;
            props.draftLogic = void 0;
            props.hasDraftStatus = false;
            if (draftPropertySetting) {
              draftPropertySetting.settingEl.remove();
              draftPropertySetting = null;
            }
            if (draftLogicSetting) {
              draftLogicSetting.settingEl.remove();
              draftLogicSetting = null;
            }
          }
        });
      });
      if (props.hasDraftStatus) {
        draftPropertySetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft property").setDesc("The frontmatter property that contains draft status. Leave blank to use an underscore prefix instead.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
          text.setPlaceholder((detected == null ? void 0 : detected.property) || "draft").setValue(props.draftProperty || "").onChange((value) => {
            props.draftProperty = value.trim() || void 0;
            if (value === "published") {
              props.draftLogic = "false-draft";
            } else if (value) {
              props.draftLogic = "true-draft";
            }
            if (value && !draftLogicSetting) {
              draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((dropdownValue) => {
                props.draftLogic = dropdownValue;
              }));
              draftLogicSetting.settingEl.remove();
              if (draftPropertySetting) {
                draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
              }
            } else if (!value && draftLogicSetting) {
              draftLogicSetting.settingEl.remove();
              draftLogicSetting = null;
            }
          });
        });
        draftPropertySetting.settingEl.remove();
        draftSetting.settingEl.insertAdjacentElement("afterend", draftPropertySetting.settingEl);
        if (props.draftProperty) {
          draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((value) => {
            props.draftLogic = value;
          }));
          draftLogicSetting.settingEl.remove();
          if (draftPropertySetting !== null) {
            draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
          }
        }
      }
      const imageSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has image/cover property?").setDesc("Does this content type have an image or cover property? Used for Bases CMS cover images and Image Manager.");
      let imageTextSetting = null;
      imageSetting.addToggle((toggle) => toggle.setValue(!!props.imageProperty).onChange((value) => {
        if (value && !props.imageProperty) {
          const detected = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
          props.imageProperty = detected || "image";
          if (!imageTextSetting) {
            imageTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Image property").setDesc("The frontmatter property that contains the image/cover (e.g., image, cover, coverImage, thumbnail, featuredImage). Leave blank if not applicable.").addText((text) => {
              const detected2 = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
              text.setPlaceholder(detected2 || "image").setValue(props.imageProperty || "").onChange((value2) => {
                props.imageProperty = value2.trim() || void 0;
              });
            });
            imageTextSetting.settingEl.remove();
            imageSetting.settingEl.insertAdjacentElement("afterend", imageTextSetting.settingEl);
          }
        } else if (!value) {
          props.imageProperty = void 0;
          if (imageTextSetting) {
            imageTextSetting.settingEl.remove();
            imageTextSetting = null;
          }
        }
      }));
      if (props.imageProperty) {
        imageTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Image property").setDesc("The frontmatter property that contains the image/cover (e.g., image, cover, coverImage, thumbnail, featuredImage). Leave blank if not applicable.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
          text.setPlaceholder(detected || "image").setValue(props.imageProperty || "").onChange((value) => {
            props.imageProperty = value.trim() || void 0;
          });
        });
        imageTextSetting.settingEl.remove();
        imageSetting.settingEl.insertAdjacentElement("afterend", imageTextSetting.settingEl);
      }
      contentTypeWrapper.createEl("h4", { text: "Template" });
      contentTypeWrapper.createEl("p", {
        text: 'Edit the template that will be used when creating new files of this content type. Use {{title}} and {{date}} as variables. Note: {{title}} should be in quotes (e.g., title: "{{title}}"), while {{date}} should not be in quotes (e.g., date: {{date}}).'
      });
      if (!props.template) {
        const pathResolver2 = new PathResolver(this.app);
        const folderPath2 = pathResolver2.getFolderPathFromVaultRoot(contentType.folder, this.state.projectDetection);
        const aggregateProps2 = await this.frontmatterAnalyzer.getPropertiesInFolder(folderPath2, this.state.enableMdxSupport);
        props.template = this.generateDefaultTemplate(props, example, aggregateProps2);
      }
      const templateTextArea = contentTypeWrapper.createEl("textarea", {
        cls: "template-editor",
        attr: {
          rows: "10",
          style: "width: 100%; font-family: monospace;",
          spellcheck: "false"
        }
      });
      templateTextArea.value = props.template || "";
      templateTextArea.addEventListener("input", (e) => {
        const target = e.target;
        props.template = target.value;
      });
    }
  }
  generateDefaultTemplate(props, example, aggregateProps) {
    let template = "---\n";
    if (example && example.rawYaml) {
      const lines = example.rawYaml.split("\n");
      const processedProps = /* @__PURE__ */ new Set();
      let titleAdded = false;
      if (props.titleProperty) {
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) continue;
          const colonIndex = trimmed.indexOf(":");
          if (colonIndex > 0) {
            const prop = trimmed.substring(0, colonIndex).trim();
            if (prop === props.titleProperty) {
              template += `${props.titleProperty}: "{{title}}"
`;
              titleAdded = true;
              processedProps.add(prop);
              continue;
            }
          }
        }
        if (!titleAdded) {
          template += `${props.titleProperty}: "{{title}}"
`;
        }
      }
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith("#")) continue;
        const colonIndex = trimmed.indexOf(":");
        if (colonIndex > 0) {
          const prop = trimmed.substring(0, colonIndex).trim();
          if (processedProps.has(prop)) {
            continue;
          }
          if (prop === props.titleProperty) {
            continue;
          }
          if (prop === props.dateProperty && props.dateProperty) {
            template += `${props.dateProperty}: {{date}}
`;
            processedProps.add(prop);
            continue;
          }
          if (prop === props.descriptionProperty) {
            template += `${props.descriptionProperty}: ""
`;
            processedProps.add(prop);
            continue;
          }
          const value = example.frontmatter[prop];
          if (value === null || value === void 0) {
            template += `${prop}:
`;
          } else if (Array.isArray(value)) {
            template += `${prop}: []
`;
          } else if (typeof value === "boolean") {
            template += `${prop}: ${value}
`;
          } else if (typeof value === "number") {
            template += `${prop}: ${value}
`;
          } else if (typeof value === "string") {
            if (/^\d{4}-\d{2}-\d{2}/.test(value) && prop.toLowerCase().includes("date")) {
              template += `${prop}: {{date}}
`;
            } else {
              template += `${prop}: ""
`;
            }
          } else if (typeof value === "object") {
            if (Array.isArray(value)) {
              template += `${prop}: []
`;
            } else {
              template += `${prop}:
`;
            }
          }
          processedProps.add(prop);
        }
      }
      for (const prop of aggregateProps) {
        if (processedProps.has(prop)) continue;
        if (prop === props.titleProperty) {
          template += `${prop}: "{{title}}"
`;
        } else if (prop === props.dateProperty) {
          template += `${prop}: {{date}}
`;
        } else if (prop === props.descriptionProperty) {
          template += `${prop}: ""
`;
        } else if (prop === props.tagsProperty) {
          template += `${prop}: []
`;
        } else if (prop === props.imageProperty) {
          template += `${prop}: ""
`;
        } else if (prop === props.draftProperty) {
          const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
          template += `${prop}: ${draftValue}
`;
        } else {
          template += `${prop}: ""
`;
        }
        processedProps.add(prop);
      }
    } else {
      if (props.titleProperty) {
        template += `${props.titleProperty}: "{{title}}"
`;
      }
      if (props.dateProperty) {
        template += `${props.dateProperty}: {{date}}
`;
      }
      if (props.descriptionProperty) {
        template += `${props.descriptionProperty}: ""
`;
      }
      if (props.tagsProperty) {
        template += `${props.tagsProperty}: []
`;
      }
      if (props.draftProperty) {
        const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
        template += `${props.draftProperty}: ${draftValue}
`;
      }
    }
    template += "---\n";
    return template;
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Frontmatter properties";
  }
  getDescription() {
    return "Map frontmatter properties";
  }
};

// src/ui/wizard/EditingToolbarStep.ts
var import_obsidian12 = require("obsidian");
var EditingToolbarStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Editing Toolbar" });
    containerEl.createEl("p", {
      text: "Do you want to use the Editing Toolbar?"
    });
    containerEl.createEl("p", {
      text: "This enables a visual editing toolbar for formatting text. The toolbar can be toggled on/off via command."
    });
    new import_obsidian12.Setting(containerEl).setName("Enable Editing Toolbar").setDesc("Show the editing toolbar command in the page header").addToggle((toggle) => toggle.setValue(this.state.enableEditingToolbar).onChange((value) => {
      this.state.enableEditingToolbar = value;
    }));
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Editing Toolbar preference";
  }
  getDescription() {
    return "Configure editing toolbar preference";
  }
};

// src/ui/wizard/BasesCMSConfigStep.ts
var BasesCMSConfigStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Bases CMS configuration" });
    containerEl.createEl("p", {
      text: "Bases CMS views will be automatically created for each enabled content type using your mapped frontmatter properties."
    });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    if (enabledTypes.length === 0) {
      containerEl.createEl("p", {
        text: "No content types enabled. Please go back and enable at least one content type."
      });
      return;
    }
    containerEl.createEl("h3", { text: "Views to be created:" });
    const list = containerEl.createEl("ul");
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        const properties = [];
        if (props.titleProperty) properties.push(`title: ${props.titleProperty}`);
        if (props.dateProperty) properties.push(`date: ${props.dateProperty}`);
        if (props.descriptionProperty) properties.push(`description: ${props.descriptionProperty}`);
        if (props.tagsProperty) properties.push(`tags: ${props.tagsProperty}`);
        if (props.imageProperty) properties.push(`image: ${props.imageProperty}`);
        if (props.draftProperty) properties.push(`draft: ${props.draftProperty}`);
        const propertiesText = properties.length > 0 ? properties.join(", ") : "default properties";
        list.createEl("li", {
          text: `${contentType.name}: ${propertiesText}`
        });
      }
    }
    containerEl.createEl("p", {
      text: "You can customize these views later in the Bases CMS settings."
    });
  }
  validate() {
    return this.state.contentTypes.some((ct) => ct.enabled);
  }
  getTitle() {
    return "Bases CMS configuration";
  }
  getDescription() {
    return "Configure Bases CMS views";
  }
};

// src/ui/wizard/AstroComposerStep.ts
var AstroComposerStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Astro Composer configuration" });
    containerEl.createEl("p", {
      text: "Astro Composer will be configured with your content types and frontmatter properties."
    });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    if (enabledTypes.length === 0) {
      containerEl.createEl("p", {
        text: "No content types enabled."
      });
      return;
    }
    containerEl.createEl("h3", { text: "Content types to configure:" });
    const list = containerEl.createEl("ul");
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        const modeLabel = contentType.fileOrganization === "folder" ? "folder-based" : "file-based";
        list.createEl("li", {
          text: `${contentType.name} (${contentType.folder}): ${modeLabel}`
        });
      }
    }
    if (this.state.projectDetection) {
      if (this.state.projectDetection.projectRoot) {
        containerEl.createEl("p", {
          text: `Project root: ${this.state.projectDetection.projectRoot}`
        });
      }
      if (this.state.projectDetection.configFilePath) {
        containerEl.createEl("p", {
          text: `Config file: ${this.state.projectDetection.configFilePath}`
        });
      }
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Astro Composer configuration";
  }
  getDescription() {
    return "Configure Astro Composer";
  }
};

// src/ui/wizard/SEOConfigStep.ts
var import_obsidian13 = require("obsidian");
function setCssProps5(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var SEOConfigStep = class extends BaseWizardStep {
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "SEO plugin configuration" });
    containerEl.createEl("p", {
      text: "SEO plugin will be configured using your mapped frontmatter properties."
    });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    const firstType = enabledTypes[0];
    const firstProps = firstType ? this.state.frontmatterProperties[firstType.id] : void 0;
    const titleProperties = /* @__PURE__ */ new Set();
    const descriptionProperties = /* @__PURE__ */ new Set();
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        if (props.titleProperty) {
          titleProperties.add(props.titleProperty);
        }
        if (props.descriptionProperty) {
          descriptionProperties.add(props.descriptionProperty);
        }
      }
    }
    if (titleProperties.size > 1 || descriptionProperties.size > 1) {
      const warningDiv = containerEl.createDiv({ cls: "vault-cms-warning" });
      setCssProps5(warningDiv, {
        padding: "10px",
        backgroundColor: "var(--background-modifier-border)",
        borderLeft: "3px solid var(--text-warning)",
        marginBottom: "15px"
      });
      warningDiv.createEl("p", {
        text: "\u26A0\uFE0F Warning: Different content types use different properties for title or description.",
        attr: { style: "margin: 0 0 5px 0; font-weight: bold;" }
      });
      warningDiv.createEl("p", {
        text: "The SEO plugin will use the first content type's properties. You may need to manually configure SEO settings for other content types.",
        attr: { style: "margin: 0;" }
      });
    }
    if (firstProps) {
      containerEl.createEl("h3", { text: "Configuration:" });
      containerEl.createEl("p", {
        text: `Title property: ${firstProps.titleProperty || "(using filename)"}`
      });
      if (firstProps.descriptionProperty) {
        containerEl.createEl("p", {
          text: `Description property: ${firstProps.descriptionProperty}`
        });
      }
      const scanDirs = enabledTypes.map((ct) => ct.folder).join(", ");
      containerEl.createEl("p", {
        text: `Scan directories: ${scanDirs}`
      });
    }
    const pathResolver = new PathResolver(this.app);
    const defaultScanDirs = this.state.contentTypes.filter((ct) => ct.enabled).map((ct) => pathResolver.getFolderPathFromVaultRoot(ct.folder, this.state.projectDetection)).join(",");
    const savedScanDirs = (_a = this.state.seoConfig) == null ? void 0 : _a.scanDirectories;
    const initialScanDirs = savedScanDirs && savedScanDirs.trim() ? savedScanDirs : defaultScanDirs;
    if (!this.state.seoConfig.scanDirectories || !this.state.seoConfig.scanDirectories.trim()) {
      this.state.seoConfig.scanDirectories = initialScanDirs;
    }
    new import_obsidian13.Setting(containerEl).setName("Scan directories").setDesc("Comma-separated list of directories to scan (you can customize this)").addText((text) => text.setValue(initialScanDirs).onChange((value) => {
      if (this.state.seoConfig) {
        this.state.seoConfig.scanDirectories = value;
      }
    }));
  }
  validate() {
    return true;
  }
  getTitle() {
    return "SEO configuration";
  }
  getDescription() {
    return "Configure SEO plugin";
  }
};

// src/ui/wizard/OptionalPluginsStep.ts
var import_obsidian14 = require("obsidian");

// src/utils/PluginManager.ts
var PluginManager = class {
  constructor(app) {
    this.app = app;
  }
  async enablePlugin(pluginId) {
    var _a, _b;
    const plugins = this.app.plugins;
    if (!plugins) {
      return;
    }
    const plugin = (_a = plugins.plugins) == null ? void 0 : _a[pluginId];
    if (plugin && !plugin.enabled) {
      await ((_b = plugins.enablePlugin) == null ? void 0 : _b.call(plugins, pluginId));
    }
  }
  async disablePlugin(pluginId) {
    var _a, _b;
    const plugins = this.app.plugins;
    if (!plugins) {
      return;
    }
    const plugin = (_a = plugins.plugins) == null ? void 0 : _a[pluginId];
    if (plugin && plugin.enabled) {
      await ((_b = plugins.disablePlugin) == null ? void 0 : _b.call(plugins, pluginId));
    }
  }
  async setPluginStates(enabled, disabled) {
    const corePlugins = ["bases-cms", "astro-composer", "vault-cms"];
    const safeDisabled = disabled.filter((p) => !corePlugins.includes(p));
    for (const pluginId of safeDisabled) {
      await this.disablePlugin(pluginId);
    }
    for (const pluginId of enabled) {
      await this.enablePlugin(pluginId);
    }
  }
  getPresetPlugins(preset) {
    const corePlugins = [
      "astro-composer",
      "bases-cms",
      "homepage",
      "new-tab-default-page",
      "property-over-file-name",
      "settings-search",
      "statusbar-organizer",
      "seo",
      "ui-tweaker",
      "zenmode",
      "cmdr",
      "simple-focus",
      "tag-wrangler"
    ];
    const optionalPlugins = [
      "editing-toolbar",
      "insert-unsplash-image",
      "custom-save",
      "title-only-tab",
      "obsidian-paste-image-rename",
      "obsidian42-brat",
      "obsidian-hider",
      "disable-tabs",
      "obsidian-style-settings",
      "mdx-as-md-obsidian",
      "explorer-focus"
    ];
    const opinionatedPlugins = [
      "obsidian-oxygen",
      "obsidian-style-settings"
    ];
    if (preset === "vanilla") {
      return {
        enabled: [...corePlugins, ...optionalPlugins.filter((p) => !opinionatedPlugins.includes(p))],
        disabled: opinionatedPlugins
      };
    } else if (preset === "opinionated") {
      return {
        enabled: [...corePlugins, ...optionalPlugins],
        disabled: []
      };
    } else {
      return {
        enabled: [],
        disabled: []
      };
    }
  }
};

// src/ui/wizard/OptionalPluginsStep.ts
function setCssProps6(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var OptionalPluginsStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.pluginManager = new PluginManager(app);
  }
  display() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Plugin configuration" });
    containerEl.createEl("p", {
      text: "Review and configure your installed plugins. Essential plugins are recommended for the core Vault CMS experience."
    });
    const allPlugins = [
      // Essential plugins (alphabetically ordered)
      { id: "astro-composer", name: "Astro Composer", category: "essential" },
      { id: "bases-cms", name: "Bases CMS", category: "essential" },
      { id: "new-tab-default-page", name: "Default New Tab Page", category: "essential" },
      { id: "editing-toolbar", name: "Editing Toolbar", category: "essential" },
      { id: "home-base", name: "Home Base", category: "essential" },
      { id: "homepage", name: "Homepage", category: "essential" },
      { id: "image-manager", name: "Image Manager", category: "essential" },
      { id: "obsidian-paste-image-rename", name: "Paste Image Rename", category: "essential" },
      { id: "property-over-file-name", name: "Property Over File Name", category: "essential" },
      { id: "seo", name: "SEO", category: "essential" },
      { id: "ui-tweaker", name: "UI Tweaker", category: "essential" },
      { id: "simple-focus", name: "Simple Focus", category: "essential" },
      { id: "statusbar-organizer", name: "Status Bar Organizer", category: "essential" },
      // Nice to have plugins (alphabetically ordered)
      { id: "alias-file-name-history", name: "Alias File Name History", category: "nice-to-have" },
      { id: "data-files-editor", name: "Data Files Editor", category: "nice-to-have" },
      { id: "iconic", name: "Iconic", category: "nice-to-have" },
      { id: "paste-image-into-property", name: "Paste Image Into Property", category: "nice-to-have" },
      { id: "settings-search", name: "Settings Search", category: "nice-to-have" },
      { id: "tag-wrangler", name: "Tag Wrangler", category: "nice-to-have" },
      { id: "zenmode", name: "Zen Mode", category: "nice-to-have" },
      { id: "explorer-focus", name: "Explorer Focus", category: "nice-to-have" }
    ];
    const plugins = this.app.plugins;
    const installedPluginIds = (plugins == null ? void 0 : plugins.plugins) ? Object.keys(plugins.plugins) : [];
    const ignoredPlugins = [
      "obsidian42-brat",
      "astro-modular-settings",
      "folder-notes",
      "disable-tabs",
      "vault-cms"
      // Don't show Vault CMS plugin itself
    ];
    const essentialPlugins = allPlugins.filter(
      (p) => p.category === "essential" && installedPluginIds.includes(p.id) && !ignoredPlugins.includes(p.id)
    );
    const niceToHavePlugins = allPlugins.filter(
      (p) => p.category === "nice-to-have" && installedPluginIds.includes(p.id) && !ignoredPlugins.includes(p.id)
    ).sort((a, b) => a.name.localeCompare(b.name));
    if (essentialPlugins.length > 0) {
      containerEl.createEl("h3", { text: "Essential plugins", cls: "vault-cms-section-header" });
      containerEl.createEl("p", {
        text: "These plugins are recommended for the core Vault CMS experience.",
        cls: "vault-cms-section-desc"
      });
      for (const plugin of essentialPlugins) {
        const pluginInstance = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[plugin.id];
        const isInstalled = !!pluginInstance;
        const pluginInstanceTyped = pluginInstance;
        const isCurrentlyEnabled = (_e = (_d = (_c = (_b = plugins == null ? void 0 : plugins.enabledPlugins) == null ? void 0 : _b.has) == null ? void 0 : _c.call(_b, plugin.id)) != null ? _d : pluginInstanceTyped == null ? void 0 : pluginInstanceTyped.enabled) != null ? _e : false;
        console.debug(`Plugin ${plugin.id}: installed=${isInstalled}, enabled=${isCurrentlyEnabled}`);
        if (isInstalled && isCurrentlyEnabled) {
          if (!this.state.enabledPlugins.includes(plugin.id)) {
            this.state.enabledPlugins.push(plugin.id);
          }
          this.state.disabledPlugins = this.state.disabledPlugins.filter((p) => p !== plugin.id);
        } else if (isInstalled && !isCurrentlyEnabled) {
          this.state.enabledPlugins = this.state.enabledPlugins.filter((p) => p !== plugin.id);
          if (!this.state.disabledPlugins.includes(plugin.id)) {
            this.state.disabledPlugins.push(plugin.id);
          }
        }
        const setting = new import_obsidian14.Setting(containerEl).setName(plugin.name).setDesc(isInstalled ? isCurrentlyEnabled ? "Installed and enabled" : "Installed but disabled" : "Not installed");
        const iconContainer = setting.controlEl.createDiv({ cls: "vault-cms-plugin-status" });
        if (isInstalled && isCurrentlyEnabled) {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-check-circle-2");
          setCssProps6(iconContainer, { color: "var(--text-success)" });
        } else {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-x-circle");
          setCssProps6(iconContainer, { color: "var(--text-error)" });
        }
      }
    }
    if (niceToHavePlugins.length > 0) {
      containerEl.createEl("h3", { text: "Nice to have plugins", cls: "vault-cms-section-header" });
      containerEl.createEl("p", {
        text: "These plugins can be helpful depending on your theme's capabilities and workflow needs.",
        cls: "vault-cms-section-desc"
      });
      for (const plugin of niceToHavePlugins) {
        const pluginInstance = (_f = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _f[plugin.id];
        const isInstalled = !!pluginInstance;
        const pluginInstanceTyped = pluginInstance;
        const isCurrentlyEnabled = (_j = (_i = (_h = (_g = plugins == null ? void 0 : plugins.enabledPlugins) == null ? void 0 : _g.has) == null ? void 0 : _h.call(_g, plugin.id)) != null ? _i : pluginInstanceTyped == null ? void 0 : pluginInstanceTyped.enabled) != null ? _j : false;
        console.debug(`Plugin ${plugin.id}: installed=${isInstalled}, enabled=${isCurrentlyEnabled}`);
        if (isInstalled && isCurrentlyEnabled) {
          if (!this.state.enabledPlugins.includes(plugin.id)) {
            this.state.enabledPlugins.push(plugin.id);
          }
          this.state.disabledPlugins = this.state.disabledPlugins.filter((p) => p !== plugin.id);
        } else if (isInstalled && !isCurrentlyEnabled) {
          this.state.enabledPlugins = this.state.enabledPlugins.filter((p) => p !== plugin.id);
          if (!this.state.disabledPlugins.includes(plugin.id)) {
            this.state.disabledPlugins.push(plugin.id);
          }
        }
        const setting = new import_obsidian14.Setting(containerEl).setName(plugin.name).setDesc(isInstalled ? isCurrentlyEnabled ? "Installed and enabled" : "Installed but disabled" : "Not installed");
        const iconContainer = setting.controlEl.createDiv({ cls: "vault-cms-plugin-status" });
        if (isInstalled && isCurrentlyEnabled) {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-check-circle-2");
          setCssProps6(iconContainer, { color: "var(--text-success)" });
        } else {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-x-circle");
          setCssProps6(iconContainer, { color: "var(--text-error)" });
        }
      }
    }
    if (essentialPlugins.length === 0 && niceToHavePlugins.length === 0) {
      containerEl.createEl("p", {
        text: "No Vault CMS plugins detected. Make sure you have installed the recommended plugins."
      });
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Optional Plugins";
  }
  getDescription() {
    return "Configure optional plugins";
  }
};

// src/ui/wizard/IgnoreStep.ts
var import_obsidian16 = require("obsidian");

// src/utils/ProjectOptimizer.ts
var import_obsidian15 = require("obsidian");
var path6 = __toESM(require("path"), 1);
var fs5 = __toESM(require("fs"), 1);
function setCssProps7(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var ProjectOptimizer = class {
  constructor(app, state) {
    this.app = app;
    this.state = state;
  }
  async getStatus() {
    var _a, _b;
    const status = {
      gitIgnoreStatus: "not-configured",
      viteIgnoreStatus: "not-configured"
    };
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) {
      console.debug("[Vault CMS] ProjectOptimizer: No projectRoot in state");
      return status;
    }
    const configDir = this.app.vault.configDir;
    console.debug("[Vault CMS] ProjectOptimizer: Checking status for root:", projectRoot, "configDir:", configDir);
    const gitIgnorePath = path6.join(projectRoot, ".gitignore");
    if (fs5.existsSync(gitIgnorePath)) {
      const content = fs5.readFileSync(gitIgnorePath, "utf8");
      const isConfigured = content.includes(`${configDir}/workspace.json`) || content.includes(`**/${configDir}/workspace.json`);
      console.debug("[Vault CMS] ProjectOptimizer: .gitignore exists, configured:", isConfigured);
      if (isConfigured) {
        status.gitIgnoreStatus = "configured";
      }
    } else {
      console.debug("[Vault CMS] ProjectOptimizer: .gitignore NOT found at:", gitIgnorePath);
    }
    const astroConfigNames = ["astro.config.ts", "astro.config.mjs", "astro.config.js", "astro.config.mts", "astro.config.cjs"];
    let resolvedViteConfigPath = "";
    for (const name of astroConfigNames) {
      const p = path6.join(projectRoot, name);
      if (fs5.existsSync(p)) {
        resolvedViteConfigPath = p;
        break;
      }
    }
    if (!resolvedViteConfigPath && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath)) {
      resolvedViteConfigPath = this.state.projectDetection.configFilePath;
    }
    if (resolvedViteConfigPath && fs5.existsSync(resolvedViteConfigPath)) {
      console.debug("[Vault CMS] ProjectOptimizer: Checking Vite config at:", resolvedViteConfigPath);
      const content = fs5.readFileSync(resolvedViteConfigPath, "utf8");
      const hasWatchIgnored = content.includes("server.watch.ignored") || content.includes("ignored:");
      const hasConfigDir = content.includes(configDir);
      console.debug("[Vault CMS] ProjectOptimizer: Vite config has patterns:", { hasWatchIgnored, hasConfigDir });
      if (hasWatchIgnored && hasConfigDir) {
        status.viteIgnoreStatus = "configured";
      }
    } else {
      console.debug("[Vault CMS] ProjectOptimizer: No valid Astro config found to check");
    }
    return status;
  }
  async configureGitIgnore() {
    var _a;
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) {
      console.error("[Vault CMS] ProjectOptimizer: No projectRoot for Git configuration");
      return false;
    }
    const configDir = this.app.vault.configDir;
    const gitIgnorePath = path6.join(projectRoot, ".gitignore");
    const rules = `
# Obsidian workspace files
**/${configDir}/workspace.json
**/${configDir}/workspace-mobile.json
`;
    console.debug("[Vault CMS] ProjectOptimizer: Configuring Git ignore at:", gitIgnorePath);
    try {
      if (fs5.existsSync(gitIgnorePath)) {
        let content = fs5.readFileSync(gitIgnorePath, "utf8");
        const hasNewPattern = content.includes(`**/${configDir}/workspace.json`);
        const hasOldPattern = content.includes(`*/${configDir}/workspace.json`) || content.includes(`${configDir}/workspace.json`);
        if (hasOldPattern && !hasNewPattern) {
          console.debug("[Vault CMS] ProjectOptimizer: Updating old Git patterns");
          content = content.replace(new RegExp(`\\*?/?${configDir}/workspace\\.json`, "g"), `**/${configDir}/workspace.json`);
          content = content.replace(new RegExp(`\\*?/?${configDir}/workspace-mobile\\.json`, "g"), `**/${configDir}/workspace-mobile.json`);
          fs5.writeFileSync(gitIgnorePath, content, "utf8");
        } else if (!hasNewPattern) {
          console.debug("[Vault CMS] ProjectOptimizer: Adding new Git patterns");
          content += rules;
          fs5.writeFileSync(gitIgnorePath, content, "utf8");
        } else {
          console.debug("[Vault CMS] ProjectOptimizer: Git patterns already present");
        }
      } else {
        console.debug("[Vault CMS] ProjectOptimizer: Creating new .gitignore");
        fs5.writeFileSync(gitIgnorePath, rules, "utf8");
      }
      return true;
    } catch (error) {
      console.error("[Vault CMS] Failed to update .gitignore:", error);
      throw error;
    }
  }
  async configureViteIgnore() {
    var _a, _b;
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) return false;
    const configDir = this.app.vault.configDir;
    const astroConfigNames = ["astro.config.ts", "astro.config.mjs", "astro.config.js", "astro.config.mts", "astro.config.cjs"];
    let resolvedConfigPath = "";
    let configFileName = "";
    for (const name of astroConfigNames) {
      const p = path6.join(projectRoot, name);
      if (fs5.existsSync(p)) {
        resolvedConfigPath = p;
        configFileName = name;
        break;
      }
    }
    if (!resolvedConfigPath && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath)) {
      resolvedConfigPath = this.state.projectDetection.configFilePath;
      configFileName = path6.basename(resolvedConfigPath);
    }
    if (!resolvedConfigPath || !fs5.existsSync(resolvedConfigPath)) {
      console.error("[Vault CMS] ProjectOptimizer: Vite config NOT found in:", projectRoot);
      throw new Error(`Astro config file not found in: ${projectRoot}`);
    }
    console.debug("[Vault CMS] ProjectOptimizer: Configuring Vite ignore at:", resolvedConfigPath);
    try {
      const content = fs5.readFileSync(resolvedConfigPath, "utf8");
      if (content.includes("server.watch.ignored") && content.includes(configDir)) {
        return true;
      }
      const exportIdx = content.lastIndexOf("export default");
      let startIndex = -1;
      let endIndex = -1;
      let configBody = "";
      let isWholeFile = false;
      if (exportIdx !== -1) {
        startIndex = content.indexOf("{", exportIdx);
        if (startIndex !== -1) {
          let braceCount = 0;
          for (let i = startIndex; i < content.length; i++) {
            if (content[i] === "{") braceCount++;
            else if (content[i] === "}") braceCount--;
            if (braceCount === 0) {
              endIndex = i;
              break;
            }
          }
          if (endIndex !== -1) {
            configBody = content.substring(startIndex + 1, endIndex);
          }
        }
      }
      if (!configBody && (content.includes("vite:") || content.includes("server:"))) {
        configBody = content;
        isWholeFile = true;
      }
      if (configBody) {
        if (configBody.includes("vite:")) {
          if (configBody.includes("server:")) {
            if (configBody.includes("watch:")) {
              if (configBody.includes("ignored:")) {
                if (!configBody.includes(configDir)) {
                  configBody = configBody.replace(/ignored:\s*\[([^\]]*)\]/, (_m, p1) => {
                    const existing = p1.trim();
                    const separator = existing ? ", " : "";
                    return `ignored: [${existing}${separator}'**/${configDir}/**', '**/_bases/**', '**/bases/**']`;
                  });
                }
              } else {
                configBody = configBody.replace(/watch:\s*\{/, `watch: {
      ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**'],`);
              }
            } else {
              configBody = configBody.replace(/server:\s*\{/, `server: {
    watch: {
      ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
    },`);
            }
          } else {
            configBody = configBody.replace(/vite:\s*\{/, `vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
      }
    },`);
          }
        } else {
          if (isWholeFile) {
            if (content.includes("defineConfig")) {
              configBody = configBody.replace(/defineConfig\s*\(\s*\{/, `defineConfig({
  vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
      }
    }
  },`);
            } else {
              throw new Error(`Could not find a clear place to insert Vite config in ${configFileName}.`);
            }
          } else {
            configBody = `
  vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
      }
    }
  },` + configBody;
          }
        }
        const updatedContent = isWholeFile ? configBody : content.substring(0, startIndex + 1) + configBody + content.substring(endIndex);
        fs5.writeFileSync(resolvedConfigPath, updatedContent, "utf8");
        return true;
      } else {
        throw new Error(`Could not parse configuration in ${configFileName}.`);
      }
    } catch (error) {
      console.error(`ProjectOptimizer: Error updating ${configFileName}:`, error);
      throw error;
    }
  }
  renderStatus(container, status) {
    const statusEl = container.createDiv({ cls: "vault-cms-plugin-status" });
    if (status === "configured") {
      (0, import_obsidian15.setIcon)(statusEl, "lucide-check-circle-2");
      setCssProps7(statusEl, { color: "var(--text-success)" });
    } else {
      (0, import_obsidian15.setIcon)(statusEl, "lucide-alert-circle");
      setCssProps7(statusEl, { color: "var(--text-warning)" });
    }
  }
};

// src/ui/wizard/IgnoreStep.ts
var IgnoreStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.optimizer = new ProjectOptimizer(app, state);
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const status = await this.optimizer.getStatus();
    this.state.ignoreConfig.gitIgnoreConfigured = status.gitIgnoreStatus === "configured";
    this.state.ignoreConfig.viteIgnoreConfigured = status.viteIgnoreStatus === "configured";
    containerEl.createEl("h2", { text: "Project optimization (optional)" });
    containerEl.createEl("p", {
      text: "Optimize your project by ignoring Obsidian-specific files in Git and Vite."
    });
    this.gitSetting = new import_obsidian16.Setting(containerEl);
    this.updateGitSetting(status.gitIgnoreStatus);
    this.viteSetting = new import_obsidian16.Setting(containerEl);
    this.updateViteSetting(status.viteIgnoreStatus);
    return Promise.resolve();
  }
  updateGitSetting(status) {
    this.gitSetting.setName("Ignore workspace files in Git").setDesc("Add Obsidian workspace files to .gitignore to prevent them from being tracked.").clear();
    this.gitSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureGitIgnore();
          this.state.ignoreConfig.gitIgnoreConfigured = true;
          new import_obsidian16.Notice(".gitignore updated");
          const newStatus = await this.optimizer.getStatus();
          this.updateGitSetting(newStatus.gitIgnoreStatus);
        } catch (error) {
          new import_obsidian16.Notice(`Failed to update .gitignore: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.gitSetting.controlEl, status);
  }
  updateViteSetting(status) {
    this.viteSetting.setName("Ignore workspace and bases folders in Vite").setDesc("Configure Vite to ignore Obsidian and bases folders.").clear();
    this.viteSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureViteIgnore();
          this.state.ignoreConfig.viteIgnoreConfigured = true;
          new import_obsidian16.Notice("Vite optimization applied");
          const newStatus = await this.optimizer.getStatus();
          this.updateViteSetting(newStatus.viteIgnoreStatus);
        } catch (error) {
          new import_obsidian16.Notice(`Failed to update Vite config: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.viteSetting.controlEl, status);
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Project optimization (optional)";
  }
  getDescription() {
    return "Configure project-level ignores";
  }
};

// src/ui/wizard/GitSetupStep.ts
var import_obsidian22 = require("obsidian");
init_GitManager();

// src/utils/BasesCMSConfig.ts
var import_obsidian18 = require("obsidian");
var BasesCMSConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
  }
  async resolveBaseFilePath() {
    const preferredPath = "_bases/Home.base";
    const legacyPath = "bases/Home.base";
    if (await this.app.vault.adapter.exists(preferredPath)) {
      return preferredPath;
    }
    if (await this.app.vault.adapter.exists(legacyPath)) {
      return legacyPath;
    }
    if (await this.app.vault.adapter.exists("_bases")) {
      return preferredPath;
    }
    if (await this.app.vault.adapter.exists("bases")) {
      return legacyPath;
    }
    return preferredPath;
  }
  async createOrUpdateBaseFile(contentTypes, frontmatterProperties, defaultContentTypeId, projectDetection, enableMdxSupport) {
    const baseFilePath = await this.resolveBaseFilePath();
    const folderPath = baseFilePath.split("/")[0];
    const basesFolder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!basesFolder) {
      try {
        await this.app.vault.createFolder(folderPath);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (!errorMessage || !errorMessage.includes("already exists")) {
          console.warn(`BasesCMSConfig: Could not create ${folderPath} folder:`, error);
        }
      }
    }
    const baseFileAbstract = this.app.vault.getAbstractFileByPath(baseFilePath);
    let baseFile = baseFileAbstract instanceof import_obsidian18.TFile ? baseFileAbstract : null;
    let existingBase = null;
    if (baseFile) {
      try {
        const content = await this.app.vault.read(baseFile);
        existingBase = parse2(content);
      } catch (error) {
        console.error("BasesCMSConfig: Failed to parse existing base file:", error);
      }
    }
    const enabledTypes = contentTypes.filter((ct) => ct.enabled);
    console.debug("BasesCMSConfig: Generating base content for", contentTypes.length, "content types");
    console.debug("BasesCMSConfig: Enabled content types:", enabledTypes.map((ct) => ct.name));
    const baseContent = this.generateBaseContent(contentTypes, frontmatterProperties, defaultContentTypeId, existingBase, projectDetection, enableMdxSupport);
    const viewMatches = baseContent.match(/^\s*-\s+type:\s+bases-cms/gm);
    const viewCount = viewMatches ? viewMatches.length : 0;
    console.debug("BasesCMSConfig: Generated", viewCount, "views in base content");
    const baseFileAbstract2 = this.app.vault.getAbstractFileByPath(baseFilePath);
    baseFile = baseFileAbstract2 instanceof import_obsidian18.TFile ? baseFileAbstract2 : null;
    if (baseFile) {
      console.debug(`BasesCMSConfig: Modifying existing ${baseFilePath} file`);
      try {
        await this.app.vault.modify(baseFile, baseContent);
        console.debug(`BasesCMSConfig: Successfully modified ${baseFilePath} file`);
        return;
      } catch (error) {
        console.error("BasesCMSConfig: Failed to modify file:", error);
        throw error;
      }
    }
    console.debug(`BasesCMSConfig: Creating new ${baseFilePath} file`);
    try {
      await this.app.vault.create(baseFilePath, baseContent);
      console.debug(`BasesCMSConfig: Successfully created ${baseFilePath} file`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
        console.debug("BasesCMSConfig: File existed, attempting direct modify via path");
        try {
          const adapter = this.app.vault.adapter;
          if (adapter && typeof adapter.write === "function") {
            await adapter.write(baseFilePath, baseContent);
            console.debug("BasesCMSConfig: Successfully wrote Home.base file via adapter");
          } else {
            console.debug("BasesCMSConfig: Adapter write not available, retrying getAbstractFileByPath");
            for (let i = 0; i < 10; i++) {
              await new Promise((resolve9) => setTimeout(resolve9, 200));
              const retryFileAbstract = this.app.vault.getAbstractFileByPath(baseFilePath);
              const retryFile = retryFileAbstract instanceof import_obsidian18.TFile ? retryFileAbstract : null;
              if (retryFile) {
                await this.app.vault.modify(retryFile, baseContent);
                console.debug(`BasesCMSConfig: Successfully modified Home.base file on retry ${i + 1}`);
                return;
              }
            }
            console.error("BasesCMSConfig: File exists but cannot be found after all retries");
            throw new Error(`File exists but cannot be accessed. Please try again or manually edit ${baseFilePath}`);
          }
        } catch (writeError) {
          console.error("BasesCMSConfig: Failed to write file via adapter:", writeError);
          throw writeError;
        }
      } else {
        console.error("BasesCMSConfig: Failed to create base file:", error);
        throw error;
      }
    }
  }
  generateBaseContent(contentTypes, frontmatterProperties, defaultContentTypeId, existingBase, projectDetection, enableMdxSupport) {
    const lines = [];
    const defaultContentType = defaultContentTypeId ? contentTypes.find((ct) => ct.id === defaultContentTypeId && ct.enabled) : null;
    if (defaultContentType) {
      lines.push(`defaultView: "${defaultContentType.name}"`);
    }
    if (existingBase == null ? void 0 : existingBase.formulas) {
      lines.push("formulas:");
      for (const [key, value] of Object.entries(existingBase.formulas)) {
        if (typeof value === "string") {
          lines.push(`  ${key}: |-`);
          const formulaLines = value.split("\n");
          for (const formulaLine of formulaLines) {
            lines.push(`    ${formulaLine}`);
          }
        }
      }
      lines.push("");
    }
    lines.push("filters:");
    if (enableMdxSupport) {
      lines.push("  or:");
      lines.push('    - file.ext == "md"');
      lines.push('    - file.ext == "mdx"');
    } else {
      lines.push("  and:");
      lines.push('    - file.ext == "md"');
    }
    lines.push("");
    const allProperties = /* @__PURE__ */ new Set();
    for (const contentType of contentTypes) {
      const props = frontmatterProperties[contentType.id];
      if (props) {
        if (props.titleProperty) allProperties.add(`note.${props.titleProperty}`);
        if (props.dateProperty) allProperties.add(`note.${props.dateProperty}`);
        if (props.descriptionProperty) allProperties.add(`note.${props.descriptionProperty}`);
        if (props.tagsProperty) allProperties.add(`note.${props.tagsProperty}`);
        if (props.draftProperty) allProperties.add(`note.${props.draftProperty}`);
        if (props.imageProperty) allProperties.add(`note.${props.imageProperty}`);
      }
    }
    allProperties.add("note.title");
    allProperties.add("note.date");
    allProperties.add("note.pubDate");
    allProperties.add("note.draft");
    allProperties.add("file.fullname");
    allProperties.add("file.name");
    if (existingBase == null ? void 0 : existingBase.properties) {
      for (const prop of Object.keys(existingBase.properties)) {
        if (prop.startsWith("formula.")) {
          allProperties.add(prop);
        }
      }
    }
    if (allProperties.size > 0) {
      lines.push("properties:");
      const existingProps = (existingBase == null ? void 0 : existingBase.properties) || {};
      for (const prop of Array.from(allProperties).sort()) {
        lines.push(`  ${prop}:`);
        const existingProp = existingProps[prop];
        if (existingProp == null ? void 0 : existingProp.displayName) {
          lines.push(`    displayName: ${existingProp.displayName}`);
        } else if (prop === "file.fullname") {
          lines.push(`    displayName: Full File Name`);
        } else {
          const propName = prop.replace("note.", "").replace("file.", "");
          lines.push(`    displayName: ${this.capitalizeFirst(propName)}`);
        }
      }
      lines.push("");
    }
    lines.push("views:");
    const existingViews = (existingBase == null ? void 0 : existingBase.views) || [];
    const viewsByName = /* @__PURE__ */ new Map();
    for (const view of existingViews) {
      if (view.name) viewsByName.set(view.name, view);
    }
    const finalViews = [];
    const processedViewNames = /* @__PURE__ */ new Set();
    const enabledTypes = contentTypes.filter((ct) => ct.enabled);
    const defaultType = defaultContentTypeId ? enabledTypes.find((ct) => ct.id === defaultContentTypeId) : null;
    const otherTypes = enabledTypes.filter((ct) => ct !== defaultType);
    const processType = (ct) => {
      const props = frontmatterProperties[ct.id];
      if (!props) return;
      const existingView = viewsByName.get(ct.name);
      const generatedView = this.generateViewForContentType(ct, props, projectDetection);
      if (existingView) {
        const coreUpdates = {
          filters: generatedView.filters,
          newNoteLocation: generatedView.newNoteLocation,
          titleProperty: generatedView.titleProperty,
          dateProperty: generatedView.dateProperty,
          draftStatusProperty: generatedView.draftStatusProperty,
          tagsProperty: generatedView.tagsProperty,
          showTags: generatedView.showTags,
          showDraftStatus: generatedView.showDraftStatus,
          draftStatusReverse: generatedView.draftStatusReverse,
          draftStatusUseFilenamePrefix: generatedView.draftStatusUseFilenamePrefix
        };
        finalViews.push({ ...existingView, ...coreUpdates });
        processedViewNames.add(ct.name);
      } else {
        finalViews.push(generatedView);
        processedViewNames.add(ct.name);
      }
    };
    if (defaultType) processType(defaultType);
    for (const ct of otherTypes) processType(ct);
    for (const view of existingViews) {
      if (view.name === "Vault CMS Guide" || view.name === "Guide" || processedViewNames.has(view.name)) continue;
      finalViews.push(view);
    }
    let guideView = viewsByName.get("Vault CMS Guide") || viewsByName.get("Guide");
    if (guideView) {
      guideView = { ...guideView, name: "Vault CMS Guide" };
      finalViews.push(guideView);
    }
    for (const view of finalViews) {
      lines.push(...this.serializeView(view));
    }
    return lines.join("\n");
  }
  generateViewForContentType(contentType, props, projectDetection) {
    const folderPath = this.pathResolver.getBasesCMSFolderPath(contentType.folder, projectDetection);
    const view = {
      type: "bases-cms",
      name: contentType.name,
      filters: {
        and: [
          folderPath === "" || folderPath === "." ? 'file.folder == "/"' : `file.folder.startsWith("${folderPath}")`
        ]
      },
      imageFormat: "cover",
      showDate: true,
      customizeNewButton: true,
      newNoteLocation: folderPath,
      fallbackToEmbeds: "if-empty",
      propertyDisplay1: "file.fullname",
      showTextPreview: true,
      propertyLabels: "above",
      sort: [
        {
          property: props.dateProperty ? `note.${props.dateProperty}` : "file.ctime",
          direction: "DESC"
        }
      ]
    };
    if (props.titleProperty) {
      view.titleProperty = `note.${props.titleProperty}`;
    } else {
      view.titleProperty = `file.fullname`;
    }
    if (props.dateProperty) {
      view.dateProperty = `note.${props.dateProperty}`;
    } else {
      view.dateProperty = `file.ctime`;
    }
    if (props.descriptionProperty) {
      view.descriptionProperty = `note.${props.descriptionProperty}`;
    }
    if (props.imageProperty) {
      view.imageProperty = `note.${props.imageProperty}`;
    }
    view.showTags = !!props.tagsProperty;
    if (props.tagsProperty) {
      view.tagsProperty = `note.${props.tagsProperty}`;
    }
    view.showDraftStatus = !!props.hasDraftStatus;
    if (props.hasDraftStatus) {
      if (props.draftProperty) {
        view.draftStatusProperty = `note.${props.draftProperty}`;
        view.draftStatusReverse = props.draftLogic === "false-draft";
      } else {
        view.draftStatusUseFilenamePrefix = true;
      }
    }
    return view;
  }
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  /**
   * Serialize a view object to YAML lines (with proper indentation)
   */
  serializeView(view) {
    const viewLines = [];
    viewLines.push("  - type: bases-cms");
    viewLines.push(`    name: "${view.name}"`);
    if (view.filters) {
      viewLines.push("    filters:");
      if (view.filters.and) {
        if (view.filters.and.length === 0) {
          viewLines.push("      and: []");
        } else {
          viewLines.push("      and:");
          for (const filter of view.filters.and) {
            if (typeof filter === "string") {
              viewLines.push(`        - ${filter}`);
            } else if (typeof filter === "object") {
              for (const [key, value] of Object.entries(filter)) {
                const valueStr = typeof value === "string" ? `"${value}"` : String(value);
                viewLines.push(`        - ${key}: ${valueStr}`);
              }
            }
          }
        }
      }
    }
    if (view.groupBy) {
      viewLines.push("    groupBy:");
      if (typeof view.groupBy === "object") {
        if (view.groupBy.property) viewLines.push(`      property: ${view.groupBy.property}`);
        if (view.groupBy.direction) viewLines.push(`      direction: ${view.groupBy.direction}`);
      } else if (typeof view.groupBy === "string") {
        viewLines.push(`      ${view.groupBy}`);
      }
    }
    if (view.order) {
      if (view.order.length === 0) {
        viewLines.push("    order: []");
      } else {
        viewLines.push("    order:");
        for (const orderItem of view.order) {
          viewLines.push(`      - ${orderItem}`);
        }
      }
    }
    if (view.sort) {
      if (view.sort.length === 0) {
        viewLines.push("    sort: []");
      } else {
        viewLines.push("    sort:");
        for (const sortItem of view.sort) {
          if (typeof sortItem === "object" && sortItem.property) {
            viewLines.push(`      - property: ${sortItem.property}`);
            viewLines.push(`        direction: ${sortItem.direction || "ASC"}`);
          }
        }
      }
    }
    const skipProps = ["type", "name", "filters", "groupBy", "order", "sort"];
    for (const prop of Object.keys(view)) {
      if (skipProps.includes(prop) || view[prop] === void 0) {
        continue;
      }
      const value = view[prop];
      if (value === null) {
        viewLines.push(`    ${prop}: null`);
      } else if (typeof value === "boolean") {
        viewLines.push(`    ${prop}: ${value}`);
      } else if (typeof value === "number") {
        viewLines.push(`    ${prop}: ${value}`);
      } else if (typeof value === "string") {
        if (value === "") {
          viewLines.push(`    ${prop}: ""`);
          continue;
        }
        const isPropertyRef = (prop.includes("Property") || prop.startsWith("propertyDisplay")) && (value.startsWith("note.") || value.startsWith("file."));
        if (isPropertyRef) {
          viewLines.push(`    ${prop}: ${value}`);
        } else if (prop === "newNoteLocation") {
          viewLines.push(`    ${prop}: "${value}"`);
        } else {
          viewLines.push(`    ${prop}: "${value}"`);
        }
      }
    }
    return viewLines;
  }
};

// src/utils/SEOConfig.ts
var SEOConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
    this.safeWriter = new SafeConfigWriter(app);
  }
  generateSEOConfig(contentTypes, frontmatterProperties, projectDetection, enableMdxSupport) {
    const firstType = contentTypes.find((ct) => ct.enabled);
    const firstProps = firstType ? frontmatterProperties[firstType.id] : void 0;
    const scanDirectories = contentTypes.filter((ct) => ct.enabled).map((ct) => this.pathResolver.getFolderPathFromVaultRoot(ct.folder, projectDetection)).join(",");
    const config = {
      // Only set titleProperty if it exists (not blank) - this comes from the wizard
      titleProperty: (firstProps == null ? void 0 : firstProps.titleProperty) && firstProps.titleProperty.trim() !== "" ? firstProps.titleProperty : "title",
      // Default fallback
      // Only set descriptionProperty if it exists (not blank) - this comes from the wizard
      descriptionProperty: (firstProps == null ? void 0 : firstProps.descriptionProperty) && firstProps.descriptionProperty.trim() !== "" ? firstProps.descriptionProperty : void 0,
      scanDirectories,
      // Don't set these - we don't collect them in the wizard
      keywordProperty: void 0,
      useFilenameAsTitle: false,
      useFilenameAsSlug: true,
      enableMDXSupport: enableMdxSupport != null ? enableMdxSupport : false
    };
    return config;
  }
  async saveConfig(config) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const seoPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["seo"];
      if (seoPlugin && seoPlugin.settings) {
        const pluginSettings = seoPlugin.settings;
        if (config.scanDirectories) {
          pluginSettings.scanDirectories = config.scanDirectories;
        }
        if (config.titleProperty !== void 0) {
          pluginSettings.titleProperty = config.titleProperty;
        }
        if (config.descriptionProperty !== void 0) {
          pluginSettings.descriptionProperty = config.descriptionProperty;
        }
        if (config.enableMDXSupport !== void 0) {
          pluginSettings.enableMDXSupport = config.enableMDXSupport;
        }
        if (typeof seoPlugin.saveSettings === "function") {
          await seoPlugin.saveSettings();
          console.debug("SEOConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save SEO config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "seo";
    try {
      let existingData = await this.safeWriter.readConfig(pluginId);
      if (!existingData) {
        existingData = {};
      }
      const mergedData = {
        ...existingData,
        // Always update scanDirectories
        scanDirectories: config.scanDirectories,
        // Update titleProperty if provided (from wizard)
        ...config.titleProperty !== void 0 && { titleProperty: config.titleProperty },
        // Update descriptionProperty if provided (from wizard)
        ...config.descriptionProperty !== void 0 && { descriptionProperty: config.descriptionProperty },
        // Update enableMDXSupport if provided (from wizard)
        ...config.enableMDXSupport !== void 0 && { enableMDXSupport: config.enableMDXSupport }
        // All other properties (keywordProperty, useFilenameAsTitle, useFilenameAsSlug, etc.)
        // are preserved from existingData - we don't collect them in the wizard
      };
      const success = await this.safeWriter.writeConfig(pluginId, mergedData, {
        showNotice: true,
        createBackup: true
      });
      if (!success) {
        throw new Error("Failed to save SEO configuration");
      }
      console.debug("SEOConfig: Successfully saved SEO plugin configuration");
    } catch (error) {
      console.error("Failed to save SEO config (fallback):", error);
      throw error;
    }
  }
};

// src/utils/PropertyOverFileNameConfig.ts
var import_obsidian19 = require("obsidian");
var PropertyOverFileNameConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(config) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const propertyOverFileNamePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["property-over-file-name"];
      if (propertyOverFileNamePlugin && propertyOverFileNamePlugin.settings) {
        const pluginSettings = propertyOverFileNamePlugin.settings;
        console.debug("PropertyOverFileNameConfig: Using plugin.saveSettings() method");
        console.debug("PropertyOverFileNameConfig: Input config.enableMdxSupport =", config.enableMdxSupport);
        if (config.propertyKey) {
          pluginSettings.propertyKey = config.propertyKey;
        }
        if (config.enableMdxSupport !== void 0) {
          pluginSettings.enableMdxSupport = config.enableMdxSupport;
          console.debug("PropertyOverFileNameConfig: Set pluginSettings.enableMdxSupport to", config.enableMdxSupport);
        } else {
          console.warn("PropertyOverFileNameConfig: config.enableMdxSupport is undefined!");
        }
        if (typeof propertyOverFileNamePlugin.saveSettings === "function") {
          await propertyOverFileNamePlugin.saveSettings();
          console.debug("PropertyOverFileNameConfig: Successfully saved via plugin.saveSettings()");
          return;
        } else {
          console.warn("PropertyOverFileNameConfig: Plugin saveSettings not available, using fallback");
        }
      } else {
        console.warn("PropertyOverFileNameConfig: Plugin not found or settings not available, using fallback");
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Property Over File Name config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "property-over-file-name";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      let existingData = {};
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian19.TFile) {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      }
      console.debug("PropertyOverFileNameConfig: Using fallback file method");
      console.debug("PropertyOverFileNameConfig: Input config =", JSON.stringify(config));
      console.debug("PropertyOverFileNameConfig: Input config.enableMdxSupport =", config.enableMdxSupport);
      console.debug("PropertyOverFileNameConfig: Existing data =", JSON.stringify(existingData));
      const mergedData = {
        ...existingData,
        ...config
      };
      if (config.enableMdxSupport !== void 0) {
        mergedData.enableMdxSupport = config.enableMdxSupport;
        console.debug("PropertyOverFileNameConfig: Explicitly set enableMdxSupport to", config.enableMdxSupport);
      } else {
        console.warn("PropertyOverFileNameConfig: config.enableMdxSupport is undefined!");
      }
      console.debug("PropertyOverFileNameConfig: Final mergedData.enableMdxSupport =", mergedData.enableMdxSupport);
      console.debug("PropertyOverFileNameConfig: Final mergedData =", JSON.stringify(mergedData));
      if (dataFile instanceof import_obsidian19.TFile) {
        await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
      } else {
        const pluginDir = `${configDir}/plugins/${pluginId}`;
        const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
        if (!pluginDirFile) {
          try {
            await this.app.vault.createFolder(pluginDir);
          } catch (error) {
            if (error instanceof Error && !error.message.includes("already exists")) {
              throw error;
            }
          }
        }
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      }
    } catch (error) {
      console.error("Failed to save Property Over File Name config (fallback):", error);
      throw error;
    }
  }
};

// src/utils/UITweakerConfig.ts
var import_obsidian20 = require("obsidian");
var UITweakerConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(enableMdxSupport) {
    var _a;
    const pluginId = "ui-tweaker";
    try {
      const plugins = this.app.plugins;
      const uiTweakerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (uiTweakerPlugin && uiTweakerPlugin.settings) {
        console.debug("UITweakerConfig: Using plugin.settings API");
        const settings = uiTweakerPlugin.settings;
        this.forceMdxUpdate(settings, enableMdxSupport);
        if (typeof uiTweakerPlugin.saveSettings === "function") {
          await uiTweakerPlugin.saveSettings();
          console.debug("UITweakerConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("UITweakerConfig: Plugin API not available, using fallback file method");
      await this.saveConfigFallback(enableMdxSupport);
    } catch (error) {
      console.error("Failed to save UI Tweaker config:", error);
      await this.saveConfigFallback(enableMdxSupport);
    }
  }
  forceMdxUpdate(settings, enableMdxSupport) {
    const mdxFileTypes = enableMdxSupport ? "md,mdx" : "md";
    if (!settings.tabBarCommands || !Array.isArray(settings.tabBarCommands)) {
      settings.tabBarCommands = [];
    }
    const tabBarCommands = settings.tabBarCommands;
    const toolbarCommandIndex = tabBarCommands.findIndex((cmd) => cmd.id === "editing-toolbar:hide-show-menu");
    if (toolbarCommandIndex !== -1) {
      tabBarCommands[toolbarCommandIndex] = {
        ...tabBarCommands[toolbarCommandIndex],
        "showOnFileTypes": mdxFileTypes
      };
      console.debug(`UITweakerConfig: Updated existing toolbar command showOnFileTypes to ${mdxFileTypes}`);
    } else {
      tabBarCommands.push({
        "id": "editing-toolbar:hide-show-menu",
        "icon": "lucide-panel-top-open",
        "name": "Toggle editing toolbar",
        "displayName": "Editing Toolbar: Hide/Show ",
        "mode": "desktop",
        "toggleIcon": "lucide-panel-top-close",
        "showOnFileTypes": mdxFileTypes
      });
      console.debug(`UITweakerConfig: Added missing toolbar command with showOnFileTypes=${mdxFileTypes}`);
    }
  }
  async saveConfigFallback(enableMdxSupport) {
    const pluginId = "ui-tweaker";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian20.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing ui-tweaker data.json:", error);
      }
    }
    this.forceMdxUpdate(existingData, enableMdxSupport);
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(existingData, null, 2);
    if (dataFile instanceof import_obsidian20.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("UITweakerConfig: Successfully saved ui-tweaker config via fallback");
  }
};

// src/utils/DataFilesEditorConfig.ts
var import_obsidian21 = require("obsidian");
var DataFilesEditorConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(enabled) {
    var _a;
    const pluginId = "data-files-editor";
    try {
      const plugins = this.app.plugins;
      const plugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (plugin && plugin.settings) {
        console.debug("DataFilesEditorConfig: Using plugin.settings API");
        const settings = plugin.settings;
        this.applySettings(settings, enabled);
        if (typeof plugin.saveSettings === "function") {
          await plugin.saveSettings();
          console.debug("DataFilesEditorConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("DataFilesEditorConfig: Plugin API not available or settings not loaded, using fallback file method");
      await this.saveConfigFallback(enabled);
    } catch (error) {
      console.error("Failed to save Data Files Editor config:", error);
      await this.saveConfigFallback(enabled);
    }
  }
  applySettings(settings, enabled) {
    settings.doLoadJson = enabled;
    settings.doCreateJson = enabled;
    settings.doLoadAstro = enabled;
    settings.doCreateAstro = enabled;
    settings.doLoadTxt = false;
    settings.doCreateTxt = false;
    settings.doLoadXml = false;
    settings.doCreateXml = false;
    settings.doLoadYaml = false;
    settings.doCreateYaml = false;
    settings.doLoadTs = false;
    settings.doCreateTs = false;
    settings.doLoadCss = false;
    settings.doCreateCss = false;
    settings.doLoadHtml = false;
    settings.doCreateHtml = false;
    settings.doLoadJs = false;
    settings.doCreateJs = false;
    settings.doLoadMjs = false;
    settings.doCreateMjs = false;
    settings.doAutosaveFiles = true;
    settings.lineWrapping = true;
  }
  async saveConfigFallback(enabled) {
    const pluginId = "data-files-editor";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian21.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing data-files-editor data.json:", error);
      }
    }
    this.applySettings(existingData, enabled);
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(existingData, null, 2);
    if (dataFile instanceof import_obsidian21.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("DataFilesEditorConfig: Successfully saved data-files-editor config via fallback");
  }
};

// src/utils/ConfigFlushService.ts
var ConfigFlushService = class {
  constructor(app) {
    this.app = app;
    this.basesCMSConfigurator = new BasesCMSConfigurator(app);
    this.astroComposerConfigurator = new AstroComposerConfigurator(app);
    this.seoConfigurator = new SEOConfigurator(app);
    this.propertyOverFileNameConfigurator = new PropertyOverFileNameConfigurator(app);
    this.uiTweakerConfigurator = new UITweakerConfigurator(app);
    this.imageManagerConfigurator = new ImageManagerConfigurator(app);
    this.homeBaseConfigurator = new HomeBaseConfigurator(app);
    this.explorerFocusConfigurator = new ExplorerFocusConfigurator(app);
    this.dataFilesEditorConfigurator = new DataFilesEditorConfigurator(app);
    this.editingToolbarConfigurator = new EditingToolbarConfigurator(app);
  }
  /**
   * Flushes current wizard state to various plugin configuration files.
   * This ensures the disk reflects the current wizard configuration without
   * needing to reach the finalization step.
   */
  async flush(state) {
    console.debug("ConfigFlushService: Starting configuration flush");
    await this.basesCMSConfigurator.createOrUpdateBaseFile(
      state.contentTypes,
      state.frontmatterProperties,
      state.defaultContentTypeId,
      state.projectDetection,
      state.enableMdxSupport === true
    );
    if (state.projectDetection) {
      const astroConfig = await this.astroComposerConfigurator.configureAstroComposer(
        state.contentTypes,
        state.frontmatterProperties,
        state.projectDetection.projectRoot,
        state.projectDetection.configFilePath,
        state.defaultContentTypeId,
        state.projectDetection,
        state.enableMdxSupport
      );
      state.astroComposerConfig = astroConfig;
      await this.astroComposerConfigurator.saveConfig(astroConfig);
    }
    const seoConfig = this.seoConfigurator.generateSEOConfig(
      state.contentTypes,
      state.frontmatterProperties,
      state.projectDetection,
      state.enableMdxSupport
    );
    state.seoConfig = seoConfig;
    await this.seoConfigurator.saveConfig(seoConfig);
    const firstType = state.contentTypes.find((ct) => ct.enabled);
    const firstProps = firstType ? state.frontmatterProperties[firstType.id] : void 0;
    if (firstProps && firstProps.titleProperty) {
      state.propertyOverFileName.propertyKey = firstProps.titleProperty;
    }
    state.propertyOverFileName.enableMdxSupport = state.enableMdxSupport === true;
    await this.propertyOverFileNameConfigurator.saveConfig(state.propertyOverFileName);
    await this.uiTweakerConfigurator.saveConfig(state.enableMdxSupport === true);
    if (state.enabledPlugins.includes("image-manager") || Object.keys(state.imageManager).length > 0) {
      await this.imageManagerConfigurator.resolveAndSyncImageProperty(state);
      await this.imageManagerConfigurator.saveConfig(state.imageManager);
    }
    if (state.enabledPlugins.includes("home-base") || Object.keys(state.homeBase).length > 0) {
      await this.homeBaseConfigurator.saveConfig(state.homeBase);
    }
    if (state.enabledPlugins.includes("explorer-focus") || Object.keys(state.explorerFocus).length > 0) {
      await this.explorerFocusConfigurator.saveConfig(state.explorerFocus);
    }
    await this.editingToolbarConfigurator.toggleVisibility(this.app, state.enableEditingToolbar);
    await this.dataFilesEditorConfigurator.saveConfig(state.enableExtendedFileTypes === true);
    console.debug("ConfigFlushService: Configuration flush complete");
  }
};

// src/ui/wizard/GitSetupStep.ts
var path8 = __toESM(require("path"), 1);
var GitSetupStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.hasAdvanced = false;
    this.gitManager = GitManager;
    this.configFlushService = new ConfigFlushService(app);
    this.safeConfigWriter = new SafeConfigWriter(app);
    this.showNextButton = false;
  }
  getAbsoluteProjectRoot() {
    var _a;
    const relativeRoot = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) || ".";
    if (path8.isAbsolute(relativeRoot)) {
      return relativeRoot;
    }
    const adapter = this.app.vault.adapter;
    const vaultRoot = adapter.getBasePath ? adapter.getBasePath() : "";
    return path8.resolve(vaultRoot, relativeRoot);
  }
  async display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Git Integration" });
    const projectRoot = this.getAbsoluteProjectRoot();
    let isRepo = false;
    let remoteUrl = null;
    if (projectRoot) {
      isRepo = await this.gitManager.isRepo(projectRoot);
      if (isRepo) {
        remoteUrl = await this.gitManager.getRemoteUrl(projectRoot);
        const rootInfo = containerEl.createDiv({ cls: "git-root-info", attr: { style: "margin-bottom: 1rem;" } });
        rootInfo.createEl("b", { text: "Project Root: " });
        rootInfo.createSpan({ text: this.toRelativePath(projectRoot) });
        const statusEl = containerEl.createDiv({
          cls: "git-status-message",
          attr: { style: "margin-bottom: 2rem; padding: 1rem; border: 1px solid var(--background-modifier-border); border-radius: 4px;" }
        });
        statusEl.createEl("b", { text: "Status: " });
        statusEl.createSpan({
          text: "Git is already initialized.",
          attr: { style: "color: var(--text-success); font-weight: bold;" }
        });
        if (remoteUrl) {
          const remoteEl = statusEl.createDiv({ attr: { style: "margin-top: 0.5rem;" } });
          remoteEl.createEl("b", { text: "Remote: " });
          remoteEl.createSpan({ text: remoteUrl });
        }
      }
    }
    const configContainer = containerEl.createDiv({ cls: "git-config-container" });
    const instructions = configContainer.createDiv({ cls: "git-instructions" });
    instructions.createEl("p", {
      text: 'Connect your project to GitHub to publish your site. Click "Skip" to skip Git setup now and set it up later.'
    });
    const tokenLink = instructions.createEl("p");
    tokenLink.createEl("a", {
      text: "Generate a new GitHub Personal access token",
      href: `https://github.com/settings/tokens/new?scopes=repo&description=${encodeURIComponent((this.state.gitConfig.repoName || "Project") + " (Vault CMS)")}`
    });
    const tokenHelp = instructions.createEl("ul");
    tokenHelp.createEl("li", { text: `Set a Note (e.g., "${this.state.gitConfig.repoName || "Project"} (Vault CMS)")` });
    tokenHelp.createEl("li", { text: 'Set Expiration to "No expiration"' });
    tokenHelp.createEl("li", { text: 'Check the "repo" box (so all top options are selected)' });
    tokenHelp.createEl("li", { text: 'Click "Generate token" at the bottom, copy it, and paste it below.' });
    if (!remoteUrl) {
      configContainer.createEl("h3", { text: isRepo ? "Connect to GitHub" : "Create New Repository" });
    } else {
      configContainer.createEl("h3", { text: "Update GitHub Connection" });
    }
    const patSetting = new import_obsidian22.Setting(configContainer).setName("GitHub Personal Access Token").setDesc("Stored securely in Obsidian Secrets.").addExtraButton((btn) => {
      btn.setIcon("link").setTooltip("Generate a new Personal access token on GitHub").onClick(() => {
        const description = encodeURIComponent((this.state.gitConfig.repoName || "Project") + " (Vault CMS)");
        window.open(`https://github.com/settings/tokens/new?scopes=repo&description=${description}`);
      });
    });
    const secretId = "vault-cms-github-pat";
    let secretValue = (_a = this.app.secretStorage) == null ? void 0 : _a.getSecret(secretId);
    if (secretValue && !this.state.gitConfig.pat) {
    }
    patSetting.addText((text) => {
      text.setPlaceholder("ghp_xxxxxxxxxxxx").setValue(secretValue ? "********" : "").onChange((value) => {
        this.state.gitConfig.pat = value.trim();
      });
      text.inputEl.type = "password";
    });
    const patStatus = configContainer.createDiv({ cls: "pat-status-info", attr: { style: "margin-bottom: 1rem; font-size: 0.9em; color: var(--text-muted);" } });
    if (secretValue) {
      patStatus.createSpan({ text: "\u2713 Linked to Obsidian Secret: ", attr: { style: "color: var(--text-success); font-weight: bold;" } });
      patStatus.createSpan({ text: secretId });
    }
    patSetting.addButton((button) => {
      button.setButtonText("Verify Token").onClick(async () => {
        var _a2;
        let token = this.state.gitConfig.pat;
        if (!token || token === "********" || token === "vault-cms-github-pat") {
          token = (_a2 = this.app.secretStorage) == null ? void 0 : _a2.getSecret("vault-cms-github-pat");
        }
        if (!token) {
          new import_obsidian22.Notice("Please enter or paste your GitHub Personal Access Token.");
          return;
        }
        button.setDisabled(true);
        button.setButtonText("Verifying...");
        patStatus.empty();
        try {
          const username = await this.gitManager.verifyToken(token);
          if (username) {
            new import_obsidian22.Notice(`Token verified successfully as ${username}!`);
            patStatus.createSpan({ text: `\u2713 Verified as `, attr: { style: "color: var(--text-success);" } });
            patStatus.createEl("b", { text: username });
            if (this.app.secretStorage) {
              await this.app.secretStorage.setSecret("vault-cms-github-pat", token);
            }
            try {
              this.app.saveLocalStorage("obsidian-git:username", username);
            } catch (e) {
              localStorage.setItem("obsidian-git:username", username);
            }
            this.state.gitConfig.enabled = true;
            button.setButtonText("Verified");
            button.buttonEl.style.backgroundColor = "var(--interactive-accent)";
            button.buttonEl.style.color = "var(--text-on-accent)";
          } else {
            new import_obsidian22.Notice("Invalid token or GitHub API error.");
            patStatus.createSpan({ text: "\u2717 Invalid token or GitHub API error.", attr: { style: "color: var(--text-error);" } });
            button.setButtonText("Verify Token");
            button.setDisabled(false);
          }
        } catch (e) {
          new import_obsidian22.Notice("Verification failed. Check your connection.");
          patStatus.createSpan({ text: "\u2717 Verification failed. Check your connection.", attr: { style: "color: var(--text-error);" } });
          button.setButtonText("Verify Token");
          button.setDisabled(false);
        }
      });
    });
    new import_obsidian22.Setting(configContainer).setName(remoteUrl ? "New Repository Name" : "Repository Name").setDesc("The name of your GitHub repository.").addText((text) => {
      const defaultName = projectRoot ? projectRoot.split(/[\\/]/).pop() : "";
      const initialValue = this.state.gitConfig.repoName || defaultName || "";
      if (!this.state.gitConfig.repoName) {
        this.state.gitConfig.repoName = initialValue;
      }
      text.setPlaceholder("my-blog").setValue(initialValue).onChange((value) => {
        this.state.gitConfig.repoName = value.trim();
      });
    });
    new import_obsidian22.Setting(configContainer).setName("Description").setDesc("A short description for your repository.").addText((text) => {
      text.setPlaceholder("My personal blog").setValue(this.state.gitConfig.repoDescription || "").onChange((value) => {
        this.state.gitConfig.repoDescription = value.trim();
      });
    });
    new import_obsidian22.Setting(configContainer).setName("Private Repository").setDesc("Keep this repository private and hidden from the public.").addToggle((toggle) => {
      toggle.setValue(this.state.gitConfig.isPrivate).onChange((value) => {
        this.state.gitConfig.isPrivate = value;
      });
    });
    new import_obsidian22.Setting(configContainer).setName("Default Branch").setDesc('The name of the initial branch (e.g., "main" or "master").').addText((text) => {
      const initialBranch = this.state.gitConfig.branchName || "main";
      if (!this.state.gitConfig.branchName) {
        this.state.gitConfig.branchName = initialBranch;
      }
      text.setPlaceholder("main").setValue(initialBranch).onChange((value) => {
        this.state.gitConfig.branchName = value.trim() || "main";
      });
    });
    new import_obsidian22.Setting(configContainer).setName("Auto-configure Git plugin").setDesc('Automatically set up the "Git" plugin to work with this project.').addToggle((toggle) => {
      toggle.setValue(this.state.gitConfig.autoConfigureObsidianGit).onChange((value) => {
        this.state.gitConfig.autoConfigureObsidianGit = value;
      });
    });
    const actionContainer = configContainer.createDiv({ cls: "git-action-container", attr: { style: "margin-top: 2rem;" } });
    let buttonText = isRepo ? remoteUrl ? "Update Remote & Push" : "Connect to GitHub" : "Initialize & Push to GitHub";
    const createBtn = new import_obsidian22.ButtonComponent(actionContainer).setButtonText(buttonText).setCta().onClick(async () => {
      await this.handleGitSetup(createBtn, isRepo, !!remoteUrl);
    });
    configContainer.createEl("p", {
      cls: "git-skip-info",
      attr: { style: "font-size: 0.8em; color: var(--text-muted); margin-top: 1rem; border-top: 1px solid var(--background-modifier-border); padding-top: 1rem;" },
      text: 'Click "Skip" to skip Git setup.'
    });
  }
  async handleGitSetup(button, alreadyRepo, alreadyHasRemote) {
    var _a;
    if (this.hasAdvanced) return;
    let { pat } = this.state.gitConfig;
    const { repoName, repoDescription, isPrivate, branchName } = this.state.gitConfig;
    const projectRoot = this.getAbsoluteProjectRoot();
    const branch = branchName || "main";
    if (!pat || pat === "********" || pat === "vault-cms-github-pat") {
      pat = ((_a = this.app.secretStorage) == null ? void 0 : _a.getSecret("vault-cms-github-pat")) || pat;
    }
    const token = pat;
    if (!token || token === "********" || token === "vault-cms-github-pat" || !projectRoot) {
      new import_obsidian22.Notice("Please provide a valid Token and ensure project root is detected.");
      button.setDisabled(false);
      return;
    }
    if (!alreadyHasRemote && !repoName) {
      new import_obsidian22.Notice("Please provide a Repository Name.");
      button.setDisabled(false);
      return;
    }
    button.setDisabled(true);
    button.setButtonText(alreadyHasRemote ? "Updating..." : "Initializing...");
    try {
      if (!alreadyRepo) {
        await this.gitManager.initRepo(projectRoot);
        new import_obsidian22.Notice("Local Git repository initialized.");
      }
      new import_obsidian22.Notice(alreadyHasRemote ? "Creating new GitHub repository..." : "Creating GitHub repository...");
      const repoInfo = await this.gitManager.createGitHubRepo(token, repoName, repoDescription || "", isPrivate);
      await this.gitManager.setRemote(projectRoot, repoInfo.clone_url);
      new import_obsidian22.Notice(`Successfully ${alreadyHasRemote ? "updated" : "connected"} to ${repoInfo.html_url}`);
      try {
        await this.configFlushService.flush(this.state);
        console.debug("GitSetupStep: Early configuration flush successful");
      } catch (flushError) {
        console.warn("GitSetupStep: Early configuration flush failed, but continuing with sync:", flushError);
      }
      try {
        await this.gitManager.initialCommitAndPush(projectRoot, branch, "origin", token);
        new import_obsidian22.Notice("Successfully synced with GitHub!");
      } catch (pushError) {
        console.error("Sync failed:", pushError);
        new import_obsidian22.Notice("Initial sync failed. Please ensure you have Git configured locally and your credentials are set up (e.g. Git Credential Manager).");
      }
      if (this.state.gitConfig.autoConfigureObsidianGit) {
        await this.configureObsidianGit(token, projectRoot, branch);
      }
      if (pat && this.app.secretStorage) {
        await this.app.secretStorage.setSecret("vault-cms-github-pat", pat);
      }
      this.state.gitConfig.pat = "";
      this.state.gitConfig.enabled = true;
      button.setButtonText("Success!");
      new import_obsidian22.Notice("Git setup complete!");
      if (!this.hasAdvanced) {
        this.hasAdvanced = true;
        setTimeout(() => this.onNext(), 1500);
      }
    } catch (error) {
      console.error("Git integration failed:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new import_obsidian22.Notice(`Setup failed: ${errorMessage}`);
      button.setDisabled(false);
      button.setButtonText(alreadyHasRemote ? "Update Settings & Sync" : "Initialize & Push to GitHub");
    }
  }
  async configureObsidianGit(pat, projectRoot, branch) {
    var _a;
    console.debug("GitSetupStep: Configuring Obsidian Git plugin...");
    try {
      this.app.saveLocalStorage("obsidian-git:password", pat);
    } catch (e) {
      localStorage.setItem("obsidian-git:password", pat);
    }
    const adapter = this.app.vault.adapter;
    const vaultRoot = adapter.getBasePath ? adapter.getBasePath() : "";
    if (vaultRoot && projectRoot) {
      const absoluteProjectRoot = path8.isAbsolute(projectRoot) ? projectRoot : path8.resolve(vaultRoot, projectRoot);
      const relativePath = path8.relative(vaultRoot, absoluteProjectRoot).replace(/\\/g, "/");
      const configUpdates = {
        basePath: relativePath || "",
        gitRemote: "origin",
        remoteName: "origin",
        // Some versions use this
        mainBranch: branch,
        branch,
        // Some versions use this
        currentRemote: "origin"
      };
      const gitPlugin = (_a = this.app.plugins) == null ? void 0 : _a.getPlugin("obsidian-git");
      if (gitPlugin) {
        console.debug("GitSetupStep: Found running Obsidian Git plugin, updating in-memory settings");
        gitPlugin.settings = {
          ...gitPlugin.settings,
          ...configUpdates
        };
        if (typeof gitPlugin.saveSettings === "function") {
          await gitPlugin.saveSettings();
        }
      }
      await this.safeConfigWriter.mergeConfig("obsidian-git", configUpdates);
    }
    new import_obsidian22.Notice("Obsidian Git plugin configured.");
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Git Integration";
  }
  getDescription() {
    return "Connect to GitHub";
  }
};

// src/ui/wizard/FinalizeStep.ts
var import_obsidian23 = require("obsidian");
var FinalizeStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.applied = false;
    this.pluginManager = new PluginManager(app);
    this.basesCMSConfigurator = new BasesCMSConfigurator(app);
    this.configFlushService = new ConfigFlushService(app);
  }
  isApplied() {
    return this.applied;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Finalize configuration" });
    containerEl.createEl("p", {
      text: 'Review your configuration and click "Apply and restart" below to save and apply all settings.'
    });
    const summary = containerEl.createEl("div", { cls: "finalize-summary" });
    summary.createEl("h3", { text: "Summary" });
    const enabledContentTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    summary.createEl("p", { text: `Content Types: ${enabledContentTypes.length}` });
    summary.createEl("p", { text: `Editing Toolbar: ${this.state.enableEditingToolbar ? "Enabled" : "Disabled"}` });
    const basesViewsCount = enabledContentTypes.length;
    summary.createEl("p", { text: `Bases CMS Views: ${basesViewsCount} new view${basesViewsCount !== 1 ? "s" : ""} to be created` });
    const seoDirectories = enabledContentTypes.map((ct) => ct.folder);
    const seoDirectoriesCount = seoDirectories.length;
    summary.createEl("p", { text: `SEO Scan Directories: ${seoDirectoriesCount} director${seoDirectoriesCount !== 1 ? "ies" : "y"} (${seoDirectories.join(", ")})` });
  }
  async applyConfiguration(shouldRestart = false) {
    return this.applyConfigurationInternal(shouldRestart);
  }
  async applyConfigurationInternal(shouldRestart = false) {
    if (this.applied) {
      return;
    }
    try {
      console.debug("FinalizeStep: Starting configuration application");
      console.debug("FinalizeStep: Enabled content types:", this.state.contentTypes.filter((ct) => ct.enabled).map((ct) => ct.name));
      console.debug("FinalizeStep: Configuring plugin states");
      if (this.state.enableExtendedFileTypes) {
        const pluginId = "data-files-editor";
        if (!this.state.enabledPlugins.includes(pluginId)) {
          console.debug(`FinalizeStep: Enabling ${pluginId} because Extended File Types is toggle on`);
          this.state.enabledPlugins.push(pluginId);
        }
        this.state.disabledPlugins = this.state.disabledPlugins.filter((p) => p !== pluginId);
      }
      await this.pluginManager.setPluginStates(this.state.enabledPlugins, this.state.disabledPlugins);
      await this.configFlushService.flush(this.state);
      if (this.state.defaultContentTypeId) {
        const defaultType = this.state.contentTypes.find((ct) => ct.id === this.state.defaultContentTypeId);
        if (defaultType) {
          console.debug("FinalizeStep: Configuring Obsidian settings for default content type:", defaultType.name);
          const app = this.app;
          let targetPath = "./";
          if (this.state.attachmentHandlingMode === "same-folder") {
            targetPath = "./";
          } else if (this.state.attachmentHandlingMode === "subfolder") {
            const folderName = this.state.attachmentFolderName || "attachments";
            targetPath = `./${folderName}`;
          } else if (this.state.attachmentHandlingMode === "specified-folder") {
            const folderName = this.state.attachmentFolderName || "attachments";
            targetPath = folderName;
          }
          if (app.setting && typeof app.setting.set === "function") {
            console.debug("FinalizeStep: Using app.setting API");
            await app.setting.set("newFileLocation", "folder");
            await app.setting.set("newFileFolderPath", defaultType.folder);
            await app.setting.set("attachmentFolderPath", targetPath);
            await app.setting.set("newLinkFormat", "relative");
            if (typeof app.setting.save === "function") {
              await app.setting.save();
              console.debug("FinalizeStep: Obsidian settings saved via app.setting.save()");
            }
          } else {
            console.debug("FinalizeStep: Using vault.config API");
            const vault = this.app.vault;
            const obsidianSettings = vault.config;
            if (!obsidianSettings) {
              console.error("FinalizeStep: vault.config is not available");
            } else {
              obsidianSettings.newFileLocation = "folder";
              obsidianSettings.newFileFolderPath = defaultType.folder;
              obsidianSettings.attachmentFolderPath = targetPath;
              obsidianSettings.newLinkFormat = "relative";
              if (typeof vault.saveConfig === "function") {
                await vault.saveConfig();
                console.debug("FinalizeStep: Obsidian settings saved via vault.saveConfig()");
              } else {
                console.error("FinalizeStep: vault.saveConfig() is not available");
              }
            }
          }
        }
      }
      this.applied = true;
      if (shouldRestart) {
        new import_obsidian23.Notice("Configuration applied. Obsidian will now restart...", 3e3);
      } else {
        new import_obsidian23.Notice("Configuration applied successfully! You may need to restart Obsidian to see all changes.", 8e3);
      }
    } catch (error) {
      console.error("Failed to apply configuration:", error);
      new import_obsidian23.Notice("Failed to apply configuration. Please check the console for details.", 6e3);
    }
  }
  /**
   * Find any active Bases views and switch them to the new default view.
   * Closes old tabs and reopens them to force a clean reload if not restarting.
   */
  async updateActiveBasesViews(defaultViewName, shouldRestart) {
    const baseFilePath = await this.basesCMSConfigurator.resolveBaseFilePath();
    let updated = false;
    const leavesToUpdate = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      const viewType = leaf.view.getViewType();
      if (viewType === "bases" || viewType === "bases-cms") {
        const state = leaf.getViewState();
        if (((_a = state.state) == null ? void 0 : _a.file) === baseFilePath) {
          console.debug(`FinalizeStep: Found Bases leaf to update (type: ${viewType})`);
          leavesToUpdate.push({ leaf, state });
        }
      }
    });
    for (const { leaf, state } of leavesToUpdate) {
      console.debug("FinalizeStep: Updating existing Bases leaf state");
      await leaf.setViewState({
        ...state,
        state: {
          ...state.state,
          view: defaultViewName,
          viewName: defaultViewName
        }
      });
      updated = true;
    }
    if (!updated) {
      console.debug("FinalizeStep: Opening new Bases leaf with fresh state");
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.setViewState({
        type: "bases-cms",
        active: true,
        state: {
          file: baseFilePath,
          view: defaultViewName,
          viewName: defaultViewName
        }
      });
      this.app.workspace.setActiveLeaf(leaf, { focus: true });
      updated = true;
    }
    if (shouldRestart) {
      try {
        const adapter = this.app.vault.adapter;
        const configDir = this.app.vault.configDir;
        const workspacePath = `${configDir}/workspace.json`;
        if (await adapter.exists(workspacePath)) {
          console.debug("FinalizeStep: Attempting direct workspace.json modification");
          const content = await adapter.read(workspacePath);
          const workspace = JSON.parse(content);
          let modified = false;
          const updateNode = (node) => {
            var _a;
            if (!node) return;
            if (node.type === "leaf" && node.state) {
              if ((node.state.type === "bases" || node.state.type === "bases-cms") && ((_a = node.state.state) == null ? void 0 : _a.file) === baseFilePath) {
                console.debug(`FinalizeStep: Found Bases leaf in workspace.json, updating to ${defaultViewName}`);
                if (node.state.state) {
                  node.state.state.view = defaultViewName;
                  node.state.state.viewName = defaultViewName;
                  modified = true;
                }
              }
            }
            if (node.children) {
              if (Array.isArray(node.children)) {
                node.children.forEach((child) => updateNode(child));
              } else {
                updateNode(node.children);
              }
            }
          };
          updateNode(workspace.main);
          updateNode(workspace.left);
          updateNode(workspace.right);
          if (modified) {
            await adapter.write(workspacePath, JSON.stringify(workspace, null, 2));
            console.debug("FinalizeStep: Successfully modified workspace.json");
          }
        }
      } catch (error) {
        console.warn("FinalizeStep: Failed to modify workspace.json directly:", error);
      }
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Finalize";
  }
  getDescription() {
    return "Review and apply configuration";
  }
};

// src/ui/wizard/WizardStateMachine.ts
var WizardStateMachine = class {
  constructor(steps) {
    // State to step index mapping
    this.stateStepMap = /* @__PURE__ */ new Map([
      ["welcome", 0],
      ["detect", 1],
      ["content-types", 2],
      ["frontmatter", 4],
      ["plugins", 9],
      ["complete", 12]
    ]);
    // Reverse mapping: step index to state
    this.stepStateMap = /* @__PURE__ */ new Map([
      [0, "welcome"],
      [1, "detect"],
      [2, "content-types"],
      [3, "content-types"],
      // DefaultContentTypeStep is part of content-types
      [4, "frontmatter"],
      [5, "plugins"],
      // EditingToolbarStep starts plugin configuration
      [6, "plugins"],
      // BasesCMSConfigStep
      [7, "plugins"],
      // AstroComposerStep
      [8, "plugins"],
      // SEOConfigStep
      [9, "plugins"],
      // OptionalPluginsStep
      [10, "plugins"],
      // IgnoreStep
      [11, "plugins"],
      // GitSetupStep
      [12, "complete"]
      // FinalizeStep
    ]);
    // State transition rules
    this.transitions = /* @__PURE__ */ new Map([
      ["welcome", ["detect"]],
      ["detect", ["content-types"]],
      ["content-types", ["frontmatter"]],
      ["frontmatter", ["plugins"]],
      ["plugins", ["complete"]],
      ["complete", []]
      // Terminal state
    ]);
    this.currentState = "welcome";
    this.stepIndex = 0;
    this.steps = steps || [
      WelcomeStep,
      ProjectDetectionStep,
      ContentTypeStep,
      DefaultContentTypeStep,
      FrontmatterPropertiesStep,
      EditingToolbarStep,
      BasesCMSConfigStep,
      AstroComposerStep,
      SEOConfigStep,
      OptionalPluginsStep,
      IgnoreStep,
      GitSetupStep,
      FinalizeStep
    ];
  }
  /**
   * Get the current state
   */
  getState() {
    return this.currentState;
  }
  /**
   * Get the current step index
   */
  getStepIndex() {
    return this.stepIndex;
  }
  /**
   * Get the total number of steps
   */
  getTotalSteps() {
    return this.steps.length;
  }
  /**
   * Get the step constructor for a given index
   */
  getStepConstructor(index) {
    return this.steps[index];
  }
  /**
   * Check if we can transition to the next step/state
   */
  canGoNext() {
    return this.stepIndex < this.steps.length - 1;
  }
  /**
   * Check if we can go back to the previous step/state
   */
  canGoBack() {
    return this.stepIndex > 0;
  }
  /**
   * Move to the next step
   * Updates both step index and state
   */
  next() {
    if (!this.canGoNext()) {
      console.warn("WizardStateMachine: Cannot go to next step - already at final step");
      return;
    }
    const nextStepIndex = this.stepIndex + 1;
    const nextState = this.stepStateMap.get(nextStepIndex);
    if (!nextState) {
      console.error(`WizardStateMachine: No state mapping for step index ${nextStepIndex}`);
      return;
    }
    const allowedTransitions = this.transitions.get(this.currentState) || [];
    if (!allowedTransitions.includes(nextState) && nextState !== this.currentState) {
      console.warn(
        `WizardStateMachine: Invalid transition from ${this.currentState} to ${nextState}`
      );
    }
    this.stepIndex = nextStepIndex;
    this.currentState = nextState;
    console.debug(
      `WizardStateMachine: Transitioned to step ${this.stepIndex} (state: ${this.currentState})`
    );
  }
  /**
   * Move to the previous step
   * Updates both step index and state
   */
  previous() {
    if (!this.canGoBack()) {
      console.warn("WizardStateMachine: Cannot go to previous step - already at first step");
      return;
    }
    const prevStepIndex = this.stepIndex - 1;
    const prevState = this.stepStateMap.get(prevStepIndex);
    if (!prevState) {
      console.error(`WizardStateMachine: No state mapping for step index ${prevStepIndex}`);
      return;
    }
    this.stepIndex = prevStepIndex;
    this.currentState = prevState;
    console.debug(
      `WizardStateMachine: Went back to step ${this.stepIndex} (state: ${this.currentState})`
    );
  }
  /**
   * Jump to a specific step index
   * Updates both step index and state
   */
  jumpToStep(index) {
    const clampedIndex = Math.max(0, Math.min(index, this.steps.length - 1));
    const state = this.stepStateMap.get(clampedIndex);
    if (!state) {
      console.error(`WizardStateMachine: No state mapping for step index ${clampedIndex}`);
      return;
    }
    this.stepIndex = clampedIndex;
    this.currentState = state;
    console.debug(
      `WizardStateMachine: Jumped to step ${this.stepIndex} (state: ${this.currentState})`
    );
  }
  /**
   * Jump to a specific state
   * This will move to the first step of that state
   */
  jumpToState(state) {
    const stepIndex = this.stateStepMap.get(state);
    if (stepIndex === void 0) {
      console.error(`WizardStateMachine: No step mapping for state ${state}`);
      return;
    }
    this.jumpToStep(stepIndex);
  }
  /**
   * Get progress as a percentage
   */
  getProgress() {
    if (this.steps.length === 0) return 0;
    return (this.stepIndex + 1) / this.steps.length * 100;
  }
  /**
   * Get a human-readable description of the current state
   */
  getStateDescription() {
    switch (this.currentState) {
      case "welcome":
        return "Welcome";
      case "detect":
        return "Project Detection";
      case "content-types":
        return "Content Type Setup";
      case "frontmatter":
        return "Frontmatter Configuration";
      case "plugins":
        return "Plugin Configuration";
      case "complete":
        return "Finalization";
      default:
        return "Unknown State";
    }
  }
  /**
   * Debug: Get a summary of the current state machine status
   */
  getDebugInfo() {
    return `State: ${this.currentState} (${this.getStateDescription()}) | Step: ${this.stepIndex + 1}/${this.steps.length} | Progress: ${this.getProgress().toFixed(1)}%`;
  }
};

// src/ui/SetupWizardModal.ts
function setCssProps8(element, props) {
  for (const [key, value] of Object.entries(props)) {
    const cssKey = key.replace(/([A-Z])/g, "-$1").toLowerCase();
    element.style.setProperty(cssKey, value);
  }
}
var SetupWizardModal = class extends import_obsidian24.Modal {
  // Track the last step where "Next" was clicked
  constructor(app, initialState, pluginInstance) {
    var _a, _b;
    super(app);
    this.currentStepInstance = null;
    this.isCompleting = false;
    this.initialSettingsSnapshot = null;
    this.lastSavedStepIndex = -1;
    this.plugin = pluginInstance || ((_b = (_a = app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["vault-cms"]);
    if (!this.plugin) {
      throw new Error("VaultCMSPlugin instance is required");
    }
    this.stateManager = new WizardStateManager(this.plugin);
    if (initialState) {
      this.stateManager.updateState(initialState);
    }
    this.steps = [
      WelcomeStep,
      ProjectDetectionStep,
      ContentTypeStep,
      DefaultContentTypeStep,
      FrontmatterPropertiesStep,
      EditingToolbarStep,
      BasesCMSConfigStep,
      AstroComposerStep,
      SEOConfigStep,
      OptionalPluginsStep,
      IgnoreStep,
      GitSetupStep,
      FinalizeStep
    ];
    this.stateMachine = new WizardStateMachine(this.steps);
    console.debug("SetupWizardModal: State machine initialized -", this.stateMachine.getDebugInfo());
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vault-cms-wizard");
    await this.stateManager.refreshState();
    this.initialSettingsSnapshot = this.createSettingsSnapshot();
    void this.renderCurrentStep();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.isCompleting = false;
  }
  scrollToTop() {
    const { contentEl } = this;
    let scrollableParent = contentEl;
    while (scrollableParent && scrollableParent !== document.body) {
      const style = window.getComputedStyle(scrollableParent);
      if (scrollableParent.scrollHeight > scrollableParent.clientHeight && (style.overflowY === "auto" || style.overflowY === "scroll" || style.overflow === "auto" || style.overflow === "scroll")) {
        scrollableParent.scrollTop = 0;
        break;
      }
      scrollableParent = scrollableParent.parentElement;
    }
    const modalContent = contentEl.closest(".modal-content");
    if (modalContent) {
      modalContent.scrollTop = 0;
    }
    const modalContainer = contentEl.closest(".modal-container");
    if (modalContainer) {
      modalContainer.scrollTop = 0;
    }
    contentEl.scrollTop = 0;
  }
  async renderCurrentStep() {
    const { contentEl } = this;
    this.scrollToTop();
    contentEl.empty();
    contentEl.addClass("vault-cms-wizard");
    this.scrollToTop();
    this.renderProgress(contentEl);
    const stepContent = contentEl.createDiv("wizard-content");
    await this.renderStepContent(stepContent);
    this.renderFooter(contentEl);
    requestAnimationFrame(() => {
      this.scrollToTop();
    });
  }
  renderProgress(container) {
    try {
      const state = this.stateManager.getState();
      const totalSteps = this.steps.length;
      if (!state || !this.stateMachine) {
        console.error("SetupWizardModal: state or stateMachine is missing in renderProgress");
        return;
      }
      const progress = container.createDiv("wizard-progress");
      this.stateMachine.jumpToStep(state.currentStep);
      const progressBar = progress.createDiv("progress-bar");
      const progressFill = progressBar.createDiv("progress-fill");
      const progressPercent = (state.currentStep + 1) / totalSteps * 100;
      progressFill.style.width = `${progressPercent}%`;
      const progressText = progress.createDiv("progress-text");
      progressText.textContent = `Step ${state.currentStep + 1} of ${totalSteps} - ${this.stateMachine.getStateDescription()}`;
    } catch (error) {
      console.error("SetupWizardModal: Error rendering progress bar:", error);
    }
  }
  async renderStepContent(container) {
    const state = this.stateManager.getState();
    const stepIndex = state.currentStep;
    if (stepIndex >= 0 && stepIndex < this.steps.length) {
      const StepClass = this.steps[stepIndex];
      const stepName = StepClass.name || "Unknown";
      console.debug(
        `SetupWizardModal: Displaying step ${stepIndex + 1}/${this.steps.length}: ${stepName}`,
        `[${this.stateMachine.getDebugInfo()}]`
      );
      this.currentStepInstance = new StepClass(
        this.app,
        container,
        state,
        () => {
          void (async () => {
            if (this.currentStepInstance && this.currentStepInstance.validate()) {
              await this.saveCurrentStepToWizardState();
              this.stateManager.nextStep(this.steps.length);
              this.stateMachine.next();
              console.debug("SetupWizardModal: Advanced to next step -", this.stateMachine.getDebugInfo());
              await this.renderCurrentStep();
            }
          })();
        },
        () => {
          this.discardCurrentStepChanges();
          this.stateManager.previousStep();
          this.stateMachine.previous();
          console.debug("SetupWizardModal: Went back to previous step -", this.stateMachine.getDebugInfo());
          void this.renderCurrentStep();
        },
        () => this.close()
      );
      await this.currentStepInstance.display();
    }
  }
  renderFooter(container) {
    var _a;
    const footer = container.createDiv("wizard-footer");
    setCssProps8(footer, { display: "flex", justifyContent: "space-between", alignItems: "center" });
    if (this.stateManager.getState().currentStep === 0) {
      const startupSetting = footer.createDiv("wizard-startup-setting-footer");
      const label = startupSetting.createEl("label", { cls: "wizard-checkbox-label" });
      setCssProps8(label, { cursor: "default" });
      const checkbox = label.createEl("input", { type: "checkbox" });
      setCssProps8(checkbox, { cursor: "default" });
      checkbox.checked = !this.plugin.settings.runWizardOnStartup;
      label.createSpan({ text: " I've already set up my vault, don't show on startup" });
      checkbox.addEventListener("change", () => {
        this.plugin.settings.runWizardOnStartup = !checkbox.checked;
        void this.plugin.saveSettings();
      });
    } else {
      footer.createDiv();
    }
    const buttons = footer.createDiv("wizard-buttons");
    setCssProps8(buttons, { display: "flex", gap: "10px" });
    if (this.stateManager.canGoPrevious()) {
      const prevBtn = buttons.createEl("button", {
        text: "Previous",
        cls: "mod-button"
      });
      prevBtn.addEventListener("click", () => {
        this.discardCurrentStepChanges();
        this.stateManager.previousStep();
        void this.renderCurrentStep();
      });
    }
    if (this.stateManager.canGoNext(this.steps.length)) {
      if (this.stateManager.getState().currentStep !== 0 && ((_a = this.currentStepInstance) == null ? void 0 : _a.showNextButton) !== false) {
        const nextBtn = buttons.createEl("button", {
          text: "Next",
          cls: "mod-button mod-cta"
        });
        nextBtn.addEventListener("click", () => {
          void (async () => {
            if (this.currentStepInstance && this.currentStepInstance.validate()) {
              await this.saveCurrentStepToWizardState();
              this.lastSavedStepIndex = this.stateManager.getState().currentStep;
              this.stateManager.nextStep(this.steps.length);
              await this.renderCurrentStep();
            }
          })();
        });
      }
    } else {
      if (this.currentStepInstance instanceof FinalizeStep) {
        const applyBtn = buttons.createEl("button", {
          text: "Apply",
          cls: "mod-button"
        });
        applyBtn.addEventListener("click", () => {
          void this.handleComplete(false);
        });
        const applyRestartBtn = buttons.createEl("button", {
          text: "Apply and restart",
          cls: "mod-button mod-cta"
        });
        applyRestartBtn.addEventListener("click", () => {
          void this.handleComplete(true);
        });
      } else {
        const completeBtn = buttons.createEl("button", {
          text: "Complete setup",
          cls: "mod-button mod-cta"
        });
        completeBtn.addEventListener("click", () => {
          void this.handleComplete(false);
        });
      }
    }
    if (this.stateManager.canGoNext(this.steps.length)) {
      if (this.stateManager.getState().currentStep !== 0) {
        const skipBtn = buttons.createEl("button", {
          text: "Skip",
          cls: "mod-button"
        });
        skipBtn.addClass("wizard-skip-button");
        setCssProps8(skipBtn, { opacity: "0.6" });
        skipBtn.addEventListener("click", () => {
          this.stateManager.nextStep(this.steps.length);
          void this.renderCurrentStep();
        });
      }
    }
  }
  async handleComplete(shouldRestart) {
    if (this.isCompleting) return;
    this.isCompleting = true;
    try {
      if (this.currentStepInstance && this.currentStepInstance.validate()) {
        if (this.currentStepInstance instanceof FinalizeStep) {
          await this.currentStepInstance.applyConfiguration(shouldRestart);
        } else {
          await this.saveCurrentStepToWizardState();
        }
        this.plugin.settings.wizardCompleted = true;
        this.plugin.settings.runWizardOnStartup = false;
        await this.plugin.saveSettings();
        await this.plugin.loadSettings();
        this.close();
        if (shouldRestart) {
          setTimeout(() => {
            this.app.commands.executeCommandById("app:reload");
          }, 1e3);
        }
      }
    } catch (error) {
      console.error("Error completing wizard:", error);
      new import_obsidian24.Notice("Failed to complete setup. Please check the console for details.");
    } finally {
      this.isCompleting = false;
    }
  }
  async saveCurrentStepToWizardState() {
    try {
      await this.stateManager.buildFinalSettings();
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
    } catch (error) {
      console.error("Error saving current step to data.json:", error);
    }
  }
  discardCurrentStepChanges() {
    void this.stateManager.refreshState();
  }
  async saveWizardStateToDataJson(showNotification = true) {
    try {
      await this.stateManager.buildFinalSettings();
      const hasChanges = this.hasSettingsChanged();
      if (!hasChanges) {
        return;
      }
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
      if (showNotification) {
        new import_obsidian24.Notice("Configuration saved");
      }
    } catch (error) {
      console.error("Error saving wizard state to data.json:", error);
      if (showNotification) {
        new import_obsidian24.Notice(`Failed to save configuration: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  createSettingsSnapshot() {
    const state = this.stateManager.getState();
    return JSON.parse(JSON.stringify({
      projectDetection: state.projectDetection,
      contentTypes: state.contentTypes,
      frontmatterProperties: state.frontmatterProperties,
      defaultContentTypeId: state.defaultContentTypeId,
      preset: state.preset,
      enableEditingToolbar: state.enableEditingToolbar,
      enabledPlugins: state.enabledPlugins,
      disabledPlugins: state.disabledPlugins,
      theme: state.theme,
      basesCMSConfig: state.basesCMSConfig,
      astroComposerConfig: state.astroComposerConfig,
      seoConfig: state.seoConfig,
      propertyOverFileName: state.propertyOverFileName,
      imageManager: state.imageManager,
      homeBase: state.homeBase
    }));
  }
  hasSettingsChanged() {
    if (!this.initialSettingsSnapshot) {
      return false;
    }
    const currentSnapshot = this.createSettingsSnapshot();
    return JSON.stringify(currentSnapshot.projectDetection) !== JSON.stringify(this.initialSettingsSnapshot.projectDetection) || JSON.stringify(currentSnapshot.contentTypes) !== JSON.stringify(this.initialSettingsSnapshot.contentTypes) || JSON.stringify(currentSnapshot.frontmatterProperties) !== JSON.stringify(this.initialSettingsSnapshot.frontmatterProperties) || currentSnapshot.defaultContentTypeId !== this.initialSettingsSnapshot.defaultContentTypeId || currentSnapshot.preset !== this.initialSettingsSnapshot.preset || currentSnapshot.enableEditingToolbar !== this.initialSettingsSnapshot.enableEditingToolbar || JSON.stringify(currentSnapshot.enabledPlugins) !== JSON.stringify(this.initialSettingsSnapshot.enabledPlugins) || JSON.stringify(currentSnapshot.disabledPlugins) !== JSON.stringify(this.initialSettingsSnapshot.disabledPlugins) || currentSnapshot.theme !== this.initialSettingsSnapshot.theme || JSON.stringify(currentSnapshot.basesCMSConfig) !== JSON.stringify(this.initialSettingsSnapshot.basesCMSConfig) || JSON.stringify(currentSnapshot.astroComposerConfig) !== JSON.stringify(this.initialSettingsSnapshot.astroComposerConfig) || JSON.stringify(currentSnapshot.seoConfig) !== JSON.stringify(this.initialSettingsSnapshot.seoConfig) || JSON.stringify(currentSnapshot.propertyOverFileName) !== JSON.stringify(this.initialSettingsSnapshot.propertyOverFileName) || JSON.stringify(currentSnapshot.imageManager) !== JSON.stringify(this.initialSettingsSnapshot.imageManager) || JSON.stringify(currentSnapshot.homeBase) !== JSON.stringify(this.initialSettingsSnapshot.homeBase);
  }
  getState() {
    return this.stateManager.getState();
  }
  // Callback to save state to plugin settings (kept for backward compatibility)
  setSaveCallback(callback) {
    console.warn("setSaveCallback is deprecated - state is now managed automatically");
  }
};

// src/ui/HealthCheckModal.ts
var import_obsidian25 = require("obsidian");
var HealthCheckModal = class extends import_obsidian25.Modal {
  constructor(app, plugin) {
    super(app);
    this.results = [];
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vault-cms-health-check");
    contentEl.createEl("h2", { text: "Vault CMS Health Check" });
    await this.runHealthChecks();
    this.displayResults(contentEl);
    const footer = contentEl.createDiv({ cls: "health-check-footer" });
    const closeBtn = footer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeBtn.addEventListener("click", () => this.close());
  }
  async runHealthChecks() {
    this.results = [];
    await this.checkCompanionPluginsInstalled();
    await this.checkCompanionPluginsEnabled();
    await this.checkAstroProjectDetection();
    await this.checkPluginConfiguration();
    await this.checkGitIntegration();
  }
  async checkCompanionPluginsInstalled() {
    var _a;
    const requiredPlugins = [
      { id: "astro-composer", name: "Astro Composer" },
      { id: "bases-cms", name: "Bases CMS" },
      { id: "home-base", name: "Home Base" },
      { id: "seo", name: "SEO" }
    ];
    const optionalPlugins = [
      { id: "property-over-file-name", name: "Property Over File Name" },
      { id: "image-manager", name: "Image Manager" }
    ];
    const checks = [];
    const plugins = ((_a = this.app.plugins) == null ? void 0 : _a.plugins) || {};
    for (const plugin of requiredPlugins) {
      const isInstalled = !!plugins[plugin.id];
      checks.push({
        name: `${plugin.name} installed`,
        status: isInstalled ? "pass" : "fail",
        message: isInstalled ? void 0 : "Plugin not installed"
      });
    }
    for (const plugin of optionalPlugins) {
      const isInstalled = !!plugins[plugin.id];
      checks.push({
        name: `${plugin.name} installed`,
        status: isInstalled ? "pass" : "warning",
        message: isInstalled ? void 0 : "Optional plugin not installed"
      });
    }
    this.results.push({
      category: "Plugin Installation",
      checks
    });
  }
  async checkCompanionPluginsEnabled() {
    const requiredPlugins = [
      { id: "astro-composer", name: "Astro Composer" },
      { id: "bases-cms", name: "Bases CMS" },
      { id: "home-base", name: "Home Base" },
      { id: "seo", name: "SEO" }
    ];
    const checks = [];
    const pluginsAPI = this.app.plugins;
    const enabledPlugins = (pluginsAPI == null ? void 0 : pluginsAPI.enabledPlugins) || /* @__PURE__ */ new Set();
    for (const plugin of requiredPlugins) {
      const isEnabled = enabledPlugins.has(plugin.id);
      checks.push({
        name: `${plugin.name} enabled`,
        status: isEnabled ? "pass" : "fail",
        message: isEnabled ? void 0 : "Plugin is installed but not enabled"
      });
    }
    this.results.push({
      category: "Plugin Status",
      checks
    });
  }
  async checkAstroProjectDetection() {
    const checks = [];
    const hasProjectRoot = !!this.plugin.settings.projectRoot;
    const hasConfigFile = !!this.plugin.settings.configFilePath;
    checks.push({
      name: "Project root configured",
      status: hasProjectRoot ? "pass" : "fail",
      message: hasProjectRoot ? this.plugin.settings.projectRoot : "Project root not set"
    });
    checks.push({
      name: "Config file detected",
      status: hasConfigFile ? "pass" : "fail",
      message: hasConfigFile ? this.plugin.settings.configFilePath : "Config file not found"
    });
    if (hasProjectRoot && hasConfigFile) {
      const detector = new ProjectDetector(this.app);
      try {
        const detection = await detector.detectProject();
        checks.push({
          name: "Project structure valid",
          status: detection ? "pass" : "warning",
          message: detection ? `Found ${detection.configFilePath}` : "Could not validate project structure"
        });
      } catch (error) {
        checks.push({
          name: "Project structure valid",
          status: "warning",
          message: `Error: ${error instanceof Error ? error.message : String(error)}`
        });
      }
    }
    const hasContentTypes = this.plugin.settings.contentTypes && this.plugin.settings.contentTypes.length > 0;
    checks.push({
      name: "Content types configured",
      status: hasContentTypes ? "pass" : "warning",
      message: hasContentTypes ? `${this.plugin.settings.contentTypes.length} content type(s) configured` : "No content types configured"
    });
    this.results.push({
      category: "Astro Project",
      checks
    });
  }
  async checkPluginConfiguration() {
    var _a, _b, _c, _d, _e, _f, _g;
    const checks = [];
    const configDir = this.app.vault.configDir;
    let astroComposerContentTypes = 0;
    try {
      const plugins = this.app.plugins;
      const astroComposerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["astro-composer"];
      if ((_b = astroComposerPlugin == null ? void 0 : astroComposerPlugin.settings) == null ? void 0 : _b.contentTypes) {
        astroComposerContentTypes = astroComposerPlugin.settings.contentTypes.length;
      } else {
        const astroComposerPath = `${configDir}/plugins/astro-composer/data.json`;
        const astroFile = this.app.vault.getAbstractFileByPath(astroComposerPath);
        if (astroFile instanceof import_obsidian25.TFile) {
          const content = await this.app.vault.read(astroFile);
          const data = JSON.parse(content);
          astroComposerContentTypes = ((_c = data.contentTypes) == null ? void 0 : _c.length) || 0;
        }
      }
    } catch (e) {
    }
    checks.push({
      name: "Astro Composer configured",
      status: astroComposerContentTypes > 0 ? "pass" : "warning",
      message: astroComposerContentTypes > 0 ? `${astroComposerContentTypes} content type(s)` : "No content types configured"
    });
    let basesConfigured = false;
    let basesMessage = "No base file found";
    try {
      const basesFile1 = this.app.vault.getAbstractFileByPath("_bases/Home.base");
      const basesFile2 = this.app.vault.getAbstractFileByPath("bases/Home.base");
      if (basesFile1 || basesFile2) {
        basesConfigured = true;
        basesMessage = basesFile1 ? "_bases/Home.base found" : "bases/Home.base found";
      }
    } catch (e) {
    }
    checks.push({
      name: "Bases CMS configured",
      status: basesConfigured ? "pass" : "warning",
      message: basesMessage
    });
    let seoScanDirs = "";
    try {
      const plugins = this.app.plugins;
      const seoPlugin = (_d = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _d["seo"];
      if ((_e = seoPlugin == null ? void 0 : seoPlugin.settings) == null ? void 0 : _e.scanDirectories) {
        seoScanDirs = seoPlugin.settings.scanDirectories;
      } else {
        const seoPath = `${configDir}/plugins/seo/data.json`;
        const seoFile = this.app.vault.getAbstractFileByPath(seoPath);
        if (seoFile instanceof import_obsidian25.TFile) {
          const content = await this.app.vault.read(seoFile);
          const data = JSON.parse(content);
          seoScanDirs = data.scanDirectories || "";
        }
      }
    } catch (e) {
    }
    checks.push({
      name: "SEO plugin configured",
      status: seoScanDirs.length > 0 ? "pass" : "warning",
      message: seoScanDirs.length > 0 ? `Scanning: ${seoScanDirs}` : "No scan directories configured"
    });
    const hasDefaultContentType = !!this.plugin.settings.defaultContentTypeId;
    let defaultContentTypeName = this.plugin.settings.defaultContentTypeId || "";
    if (hasDefaultContentType) {
      try {
        const plugins = this.app.plugins;
        const astroComposerPlugin = (_f = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _f["astro-composer"];
        const contentTypes = (_g = astroComposerPlugin == null ? void 0 : astroComposerPlugin.settings) == null ? void 0 : _g.contentTypes;
        if (contentTypes) {
          const matchingType = contentTypes.find((ct) => ct.id === this.plugin.settings.defaultContentTypeId);
          if (matchingType == null ? void 0 : matchingType.name) {
            defaultContentTypeName = matchingType.name;
          }
        }
      } catch (e) {
      }
    }
    checks.push({
      name: "Default content type set",
      status: hasDefaultContentType ? "pass" : "warning",
      message: hasDefaultContentType ? defaultContentTypeName : "No default content type"
    });
    this.results.push({
      category: "Plugin Configuration",
      checks
    });
  }
  async checkGitIntegration() {
    var _a;
    const checks = [];
    const { gitConfig, projectRoot } = this.plugin.settings;
    if (projectRoot) {
      const { GitManager: GitManager2 } = await Promise.resolve().then(() => (init_GitManager(), GitManager_exports));
      const isRepo = await GitManager2.isRepo(projectRoot);
      const remoteUrl = isRepo ? await GitManager2.getRemoteUrl(projectRoot) : null;
      checks.push({
        name: "Git repository initialized",
        status: isRepo ? "pass" : "fail",
        message: isRepo ? "Repository detected at project root" : "No repository found at project root"
      });
      if (isRepo) {
        const isConfigured = gitConfig.enabled || !!remoteUrl;
        checks.push({
          name: "Git integration status",
          status: isConfigured ? "pass" : "warning",
          message: remoteUrl ? `Connected to ${remoteUrl}` : gitConfig.enabled ? "Integration active" : "Not configured (Optional)"
        });
        const savedSecret = (_a = this.app.secretStorage) == null ? void 0 : _a.getSecret("vault-cms-github-pat");
        const hasPat = !!(gitConfig.pat || savedSecret);
        if (gitConfig.enabled) {
          checks.push({
            name: "GitHub PAT configured",
            status: hasPat ? "pass" : "warning",
            message: hasPat ? "Token present" : "No token found in settings"
          });
        }
      }
    } else {
      checks.push({
        name: "Git repository check",
        status: "fail",
        message: "Project root not configured"
      });
    }
    this.results.push({
      category: "Git Integration",
      checks
    });
  }
  displayResults(container) {
    const resultsContainer = container.createDiv({ cls: "health-check-results" });
    for (const result of this.results) {
      const categorySection = resultsContainer.createDiv({ cls: "health-check-category" });
      categorySection.createEl("h3", { text: result.category });
      const checksList = categorySection.createDiv({ cls: "health-check-list" });
      for (const check of result.checks) {
        const checkItem = checksList.createDiv({ cls: "health-check-item" });
        const statusIcon = checkItem.createSpan({ cls: "health-check-icon" });
        if (check.status === "pass") {
          (0, import_obsidian25.setIcon)(statusIcon, "lucide-check-circle-2");
          statusIcon.addClass("health-check-pass");
        } else if (check.status === "fail") {
          (0, import_obsidian25.setIcon)(statusIcon, "lucide-alert-circle");
          statusIcon.addClass("health-check-fail");
        } else {
          (0, import_obsidian25.setIcon)(statusIcon, "lucide-help-circle");
          statusIcon.addClass("health-check-warning");
        }
        const checkName = checkItem.createSpan({
          text: check.name,
          cls: "health-check-name"
        });
        if (check.message) {
          const checkMessage = checkItem.createDiv({
            text: check.message,
            cls: "health-check-message"
          });
        }
      }
    }
    this.addStyles(container);
  }
  addStyles(container) {
    const style = container.createEl("style");
    style.textContent = `
			.vault-cms-health-check {
				padding: 20px;
			}

			.health-check-results {
				margin: 20px 0;
			}

			.health-check-category {
				margin-bottom: 30px;
			}

			.health-check-category h3 {
				margin-bottom: 10px;
				border-bottom: 1px solid var(--background-modifier-border);
				padding-bottom: 5px;
			}

			.health-check-list {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}

			.health-check-item {
				display: flex;
				align-items: flex-start;
				gap: 10px;
				padding: 8px;
				background: var(--background-secondary);
				border-radius: 4px;
			}

			.health-check-icon {
				font-size: 18px;
				font-weight: bold;
				min-width: 24px;
				text-align: center;
			}

			.health-check-pass {
				color: var(--text-success);
			}

			.health-check-fail {
				color: var(--text-error);
			}

			.health-check-warning {
				color: var(--text-warning);
			}

			.health-check-icon svg {
				width: 18px;
				height: 18px;
				display: block;
			}

			.health-check-icon {
				display: flex;
				align-items: center;
				justify-content: center;
				min-width: 24px;
				height: 24px;
			}

			.health-check-name {
				flex: 1;
				font-weight: 500;
			}

			.health-check-message {
				font-size: 0.9em;
				color: var(--text-muted);
				margin-left: 34px;
				margin-top: 4px;
			}

			.health-check-footer {
				display: flex;
				justify-content: flex-end;
				margin-top: 20px;
				padding-top: 15px;
				border-top: 1px solid var(--background-modifier-border);
			}
		`;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/settings-compat.ts
var import_obsidian26 = require("obsidian");
function createSettingsGroup(containerEl, heading, manifestId) {
  if ((0, import_obsidian26.requireApiVersion)("1.11.0")) {
    const obsidian = require("obsidian");
    const SettingGroup = obsidian.SettingGroup;
    const group = heading ? new SettingGroup(containerEl).setHeading(heading) : new SettingGroup(containerEl);
    return {
      addSetting(cb) {
        group.addSetting(cb);
      }
    };
  } else {
    if (manifestId) {
      containerEl.addClass(`${manifestId}-settings-compat`);
    }
    if (heading) {
      const headingEl = containerEl.createDiv("setting-group-heading");
      headingEl.createEl("h3", { text: heading });
    }
    return {
      addSetting(cb) {
        const setting = new import_obsidian26.Setting(containerEl);
        cb(setting);
      }
    };
  }
}

// src/utils/PresetManager.ts
var import_obsidian28 = require("obsidian");

// src/ui/ApplyPresetModal.ts
var import_obsidian27 = require("obsidian");
var ApplyPresetModal = class extends import_obsidian27.Modal {
  constructor(app, backupPath, onConfirm) {
    super(app);
    this.backupPath = backupPath;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Preset applied successfully" });
    contentEl.createEl("p", { text: "The preset has been applied successfully. You need to reload Obsidian for all changes to take effect." });
    contentEl.createEl("p", { text: `A backup of your original configuration folder was created at: ${this.backupPath}` });
    new import_obsidian27.Setting(contentEl).setName("Delete backup and reload").setDesc('Remove the backup folder and reload Obsidian. This is the recommended "clean" option.').addButton((button) => button.setButtonText("Delete and reload").setCta().onClick(() => {
      this.close();
      this.onConfirm(true);
    }));
    new import_obsidian27.Setting(contentEl).setName("Keep backup and reload").setDesc("Keep the backup folder for safety and reload Obsidian.").addButton((button) => button.setButtonText("Keep and reload").onClick(() => {
      this.close();
      this.onConfirm(false);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/PresetManager.ts
var PresetManager = class {
  constructor(app) {
    this.app = app;
  }
  async applyPreset(repo, presetName) {
    if (!repo || !presetName) {
      new import_obsidian28.Notice("Please configure both repository and preset name in settings.");
      return;
    }
    try {
      new import_obsidian28.Notice(`Fetching preset "${presetName}" from ${repo}...`);
      const files = await this.fetchPresetFilesRecursive(repo, presetName);
      if (files.length === 0) {
        new import_obsidian28.Notice(`No files found for preset "${presetName}" in repo ${repo}.`);
        return;
      }
      new import_obsidian28.Notice("Backing up configuration folder...");
      const backupPath = await this.backupObsidianFolder();
      new import_obsidian28.Notice(`Downloading and applying ${files.length} files...`);
      let successCount = 0;
      for (const file of files) {
        if (file.download_url) {
          const relativePath = file.path.substring(presetName.length + 1);
          try {
            await this.downloadAndWriteFile(file.download_url, relativePath);
            successCount++;
          } catch (e) {
            console.error(`Failed to download ${relativePath}:`, e);
          }
        }
      }
      new import_obsidian28.Notice(`Applied ${successCount} files.`);
      new ApplyPresetModal(this.app, backupPath, (deleteBackup) => {
        void (async () => {
          if (deleteBackup) {
            try {
              await this.app.vault.adapter.rmdir(backupPath, true);
              new import_obsidian28.Notice("Backup deleted.");
            } catch (e) {
              console.error("Failed to delete backup:", e);
              new import_obsidian28.Notice("Failed to delete backup folder. You may need to remove it manually.");
            }
          }
          const appWithCommands = this.app;
          if (appWithCommands.commands && typeof appWithCommands.commands.executeCommandById === "function") {
            appWithCommands.commands.executeCommandById("app:reload");
          }
        })();
      }).open();
    } catch (error) {
      console.error("Failed to apply preset:", error);
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian28.Notice(`Failed to apply preset: ${message}`);
    }
  }
  async fetchPresetFilesRecursive(repo, path10) {
    const url = `https://api.github.com/repos/${repo}/contents/${path10}`;
    try {
      const response = await (0, import_obsidian28.requestUrl)({ url });
      if (response.status !== 200) {
        throw new Error(`GitHub API returned status ${response.status}`);
      }
      const items = response.json;
      let allFiles = [];
      for (const item of items) {
        if (item.type === "dir") {
          const subFiles = await this.fetchPresetFilesRecursive(repo, item.path);
          allFiles = allFiles.concat(subFiles);
        } else if (item.type === "file") {
          allFiles.push(item);
        }
      }
      return allFiles;
    } catch (e) {
      if (e && typeof e === "object" && "status" in e && e.status === 404) {
        throw new Error(`Preset folder "${path10}" not found in repository "${repo}".`);
      }
      throw e;
    }
  }
  async backupObsidianFolder() {
    const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").split("T")[0] + "-" + Math.floor(Date.now() / 1e3);
    const configDir = this.app.vault.configDir;
    const backupPath = `${configDir}_backup_${timestamp2}`;
    const adapter = this.app.vault.adapter;
    await adapter.mkdir(backupPath);
    await this.copyRecursive(configDir, `${backupPath}/${configDir}`);
    return backupPath;
  }
  async copyRecursive(source, destination) {
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(source)) {
      return;
    }
    const stats = await adapter.list(source);
    if (!await adapter.exists(destination)) {
      await adapter.mkdir(destination);
    }
    for (const file of stats.files) {
      const fileName = file.split("/").pop();
      if (fileName) {
        const destFile = destination + "/" + fileName;
        try {
          await adapter.copy(file, destFile);
        } catch (e) {
          console.error(`Failed to copy file ${file} to ${destFile}:`, e);
        }
      }
    }
    for (const folder of stats.folders) {
      const folderName = folder.split("/").pop();
      if (folderName) {
        const destFolder = destination + "/" + folderName;
        await this.copyRecursive(folder, destFolder);
      }
    }
  }
  async downloadAndWriteFile(url, path10) {
    const adapter = this.app.vault.adapter;
    const response = await (0, import_obsidian28.requestUrl)({ url });
    if (response.status !== 200) {
      throw new Error(`Failed to download ${path10} from ${url}`);
    }
    const parts = path10.split("/");
    if (parts.length > 1) {
      for (let i = 1; i < parts.length; i++) {
        const dir = parts.slice(0, i).join("/");
        if (!await adapter.exists(dir)) {
          await adapter.mkdir(dir);
        }
      }
    }
    await adapter.writeBinary(path10, response.arrayBuffer);
  }
};

// src/ui/SettingsTab.ts
var SettingsTab = class extends import_obsidian29.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.icon = "lucide-vault";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.contentEl = containerEl.createDiv("vault-cms-settings-container");
    void this.render();
  }
  async render() {
    if (!this.contentEl) return;
    this.contentEl.empty();
    const generalGroup = createSettingsGroup(this.contentEl, void 0, "vault-cms");
    generalGroup.addSetting((setting) => {
      setting.setName("Open setup wizard").setDesc("Launch the setup wizard").addButton((button) => {
        button.setButtonText("Open wizard").setCta().onClick(() => {
          new SetupWizardModal(this.app, this.plugin.settings, this.plugin).open();
        });
      });
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Run wizard on startup").setDesc("Automatically open the wizard when the plugin loads").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.runWizardOnStartup).onChange(async (value) => {
          this.plugin.settings.runWizardOnStartup = value;
          await this.plugin.saveSettings();
        });
      });
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Health check").setDesc("Check plugin installation and configuration status").addButton((button) => {
        button.setButtonText("Run health check").onClick(() => {
          new HealthCheckModal(this.app, this.plugin).open();
        });
      });
    });
    const presetGroup = createSettingsGroup(this.contentEl, "Preset configuration", "vault-cms-presets");
    presetGroup.addSetting((setting) => {
      setting.setName("Preset folder name").setDesc("Folder name in the repository").addText((text) => {
        text.setPlaceholder("Example: starlight").setValue(this.plugin.settings.presetName).onChange(async (value) => {
          this.plugin.settings.presetName = value;
          await this.plugin.saveSettings();
        });
      });
    });
    presetGroup.addSetting((setting) => {
      setting.setName("Presets repository").setDesc("GitHub repository containing the presets").addText((text) => {
        text.setPlaceholder("Example: owner/repo").setValue(this.plugin.settings.presetsRepo).onChange(async (value) => {
          this.plugin.settings.presetsRepo = value;
          await this.plugin.saveSettings();
        });
      });
    });
    presetGroup.addSetting((setting) => {
      setting.setName("Download and apply preset").setDesc("Download the specified preset and apply it to your vault").addButton((button) => {
        button.setButtonText("Apply preset").onClick(async () => {
          const manager = new PresetManager(this.app);
          await manager.applyPreset(this.plugin.settings.presetsRepo, this.plugin.settings.presetName);
        });
      });
    });
    const gitGroup = createSettingsGroup(this.contentEl, "Git configuration", "vault-cms-git");
    let isFullyConfigured = false;
    if (this.plugin.settings.projectRoot && this.plugin.settings.projectRoot.trim() !== "") {
      try {
        const { GitManager: GitManager2 } = await Promise.resolve().then(() => (init_GitManager(), GitManager_exports));
        const projectRoot = this.plugin.settings.projectRoot;
        const isRepo = await GitManager2.isRepo(projectRoot);
        const remoteUrl = isRepo ? await GitManager2.getRemoteUrl(projectRoot) : null;
        isFullyConfigured = isRepo && !!remoteUrl;
        gitGroup.addSetting((setting) => {
          setting.setName("Local repository status").setDesc(isRepo ? "Git is initialized at project root." : "Git is NOT initialized at project root.");
          const statusIcon = setting.controlEl.createSpan({
            cls: isRepo ? "git-status-icon-ok" : "git-status-icon-warn",
            attr: { style: `margin-left: 10px; color: ${isRepo ? "var(--text-success)" : "var(--text-warning)"};` }
          });
          statusIcon.setText(isRepo ? "\u2713 Detected" : "\u26A0 Missing");
        });
        gitGroup.addSetting((setting) => {
          setting.setName("Project root path").setDesc("Direct path being checked for Git").addText((text) => {
            text.setValue(projectRoot).setDisabled(true);
          });
        });
        if (remoteUrl) {
          gitGroup.addSetting((setting) => {
            setting.setName("Remote URL").setDesc("Connected GitHub repository").addText((text) => {
              text.setValue(remoteUrl).setDisabled(true);
            });
          });
        }
      } catch (error) {
        console.warn("SettingsTab: Failed to check Git status:", error);
      }
    }
    if (!isFullyConfigured) {
      gitGroup.addSetting((setting) => {
        setting.setName("Manage Git integration").setDesc("Initialize repository, connect to GitHub, or update credentials.").addButton((button) => {
          button.setButtonText("Setup / Update Git...").onClick(() => {
            const modal = new SetupWizardModal(this.app, { currentStep: 11 }, this.plugin);
            modal.open();
          });
        });
      });
    }
    const optimizationGroup = createSettingsGroup(this.contentEl, "Project optimization (optional)", "vault-cms-optimization");
    if (!this.plugin.settings.projectRoot) {
      optimizationGroup.addSetting((setting) => {
        setting.setName("Project not detected").setDesc("Complete the setup wizard first to detect your Astro project before configuring optimizations.");
      });
      return;
    }
    const wizardState = {
      ...this.plugin.settings,
      currentStep: 0,
      projectDetection: {
        projectRoot: this.plugin.settings.projectRoot,
        configFilePath: this.plugin.settings.configFilePath,
        vaultLocation: "content"
      }
    };
    this.optimizer = new ProjectOptimizer(this.app, wizardState);
    const status = await this.optimizer.getStatus();
    optimizationGroup.addSetting((setting) => {
      this.gitSetting = setting;
      this.updateGitSetting(status.gitIgnoreStatus);
    });
    optimizationGroup.addSetting((setting) => {
      this.viteSetting = setting;
      this.updateViteSetting(status.viteIgnoreStatus);
    });
  }
  updateGitSetting(status) {
    this.gitSetting.setName("Ignore in Git").setDesc("Add workspace files to Git ignore").clear();
    this.gitSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          const success = await this.optimizer.configureGitIgnore();
          if (success) {
            this.plugin.settings.ignoreConfig.gitIgnoreConfigured = true;
            await this.plugin.saveSettings();
            new import_obsidian29.Notice("Git ignore updated");
          } else {
            new import_obsidian29.Notice("Could not configure Git ignore: project root not detected");
          }
          const newStatus = await this.optimizer.getStatus();
          this.updateGitSetting(newStatus.gitIgnoreStatus);
        } catch (error) {
          new import_obsidian29.Notice(`Failed to update Git ignore: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.gitSetting.controlEl, status);
  }
  updateViteSetting(status) {
    this.viteSetting.setName("Ignore in Vite").setDesc("Configure Vite to ignore internal folders").clear();
    this.viteSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          const success = await this.optimizer.configureViteIgnore();
          if (success) {
            this.plugin.settings.ignoreConfig.viteIgnoreConfigured = true;
            await this.plugin.saveSettings();
            new import_obsidian29.Notice("Vite optimization applied");
          } else {
            new import_obsidian29.Notice("Could not configure Vite: project root not detected");
          }
          const newStatus = await this.optimizer.getStatus();
          this.updateViteSetting(newStatus.viteIgnoreStatus);
        } catch (error) {
          new import_obsidian29.Notice(`Failed to update Vite config: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.viteSetting.controlEl, status);
  }
};

// src/commands/index.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "open-wizard",
    name: "Open setup wizard",
    callback: () => {
      const wizard = new SetupWizardModal(plugin.app, plugin.settings, plugin);
      wizard.open();
    }
  });
  plugin.addCommand({
    id: "health-check",
    name: "Check Vault CMS setup",
    callback: () => {
      const healthCheck = new HealthCheckModal(plugin.app, plugin);
      healthCheck.open();
    }
  });
  plugin.addCommand({
    id: "download-apply-preset",
    name: "Download and apply preset",
    callback: async () => {
      const manager = new PresetManager(plugin.app);
      await manager.applyPreset(plugin.settings.presetsRepo, plugin.settings.presetName);
    }
  });
}

// src/main.ts
var path9 = __toESM(require("path"), 1);
var VaultCMSPlugin = class extends import_obsidian30.Plugin {
  async onload() {
    await this.loadSettings();
    if (this.settings.projectRoot && !path9.isAbsolute(this.settings.projectRoot)) {
      const adapter = this.app.vault.adapter;
      const vaultPath = adapter.basePath || adapter.path;
      if (vaultPath) {
        const absolutePath = path9.resolve(vaultPath, this.settings.projectRoot);
        console.debug(`[Vault CMS] Repairing relative projectRoot: ${this.settings.projectRoot} -> ${absolutePath}`);
        this.settings.projectRoot = absolutePath;
        await this.saveSettings();
      }
    }
    registerCommands(this);
    this.addSettingTab(new SettingsTab(this.app, this));
    if (this.settings.runWizardOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        this.startupTimeoutId = window.setTimeout(() => {
          void (async () => {
            await this.loadSettings();
            if (this.settings.runWizardOnStartup) {
              const wizard = new SetupWizardModal(this.app, void 0, this);
              wizard.open();
            }
          })();
        }, 2e3);
      });
    }
  }
  onunload() {
    if (this.startupTimeoutId) {
      window.clearTimeout(this.startupTimeoutId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL3V0aWxzL0dpdE1hbmFnZXIudHMiLCAic3JjL21haW4udHMiLCAic3JjL3NldHRpbmdzLnRzIiwgInNyYy91aS9TZXR0aW5nc1RhYi50cyIsICJzcmMvdWkvU2V0dXBXaXphcmRNb2RhbC50cyIsICJzcmMvdXRpbHMvSW1hZ2VNYW5hZ2VyQ29uZmlnLnRzIiwgInNyYy91dGlscy9Ib21lQmFzZUNvbmZpZy50cyIsICJzcmMvdXRpbHMvRXhwbG9yZXJGb2N1c0NvbmZpZy50cyIsICJzcmMvdXRpbHMvRWRpdGluZ1Rvb2xiYXJDb25maWcudHMiLCAic3JjL3VpL3dpemFyZC9XaXphcmRTdGF0ZU1hbmFnZXIudHMiLCAic3JjL3VpL3dpemFyZC9CYXNlV2l6YXJkU3RlcC50cyIsICJzcmMvdWkvd2l6YXJkL1dlbGNvbWVTdGVwLnRzIiwgInNyYy91aS93aXphcmQvUHJvamVjdERldGVjdGlvblN0ZXAudHMiLCAic3JjL3V0aWxzL1Byb2plY3REZXRlY3Rvci50cyIsICJzcmMvdXRpbHMvTWR4RGV0ZWN0b3IudHMiLCAic3JjL3V0aWxzL0NvbnRlbnRUeXBlRGV0ZWN0b3IudHMiLCAic3JjL3VpL3dpemFyZC9Db250ZW50VHlwZVN0ZXAudHMiLCAic3JjL3V0aWxzL1BhdGhSZXNvbHZlci50cyIsICJzcmMvdXRpbHMvU2FmZUNvbmZpZ1dyaXRlci50cyIsICJzcmMvdXRpbHMvQXN0cm9Db21wb3NlckNvbmZpZy50cyIsICJzcmMvdWkvd2l6YXJkL0RlZmF1bHRDb250ZW50VHlwZVN0ZXAudHMiLCAic3JjL3VpL3dpemFyZC9Gcm9udG1hdHRlclByb3BlcnRpZXNTdGVwLnRzIiwgInNyYy91dGlscy9Gcm9udG1hdHRlckFuYWx5emVyLnRzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9pZGVudGl0eS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvdmlzaXQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9kaXJlY3RpdmVzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvYW5jaG9ycy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2FwcGx5UmV2aXZlci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvdG9KUy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvTm9kZS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvQWxpYXMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1NjYWxhci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2NyZWF0ZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL0NvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlDb21tZW50LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvZm9sZEZsb3dMaW5lcy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeVBhaXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2xvZy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL21lcmdlLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9hZGRQYWlyVG9KU01hcC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvUGFpci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1lBTUxNYXAuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9ZQU1MU2VxLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL3NlcS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbnVsbC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvYm9vbC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2ludC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvanNvbi9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9iaW5hcnkuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9wYWlycy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL29tYXAuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9ib29sLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9pbnQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zZXQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS90aW1lc3RhbXAuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS90YWdzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvU2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5RG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9Eb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtcHJvcHMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1jb250YWlucy1uZXdsaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtZmxvdy1pbmRlbnQtY2hlY2suanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1tYXAtaW5jbHVkZXMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1tYXAuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zZXEuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1lbmQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1jb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2UtZG9jLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9jc3QtdmlzaXQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2xpbmUtY291bnRlci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wdWJsaWMtYXBpLmpzIiwgInNyYy91aS93aXphcmQvRWRpdGluZ1Rvb2xiYXJTdGVwLnRzIiwgInNyYy91aS93aXphcmQvQmFzZXNDTVNDb25maWdTdGVwLnRzIiwgInNyYy91aS93aXphcmQvQXN0cm9Db21wb3NlclN0ZXAudHMiLCAic3JjL3VpL3dpemFyZC9TRU9Db25maWdTdGVwLnRzIiwgInNyYy91aS93aXphcmQvT3B0aW9uYWxQbHVnaW5zU3RlcC50cyIsICJzcmMvdXRpbHMvUGx1Z2luTWFuYWdlci50cyIsICJzcmMvdWkvd2l6YXJkL0lnbm9yZVN0ZXAudHMiLCAic3JjL3V0aWxzL1Byb2plY3RPcHRpbWl6ZXIudHMiLCAic3JjL3VpL3dpemFyZC9HaXRTZXR1cFN0ZXAudHMiLCAic3JjL3V0aWxzL0Jhc2VzQ01TQ29uZmlnLnRzIiwgInNyYy91dGlscy9TRU9Db25maWcudHMiLCAic3JjL3V0aWxzL1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnLnRzIiwgInNyYy91dGlscy9VSVR3ZWFrZXJDb25maWcudHMiLCAic3JjL3V0aWxzL0RhdGFGaWxlc0VkaXRvckNvbmZpZy50cyIsICJzcmMvdXRpbHMvQ29uZmlnRmx1c2hTZXJ2aWNlLnRzIiwgInNyYy91aS93aXphcmQvRmluYWxpemVTdGVwLnRzIiwgInNyYy91aS93aXphcmQvV2l6YXJkU3RhdGVNYWNoaW5lLnRzIiwgInNyYy91aS9IZWFsdGhDaGVja01vZGFsLnRzIiwgInNyYy91dGlscy9zZXR0aW5ncy1jb21wYXQudHMiLCAic3JjL3V0aWxzL1ByZXNldE1hbmFnZXIudHMiLCAic3JjL3VpL0FwcGx5UHJlc2V0TW9kYWwudHMiLCAic3JjL2NvbW1hbmRzL2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyByZXF1ZXN0VXJsLCBSZXF1ZXN0VXJsUGFyYW0gfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcclxuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuXHJcbmNvbnN0IGV4ZWNBc3luYyA9IHByb21pc2lmeShleGVjKTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR2l0SHViUmVwb1Jlc3BvbnNlIHtcclxuICAgIGNsb25lX3VybDogc3RyaW5nO1xyXG4gICAgaHRtbF91cmw6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdpdE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSBkaXJlY3RvcnkgaXMgYSBHaXQgcmVwb3NpdG9yeS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGlzUmVwbyhwcm9qZWN0Um9vdDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgaWYgKCFwcm9qZWN0Um9vdCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUocHJvamVjdFJvb3QpO1xyXG4gICAgICAgICAgICBjb25zdCBkb3RHaXRQYXRoID0gcGF0aC5qb2luKGFic29sdXRlUGF0aCwgJy5naXQnKTtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhkb3RHaXRQYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdE1hbmFnZXIuaXNSZXBvIGNoZWNrOicsIHtcclxuICAgICAgICAgICAgICAgIHByb2plY3RSb290LFxyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgZG90R2l0UGF0aCxcclxuICAgICAgICAgICAgICAgIGV4aXN0c1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhhYnNvbHV0ZVBhdGgpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBTVFJJQ1QgQ0hFQ0s6IE9ubHkgY29uc2lkZXIgaXQgYSByZXBvIGlmIC5naXQgZXhpc3RzIEVYQUNUTFkgaW4gdGhpcyBmb2xkZXIuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgXCJnaG9zdFwiIGRldGVjdGlvbiBmcm9tIHBhcmVudCByZXBvc2l0b3JpZXMuXHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignR2l0TWFuYWdlci5pc1JlcG8gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgR2l0IHJlcG9zaXRvcnkgYXQgdGhlIGdpdmVuIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBpbml0UmVwbyhwcm9qZWN0Um9vdDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgYXdhaXQgZXhlY0FzeW5jKCdnaXQgaW5pdCcsIHsgY3dkOiBwcm9qZWN0Um9vdCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHJlbW90ZSBVUkwgZm9yIHRoZSByZXBvc2l0b3J5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgc2V0UmVtb3RlKHByb2plY3RSb290OiBzdHJpbmcsIHVybDogc3RyaW5nLCByZW1vdGVOYW1lOiBzdHJpbmcgPSAnb3JpZ2luJyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHJlbW90ZSBhZGQgJHtyZW1vdGVOYW1lfSAke3VybH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gSWYgcmVtb3RlIGFscmVhZHkgZXhpc3RzLCB1cGRhdGUgaXRcclxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXhlY0FzeW5jKGBnaXQgcmVtb3RlIHNldC11cmwgJHtyZW1vdGVOYW1lfSAke3VybH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJlbW90ZSBVUkwgZm9yIHRoZSByZXBvc2l0b3J5LCBzY3J1YmJpbmcgYW55IHRva2VucyBmb3Igc2VjdXJpdHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBnZXRSZW1vdGVVcmwocHJvamVjdFJvb3Q6IHN0cmluZywgcmVtb3RlTmFtZTogc3RyaW5nID0gJ29yaWdpbicpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHN0ZG91dCB9ID0gYXdhaXQgZXhlY0FzeW5jKGBnaXQgcmVtb3RlIGdldC11cmwgJHtyZW1vdGVOYW1lfWAsIHsgY3dkOiBwcm9qZWN0Um9vdCB9KTtcclxuICAgICAgICAgICAgbGV0IHVybCA9IHN0ZG91dC50cmltKCkgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh1cmwgJiYgdXJsLmluY2x1ZGVzKCdAZ2l0aHViLmNvbScpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY3J1YiB0b2tlbjogaHR0cHM6Ly9naHBfeHh4QGdpdGh1Yi5jb20vLi4uIC0+IGh0dHBzOi8vZ2l0aHViLmNvbS8uLi5cclxuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9odHRwczpcXC9cXC8uKkBnaXRodWJcXC5jb20vLCAnaHR0cHM6Ly9naXRodWIuY29tJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbG9jYWwgYnJhbmNoIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBnZXRDdXJyZW50QnJhbmNoKHByb2plY3RSb290OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3Rkb3V0IH0gPSBhd2FpdCBleGVjQXN5bmMoJ2dpdCBicmFuY2ggLS1zaG93LWN1cnJlbnQnLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGRvdXQudHJpbSgpIHx8ICdtYWluJztcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtYWluJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluaXRpYWwgY29tbWl0IGFuZCBwdXNoZXMgdG8gdGhlIHJlbW90ZSwgc2V0dGluZyB0aGUgdXBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBpbml0aWFsQ29tbWl0QW5kUHVzaChwcm9qZWN0Um9vdDogc3RyaW5nLCBicmFuY2g6IHN0cmluZywgcmVtb3RlTmFtZTogc3RyaW5nID0gJ29yaWdpbicsIHRva2VuPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnR2l0TWFuYWdlci5pbml0aWFsQ29tbWl0QW5kUHVzaDogc3RhcnRpbmcnLCB7IHByb2plY3RSb290LCBicmFuY2gsIHJlbW90ZU5hbWUsIGhhc1Rva2VuOiAhIXRva2VuIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gMS4gRW5zdXJlIHVzZXIgaWRlbnRpdHkgaXMgc2V0IChnaXQgY29tbWl0IGZhaWxzIHdpdGhvdXQgaXQpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoJ2dpdCBjb25maWcgdXNlci5uYW1lJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdE1hbmFnZXI6IFNldHRpbmcgbG9jYWwgZ2l0IHVzZXIubmFtZScpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXhlY0FzeW5jKCdnaXQgY29uZmlnIHVzZXIubmFtZSBcIlZhdWx0IENNUyBVc2VyXCInLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoJ2dpdCBjb25maWcgdXNlci5lbWFpbCBcInZhdWx0LWNtc0BleGFtcGxlLmNvbVwiJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAyLiBBZGQgYWxsIGZpbGVzXHJcbiAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYygnZ2l0IGFkZCAuJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gMy4gQ29tbWl0XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoJ2dpdCBjb21taXQgLW0gXCJJbml0aWFsIGNvbW1pdCBmcm9tIFZhdWx0IENNU1wiJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChjb21taXRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gY29tbWl0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGNvbW1pdEVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoY29tbWl0RXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnbm90aGluZyB0byBjb21taXQnKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ3dvcmtpbmcgdHJlZSBjbGVhbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnR2l0TWFuYWdlcjogTm90aGluZyB0byBjb21taXQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY29tbWl0RXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDQuIEVuc3VyZSBicmFuY2ggbmFtZSBpcyBzZXQgbG9jYWxseVxyXG4gICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoYGdpdCBicmFuY2ggLU0gJHticmFuY2h9YCwgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gNS4gUHVzaCBhbmQgc2V0IHVwc3RyZWFtXHJcbiAgICAgICAgICAgIC8vIFRvIGVuc3VyZSB0aGUgcHVzaCBzdWNjZWVkcyB3aXRob3V0IGEgY3JlZGVudGlhbCBoZWxwZXIsIHdlIHRlbXBvcmFyaWx5IHVzZSB0aGUgdG9rZW4gaW4gdGhlIFVSTFxyXG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZVVybCA9IGF3YWl0IHRoaXMuZ2V0UmVtb3RlVXJsKHByb2plY3RSb290LCByZW1vdGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVVcmwgJiYgcmVtb3RlVXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdGVkVXJsID0gcmVtb3RlVXJsLnJlcGxhY2UoJ2h0dHBzOi8vJywgYGh0dHBzOi8vJHt0b2tlbn1AYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdE1hbmFnZXI6IFB1c2hpbmcgd2l0aCB0ZW1wb3JhcnkgdG9rZW4gYXV0aCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHRlbXBvcmFyaWx5IHNldCB0aGUgcmVtb3RlIFVSTCB0byBpbmNsdWRlIHRoZSB0b2tlbiBmb3IgdGhlIHB1c2hcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoYGdpdCByZW1vdGUgc2V0LXVybCAke3JlbW90ZU5hbWV9ICR7YXV0aGVudGljYXRlZFVybH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHB1c2ggLXUgJHtyZW1vdGVOYW1lfSAke2JyYW5jaH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQUxXQVlTIHJldmVydCB0byB0aGUgY2xlYW4gVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHJlbW90ZSBzZXQtdXJsICR7cmVtb3RlTmFtZX0gJHtyZW1vdGVVcmx9YCwgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZXhlY0FzeW5jKGBnaXQgcHVzaCAtdSAke3JlbW90ZU5hbWV9ICR7YnJhbmNofWAsIHsgY3dkOiBwcm9qZWN0Um9vdCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHB1c2ggLXUgJHtyZW1vdGVOYW1lfSAke2JyYW5jaH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHaXRNYW5hZ2VyLmluaXRpYWxDb21taXRBbmRQdXNoIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVwb3NpdG9yeSBvbiBHaXRIdWIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVHaXRIdWJSZXBvKHRva2VuOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgaXNQcml2YXRlOiBib29sZWFuKTogUHJvbWlzZTxHaXRIdWJSZXBvUmVzcG9uc2U+IHtcclxuICAgICAgICBjb25zdCBwYXJhbXM6IFJlcXVlc3RVcmxQYXJhbSA9IHtcclxuICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS91c2VyL3JlcG9zJyxcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYHRva2VuICR7dG9rZW59YCxcclxuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uJyxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZTogaXNQcml2YXRlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVwb3NpdG9yeSBuYW1lIGFscmVhZHkgZXhpc3RzIG9uIHlvdXIgR2l0SHViIGFjY291bnQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIG1vcmUgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZSBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgR2l0SHViIEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gdHlwZW9mIHJlc3BvbnNlLmpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShyZXNwb25zZS5qc29uKSA6IHJlc3BvbnNlLmpzb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yRGF0YT8ubWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgR2l0SHViIEFQSSBFcnJvcjogJHtlcnJvckRhdGEubWVzc2FnZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JEYXRhLmVycm9ycz8uWzBdPy5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYCAoJHtlcnJvckRhdGEuZXJyb3JzWzBdLm1lc3NhZ2V9KWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBhcnNlIGVycm9yLCB1c2UgYmFzaWMgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uIGFzIEdpdEh1YlJlcG9SZXNwb25zZTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGFscmVhZHkgYW4gRXJyb3Igd2l0aCB0aGUgbWVzc2FnZSB3ZSB3YW50XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0dpdEh1YiBBUEkgRXJyb3InKSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgdW5leHBlY3RlZCBlcnJvcnMgb3IgcmVxdWVzdCBmYWlsdXJlc1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygnNDIyJykgfHwgbWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXBvc2l0b3J5IG5hbWUgYWxyZWFkeSBleGlzdHMgb24geW91ciBHaXRIdWIgYWNjb3VudC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZmllcyBpZiB0aGUgR2l0SHViIFBBVCBpcyB2YWxpZCBhbmQgcmV0dXJucyB0aGUgdXNlcm5hbWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnlUb2tlbih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zOiBSZXF1ZXN0VXJsUGFyYW0gPSB7XHJcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2FwaS5naXRodWIuY29tL3VzZXInLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGB0b2tlbiAke3Rva2VufWAsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnYzK2pzb24nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybChwYXJhbXMpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uPy5sb2dpbiB8fCBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IFBsdWdpbiwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBWYXVsdENNU1NldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi9zZXR0aW5ncyc7XHJcbmltcG9ydCB7IFNldHRpbmdzVGFiIH0gZnJvbSAnLi91aS9TZXR0aW5nc1RhYic7XHJcbmltcG9ydCB7IFNldHVwV2l6YXJkTW9kYWwgfSBmcm9tICcuL3VpL1NldHVwV2l6YXJkTW9kYWwnO1xyXG5pbXBvcnQgeyByZWdpc3RlckNvbW1hbmRzIH0gZnJvbSAnLi9jb21tYW5kcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYXVsdENNU1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcblx0c2V0dGluZ3M6IFZhdWx0Q01TU2V0dGluZ3M7XHJcblx0cHJpdmF0ZSBzdGFydHVwVGltZW91dElkPzogbnVtYmVyO1xyXG5cclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuXHRcdC8vIFJlcGFpciByZWxhdGl2ZSBwcm9qZWN0Um9vdCB0byBhYnNvbHV0ZSBmb3IgcmVsaWFiaWxpdHlcclxuXHRcdGlmICh0aGlzLnNldHRpbmdzLnByb2plY3RSb290ICYmICFwYXRoLmlzQWJzb2x1dGUodGhpcy5zZXR0aW5ncy5wcm9qZWN0Um9vdCkpIHtcclxuXHRcdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xyXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHRcdFx0aWYgKHZhdWx0UGF0aCkge1xyXG5cdFx0XHRcdGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIHRoaXMuc2V0dGluZ3MucHJvamVjdFJvb3QpO1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYFtWYXVsdCBDTVNdIFJlcGFpcmluZyByZWxhdGl2ZSBwcm9qZWN0Um9vdDogJHt0aGlzLnNldHRpbmdzLnByb2plY3RSb290fSAtPiAke2Fic29sdXRlUGF0aH1gKTtcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnByb2plY3RSb290ID0gYWJzb2x1dGVQYXRoO1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZWdpc3RlciBjb21tYW5kc1xyXG5cdFx0cmVnaXN0ZXJDb21tYW5kcyh0aGlzKTtcclxuXHJcblx0XHQvLyBBZGQgc2V0dGluZ3MgdGFiXHJcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG5cdFx0Ly8gT3BlbiB3aXphcmQgb24gc3RhcnR1cCBpZiBjb25maWd1cmVkXHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXApIHtcclxuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xyXG5cdFx0XHRcdC8vIERlbGF5IHRoZSB3aXphcmQgdG8gbGV0IE9ic2lkaWFuIGZ1bGx5IGxvYWQgKGxpa2UgYXN0cm8tbW9kdWxhci1zZXR0aW5ncylcclxuXHRcdFx0XHR0aGlzLnN0YXJ0dXBUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHR2b2lkIChhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdC8vIFJlbG9hZCBzZXR0aW5ncyB0byBjaGVjayBpZiB1c2VyIGRpc2FibGVkIHRoZSBzZXR0aW5nXHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHdpemFyZCA9IG5ldyBTZXR1cFdpemFyZE1vZGFsKHRoaXMuYXBwLCB1bmRlZmluZWQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0XHRcdHdpemFyZC5vcGVuKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSwgMjAwMCk7IC8vIDItc2Vjb25kIGRlbGF5XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHRpZiAodGhpcy5zdGFydHVwVGltZW91dElkKSB7XHJcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zdGFydHVwVGltZW91dElkKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkgYXMgUGFydGlhbDxWYXVsdENNU1NldHRpbmdzPik7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IENvbnRlbnRUeXBlQ29uZmlnLCBGcm9udG1hdHRlclByb3BlcnRpZXMsIEJhc2VzQ01TQ29uZmlnLCBBc3Ryb0NvbXBvc2VyQ29uZmlnLCBTRU9Db25maWcsIFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnLCBJbWFnZU1hbmFnZXJDb25maWcsIEhvbWVCYXNlQ29uZmlnLCBFeHBsb3JlckZvY3VzQ29uZmlnLCBJZ25vcmVDb25maWcsIEdpdENvbmZpZyB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYXVsdENNU1NldHRpbmdzIHtcclxuXHRwcm9qZWN0Um9vdDogc3RyaW5nO1xyXG5cdGNvbmZpZ0ZpbGVQYXRoOiBzdHJpbmc7XHJcblx0Y29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdO1xyXG5cdGZyb250bWF0dGVyUHJvcGVydGllczogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIH07XHJcblx0ZGVmYXVsdENvbnRlbnRUeXBlSWQ/OiBzdHJpbmc7XHJcblx0YXR0YWNobWVudEhhbmRsaW5nTW9kZTogJ3NwZWNpZmllZC1mb2xkZXInIHwgJ3NhbWUtZm9sZGVyJyB8ICdzdWJmb2xkZXInO1xyXG5cdGF0dGFjaG1lbnRGb2xkZXJOYW1lPzogc3RyaW5nO1xyXG5cdHByZXNldDogJ3ZhbmlsbGEnIHwgJ29waW5pb25hdGVkJyB8ICdjdXN0b20nO1xyXG5cdHByZXNldE5hbWU6IHN0cmluZztcclxuXHRwcmVzZXRzUmVwbzogc3RyaW5nO1xyXG5cdGVuYWJsZUVkaXRpbmdUb29sYmFyOiBib29sZWFuO1xyXG5cdGVuYWJsZU1keFN1cHBvcnQ/OiBib29sZWFuO1xyXG5cdGVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzPzogYm9vbGVhbjtcclxuXHRlbmFibGVkUGx1Z2luczogc3RyaW5nW107XHJcblx0ZGlzYWJsZWRQbHVnaW5zOiBzdHJpbmdbXTtcclxuXHR0aGVtZTogc3RyaW5nO1xyXG5cdGJhc2VzQ01TQ29uZmlnOiBCYXNlc0NNU0NvbmZpZztcclxuXHRhc3Ryb0NvbXBvc2VyQ29uZmlnOiBBc3Ryb0NvbXBvc2VyQ29uZmlnO1xyXG5cdHNlb0NvbmZpZzogU0VPQ29uZmlnO1xyXG5cdHByb3BlcnR5T3ZlckZpbGVOYW1lOiBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZztcclxuXHRpbWFnZU1hbmFnZXI6IEltYWdlTWFuYWdlckNvbmZpZztcclxuXHRob21lQmFzZTogSG9tZUJhc2VDb25maWc7XHJcblx0ZXhwbG9yZXJGb2N1czogRXhwbG9yZXJGb2N1c0NvbmZpZztcclxuXHRpZ25vcmVDb25maWc6IElnbm9yZUNvbmZpZztcclxuXHRnaXRDb25maWc6IEdpdENvbmZpZztcclxuXHRydW5XaXphcmRPblN0YXJ0dXA6IGJvb2xlYW47XHJcblx0d2l6YXJkQ29tcGxldGVkOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogVmF1bHRDTVNTZXR0aW5ncyA9IHtcclxuXHRwcm9qZWN0Um9vdDogJycsXHJcblx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdGNvbnRlbnRUeXBlczogW10sXHJcblx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiB7fSxcclxuXHRhdHRhY2htZW50SGFuZGxpbmdNb2RlOiAnc3ViZm9sZGVyJyxcclxuXHRhdHRhY2htZW50Rm9sZGVyTmFtZTogdW5kZWZpbmVkLFxyXG5cdHByZXNldDogJ3ZhbmlsbGEnLFxyXG5cdHByZXNldE5hbWU6ICcnLFxyXG5cdHByZXNldHNSZXBvOiAnZGF2aWR2a2ltYmFsbC92YXVsdC1jbXMtcHJlc2V0cycsXHJcblx0ZW5hYmxlRWRpdGluZ1Rvb2xiYXI6IGZhbHNlLFxyXG5cdGVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzOiBmYWxzZSxcclxuXHRlbmFibGVkUGx1Z2luczogW10sXHJcblx0ZGlzYWJsZWRQbHVnaW5zOiBbXSxcclxuXHR0aGVtZTogJycsXHJcblx0YmFzZXNDTVNDb25maWc6IHtcclxuXHRcdHZpZXdzOiBbXVxyXG5cdH0sXHJcblx0YXN0cm9Db21wb3NlckNvbmZpZzoge1xyXG5cdFx0Y3VzdG9tQ29udGVudFR5cGVzOiBbXSxcclxuXHRcdGRlZmF1bHRUZW1wbGF0ZTogJycsXHJcblx0XHRjb25maWdGaWxlUGF0aDogJycsXHJcblx0XHR0ZXJtaW5hbFByb2plY3RSb290UGF0aDogJydcclxuXHR9LFxyXG5cdHNlb0NvbmZpZzoge1xyXG5cdFx0dGl0bGVQcm9wZXJ0eTogJ3RpdGxlJyxcclxuXHRcdGRlc2NyaXB0aW9uUHJvcGVydHk6IHVuZGVmaW5lZCxcclxuXHRcdHNjYW5EaXJlY3RvcmllczogJycsXHJcblx0XHR1c2VGaWxlbmFtZUFzVGl0bGU6IGZhbHNlLFxyXG5cdFx0dXNlRmlsZW5hbWVBc1NsdWc6IHRydWUsXHJcblx0XHRlbmFibGVNRFhTdXBwb3J0OiBmYWxzZVxyXG5cdH0sXHJcblx0cHJvcGVydHlPdmVyRmlsZU5hbWU6IHtcclxuXHRcdHByb3BlcnR5S2V5OiAndGl0bGUnXHJcblx0fSxcclxuXHRpbWFnZU1hbmFnZXI6IHt9LFxyXG5cdGhvbWVCYXNlOiB7fSxcclxuXHRleHBsb3JlckZvY3VzOiB7fSxcclxuXHRpZ25vcmVDb25maWc6IHtcclxuXHRcdGdpdElnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlLFxyXG5cdFx0dml0ZUlnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlXHJcblx0fSxcclxuXHRnaXRDb25maWc6IHtcclxuXHRcdGVuYWJsZWQ6IGZhbHNlLFxyXG5cdFx0aXNQcml2YXRlOiB0cnVlLFxyXG5cdFx0YnJhbmNoTmFtZTogJ21haW4nLFxyXG5cdFx0YXV0b0NvbmZpZ3VyZU9ic2lkaWFuR2l0OiB0cnVlXHJcblx0fSxcclxuXHRydW5XaXphcmRPblN0YXJ0dXA6IHRydWUsXHJcblx0d2l6YXJkQ29tcGxldGVkOiBmYWxzZVxyXG59O1xyXG5cclxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgTm90aWNlLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IFZhdWx0Q01TUGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgU2V0dXBXaXphcmRNb2RhbCB9IGZyb20gJy4vU2V0dXBXaXphcmRNb2RhbCc7XG5pbXBvcnQgeyBIZWFsdGhDaGVja01vZGFsIH0gZnJvbSAnLi9IZWFsdGhDaGVja01vZGFsJztcbmltcG9ydCB7IGNyZWF0ZVNldHRpbmdzR3JvdXAgfSBmcm9tICcuLi91dGlscy9zZXR0aW5ncy1jb21wYXQnO1xuaW1wb3J0IHsgUHJlc2V0TWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL1ByZXNldE1hbmFnZXInO1xuaW1wb3J0IHsgUHJvamVjdE9wdGltaXplciB9IGZyb20gJy4uL3V0aWxzL1Byb2plY3RPcHRpbWl6ZXInO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IFZhdWx0Q01TUGx1Z2luO1xuXHRwdWJsaWMgaWNvbiA9ICdsdWNpZGUtdmF1bHQnO1xuXHRwcml2YXRlIGNvbnRlbnRFbDogSFRNTEVsZW1lbnQ7XG5cdHByaXZhdGUgZ2l0U2V0dGluZzogU2V0dGluZztcblx0cHJpdmF0ZSB2aXRlU2V0dGluZzogU2V0dGluZztcblx0cHJpdmF0ZSBvcHRpbWl6ZXI6IFByb2plY3RPcHRpbWl6ZXI7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogVmF1bHRDTVNQbHVnaW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblx0XHR0aGlzLmNvbnRlbnRFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdigndmF1bHQtY21zLXNldHRpbmdzLWNvbnRhaW5lcicpO1xuXHRcdHZvaWQgdGhpcy5yZW5kZXIoKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcmVuZGVyKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5jb250ZW50RWwpIHJldHVybjtcblxuXHRcdHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG5cblx0XHQvLyBGaXJzdCBncm91cCAobm8gaGVhZGluZykgLSBmb2xsb3dpbmcgVUkgVHdlYWtlciBwYXR0ZXJuXG5cdFx0Y29uc3QgZ2VuZXJhbEdyb3VwID0gY3JlYXRlU2V0dGluZ3NHcm91cCh0aGlzLmNvbnRlbnRFbCwgdW5kZWZpbmVkLCAndmF1bHQtY21zJyk7XG5cblx0XHRnZW5lcmFsR3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdPcGVuIHNldHVwIHdpemFyZCcpXG5cdFx0XHRcdC5zZXREZXNjKCdMYXVuY2ggdGhlIHNldHVwIHdpemFyZCcpXG5cdFx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdPcGVuIHdpemFyZCcpXG5cdFx0XHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0bmV3IFNldHVwV2l6YXJkTW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLnNldHRpbmdzLCB0aGlzLnBsdWdpbikub3BlbigpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Z2VuZXJhbEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcblx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUnVuIHdpemFyZCBvbiBzdGFydHVwJylcblx0XHRcdFx0LnNldERlc2MoJ0F1dG9tYXRpY2FsbHkgb3BlbiB0aGUgd2l6YXJkIHdoZW4gdGhlIHBsdWdpbiBsb2FkcycpXG5cdFx0XHRcdC5hZGRUb2dnbGUodG9nZ2xlID0+IHtcblx0XHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXApXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGdlbmVyYWxHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRzZXR0aW5nLnNldE5hbWUoJ0hlYWx0aCBjaGVjaycpXG5cdFx0XHRcdC5zZXREZXNjKCdDaGVjayBwbHVnaW4gaW5zdGFsbGF0aW9uIGFuZCBjb25maWd1cmF0aW9uIHN0YXR1cycpXG5cdFx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdSdW4gaGVhbHRoIGNoZWNrJylcblx0XHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0bmV3IEhlYWx0aENoZWNrTW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luKS5vcGVuKCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBQcmVzZXQgY29uZmlndXJhdGlvbiBncm91cFxuXHRcdGNvbnN0IHByZXNldEdyb3VwID0gY3JlYXRlU2V0dGluZ3NHcm91cCh0aGlzLmNvbnRlbnRFbCwgJ1ByZXNldCBjb25maWd1cmF0aW9uJywgJ3ZhdWx0LWNtcy1wcmVzZXRzJyk7XG5cblx0XHRwcmVzZXRHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRzZXR0aW5nLnNldE5hbWUoJ1ByZXNldCBmb2xkZXIgbmFtZScpXG5cdFx0XHRcdC5zZXREZXNjKCdGb2xkZXIgbmFtZSBpbiB0aGUgcmVwb3NpdG9yeScpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdHRleHRcblx0XHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRXhhbXBsZTogc3RhcmxpZ2h0Jylcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXROYW1lKVxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXROYW1lID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cHJlc2V0R3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdQcmVzZXRzIHJlcG9zaXRvcnknKVxuXHRcdFx0XHQuc2V0RGVzYygnR2l0SHViIHJlcG9zaXRvcnkgY29udGFpbmluZyB0aGUgcHJlc2V0cycpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdHRleHRcblx0XHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRXhhbXBsZTogb3duZXIvcmVwbycpXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlc2V0c1JlcG8pXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnByZXNldHNSZXBvID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cHJlc2V0R3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdEb3dubG9hZCBhbmQgYXBwbHkgcHJlc2V0Jylcblx0XHRcdFx0LnNldERlc2MoJ0Rvd25sb2FkIHRoZSBzcGVjaWZpZWQgcHJlc2V0IGFuZCBhcHBseSBpdCB0byB5b3VyIHZhdWx0Jylcblx0XHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4ge1xuXHRcdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0FwcGx5IHByZXNldCcpXG5cdFx0XHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgUHJlc2V0TWFuYWdlcih0aGlzLmFwcCk7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IG1hbmFnZXIuYXBwbHlQcmVzZXQodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlc2V0c1JlcG8sIHRoaXMucGx1Z2luLnNldHRpbmdzLnByZXNldE5hbWUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gR2l0IENvbmZpZ3VyYXRpb24gZ3JvdXBcblx0XHRjb25zdCBnaXRHcm91cCA9IGNyZWF0ZVNldHRpbmdzR3JvdXAodGhpcy5jb250ZW50RWwsICdHaXQgY29uZmlndXJhdGlvbicsICd2YXVsdC1jbXMtZ2l0Jyk7XG5cdFx0bGV0IGlzRnVsbHlDb25maWd1cmVkID0gZmFsc2U7XG5cblx0XHQvLyBEaXNwbGF5IEdpdCBzdGF0dXMgaWYgcHJvamVjdCByb290IGlzIHNldFxuXHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0Um9vdCAmJiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0Um9vdC50cmltKCkgIT09ICcnKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCB7IEdpdE1hbmFnZXIgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXRpbHMvR2l0TWFuYWdlcicpO1xuXHRcdFx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290O1xuXHRcdFx0XHRjb25zdCBpc1JlcG8gPSBhd2FpdCBHaXRNYW5hZ2VyLmlzUmVwbyhwcm9qZWN0Um9vdCk7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVVybCA9IGlzUmVwbyA/IGF3YWl0IEdpdE1hbmFnZXIuZ2V0UmVtb3RlVXJsKHByb2plY3RSb290KSA6IG51bGw7XG5cdFx0XHRcdGlzRnVsbHlDb25maWd1cmVkID0gaXNSZXBvICYmICEhcmVtb3RlVXJsO1xuXG5cdFx0XHRcdGdpdEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcblx0XHRcdFx0XHRzZXR0aW5nLnNldE5hbWUoJ0xvY2FsIHJlcG9zaXRvcnkgc3RhdHVzJylcblx0XHRcdFx0XHRcdC5zZXREZXNjKGlzUmVwbyA/ICdHaXQgaXMgaW5pdGlhbGl6ZWQgYXQgcHJvamVjdCByb290LicgOiAnR2l0IGlzIE5PVCBpbml0aWFsaXplZCBhdCBwcm9qZWN0IHJvb3QuJyk7XG5cblx0XHRcdFx0XHRjb25zdCBzdGF0dXNJY29uID0gc2V0dGluZy5jb250cm9sRWwuY3JlYXRlU3Bhbih7XG5cdFx0XHRcdFx0XHRjbHM6IGlzUmVwbyA/ICdnaXQtc3RhdHVzLWljb24tb2snIDogJ2dpdC1zdGF0dXMtaWNvbi13YXJuJyxcblx0XHRcdFx0XHRcdGF0dHI6IHsgc3R5bGU6IGBtYXJnaW4tbGVmdDogMTBweDsgY29sb3I6ICR7aXNSZXBvID8gJ3ZhcigtLXRleHQtc3VjY2VzcyknIDogJ3ZhcigtLXRleHQtd2FybmluZyknfTtgIH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzdGF0dXNJY29uLnNldFRleHQoaXNSZXBvID8gJ1x1MjcxMyBEZXRlY3RlZCcgOiAnXHUyNkEwIE1pc3NpbmcnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Z2l0R3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUHJvamVjdCByb290IHBhdGgnKVxuXHRcdFx0XHRcdFx0LnNldERlc2MoJ0RpcmVjdCBwYXRoIGJlaW5nIGNoZWNrZWQgZm9yIEdpdCcpXG5cdFx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdFx0dGV4dC5zZXRWYWx1ZShwcm9qZWN0Um9vdClcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQodHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHJlbW90ZVVybCkge1xuXHRcdFx0XHRcdGdpdEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcblx0XHRcdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUmVtb3RlIFVSTCcpXG5cdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdDb25uZWN0ZWQgR2l0SHViIHJlcG9zaXRvcnknKVxuXHRcdFx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdFx0XHR0ZXh0LnNldFZhbHVlKHJlbW90ZVVybClcblx0XHRcdFx0XHRcdFx0XHRcdC5zZXREaXNhYmxlZCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignU2V0dGluZ3NUYWI6IEZhaWxlZCB0byBjaGVjayBHaXQgc3RhdHVzOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPbmx5IHNob3cgbWFuYWdlbWVudC9zZXR1cCBidXR0b24gaWYgTk9UIGZ1bGx5IGNvbmZpZ3VyZWRcblx0XHRpZiAoIWlzRnVsbHlDb25maWd1cmVkKSB7XG5cdFx0XHRnaXRHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnTWFuYWdlIEdpdCBpbnRlZ3JhdGlvbicpXG5cdFx0XHRcdFx0LnNldERlc2MoJ0luaXRpYWxpemUgcmVwb3NpdG9yeSwgY29ubmVjdCB0byBHaXRIdWIsIG9yIHVwZGF0ZSBjcmVkZW50aWFscy4nKVxuXHRcdFx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdFx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdTZXR1cCAvIFVwZGF0ZSBHaXQuLi4nKVxuXHRcdFx0XHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbW9kYWwgPSBuZXcgU2V0dXBXaXphcmRNb2RhbCh0aGlzLmFwcCwgeyBjdXJyZW50U3RlcDogMTEgfSwgdGhpcy5wbHVnaW4pO1xuXHRcdFx0XHRcdFx0XHRcdG1vZGFsLm9wZW4oKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBQcm9qZWN0IG9wdGltaXphdGlvbiBncm91cFxuXHRcdGNvbnN0IG9wdGltaXphdGlvbkdyb3VwID0gY3JlYXRlU2V0dGluZ3NHcm91cCh0aGlzLmNvbnRlbnRFbCwgJ1Byb2plY3Qgb3B0aW1pemF0aW9uIChvcHRpb25hbCknLCAndmF1bHQtY21zLW9wdGltaXphdGlvbicpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgcHJvamVjdCByb290IGlzIGNvbmZpZ3VyZWRcblx0XHRpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290KSB7XG5cdFx0XHRvcHRpbWl6YXRpb25Hcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUHJvamVjdCBub3QgZGV0ZWN0ZWQnKVxuXHRcdFx0XHRcdC5zZXREZXNjKCdDb21wbGV0ZSB0aGUgc2V0dXAgd2l6YXJkIGZpcnN0IHRvIGRldGVjdCB5b3VyIEFzdHJvIHByb2plY3QgYmVmb3JlIGNvbmZpZ3VyaW5nIG9wdGltaXphdGlvbnMuJyk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgb3B0aW1pemVyIGluc3RhbmNlXG5cdFx0Y29uc3Qgd2l6YXJkU3RhdGU6IFdpemFyZFN0YXRlID0ge1xuXHRcdFx0Li4udGhpcy5wbHVnaW4uc2V0dGluZ3MsXG5cdFx0XHRjdXJyZW50U3RlcDogMCxcblx0XHRcdHByb2plY3REZXRlY3Rpb246IHtcblx0XHRcdFx0cHJvamVjdFJvb3Q6IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290LFxuXHRcdFx0XHRjb25maWdGaWxlUGF0aDogdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29uZmlnRmlsZVBhdGgsXG5cdFx0XHRcdHZhdWx0TG9jYXRpb246ICdjb250ZW50J1xuXHRcdFx0fVxuXHRcdH0gYXMgV2l6YXJkU3RhdGU7XG5cblx0XHR0aGlzLm9wdGltaXplciA9IG5ldyBQcm9qZWN0T3B0aW1pemVyKHRoaXMuYXBwLCB3aXphcmRTdGF0ZSk7XG5cdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuZ2V0U3RhdHVzKCk7XG5cblx0XHRvcHRpbWl6YXRpb25Hcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHR0aGlzLmdpdFNldHRpbmcgPSBzZXR0aW5nO1xuXHRcdFx0dGhpcy51cGRhdGVHaXRTZXR0aW5nKHN0YXR1cy5naXRJZ25vcmVTdGF0dXMpO1xuXHRcdH0pO1xuXG5cdFx0b3B0aW1pemF0aW9uR3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0dGhpcy52aXRlU2V0dGluZyA9IHNldHRpbmc7XG5cdFx0XHR0aGlzLnVwZGF0ZVZpdGVTZXR0aW5nKHN0YXR1cy52aXRlSWdub3JlU3RhdHVzKTtcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlR2l0U2V0dGluZyhzdGF0dXM6ICdjb25maWd1cmVkJyB8ICdub3QtY29uZmlndXJlZCcpIHtcblx0XHR0aGlzLmdpdFNldHRpbmcuc2V0TmFtZSgnSWdub3JlIGluIEdpdCcpXG5cdFx0XHQuc2V0RGVzYygnQWRkIHdvcmtzcGFjZSBmaWxlcyB0byBHaXQgaWdub3JlJylcblx0XHRcdC5jbGVhcigpOyAvLyBDbGVhciBleGlzdGluZyBidXR0b25zIGFuZCBzdGF0dXNcblxuXHRcdHRoaXMuZ2l0U2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuY29uZmlndXJlR2l0SWdub3JlKCk7XG5cdFx0XHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVDb25maWcuZ2l0SWdub3JlQ29uZmlndXJlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdHaXQgaWdub3JlIHVwZGF0ZWQnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0NvdWxkIG5vdCBjb25maWd1cmUgR2l0IGlnbm9yZTogcHJvamVjdCByb290IG5vdCBkZXRlY3RlZCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc3QgbmV3U3RhdHVzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuZ2V0U3RhdHVzKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZUdpdFNldHRpbmcobmV3U3RhdHVzLmdpdElnbm9yZVN0YXR1cyk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byB1cGRhdGUgR2l0IGlnbm9yZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9KTtcblx0XHR0aGlzLm9wdGltaXplci5yZW5kZXJTdGF0dXModGhpcy5naXRTZXR0aW5nLmNvbnRyb2xFbCwgc3RhdHVzKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlVml0ZVNldHRpbmcoc3RhdHVzOiAnY29uZmlndXJlZCcgfCAnbm90LWNvbmZpZ3VyZWQnKSB7XG5cdFx0dGhpcy52aXRlU2V0dGluZy5zZXROYW1lKCdJZ25vcmUgaW4gVml0ZScpXG5cdFx0XHQuc2V0RGVzYygnQ29uZmlndXJlIFZpdGUgdG8gaWdub3JlIGludGVybmFsIGZvbGRlcnMnKVxuXHRcdFx0LmNsZWFyKCk7IC8vIENsZWFyIGV4aXN0aW5nIGJ1dHRvbnMgYW5kIHN0YXR1c1xuXG5cdFx0dGhpcy52aXRlU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuY29uZmlndXJlVml0ZUlnbm9yZSgpO1xuXHRcdFx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuaWdub3JlQ29uZmlnLnZpdGVJZ25vcmVDb25maWd1cmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1ZpdGUgb3B0aW1pemF0aW9uIGFwcGxpZWQnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0NvdWxkIG5vdCBjb25maWd1cmUgVml0ZTogcHJvamVjdCByb290IG5vdCBkZXRlY3RlZCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc3QgbmV3U3RhdHVzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuZ2V0U3RhdHVzKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZVZpdGVTZXR0aW5nKG5ld1N0YXR1cy52aXRlSWdub3JlU3RhdHVzKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHVwZGF0ZSBWaXRlIGNvbmZpZzogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9KTtcblx0XHR0aGlzLm9wdGltaXplci5yZW5kZXJTdGF0dXModGhpcy52aXRlU2V0dGluZy5jb250cm9sRWwsIHN0YXR1cyk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vd2l6YXJkL0Jhc2VXaXphcmRTdGVwJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGVNYW5hZ2VyIH0gZnJvbSAnLi93aXphcmQvV2l6YXJkU3RhdGVNYW5hZ2VyJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGVNYWNoaW5lIH0gZnJvbSAnLi93aXphcmQvV2l6YXJkU3RhdGVNYWNoaW5lJztcclxuaW1wb3J0IFZhdWx0Q01TUGx1Z2luIGZyb20gJy4uL21haW4nO1xyXG5pbXBvcnQgeyBXZWxjb21lU3RlcCB9IGZyb20gJy4vd2l6YXJkL1dlbGNvbWVTdGVwJztcclxuaW1wb3J0IHsgUHJvamVjdERldGVjdGlvblN0ZXAgfSBmcm9tICcuL3dpemFyZC9Qcm9qZWN0RGV0ZWN0aW9uU3RlcCc7XHJcbmltcG9ydCB7IENvbnRlbnRUeXBlU3RlcCB9IGZyb20gJy4vd2l6YXJkL0NvbnRlbnRUeXBlU3RlcCc7XHJcbmltcG9ydCB7IERlZmF1bHRDb250ZW50VHlwZVN0ZXAgfSBmcm9tICcuL3dpemFyZC9EZWZhdWx0Q29udGVudFR5cGVTdGVwJztcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzU3RlcCB9IGZyb20gJy4vd2l6YXJkL0Zyb250bWF0dGVyUHJvcGVydGllc1N0ZXAnO1xyXG5pbXBvcnQgeyBFZGl0aW5nVG9vbGJhclN0ZXAgfSBmcm9tICcuL3dpemFyZC9FZGl0aW5nVG9vbGJhclN0ZXAnO1xyXG5pbXBvcnQgeyBCYXNlc0NNU0NvbmZpZ1N0ZXAgfSBmcm9tICcuL3dpemFyZC9CYXNlc0NNU0NvbmZpZ1N0ZXAnO1xyXG5pbXBvcnQgeyBBc3Ryb0NvbXBvc2VyU3RlcCB9IGZyb20gJy4vd2l6YXJkL0FzdHJvQ29tcG9zZXJTdGVwJztcclxuaW1wb3J0IHsgU0VPQ29uZmlnU3RlcCB9IGZyb20gJy4vd2l6YXJkL1NFT0NvbmZpZ1N0ZXAnO1xyXG5pbXBvcnQgeyBPcHRpb25hbFBsdWdpbnNTdGVwIH0gZnJvbSAnLi93aXphcmQvT3B0aW9uYWxQbHVnaW5zU3RlcCc7XHJcbmltcG9ydCB7IElnbm9yZVN0ZXAgfSBmcm9tICcuL3dpemFyZC9JZ25vcmVTdGVwJztcclxuaW1wb3J0IHsgR2l0U2V0dXBTdGVwIH0gZnJvbSAnLi93aXphcmQvR2l0U2V0dXBTdGVwJztcclxuaW1wb3J0IHsgRmluYWxpemVTdGVwIH0gZnJvbSAnLi93aXphcmQvRmluYWxpemVTdGVwJztcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcclxuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcclxuXHRcdGNvbnN0IGNzc0tleSA9IGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShjc3NLZXksIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZXR1cFdpemFyZE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cdHByaXZhdGUgc3RhdGVNYW5hZ2VyOiBXaXphcmRTdGF0ZU1hbmFnZXI7XHJcblx0cHJpdmF0ZSBzdGF0ZU1hY2hpbmU6IFdpemFyZFN0YXRlTWFjaGluZTtcclxuXHRwcml2YXRlIHBsdWdpbjogVmF1bHRDTVNQbHVnaW47XHJcblx0cHJpdmF0ZSBzdGVwczogKG5ldyAoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpID0+IEJhc2VXaXphcmRTdGVwKVtdO1xyXG5cdHByaXZhdGUgY3VycmVudFN0ZXBJbnN0YW5jZTogQmFzZVdpemFyZFN0ZXAgfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIGlzQ29tcGxldGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgaW5pdGlhbFNldHRpbmdzU25hcHNob3Q6IFBhcnRpYWw8V2l6YXJkU3RhdGU+IHwgbnVsbCA9IG51bGw7XHJcblx0cHJpdmF0ZSBsYXN0U2F2ZWRTdGVwSW5kZXg6IG51bWJlciA9IC0xOyAvLyBUcmFjayB0aGUgbGFzdCBzdGVwIHdoZXJlIFwiTmV4dFwiIHdhcyBjbGlja2VkXHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBpbml0aWFsU3RhdGU/OiBQYXJ0aWFsPFdpemFyZFN0YXRlPiwgcGx1Z2luSW5zdGFuY2U/OiBWYXVsdENNU1BsdWdpbikge1xyXG5cdFx0c3VwZXIoYXBwKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luSW5zdGFuY2UgfHwgKGFwcCBhcyB7IHBsdWdpbnM/OiB7IHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBWYXVsdENNU1BsdWdpbj4gfSB9KS5wbHVnaW5zPy5wbHVnaW5zPy5bJ3ZhdWx0LWNtcyddIGFzIFZhdWx0Q01TUGx1Z2luO1xyXG5cclxuXHRcdGlmICghdGhpcy5wbHVnaW4pIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdWYXVsdENNU1BsdWdpbiBpbnN0YW5jZSBpcyByZXF1aXJlZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RhdGVNYW5hZ2VyID0gbmV3IFdpemFyZFN0YXRlTWFuYWdlcih0aGlzLnBsdWdpbik7XHJcblxyXG5cdFx0Ly8gQXBwbHkgYW55IGluaXRpYWwgc3RhdGUgb3ZlcnJpZGVzXHJcblx0XHRpZiAoaW5pdGlhbFN0YXRlKSB7XHJcblx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLnVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnN0ZXBzID0gW1xyXG5cdFx0XHRXZWxjb21lU3RlcCxcclxuXHRcdFx0UHJvamVjdERldGVjdGlvblN0ZXAsXHJcblx0XHRcdENvbnRlbnRUeXBlU3RlcCxcclxuXHRcdFx0RGVmYXVsdENvbnRlbnRUeXBlU3RlcCxcclxuXHRcdFx0RnJvbnRtYXR0ZXJQcm9wZXJ0aWVzU3RlcCxcclxuXHRcdFx0RWRpdGluZ1Rvb2xiYXJTdGVwLFxyXG5cdFx0XHRCYXNlc0NNU0NvbmZpZ1N0ZXAsXHJcblx0XHRcdEFzdHJvQ29tcG9zZXJTdGVwLFxyXG5cdFx0XHRTRU9Db25maWdTdGVwLFxyXG5cdFx0XHRPcHRpb25hbFBsdWdpbnNTdGVwLFxyXG5cdFx0XHRJZ25vcmVTdGVwLFxyXG5cdFx0XHRHaXRTZXR1cFN0ZXAsXHJcblx0XHRcdEZpbmFsaXplU3RlcFxyXG5cdFx0XTtcclxuXHJcblx0XHR0aGlzLnN0YXRlTWFjaGluZSA9IG5ldyBXaXphcmRTdGF0ZU1hY2hpbmUodGhpcy5zdGVwcyk7XHJcblxyXG5cdFx0Y29uc29sZS5kZWJ1ZygnU2V0dXBXaXphcmRNb2RhbDogU3RhdGUgbWFjaGluZSBpbml0aWFsaXplZCAtJywgdGhpcy5zdGF0ZU1hY2hpbmUuZ2V0RGVidWdJbmZvKCkpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgb25PcGVuKCkge1xyXG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHRcdGNvbnRlbnRFbC5hZGRDbGFzcygndmF1bHQtY21zLXdpemFyZCcpO1xyXG5cclxuXHRcdC8vIFJlZnJlc2ggdGhlIHdpemFyZCBzdGF0ZSB3aXRoIGN1cnJlbnQgc2V0dGluZ3NcclxuXHRcdGF3YWl0IHRoaXMuc3RhdGVNYW5hZ2VyLnJlZnJlc2hTdGF0ZSgpO1xyXG5cclxuXHRcdC8vIFN0b3JlIGEgc25hcHNob3Qgb2YgaW5pdGlhbCBzZXR0aW5ncyB0byBkZXRlY3QgY2hhbmdlcyBsYXRlclxyXG5cdFx0dGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdCA9IHRoaXMuY3JlYXRlU2V0dGluZ3NTbmFwc2hvdCgpO1xyXG5cclxuXHRcdC8vIFJlbmRlciBjdXJyZW50IHN0ZXAgKG1heSBiZSBhc3luYywgYnV0IHdlIGRvbid0IGF3YWl0IGl0KVxyXG5cdFx0dm9pZCB0aGlzLnJlbmRlckN1cnJlbnRTdGVwKCk7XHJcblx0fVxyXG5cclxuXHRvbkNsb3NlKCkge1xyXG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHJcblx0XHQvLyBXaGVuIGNsb3NpbmcsIG9ubHkgcHJlc2VydmUgY2hhbmdlcyBmcm9tIHN0ZXBzIHdoZXJlIFwiTmV4dFwiIHdhcyBjbGlja2VkXHJcblx0XHQvLyBEaXNjYXJkIHVuc2F2ZWQgY2hhbmdlcyBmcm9tIHRoZSBjdXJyZW50IHN0ZXAgKGVxdWl2YWxlbnQgdG8gXCJTa2lwXCIpXHJcblx0XHQvLyBUaGUgXCJOZXh0XCIgYnV0dG9uIGFscmVhZHkgc2F2ZWQgdGhvc2Ugc3RlcHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gc2F2ZSBhZ2FpblxyXG5cdFx0Ly8gSnVzdCBjbG9zZSB3aXRob3V0IHNhdmluZyAtIHRoaXMgZGlzY2FyZHMgY3VycmVudCBzdGVwIGNoYW5nZXMgYnV0IHByZXNlcnZlcyBwcmV2aW91cyBcIk5leHRcIiBzYXZlc1xyXG5cclxuXHRcdC8vIFJlc2V0IHRoZSBmbGFnXHJcblx0XHR0aGlzLmlzQ29tcGxldGluZyA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzY3JvbGxUb1RvcCgpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cclxuXHRcdC8vIE1ldGhvZCAxOiBGaW5kIGFuZCBzY3JvbGwgdGhlIGFjdHVhbCBzY3JvbGxhYmxlIHBhcmVudFxyXG5cdFx0bGV0IHNjcm9sbGFibGVQYXJlbnQ6IEhUTUxFbGVtZW50IHwgbnVsbCA9IGNvbnRlbnRFbDtcclxuXHRcdHdoaWxlIChzY3JvbGxhYmxlUGFyZW50ICYmIHNjcm9sbGFibGVQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHRcdFx0Y29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxhYmxlUGFyZW50KTtcclxuXHRcdFx0aWYgKHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsYWJsZVBhcmVudC5jbGllbnRIZWlnaHQgJiZcclxuXHRcdFx0XHQoc3R5bGUub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgc3R5bGUub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyB8fCBzdHlsZS5vdmVyZmxvdyA9PT0gJ2F1dG8nIHx8IHN0eWxlLm92ZXJmbG93ID09PSAnc2Nyb2xsJykpIHtcclxuXHRcdFx0XHRzY3JvbGxhYmxlUGFyZW50LnNjcm9sbFRvcCA9IDA7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0c2Nyb2xsYWJsZVBhcmVudCA9IHNjcm9sbGFibGVQYXJlbnQucGFyZW50RWxlbWVudDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNZXRob2QgMjogVHJ5IGNvbW1vbiBPYnNpZGlhbiBtb2RhbCBjb250YWluZXJzXHJcblx0XHRjb25zdCBtb2RhbENvbnRlbnQgPSBjb250ZW50RWwuY2xvc2VzdCgnLm1vZGFsLWNvbnRlbnQnKTtcclxuXHRcdGlmIChtb2RhbENvbnRlbnQpIHtcclxuXHRcdFx0KG1vZGFsQ29udGVudCBhcyBIVE1MRWxlbWVudCkuc2Nyb2xsVG9wID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtb2RhbENvbnRhaW5lciA9IGNvbnRlbnRFbC5jbG9zZXN0KCcubW9kYWwtY29udGFpbmVyJyk7XHJcblx0XHRpZiAobW9kYWxDb250YWluZXIpIHtcclxuXHRcdFx0KG1vZGFsQ29udGFpbmVyIGFzIEhUTUxFbGVtZW50KS5zY3JvbGxUb3AgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFsc28gdHJ5IGNvbnRlbnRFbCBpdHNlbGZcclxuXHRcdGNvbnRlbnRFbC5zY3JvbGxUb3AgPSAwO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyByZW5kZXJDdXJyZW50U3RlcCgpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cclxuXHRcdC8vIFNjcm9sbCB0byB0b3AgSU1NRURJQVRFTFkgYmVmb3JlIGNsZWFyaW5nIGNvbnRlbnQgdG8gcHJldmVudCB2aXN1YWwganVtcFxyXG5cdFx0dGhpcy5zY3JvbGxUb1RvcCgpO1xyXG5cclxuXHRcdC8vIENsZWFyIGNvbnRlbnRcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdFx0Y29udGVudEVsLmFkZENsYXNzKCd2YXVsdC1jbXMtd2l6YXJkJyk7XHJcblxyXG5cdFx0Ly8gU2Nyb2xsIHRvIHRvcCBhZ2FpbiBhZnRlciBjbGVhcmluZyAoaW4gY2FzZSBjbGVhcmluZyBjaGFuZ2VkIHNjcm9sbCBwb3NpdGlvbilcclxuXHRcdHRoaXMuc2Nyb2xsVG9Ub3AoKTtcclxuXHJcblx0XHQvLyBSZW5kZXIgcHJvZ3Jlc3NcclxuXHRcdHRoaXMucmVuZGVyUHJvZ3Jlc3MoY29udGVudEVsKTtcclxuXHJcblx0XHQvLyBSZW5kZXIgc3RlcCBjb250ZW50IChtYXkgYmUgYXN5bmMsIGJ1dCB3ZSBkb24ndCBhd2FpdCBpdClcclxuXHRcdGNvbnN0IHN0ZXBDb250ZW50ID0gY29udGVudEVsLmNyZWF0ZURpdignd2l6YXJkLWNvbnRlbnQnKTtcclxuXHRcdGF3YWl0IHRoaXMucmVuZGVyU3RlcENvbnRlbnQoc3RlcENvbnRlbnQpO1xyXG5cclxuXHRcdC8vIFJlbmRlciBmb290ZXJcclxuXHRcdHRoaXMucmVuZGVyRm9vdGVyKGNvbnRlbnRFbCk7XHJcblxyXG5cdFx0Ly8gRmluYWwgc2Nyb2xsIHRvIHRvcCBhZnRlciBhbGwgcmVuZGVyaW5nIGlzIGNvbXBsZXRlXHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG5cdFx0XHR0aGlzLnNjcm9sbFRvVG9wKCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVuZGVyUHJvZ3Jlc3MoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xyXG5cdFx0XHRjb25zdCB0b3RhbFN0ZXBzID0gdGhpcy5zdGVwcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIXN0YXRlIHx8ICF0aGlzLnN0YXRlTWFjaGluZSkge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1NldHVwV2l6YXJkTW9kYWw6IHN0YXRlIG9yIHN0YXRlTWFjaGluZSBpcyBtaXNzaW5nIGluIHJlbmRlclByb2dyZXNzJyk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmVzcyA9IGNvbnRhaW5lci5jcmVhdGVEaXYoJ3dpemFyZC1wcm9ncmVzcycpO1xyXG5cclxuXHRcdFx0Ly8gU3luY2hyb25pemUgc3RhdGUgbWFjaGluZSB3aXRoIGN1cnJlbnQgc3RhdGUgaW5kZXhcclxuXHRcdFx0dGhpcy5zdGF0ZU1hY2hpbmUuanVtcFRvU3RlcChzdGF0ZS5jdXJyZW50U3RlcCk7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmVzc0JhciA9IHByb2dyZXNzLmNyZWF0ZURpdigncHJvZ3Jlc3MtYmFyJyk7XHJcblx0XHRcdGNvbnN0IHByb2dyZXNzRmlsbCA9IHByb2dyZXNzQmFyLmNyZWF0ZURpdigncHJvZ3Jlc3MtZmlsbCcpO1xyXG5cclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHByb2dyZXNzIHBlcmNlbnRhZ2U6IChTdGVwIFggb2YgWSkgLT4gKChjdXJyZW50U3RlcCArIDEpIC8gdG90YWxTdGVwcykgKiAxMDBcclxuXHRcdFx0Ly8gVGhpcyBtYXRjaGVzIHRoZSByZWZlcmVuY2UgcHJvamVjdCdzIGxvZ2ljIHdoZXJlIFN0ZXAgMSBzaG93cyBwcm9ncmVzc1xyXG5cdFx0XHRjb25zdCBwcm9ncmVzc1BlcmNlbnQgPSAoKHN0YXRlLmN1cnJlbnRTdGVwICsgMSkgLyB0b3RhbFN0ZXBzKSAqIDEwMDtcclxuXHJcblx0XHRcdC8vIERpcmVjdCBzdHlsZSBhcHBsaWNhdGlvbiAobW9zdCByZWxpYWJsZSB3aXRoIHRoZSBuZXcgQ1NTKVxyXG5cdFx0XHRwcm9ncmVzc0ZpbGwuc3R5bGUud2lkdGggPSBgJHtwcm9ncmVzc1BlcmNlbnR9JWA7XHJcblxyXG5cdFx0XHQvLyBBZGQgc3RlcCB0ZXh0IGJlbG93IHRoZSBwcm9ncmVzcyBiYXIgd2l0aCBzdGF0ZSBpbmZvcm1hdGlvblxyXG5cdFx0XHRjb25zdCBwcm9ncmVzc1RleHQgPSBwcm9ncmVzcy5jcmVhdGVEaXYoJ3Byb2dyZXNzLXRleHQnKTtcclxuXHRcdFx0cHJvZ3Jlc3NUZXh0LnRleHRDb250ZW50ID0gYFN0ZXAgJHtzdGF0ZS5jdXJyZW50U3RlcCArIDF9IG9mICR7dG90YWxTdGVwc30gLSAke3RoaXMuc3RhdGVNYWNoaW5lLmdldFN0YXRlRGVzY3JpcHRpb24oKX1gO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignU2V0dXBXaXphcmRNb2RhbDogRXJyb3IgcmVuZGVyaW5nIHByb2dyZXNzIGJhcjonLCBlcnJvcik7XHJcblx0XHRcdC8vIERvbid0IHRocm93IC0gYWxsb3cgdGhlIHJlc3Qgb2YgdGhlIHdpemFyZCB0byByZW5kZXIgaWYgcG9zc2libGVcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgcmVuZGVyU3RlcENvbnRlbnQoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xyXG5cdFx0Y29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xyXG5cdFx0Y29uc3Qgc3RlcEluZGV4ID0gc3RhdGUuY3VycmVudFN0ZXA7XHJcblxyXG5cdFx0aWYgKHN0ZXBJbmRleCA+PSAwICYmIHN0ZXBJbmRleCA8IHRoaXMuc3RlcHMubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IFN0ZXBDbGFzcyA9IHRoaXMuc3RlcHNbc3RlcEluZGV4XTtcclxuXHRcdFx0Y29uc3Qgc3RlcE5hbWUgPSBTdGVwQ2xhc3MubmFtZSB8fCAnVW5rbm93bic7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoXHJcblx0XHRcdFx0YFNldHVwV2l6YXJkTW9kYWw6IERpc3BsYXlpbmcgc3RlcCAke3N0ZXBJbmRleCArIDF9LyR7dGhpcy5zdGVwcy5sZW5ndGh9OiAke3N0ZXBOYW1lfWAsXHJcblx0XHRcdFx0YFske3RoaXMuc3RhdGVNYWNoaW5lLmdldERlYnVnSW5mbygpfV1gXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UgPSBuZXcgU3RlcENsYXNzKFxyXG5cdFx0XHRcdHRoaXMuYXBwLFxyXG5cdFx0XHRcdGNvbnRhaW5lcixcclxuXHRcdFx0XHRzdGF0ZSxcclxuXHRcdFx0XHQoKSA9PiB7XHJcblx0XHRcdFx0XHQvLyBOZXh0IGhhbmRsZXIgLSBzYXZlIGFuZCBhZHZhbmNlXHJcblx0XHRcdFx0XHR2b2lkIChhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UgJiYgdGhpcy5jdXJyZW50U3RlcEluc3RhbmNlLnZhbGlkYXRlKCkpIHtcclxuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDdXJyZW50U3RlcFRvV2l6YXJkU3RhdGUoKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlTWFuYWdlci5uZXh0U3RlcCh0aGlzLnN0ZXBzLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZU1hY2hpbmUubmV4dCgpO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1NldHVwV2l6YXJkTW9kYWw6IEFkdmFuY2VkIHRvIG5leHQgc3RlcCAtJywgdGhpcy5zdGF0ZU1hY2hpbmUuZ2V0RGVidWdJbmZvKCkpO1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucmVuZGVyQ3VycmVudFN0ZXAoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSkoKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdCgpID0+IHtcclxuXHRcdFx0XHRcdC8vIEJhY2sgaGFuZGxlciAtIGRpc2NhcmQgYW5kIGdvIGJhY2tcclxuXHRcdFx0XHRcdHRoaXMuZGlzY2FyZEN1cnJlbnRTdGVwQ2hhbmdlcygpO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIucHJldmlvdXNTdGVwKCk7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlTWFjaGluZS5wcmV2aW91cygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnU2V0dXBXaXphcmRNb2RhbDogV2VudCBiYWNrIHRvIHByZXZpb3VzIHN0ZXAgLScsIHRoaXMuc3RhdGVNYWNoaW5lLmdldERlYnVnSW5mbygpKTtcclxuXHRcdFx0XHRcdHZvaWQgdGhpcy5yZW5kZXJDdXJyZW50U3RlcCgpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0KCkgPT4gdGhpcy5jbG9zZSgpXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHQvLyBBd2FpdCBkaXNwbGF5KCkgc2luY2UgaXQgbWF5IGJlIGFzeW5jXHJcblx0XHRcdGF3YWl0IHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZS5kaXNwbGF5KCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlbmRlckZvb3Rlcihjb250YWluZXI6IEhUTUxFbGVtZW50KSB7XHJcblx0XHRjb25zdCBmb290ZXIgPSBjb250YWluZXIuY3JlYXRlRGl2KCd3aXphcmQtZm9vdGVyJyk7XHJcblx0XHRzZXRDc3NQcm9wcyhmb290ZXIsIHsgZGlzcGxheTogJ2ZsZXgnLCBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9KTtcclxuXHJcblx0XHQvLyBTdGFydHVwIHNldHRpbmcgY2hlY2tib3ggKG9ubHkgb24gdGhlIGZpcnN0IHN0ZXApXHJcblx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5jdXJyZW50U3RlcCA9PT0gMCkge1xyXG5cdFx0XHRjb25zdCBzdGFydHVwU2V0dGluZyA9IGZvb3Rlci5jcmVhdGVEaXYoJ3dpemFyZC1zdGFydHVwLXNldHRpbmctZm9vdGVyJyk7XHJcblx0XHRcdGNvbnN0IGxhYmVsID0gc3RhcnR1cFNldHRpbmcuY3JlYXRlRWwoJ2xhYmVsJywgeyBjbHM6ICd3aXphcmQtY2hlY2tib3gtbGFiZWwnIH0pO1xyXG5cdFx0XHQvLyBFbnN1cmUgY3Vyc29yIGlzIGRlZmF1bHQgd2hlbiBob3ZlcmluZyBvdmVyIHRoZSBsYWJlbC9jaGVja2JveFxyXG5cdFx0XHRzZXRDc3NQcm9wcyhsYWJlbCwgeyBjdXJzb3I6ICdkZWZhdWx0JyB9KTtcclxuXHRcdFx0Y29uc3QgY2hlY2tib3ggPSBsYWJlbC5jcmVhdGVFbCgnaW5wdXQnLCB7IHR5cGU6ICdjaGVja2JveCcgfSk7XHJcblx0XHRcdHNldENzc1Byb3BzKGNoZWNrYm94LCB7IGN1cnNvcjogJ2RlZmF1bHQnIH0pO1xyXG5cdFx0XHRjaGVja2JveC5jaGVja2VkID0gIXRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cDtcclxuXHRcdFx0bGFiZWwuY3JlYXRlU3Bhbih7IHRleHQ6IFwiIEkndmUgYWxyZWFkeSBzZXQgdXAgbXkgdmF1bHQsIGRvbid0IHNob3cgb24gc3RhcnR1cFwiIH0pO1xyXG5cclxuXHRcdFx0Y2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xyXG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCA9ICFjaGVja2JveC5jaGVja2VkO1xyXG5cdFx0XHRcdHZvaWQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gRW1wdHkgZGl2IHRvIGtlZXAgYnV0dG9ucyBwdXNoZWQgdG8gdGhlIHJpZ2h0XHJcblx0XHRcdGZvb3Rlci5jcmVhdGVEaXYoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBidXR0b25zID0gZm9vdGVyLmNyZWF0ZURpdignd2l6YXJkLWJ1dHRvbnMnKTtcclxuXHRcdHNldENzc1Byb3BzKGJ1dHRvbnMsIHsgZGlzcGxheTogJ2ZsZXgnLCBnYXA6ICcxMHB4JyB9KTtcclxuXHJcblx0XHQvLyBQcmV2aW91cyBidXR0b25cclxuXHRcdGlmICh0aGlzLnN0YXRlTWFuYWdlci5jYW5Hb1ByZXZpb3VzKCkpIHtcclxuXHRcdFx0Y29uc3QgcHJldkJ0biA9IGJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuXHRcdFx0XHR0ZXh0OiAnUHJldmlvdXMnLFxyXG5cdFx0XHRcdGNsczogJ21vZC1idXR0b24nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRwcmV2QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHRcdC8vIERpc2NhcmQgYW55IGNoYW5nZXMgbWFkZSBvbiBjdXJyZW50IHN0ZXAgYW5kIGdvIGJhY2tcclxuXHRcdFx0XHR0aGlzLmRpc2NhcmRDdXJyZW50U3RlcENoYW5nZXMoKTtcclxuXHRcdFx0XHR0aGlzLnN0YXRlTWFuYWdlci5wcmV2aW91c1N0ZXAoKTtcclxuXHRcdFx0XHR2b2lkIHRoaXMucmVuZGVyQ3VycmVudFN0ZXAoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTmV4dC9Db21wbGV0ZSBidXR0b25cclxuXHRcdGlmICh0aGlzLnN0YXRlTWFuYWdlci5jYW5Hb05leHQodGhpcy5zdGVwcy5sZW5ndGgpKSB7XHJcblx0XHRcdC8vIERvbid0IHNob3cgXCJOZXh0XCIgYnV0dG9uIG9uIHRoZSBmaXJzdCBzdGVwIChXZWxjb21lU3RlcClcclxuXHRcdFx0Ly8gT1IgaWYgdGhlIHN0ZXAgZXhwbGljaXRseSBoaWRlcyBpdCAoZS5nLiBHaXRTZXR1cFN0ZXApXHJcblx0XHRcdGlmICh0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpLmN1cnJlbnRTdGVwICE9PSAwICYmIHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZT8uc2hvd05leHRCdXR0b24gIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0Y29uc3QgbmV4dEJ0biA9IGJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuXHRcdFx0XHRcdHRleHQ6ICdOZXh0JyxcclxuXHRcdFx0XHRcdGNsczogJ21vZC1idXR0b24gbW9kLWN0YSdcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRuZXh0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gU2F2ZSBjdXJyZW50IHN0ZXAgY2hhbmdlcyB0byB3aXphcmQgc3RhdGUgYW5kIGRhdGEuanNvblxyXG5cdFx0XHRcdFx0dm9pZCAoYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jdXJyZW50U3RlcEluc3RhbmNlICYmIHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZS52YWxpZGF0ZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ3VycmVudFN0ZXBUb1dpemFyZFN0YXRlKCk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gVHJhY2sgdGhhdCB0aGlzIHN0ZXAgd2FzIHNhdmVkXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5sYXN0U2F2ZWRTdGVwSW5kZXggPSB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpLmN1cnJlbnRTdGVwO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLm5leHRTdGVwKHRoaXMuc3RlcHMubGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlbmRlckN1cnJlbnRTdGVwKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEZpbmFsIHN0ZXAgLSBwcm92aWRlIEFwcGx5IGFuZCBBcHBseSBhbmQgcmVzdGFydCBvcHRpb25zXHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UgaW5zdGFuY2VvZiBGaW5hbGl6ZVN0ZXApIHtcclxuXHRcdFx0XHRjb25zdCBhcHBseUJ0biA9IGJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuXHRcdFx0XHRcdHRleHQ6ICdBcHBseScsXHJcblx0XHRcdFx0XHRjbHM6ICdtb2QtYnV0dG9uJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGFwcGx5QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHRcdFx0dm9pZCB0aGlzLmhhbmRsZUNvbXBsZXRlKGZhbHNlKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXBwbHlSZXN0YXJ0QnRuID0gYnV0dG9ucy5jcmVhdGVFbCgnYnV0dG9uJywge1xyXG5cdFx0XHRcdFx0dGV4dDogJ0FwcGx5IGFuZCByZXN0YXJ0JyxcclxuXHRcdFx0XHRcdGNsczogJ21vZC1idXR0b24gbW9kLWN0YSdcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRhcHBseVJlc3RhcnRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdFx0XHR2b2lkIHRoaXMuaGFuZGxlQ29tcGxldGUodHJ1ZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gRmFsbGJhY2sgZm9yIG90aGVyIHN0ZXBzIHRoYXQgbWlnaHQgYmUgdGhlIGxhc3Qgc3RlcFxyXG5cdFx0XHRcdGNvbnN0IGNvbXBsZXRlQnRuID0gYnV0dG9ucy5jcmVhdGVFbCgnYnV0dG9uJywge1xyXG5cdFx0XHRcdFx0dGV4dDogJ0NvbXBsZXRlIHNldHVwJyxcclxuXHRcdFx0XHRcdGNsczogJ21vZC1idXR0b24gbW9kLWN0YSdcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRjb21wbGV0ZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHRcdHZvaWQgdGhpcy5oYW5kbGVDb21wbGV0ZShmYWxzZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTa2lwIGJ1dHRvbiAoZm9yIGFsbCBzdGVwcyBleGNlcHQgdGhlIGxhc3QpXHJcblx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuY2FuR29OZXh0KHRoaXMuc3RlcHMubGVuZ3RoKSkge1xyXG5cdFx0XHQvLyBEb24ndCBzaG93IFwiU2tpcFwiIGJ1dHRvbiBvbiB0aGUgZmlyc3Qgc3RlcCAoV2VsY29tZVN0ZXApXHJcblx0XHRcdGlmICh0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpLmN1cnJlbnRTdGVwICE9PSAwKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2tpcEJ0biA9IGJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuXHRcdFx0XHRcdHRleHQ6ICdTa2lwJyxcclxuXHRcdFx0XHRcdGNsczogJ21vZC1idXR0b24nXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0c2tpcEJ0bi5hZGRDbGFzcygnd2l6YXJkLXNraXAtYnV0dG9uJyk7XHJcblx0XHRcdFx0c2V0Q3NzUHJvcHMoc2tpcEJ0biwgeyBvcGFjaXR5OiAnMC42JyB9KTtcclxuXHRcdFx0XHRza2lwQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gU2tpcCB3aXRob3V0IHNhdmluZyBjdXJyZW50IHN0ZXAgY2hhbmdlcyB0byB3aXphcmQgc3RhdGVcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLm5leHRTdGVwKHRoaXMuc3RlcHMubGVuZ3RoKTtcclxuXHRcdFx0XHRcdHZvaWQgdGhpcy5yZW5kZXJDdXJyZW50U3RlcCgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIGhhbmRsZUNvbXBsZXRlKHNob3VsZFJlc3RhcnQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGlmICh0aGlzLmlzQ29tcGxldGluZykgcmV0dXJuO1xyXG5cdFx0dGhpcy5pc0NvbXBsZXRpbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UgJiYgdGhpcy5jdXJyZW50U3RlcEluc3RhbmNlLnZhbGlkYXRlKCkpIHtcclxuXHRcdFx0XHQvLyBJZiB3ZSdyZSBvbiBGaW5hbGl6ZVN0ZXAsIGFwcGx5IGNvbmZpZ3VyYXRpb24gZmlyc3RcclxuXHRcdFx0XHRpZiAodGhpcy5jdXJyZW50U3RlcEluc3RhbmNlIGluc3RhbmNlb2YgRmluYWxpemVTdGVwKSB7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UuYXBwbHlDb25maWd1cmF0aW9uKHNob3VsZFJlc3RhcnQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBGb3Igb3RoZXIgc3RlcHMsIGp1c3Qgc2F2ZSB0aGUgY3VycmVudCBzdGVwXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDdXJyZW50U3RlcFRvV2l6YXJkU3RhdGUoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIE1hcmsgd2l6YXJkIGFzIGNvbXBsZXRlZCBhbmQgZGlzYWJsZSBzdGFydHVwIHRyaWdnZXJcclxuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy53aXphcmRDb21wbGV0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCA9IGZhbHNlO1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuXHRcdFx0XHQvLyBDUklUSUNBTDogUmVsb2FkIHNldHRpbmdzIGZyb20gZGlzayB0byBlbnN1cmUgZXZlcnl0aGluZyBpcyBzeW5jaHJvbml6ZWRcclxuXHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5sb2FkU2V0dGluZ3MoKTtcclxuXHJcblx0XHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBUcmlnZ2VyIHJlc3RhcnQgaWYgcmVxdWVzdGVkXHJcblx0XHRcdFx0aWYgKHNob3VsZFJlc3RhcnQpIHtcclxuXHRcdFx0XHRcdC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBOb3RpY2UgaXMgdmlzaWJsZSBhbmQgc2V0dGluZ3MgYXJlIHNhdmVkXHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0XHRcdFx0aW50ZXJmYWNlIEFwcFdpdGhDb21tYW5kcyBleHRlbmRzIEFwcCB7XHJcblx0XHRcdFx0XHRcdFx0Y29tbWFuZHM6IHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4ZWN1dGVDb21tYW5kQnlJZChpZDogc3RyaW5nKTogdm9pZDtcclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdCh0aGlzLmFwcCBhcyB1bmtub3duIGFzIEFwcFdpdGhDb21tYW5kcykuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmRCeUlkKCdhcHA6cmVsb2FkJyk7XHJcblx0XHRcdFx0XHR9LCAxMDAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXBsZXRpbmcgd2l6YXJkOicsIGVycm9yKTtcclxuXHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNvbXBsZXRlIHNldHVwLiBQbGVhc2UgY2hlY2sgdGhlIGNvbnNvbGUgZm9yIGRldGFpbHMuJyk7XHJcblx0XHR9IGZpbmFsbHkge1xyXG5cdFx0XHR0aGlzLmlzQ29tcGxldGluZyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ3VycmVudFN0ZXBUb1dpemFyZFN0YXRlKCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Ly8gU2F2ZSBjdXJyZW50IHN0ZXAgY2hhbmdlcyB0byB3aXphcmQgc3RhdGUgYW5kIGRhdGEuanNvblxyXG5cdFx0Ly8gVGhpcyBpcyBjYWxsZWQgd2hlbiBORVhUIGlzIGNsaWNrZWQgdG8gZW5zdXJlIGRhdGEuanNvbiBzdGF5cyBpbiBzeW5jXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBCdWlsZCBmaW5hbCBzZXR0aW5ncyBmcm9tIHdpemFyZCBzdGF0ZSAodXBkYXRlcyBwbHVnaW4uc2V0dGluZ3MpXHJcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGVNYW5hZ2VyLmJ1aWxkRmluYWxTZXR0aW5ncygpO1xyXG5cclxuXHRcdFx0Ly8gU2F2ZSB0byBkYXRhLmpzb25cclxuXHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblxyXG5cdFx0XHQvLyBSZWxvYWQgc2V0dGluZ3MgdG8gZW5zdXJlIHRoZSBwbHVnaW4gaGFzIHRoZSBsYXRlc3QgdmFsdWVzXHJcblx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLmxvYWRTZXR0aW5ncygpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGN1cnJlbnQgc3RlcCB0byBkYXRhLmpzb246JywgZXJyb3IpO1xyXG5cdFx0XHQvLyBEb24ndCBzaG93IGVycm9yIHRvIHVzZXIgLSBqdXN0IGxvZyBpdCwgYXMgdGhpcyBzaG91bGRuJ3QgYmxvY2sgbmF2aWdhdGlvblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBkaXNjYXJkQ3VycmVudFN0ZXBDaGFuZ2VzKCk6IHZvaWQge1xyXG5cdFx0Ly8gRGlzY2FyZCBjaGFuZ2VzIG1hZGUgb24gY3VycmVudCBzdGVwIC0gdGhpcyBpcyBjYWxsZWQgd2hlbiBQUkVWSU9VUyBpcyBjbGlja2VkXHJcblx0XHQvLyBSZWZyZXNoIHRoZSB3aXphcmQgc3RhdGUgdG8gc2hvdyBvcmlnaW5hbCB2YWx1ZXMgZnJvbSBkYXRhLmpzb25cclxuXHRcdHZvaWQgdGhpcy5zdGF0ZU1hbmFnZXIucmVmcmVzaFN0YXRlKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHNhdmVXaXphcmRTdGF0ZVRvRGF0YUpzb24oc2hvd05vdGlmaWNhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdC8vIFNhdmUgd2l6YXJkIHN0YXRlIGNoYW5nZXMgdG8gZGF0YS5qc29uIHdoZW4gbW9kYWwgaXMgY2xvc2VkXHJcblx0XHQvLyBUaGlzIGVuc3VyZXMgY2hhbmdlcyBhcmUgcHJlc2VydmVkIGV2ZW4gaWYgdXNlciBjbG9zZXMgbW9kYWwgd2l0aG91dCBjb21wbGV0aW5nIHdpemFyZFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gQnVpbGQgZmluYWwgc2V0dGluZ3MgZnJvbSB3aXphcmQgc3RhdGVcclxuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZU1hbmFnZXIuYnVpbGRGaW5hbFNldHRpbmdzKCk7XHJcblxyXG5cdFx0XHQvLyBDaGVjayBpZiBhbnkgY2hhbmdlcyB3ZXJlIGFjdHVhbGx5IG1hZGVcclxuXHRcdFx0Y29uc3QgaGFzQ2hhbmdlcyA9IHRoaXMuaGFzU2V0dGluZ3NDaGFuZ2VkKCk7XHJcblxyXG5cdFx0XHQvLyBPbmx5IHNhdmUgdG8gZGF0YS5qc29uIGlmIHRoZXJlIHdlcmUgYWN0dWFsIGNoYW5nZXNcclxuXHRcdFx0aWYgKCFoYXNDaGFuZ2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuOyAvLyBObyBjaGFuZ2VzLCBkb24ndCBzYXZlIGFueXRoaW5nXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNhdmUgdG8gZGF0YS5qc29uXHJcblx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuXHRcdFx0Ly8gUmVsb2FkIHNldHRpbmdzIHRvIGVuc3VyZSB0aGUgcGx1Z2luIGhhcyB0aGUgbGF0ZXN0IHZhbHVlc1xyXG5cdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5sb2FkU2V0dGluZ3MoKTtcclxuXHJcblx0XHRcdC8vIE9ubHkgc2hvdyBub3RpZmljYXRpb24gaWYgcmVxdWVzdGVkXHJcblx0XHRcdGlmIChzaG93Tm90aWZpY2F0aW9uKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZSgnQ29uZmlndXJhdGlvbiBzYXZlZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgd2l6YXJkIHN0YXRlIHRvIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdGlmIChzaG93Tm90aWZpY2F0aW9uKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHNhdmUgY29uZmlndXJhdGlvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgY3JlYXRlU2V0dGluZ3NTbmFwc2hvdCgpOiBQYXJ0aWFsPFdpemFyZFN0YXRlPiB7XHJcblx0XHQvLyBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgY3VycmVudCBzdGF0ZSBmb3IgY29tcGFyaXNvblxyXG5cdFx0Y29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xyXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuIC0tIEpTT04ucGFyc2UgcmV0dXJucyBhbnkgdHlwZVxyXG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoe1xyXG5cdFx0XHRwcm9qZWN0RGV0ZWN0aW9uOiBzdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLFxyXG5cdFx0XHRjb250ZW50VHlwZXM6IHN0YXRlLmNvbnRlbnRUeXBlcyxcclxuXHRcdFx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiBzdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXMsXHJcblx0XHRcdGRlZmF1bHRDb250ZW50VHlwZUlkOiBzdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCxcclxuXHRcdFx0cHJlc2V0OiBzdGF0ZS5wcmVzZXQsXHJcblx0XHRcdGVuYWJsZUVkaXRpbmdUb29sYmFyOiBzdGF0ZS5lbmFibGVFZGl0aW5nVG9vbGJhcixcclxuXHRcdFx0ZW5hYmxlZFBsdWdpbnM6IHN0YXRlLmVuYWJsZWRQbHVnaW5zLFxyXG5cdFx0XHRkaXNhYmxlZFBsdWdpbnM6IHN0YXRlLmRpc2FibGVkUGx1Z2lucyxcclxuXHRcdFx0dGhlbWU6IHN0YXRlLnRoZW1lLFxyXG5cdFx0XHRiYXNlc0NNU0NvbmZpZzogc3RhdGUuYmFzZXNDTVNDb25maWcsXHJcblx0XHRcdGFzdHJvQ29tcG9zZXJDb25maWc6IHN0YXRlLmFzdHJvQ29tcG9zZXJDb25maWcsXHJcblx0XHRcdHNlb0NvbmZpZzogc3RhdGUuc2VvQ29uZmlnLFxyXG5cdFx0XHRwcm9wZXJ0eU92ZXJGaWxlTmFtZTogc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUsXHJcblx0XHRcdGltYWdlTWFuYWdlcjogc3RhdGUuaW1hZ2VNYW5hZ2VyLFxyXG5cdFx0XHRob21lQmFzZTogc3RhdGUuaG9tZUJhc2VcclxuXHRcdH0pKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgaGFzU2V0dGluZ3NDaGFuZ2VkKCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKCF0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90KSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjdXJyZW50U25hcHNob3QgPSB0aGlzLmNyZWF0ZVNldHRpbmdzU25hcHNob3QoKTtcclxuXHJcblx0XHQvLyBDb21wYXJlIGtleSBzZXR0aW5ncyB0aGF0IGNhbiBiZSBjaGFuZ2VkIGluIHRoZSB3aXphcmRcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5wcm9qZWN0RGV0ZWN0aW9uKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5wcm9qZWN0RGV0ZWN0aW9uKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuY29udGVudFR5cGVzKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5jb250ZW50VHlwZXMpIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5mcm9udG1hdHRlclByb3BlcnRpZXMpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmZyb250bWF0dGVyUHJvcGVydGllcykgfHxcclxuXHRcdFx0Y3VycmVudFNuYXBzaG90LmRlZmF1bHRDb250ZW50VHlwZUlkICE9PSB0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmRlZmF1bHRDb250ZW50VHlwZUlkIHx8XHJcblx0XHRcdGN1cnJlbnRTbmFwc2hvdC5wcmVzZXQgIT09IHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QucHJlc2V0IHx8XHJcblx0XHRcdGN1cnJlbnRTbmFwc2hvdC5lbmFibGVFZGl0aW5nVG9vbGJhciAhPT0gdGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5lbmFibGVFZGl0aW5nVG9vbGJhciB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuZW5hYmxlZFBsdWdpbnMpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmVuYWJsZWRQbHVnaW5zKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuZGlzYWJsZWRQbHVnaW5zKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5kaXNhYmxlZFBsdWdpbnMpIHx8XHJcblx0XHRcdGN1cnJlbnRTbmFwc2hvdC50aGVtZSAhPT0gdGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC50aGVtZSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuYmFzZXNDTVNDb25maWcpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmJhc2VzQ01TQ29uZmlnKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuYXN0cm9Db21wb3NlckNvbmZpZykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuYXN0cm9Db21wb3NlckNvbmZpZykgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LnNlb0NvbmZpZykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3Quc2VvQ29uZmlnKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QucHJvcGVydHlPdmVyRmlsZU5hbWUpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LnByb3BlcnR5T3ZlckZpbGVOYW1lKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuaW1hZ2VNYW5hZ2VyKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5pbWFnZU1hbmFnZXIpIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5ob21lQmFzZSkgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuaG9tZUJhc2UpXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0Z2V0U3RhdGUoKTogV2l6YXJkU3RhdGUge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XHJcblx0fVxyXG5cclxuXHQvLyBDYWxsYmFjayB0byBzYXZlIHN0YXRlIHRvIHBsdWdpbiBzZXR0aW5ncyAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcclxuXHRzZXRTYXZlQ2FsbGJhY2soY2FsbGJhY2s6IChzdGF0ZTogV2l6YXJkU3RhdGUpID0+IFByb21pc2U8dm9pZD4pIHtcclxuXHRcdC8vIFRoaXMgaXMgbm93IGhhbmRsZWQgYnkgc2F2ZUN1cnJlbnRTdGVwVG9XaXphcmRTdGF0ZSBhbmQgc2F2ZVdpemFyZFN0YXRlVG9EYXRhSnNvblxyXG5cdFx0Ly8gQnV0IHdlIGtlZXAgdGhlIG1ldGhvZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5cdFx0Y29uc29sZS53YXJuKCdzZXRTYXZlQ2FsbGJhY2sgaXMgZGVwcmVjYXRlZCAtIHN0YXRlIGlzIG5vdyBtYW5hZ2VkIGF1dG9tYXRpY2FsbHknKTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IEltYWdlTWFuYWdlckNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbnR5cGUgSW1hZ2VNYW5hZ2VyUGx1Z2luID0ge1xyXG5cdHNldHRpbmdzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcblx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufTtcclxuXHJcbnR5cGUgUGx1Z2luc0FQSSA9IHtcclxuXHRwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgSW1hZ2VNYW5hZ2VyUGx1Z2luPjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRDb25maWcoKTogUHJvbWlzZTxJbWFnZU1hbmFnZXJDb25maWc+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ2ltYWdlLW1hbmFnZXInO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIFRyeSB0byB1c2UgcGx1Z2luJ3Mgc2V0dGluZ3MgQVBJIGZpcnN0XHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBpbWFnZU1hbmFnZXJQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cclxuXHRcdFx0aWYgKGltYWdlTWFuYWdlclBsdWdpbiAmJiBpbWFnZU1hbmFnZXJQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHQvLyBSZXR1cm4gcGx1Z2luIHNldHRpbmdzIGFzIGNvbmZpZ1xyXG5cdFx0XHRcdHJldHVybiBpbWFnZU1hbmFnZXJQbHVnaW4uc2V0dGluZ3MgYXMgSW1hZ2VNYW5hZ2VyQ29uZmlnO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEltYWdlIE1hbmFnZXIgY29uZmlnIGZyb20gcGx1Z2luIEFQSTonLCBlcnJvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdHJldHVybiBhd2FpdCB0aGlzLmxvYWRDb25maWdGYWxsYmFjaygpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBsb2FkQ29uZmlnRmFsbGJhY2soKTogUHJvbWlzZTxJbWFnZU1hbmFnZXJDb25maWc+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ2ltYWdlLW1hbmFnZXInO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHJcblx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblxyXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZ0RhdGEgYXMgSW1hZ2VNYW5hZ2VyQ29uZmlnO1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIEltYWdlIE1hbmFnZXIgZGF0YS5qc29uOicsIGVycm9yKTtcclxuXHRcdFx0XHRyZXR1cm4ge307XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge307XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlQ29uZmlnKGNvbmZpZzogSW1hZ2VNYW5hZ2VyQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbWFnZS1tYW5hZ2VyJztcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2QgZmlyc3QgKGxpa2UgQXN0cm8gQ29tcG9zZXIpXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBpbWFnZU1hbmFnZXJQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cclxuXHRcdFx0aWYgKGltYWdlTWFuYWdlclBsdWdpbiAmJiBpbWFnZU1hbmFnZXJQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHQvLyBVcGRhdGUgdmlhIHBsdWdpbiBzZXR0aW5ncyBBUEkgKG1hdGNoaW5nIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgcGF0dGVybilcclxuXHRcdFx0XHRjb25zdCBwbHVnaW5TZXR0aW5ncyA9IGltYWdlTWFuYWdlclBsdWdpbi5zZXR0aW5ncztcclxuXHJcblx0XHRcdFx0Ly8gTWVyZ2UgY29uZmlnIGludG8gcGx1Z2luIHNldHRpbmdzXHJcblx0XHRcdFx0T2JqZWN0LmFzc2lnbihwbHVnaW5TZXR0aW5ncywgY29uZmlnKTtcclxuXHJcblx0XHRcdFx0aWYgKHR5cGVvZiBpbWFnZU1hbmFnZXJQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBpbWFnZU1hbmFnZXJQbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdJbWFnZU1hbmFnZXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZCAobGlrZSBBc3RybyBDb21wb3NlciBmYWxsYmFjaylcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEltYWdlIE1hbmFnZXIgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gVHJ5IGZhbGxiYWNrIGV2ZW4gaWYgcGx1Z2luIG1ldGhvZCBmYWlsc1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHRcdH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBJbWFnZSBNYW5hZ2VyIGNvbmZpZyB2aWEgZmFsbGJhY2s6JywgZmFsbGJhY2tFcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogSW1hZ2VNYW5hZ2VyQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbWFnZS1tYW5hZ2VyJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHJcblx0XHQvLyBSZWFkIGV4aXN0aW5nIGRhdGEgaWYgZmlsZSBleGlzdHNcclxuXHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKSkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZXhpc3RpbmcgSW1hZ2UgTWFuYWdlciBkYXRhLmpzb24sIHN0YXJ0aW5nIGZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIGV4aXN0aW5nIGRhdGEgKHByZXNlcnZpbmcgZXhpc3Rpbmcgc2V0dGluZ3Mgbm90IGluIGNvbmZpZylcclxuXHRcdGNvbnN0IG1lcmdlZERhdGEgPSB7XHJcblx0XHRcdC4uLmV4aXN0aW5nRGF0YSxcclxuXHRcdFx0Li4uY29uZmlnXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFRyeSB0byBtb2RpZnkgZmlyc3QsIGlmIGZpbGUgZG9lc24ndCBleGlzdCBpdCB3aWxsIHRocm93LCB0aGVuIHdlIGNyZWF0ZVxyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EaXIpO1xyXG5cdFx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKHBsdWdpbkRpcik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZSBcImFscmVhZHkgZXhpc3RzXCIgZXJyb3JzXHJcblx0XHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbGVcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHQvLyBJZiBmaWxlIHdhcyBjcmVhdGVkIGJldHdlZW4gY2hlY2sgYW5kIGNyZWF0ZSwgdHJ5IHRvIG1vZGlmeSBpdFxyXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgfHwgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpKSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRcdFx0aWYgKHJldHJ5RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShyZXRyeUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc29sdmVzIHRoZSBpbWFnZSBwcm9wZXJ0eSBmcm9tIHRoZSB3aXphcmQgc3RhdGUgYW5kIHN5bmNzIGl0IHRvIEltYWdlIE1hbmFnZXIgc2V0dGluZ3NcclxuXHQgKi9cclxuXHRhc3luYyByZXNvbHZlQW5kU3luY0ltYWdlUHJvcGVydHkoc3RhdGU6IGFueSk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgY29udGVudFR5cGVzID0gc3RhdGUuY29udGVudFR5cGVzIHx8IFtdO1xyXG5cdFx0Y29uc3QgZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzID0gc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIHx8IHt9O1xyXG5cdFx0Y29uc3QgZGVmYXVsdFR5cGVJZCA9IHN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkO1xyXG5cclxuXHRcdGxldCByZXNvbHZlZEltYWdlUHJvcGVydHk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcblx0XHQvLyAxLiBDaGVjayBkZWZhdWx0IGNvbnRlbnQgdHlwZVxyXG5cdFx0aWYgKGRlZmF1bHRUeXBlSWQgJiYgZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2RlZmF1bHRUeXBlSWRdPy5pbWFnZVByb3BlcnR5KSB7XHJcblx0XHRcdHJlc29sdmVkSW1hZ2VQcm9wZXJ0eSA9IGZyb250bWF0dGVyUHJvcGVydGllc1tkZWZhdWx0VHlwZUlkXS5pbWFnZVByb3BlcnR5O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIDIuIElmIG5vdCBmb3VuZCwgY2hlY2sgYWxsIG90aGVyIGNvbnRlbnQgdHlwZXNcclxuXHRcdGlmICghcmVzb2x2ZWRJbWFnZVByb3BlcnR5KSB7XHJcblx0XHRcdGZvciAoY29uc3QgdHlwZSBvZiBjb250ZW50VHlwZXMpIHtcclxuXHRcdFx0XHRpZiAoZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW3R5cGUuaWRdPy5pbWFnZVByb3BlcnR5KSB7XHJcblx0XHRcdFx0XHRyZXNvbHZlZEltYWdlUHJvcGVydHkgPSBmcm9udG1hdHRlclByb3BlcnRpZXNbdHlwZS5pZF0uaW1hZ2VQcm9wZXJ0eTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIDMuIFVwZGF0ZSBjb25maWcgaWYgcHJvcGVydHkgd2FzIGZvdW5kXHJcblx0XHRpZiAocmVzb2x2ZWRJbWFnZVByb3BlcnR5KSB7XHJcblx0XHRcdGNvbnN0IGNvbmZpZyA9IGF3YWl0IHRoaXMubG9hZENvbmZpZygpO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHJvb3QgbGV2ZWwgZGVmYXVsdFByb3BlcnR5TmFtZVxyXG5cdFx0XHRjb25maWcuZGVmYXVsdFByb3BlcnR5TmFtZSA9IHJlc29sdmVkSW1hZ2VQcm9wZXJ0eTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBiYW5uZXIgbmVzdGVkIHByb3BlcnR5XHJcblx0XHRcdGlmIChjb25maWcuYmFubmVyKSB7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBjb25maWcuYmFubmVyID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdFx0aWYgKCEoY29uZmlnLmJhbm5lciBhcyBhbnkpLnByb3BlcnRpZXMpIHtcclxuXHRcdFx0XHRcdFx0KGNvbmZpZy5iYW5uZXIgYXMgYW55KS5wcm9wZXJ0aWVzID0ge307XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQoY29uZmlnLmJhbm5lciBhcyBhbnkpLnByb3BlcnRpZXMuaW1hZ2VQcm9wZXJ0eSA9IHJlc29sdmVkSW1hZ2VQcm9wZXJ0eTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gQ3JlYXRlIGJhbm5lciBzdHJ1Y3R1cmUgaWYgbWlzc2luZ1xyXG5cdFx0XHRcdGNvbmZpZy5iYW5uZXIgPSB7XHJcblx0XHRcdFx0XHRwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdFx0XHRcdGltYWdlUHJvcGVydHk6IHJlc29sdmVkSW1hZ2VQcm9wZXJ0eVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZyhjb25maWcpO1xyXG5cclxuXHRcdFx0Ly8gQWxzbyB1cGRhdGUgdGhlIHN0YXRlIG9iamVjdCB0byBwcmV2ZW50IG92ZXJ3cml0aW5nIHdpdGggb2xkIHZhbHVlcyBpbiBGaW5hbGl6ZVN0ZXBcclxuXHRcdFx0aWYgKHN0YXRlLmltYWdlTWFuYWdlcikge1xyXG5cdFx0XHRcdHN0YXRlLmltYWdlTWFuYWdlci5kZWZhdWx0UHJvcGVydHlOYW1lID0gcmVzb2x2ZWRJbWFnZVByb3BlcnR5O1xyXG5cdFx0XHRcdGlmIChzdGF0ZS5pbWFnZU1hbmFnZXIuYmFubmVyKSB7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHN0YXRlLmltYWdlTWFuYWdlci5iYW5uZXIgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0XHRcdGlmICghc3RhdGUuaW1hZ2VNYW5hZ2VyLmJhbm5lci5wcm9wZXJ0aWVzKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGUuaW1hZ2VNYW5hZ2VyLmJhbm5lci5wcm9wZXJ0aWVzID0ge307XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0c3RhdGUuaW1hZ2VNYW5hZ2VyLmJhbm5lci5wcm9wZXJ0aWVzLmltYWdlUHJvcGVydHkgPSByZXNvbHZlZEltYWdlUHJvcGVydHk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0YXRlLmltYWdlTWFuYWdlci5iYW5uZXIgPSB7XHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXM6IHtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZVByb3BlcnR5OiByZXNvbHZlZEltYWdlUHJvcGVydHlcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoYEltYWdlTWFuYWdlckNvbmZpZ3VyYXRvcjogU3luY2VkIGltYWdlIHByb3BlcnR5IFwiJHtyZXNvbHZlZEltYWdlUHJvcGVydHl9XCIgdG8gSW1hZ2UgTWFuYWdlciBhbmQgc3RhdGVgKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IEhvbWVCYXNlQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxudHlwZSBIb21lQmFzZVBsdWdpbiA9IHtcclxuXHRzZXR0aW5ncz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIEhvbWVCYXNlUGx1Z2luPjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBIb21lQmFzZUNvbmZpZ3VyYXRvciB7XHJcblx0cHJpdmF0ZSBhcHA6IEFwcDtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZENvbmZpZygpOiBQcm9taXNlPEhvbWVCYXNlQ29uZmlnPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdob21lLWJhc2UnO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNldHRpbmdzIEFQSSBmaXJzdFxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc3QgaG9tZUJhc2VQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGhvbWVCYXNlUGx1Z2luICYmIGhvbWVCYXNlUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Ly8gUmV0dXJuIHBsdWdpbiBzZXR0aW5ncyBhcyBjb25maWdcclxuXHRcdFx0XHRyZXR1cm4gaG9tZUJhc2VQbHVnaW4uc2V0dGluZ3MgYXMgSG9tZUJhc2VDb25maWc7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgSG9tZSBCYXNlIGNvbmZpZyBmcm9tIHBsdWdpbiBBUEk6JywgZXJyb3IpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZFxyXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMubG9hZENvbmZpZ0ZhbGxiYWNrKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIGxvYWRDb25maWdGYWxsYmFjaygpOiBQcm9taXNlPEhvbWVCYXNlQ29uZmlnPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdob21lLWJhc2UnO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHJcblx0XHQvLyBSZWFkIGV4aXN0aW5nIGRhdGEgaWYgZmlsZSBleGlzdHNcclxuXHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKSkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcblx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nRGF0YSBhcyBIb21lQmFzZUNvbmZpZztcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBIb21lIEJhc2UgZGF0YS5qc29uOicsIGVycm9yKTtcclxuXHRcdFx0XHRyZXR1cm4ge307XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHt9O1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZUNvbmZpZyhjb25maWc6IEhvbWVCYXNlQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdob21lLWJhc2UnO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2QgZmlyc3QgKGxpa2UgQXN0cm8gQ29tcG9zZXIpXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBob21lQmFzZVBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LltwbHVnaW5JZF07XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoaG9tZUJhc2VQbHVnaW4gJiYgaG9tZUJhc2VQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHQvLyBVcGRhdGUgdmlhIHBsdWdpbiBzZXR0aW5ncyBBUEkgKG1hdGNoaW5nIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgcGF0dGVybilcclxuXHRcdFx0XHRjb25zdCBwbHVnaW5TZXR0aW5ncyA9IGhvbWVCYXNlUGx1Z2luLnNldHRpbmdzO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIHBsdWdpbiBzZXR0aW5nc1xyXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24ocGx1Z2luU2V0dGluZ3MsIGNvbmZpZyk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBob21lQmFzZVBsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGF3YWl0IGhvbWVCYXNlUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnSG9tZUJhc2VDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZCAobGlrZSBBc3RybyBDb21wb3NlciBmYWxsYmFjaylcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEhvbWUgQmFzZSBjb25maWc6JywgZXJyb3IpO1xyXG5cdFx0XHQvLyBUcnkgZmFsbGJhY2sgZXZlbiBpZiBwbHVnaW4gbWV0aG9kIGZhaWxzXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdFx0fSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEhvbWUgQmFzZSBjb25maWcgdmlhIGZhbGxiYWNrOicsIGZhbGxiYWNrRXJyb3IpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHNhdmVDb25maWdGYWxsYmFjayhjb25maWc6IEhvbWVCYXNlQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdob21lLWJhc2UnO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIEhvbWUgQmFzZSBkYXRhLmpzb24sIHN0YXJ0aW5nIGZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBNZXJnZSBjb25maWcgaW50byBleGlzdGluZyBkYXRhIChwcmVzZXJ2aW5nIGV4aXN0aW5nIHNldHRpbmdzIG5vdCBpbiBjb25maWcpXHJcblx0XHRjb25zdCBtZXJnZWREYXRhID0ge1xyXG5cdFx0XHQuLi5leGlzdGluZ0RhdGEsXHJcblx0XHRcdC4uLmNvbmZpZ1xyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0Ly8gVHJ5IHRvIG1vZGlmeSBmaXJzdCwgaWYgZmlsZSBkb2Vzbid0IGV4aXN0IGl0IHdpbGwgdGhyb3csIHRoZW4gd2UgY3JlYXRlXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEVuc3VyZSBwbHVnaW4gZGlyZWN0b3J5IGV4aXN0c1xyXG5cdFx0XHRjb25zdCBwbHVnaW5EaXIgPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH1gO1xyXG5cdFx0XHRjb25zdCBwbHVnaW5EaXJGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcblx0XHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdFx0Ly8gSWdub3JlIFwiYWxyZWFkeSBleGlzdHNcIiBlcnJvcnNcclxuXHRcdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRcdGlmIChlcnJvck1lc3NhZ2UgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmlsZVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShwbHVnaW5EYXRhUGF0aCwgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdC8vIElmIGZpbGUgd2FzIGNyZWF0ZWQgYmV0d2VlbiBjaGVjayBhbmQgY3JlYXRlLCB0cnkgdG8gbW9kaWZ5IGl0XHJcblx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG5cdFx0XHRcdGlmIChlcnJvck1lc3NhZ2UgJiYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHJldHJ5RmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcdFx0XHRpZiAocmV0cnlGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KHJldHJ5RmlsZSwgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgRXhwbG9yZXJGb2N1c0NvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbnR5cGUgUGx1Z2luV2l0aFNldHRpbmdzID0ge1xyXG5cdHNldHRpbmdzPzogRXhwbG9yZXJGb2N1c0NvbmZpZztcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59O1xyXG5cclxudHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBQbHVnaW5XaXRoU2V0dGluZ3M+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoY29uZmlnOiBFeHBsb3JlckZvY3VzQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdleHBsb3Jlci1mb2N1cyc7XHJcblx0XHRcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIFRyeSB0byB1c2UgcGx1Z2luJ3MgbGl2ZSBzZXR0aW5ncyBpZiBhdmFpbGFibGVcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IGV4cGxvcmVyRm9jdXNQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGV4cGxvcmVyRm9jdXNQbHVnaW4gJiYgZXhwbG9yZXJGb2N1c1BsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0V4cGxvcmVyRm9jdXNDb25maWc6IFVzaW5nIHBsdWdpbi5zZXR0aW5ncyBBUEknKTtcclxuXHRcdFx0XHRjb25zdCBzZXR0aW5ncyA9IGV4cGxvcmVyRm9jdXNQbHVnaW4uc2V0dGluZ3M7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQXBwbHkgY29uZmlnIHRvIGxpdmUgc2V0dGluZ3NcclxuXHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb25maWcpKSB7XHJcblx0XHRcdFx0XHQoc2V0dGluZ3MgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tleV0gPSB2YWx1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2F2ZSBzZXR0aW5ncyB2aWEgcGx1Z2luIEFQSVxyXG5cdFx0XHRcdGlmICh0eXBlb2YgZXhwbG9yZXJGb2N1c1BsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGF3YWl0IGV4cGxvcmVyRm9jdXNQbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFeHBsb3JlckZvY3VzQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2QgaWYgcGx1Z2luIG5vdCBhdmFpbGFibGVcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRXhwbG9yZXJGb2N1c0NvbmZpZzogUGx1Z2luIEFQSSBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgRXhwbG9yZXIgRm9jdXMgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gVHJ5IGZhbGxiYWNrIGFueXdheVxyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZENvbmZpZygpOiBQcm9taXNlPEV4cGxvcmVyRm9jdXNDb25maWcgfCBudWxsPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdleHBsb3Jlci1mb2N1cyc7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpO1xyXG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIEV4cGxvcmVyRm9jdXNDb25maWc7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgRXhwbG9yZXIgRm9jdXMgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnOiBFeHBsb3JlckZvY3VzQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdleHBsb3Jlci1mb2N1cyc7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cdFx0XHJcblx0XHRsZXQgZXhpc3RpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xyXG5cdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHJcblx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIGV4cGxvcmVyLWZvY3VzIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBNZXJnZSB3aXRoIG91ciBjb25maWdcclxuXHRcdGNvbnN0IG1lcmdlZERhdGEgPSB7XHJcblx0XHRcdC4uLmV4aXN0aW5nRGF0YSxcclxuXHRcdFx0Li4uY29uZmlnXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEVuc3VyZSBwbHVnaW4gZGlyZWN0b3J5IGV4aXN0c1xyXG5cdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZvbGRlciBhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTYXZlIHRvIGZpbGVcclxuXHRcdGNvbnN0IGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKTtcclxuXHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgY29udGVudCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0Y29uc29sZS5kZWJ1ZygnRXhwbG9yZXJGb2N1c0NvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIGV4cGxvcmVyLWZvY3VzIGNvbmZpZyB2aWEgZmFsbGJhY2snKTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcblxyXG50eXBlIEVkaXRpbmdUb29sYmFyUGx1Z2luID0ge1xyXG5cdGVuYWJsZWQ/OiBib29sZWFuO1xyXG5cdHNldHRpbmdzPzoge1xyXG5cdFx0Y01lbnVWaXNpYmlsaXR5PzogYm9vbGVhbjtcclxuXHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XHJcblx0fTtcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG5cdGxvYWRTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcblx0cmVmcmVzaD86ICgpID0+IHZvaWQ7XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIEVkaXRpbmdUb29sYmFyUGx1Z2luPjtcclxuXHRlbmFibGVQbHVnaW4/OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuXHRkaXNhYmxlUGx1Z2luPzogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgRWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVuYWJsZS9kaXNhYmxlIHRoZSBlZGl0aW5nIHRvb2xiYXIgdmlzaWJpbGl0eVxyXG5cdCAqL1xyXG5cdGFzeW5jIHRvZ2dsZVZpc2liaWxpdHkoYXBwOiBBcHAsIGVuYWJsZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc29sZS5kZWJ1ZyhgRWRpdGluZ1Rvb2xiYXJDb25maWc6IHRvZ2dsZVZpc2liaWxpdHkgY2FsbGVkIHdpdGggZW5hYmxlPSR7ZW5hYmxlfWApO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9IChhcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRpZiAoIXBsdWdpbnMpIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBQbHVnaW5zIEFQSSBub3QgYXZhaWxhYmxlJyk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBlZGl0aW5nVG9vbGJhclBsdWdpbiA9IHBsdWdpbnMucGx1Z2lucz8uWydlZGl0aW5nLXRvb2xiYXInXTtcclxuXHRcdFx0aWYgKCFlZGl0aW5nVG9vbGJhclBsdWdpbikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRWRpdGluZ1Rvb2xiYXJDb25maWc6IEVkaXRpbmcgVG9vbGJhciBwbHVnaW4gbm90IGZvdW5kJyk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zb2xlLmRlYnVnKGBFZGl0aW5nVG9vbGJhckNvbmZpZzogRWRpdGluZyBUb29sYmFyIHBsdWdpbiBmb3VuZCwgZW5hYmxlZD0ke2VkaXRpbmdUb29sYmFyUGx1Z2luLmVuYWJsZWR9YCk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoYEVkaXRpbmdUb29sYmFyQ29uZmlnOiBQbHVnaW4gc2V0dGluZ3MgYXZhaWxhYmxlOmAsICEhZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MpO1xyXG5cclxuXHRcdFx0aWYgKGVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgRWRpdGluZ1Rvb2xiYXJDb25maWc6IEN1cnJlbnQgY01lbnVWaXNpYmlsaXR5OmAsIGVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzLmNNZW51VmlzaWJpbGl0eSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRyeSB0byB1c2UgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZCBmaXJzdFxyXG5cdFx0XHRpZiAoZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MgJiYgdHlwZW9mIGVkaXRpbmdUb29sYmFyUGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBVc2luZyBwbHVnaW4uc2F2ZVNldHRpbmdzKCkgbWV0aG9kJyk7XHJcblx0XHRcdFx0Y29uc3Qgb2xkVmFsdWUgPSBlZGl0aW5nVG9vbGJhclBsdWdpbi5zZXR0aW5ncy5jTWVudVZpc2liaWxpdHk7XHJcblx0XHRcdFx0ZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MuY01lbnVWaXNpYmlsaXR5ID0gZW5hYmxlO1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYEVkaXRpbmdUb29sYmFyQ29uZmlnOiBTZXQgY01lbnVWaXNpYmlsaXR5IGZyb20gJHtvbGRWYWx1ZX0gdG8gJHtlbmFibGV9YCk7XHJcblxyXG5cdFx0XHRcdGF3YWl0IGVkaXRpbmdUb29sYmFyUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgZWRpdGluZy10b29sYmFyIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuXHJcblx0XHRcdFx0Ly8gRGlzcGF0Y2ggdGhlIGV2ZW50IHRoYXQgZWRpdGluZy10b29sYmFyIGxpc3RlbnMgZm9yIHRvIHRyaWdnZXIgYSByZWJ1aWxkXHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRWRpdGluZ1Rvb2xiYXJDb25maWc6IERpc3BhdGNoaW5nIGVkaXRpbmdUb29sYmFyLU5ld0NvbW1hbmQgZXZlbnQnKTtcclxuXHRcdFx0XHR3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJlZGl0aW5nVG9vbGJhci1OZXdDb21tYW5kXCIpKTtcclxuXHJcblx0XHRcdFx0aWYgKGVuYWJsZSkge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRWRpdGluZ1Rvb2xiYXJDb25maWc6IFdhaXRpbmcgZm9yIHNldHRpbmdzIHRvIHBlcnNpc3QuLi4nKTtcclxuXHRcdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuXHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIGVkaXRpbmdUb29sYmFyUGx1Z2luLmxvYWRTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogUmVsb2FkaW5nIGVkaXRpbmcgdG9vbGJhciBwbHVnaW4gc2V0dGluZ3MnKTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgZWRpdGluZ1Rvb2xiYXJQbHVnaW4ubG9hZFNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBlZGl0aW5nVG9vbGJhclBsdWdpbi5yZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBSZWZyZXNoaW5nIGVkaXRpbmcgdG9vbGJhciBwbHVnaW4nKTtcclxuXHRcdFx0XHRcdFx0ZWRpdGluZ1Rvb2xiYXJQbHVnaW4ucmVmcmVzaCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRWRpdGluZ1Rvb2xiYXJDb25maWc6IFBsdWdpbiBzYXZlU2V0dGluZ3Mgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2snKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdFx0YXdhaXQgdGhpcy50b2dnbGVWaXNpYmlsaXR5RmFsbGJhY2soYXBwLCBlbmFibGUpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRWRpdGluZ1Rvb2xiYXJDb25maWc6IEZhaWxlZCB0byB0b2dnbGUgZWRpdGluZyB0b29sYmFyIHBsdWdpbjonLCBlcnJvcik7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0YXdhaXQgdGhpcy50b2dnbGVWaXNpYmlsaXR5RmFsbGJhY2soYXBwLCBlbmFibGUpO1xyXG5cdFx0XHR9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRWRpdGluZ1Rvb2xiYXJDb25maWc6IEZhaWxlZCB0byB0b2dnbGUgZWRpdGluZyB0b29sYmFyIHZpYSBmYWxsYmFjazonLCBmYWxsYmFja0Vycm9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyB0b2dnbGVWaXNpYmlsaXR5RmFsbGJhY2soYXBwOiBBcHAsIGVuYWJsZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnZWRpdGluZy10b29sYmFyJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IGFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cclxuXHRcdGxldCBleGlzdGluZ0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XHJcblx0XHRjb25zdCBkYXRhRmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cclxuXHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCBhcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIGVkaXRpbmctdG9vbGJhciBkYXRhLmpzb24sIHN0YXJ0aW5nIGZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGV4aXN0aW5nRGF0YS5jTWVudVZpc2liaWxpdHkgPSBlbmFibGU7XHJcblxyXG5cdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0YXdhaXQgYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgZWRpdGluZy10b29sYmFyIHZpYSBmaWxlIG1vZGlmeScpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdFx0aWYgKCFwbHVnaW5EaXJGaWxlKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGF3YWl0IGFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG5cdFx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGb2xkZXIgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCBhcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgZWRpdGluZy10b29sYmFyIGRhdGEuanNvbicpO1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgfHwgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpKSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0XHRcdGlmIChyZXRyeUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KHJldHJ5RmlsZSwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgZWRpdGluZy10b29sYmFyIHZpYSByZXRyeSBtb2RpZnknKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgcmV0cnlGaWxlMiA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRcdFx0XHRpZiAocmV0cnlGaWxlMiBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgYXBwLnZhdWx0Lm1vZGlmeShyZXRyeUZpbGUyLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIGVkaXRpbmctdG9vbGJhciB2aWEgZGVsYXllZCByZXRyeSBtb2RpZnknKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY3VycmVudCB2aXNpYmlsaXR5IG9mIHRoZSBlZGl0aW5nIHRvb2xiYXJcclxuXHQgKi9cclxuXHRhc3luYyBnZXRWaXNpYmlsaXR5KGFwcDogQXBwKTogUHJvbWlzZTxib29sZWFuIHwgdW5kZWZpbmVkPiB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKGFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IGVkaXRpbmdUb29sYmFyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uWydlZGl0aW5nLXRvb2xiYXInXTtcclxuXHJcblx0XHRcdGlmIChlZGl0aW5nVG9vbGJhclBsdWdpbj8uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHRyZXR1cm4gZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MuY01lbnVWaXNpYmlsaXR5O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZFxyXG5cdFx0XHRjb25zdCBjb25maWdEaXIgPSBhcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy9lZGl0aW5nLXRvb2xiYXIvZGF0YS5qc29uYDtcclxuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHJcblx0XHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCBhcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIHsgY01lbnVWaXNpYmlsaXR5PzogYm9vbGVhbiB9O1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZ0RhdGEuY01lbnVWaXNpYmlsaXR5O1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBGYWlsZWQgdG8gZ2V0IGVkaXRpbmcgdG9vbGJhciB2aXNpYmlsaXR5OicsIGVycm9yKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBWYXVsdENNU1NldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xyXG5pbXBvcnQgVmF1bHRDTVNQbHVnaW4gZnJvbSAnLi4vLi4vbWFpbic7XHJcbmltcG9ydCB7IEltYWdlTWFuYWdlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0ltYWdlTWFuYWdlckNvbmZpZyc7XHJcbmltcG9ydCB7IEhvbWVCYXNlQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvSG9tZUJhc2VDb25maWcnO1xyXG5pbXBvcnQgeyBFeHBsb3JlckZvY3VzQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvRXhwbG9yZXJGb2N1c0NvbmZpZyc7XHJcbmltcG9ydCB7IEVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvRWRpdGluZ1Rvb2xiYXJDb25maWcnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFdpemFyZFN0YXRlTWFuYWdlciB7XHJcblx0cHJpdmF0ZSBzdGF0ZTogV2l6YXJkU3RhdGU7XHJcblx0cHJpdmF0ZSBwbHVnaW46IFBsdWdpbjtcclxuXHRwcml2YXRlIGVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yOiBFZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvcjtcclxuXHJcblx0Y29uc3RydWN0b3IocGx1Z2luOiBQbHVnaW4pIHtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdFx0dGhpcy5lZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvciA9IG5ldyBFZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvcihwbHVnaW4uYXBwKTtcclxuXHRcdGNvbnN0IHNldHRpbmdzID0gKHBsdWdpbiBhcyBWYXVsdENNU1BsdWdpbikuc2V0dGluZ3M7XHJcblx0XHR0aGlzLnN0YXRlID0gdGhpcy5pbml0aWFsaXplU3RhdGUoc2V0dGluZ3MpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpbml0aWFsaXplU3RhdGUoc2V0dGluZ3M6IFZhdWx0Q01TU2V0dGluZ3MpOiBXaXphcmRTdGF0ZSB7XHJcblx0XHQvLyBJbml0aWFsaXplIHByb2plY3QgZGV0ZWN0aW9uIGZyb20gc2F2ZWQgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXHJcblx0XHRjb25zdCBzYXZlZFByb2plY3REZXRlY3Rpb24gPSBzZXR0aW5ncy5wcm9qZWN0Um9vdCAmJiBzZXR0aW5ncy5jb25maWdGaWxlUGF0aCA/IHtcclxuXHRcdFx0cHJvamVjdFJvb3Q6IHNldHRpbmdzLnByb2plY3RSb290LFxyXG5cdFx0XHRjb25maWdGaWxlUGF0aDogc2V0dGluZ3MuY29uZmlnRmlsZVBhdGgsXHJcblx0XHRcdHZhdWx0TG9jYXRpb246ICdjb250ZW50JyBhcyBjb25zdFxyXG5cdFx0fSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHQvLyBUcnkgdG8gaW5mZXIgYXR0YWNobWVudCBzZXR0aW5ncyBmcm9tIE9ic2lkaWFuIGlmIG5vdCBleHBsaWNpdGx5IHNhdmVkIGluIG91ciBzZXR0aW5nc1xyXG5cdFx0bGV0IGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSBzZXR0aW5ncy5hdHRhY2htZW50SGFuZGxpbmdNb2RlO1xyXG5cdFx0bGV0IGF0dGFjaG1lbnRGb2xkZXJOYW1lID0gc2V0dGluZ3MuYXR0YWNobWVudEZvbGRlck5hbWU7XHJcblxyXG5cdFx0aWYgKCFhdHRhY2htZW50SGFuZGxpbmdNb2RlKSB7XHJcblx0XHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0IGFzIHsgY29uZmlnPzogeyBuZXdGaWxlTG9jYXRpb24/OiBzdHJpbmc7IG5ld0ZpbGVGb2xkZXJQYXRoPzogc3RyaW5nOyBhdHRhY2htZW50Rm9sZGVyUGF0aD86IHN0cmluZzsgbmV3TGlua0Zvcm1hdD86IHN0cmluZyB9IH07XHJcblx0XHRcdGNvbnN0IG9ic2lkaWFuQ29uZmlnID0gdmF1bHQuY29uZmlnO1xyXG5cclxuXHRcdFx0aWYgKG9ic2lkaWFuQ29uZmlnPy5hdHRhY2htZW50Rm9sZGVyUGF0aCkge1xyXG5cdFx0XHRcdGNvbnN0IGZvbGRlclBhdGggPSBvYnNpZGlhbkNvbmZpZy5hdHRhY2htZW50Rm9sZGVyUGF0aDtcclxuXHRcdFx0XHRpZiAoZm9sZGVyUGF0aCA9PT0gJy4vJykge1xyXG5cdFx0XHRcdFx0YXR0YWNobWVudEhhbmRsaW5nTW9kZSA9ICdzYW1lLWZvbGRlcic7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChmb2xkZXJQYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuXHRcdFx0XHRcdGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc3ViZm9sZGVyJztcclxuXHRcdFx0XHRcdGF0dGFjaG1lbnRGb2xkZXJOYW1lID0gZm9sZGVyUGF0aC5zdWJzdHJpbmcoMik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc3BlY2lmaWVkLWZvbGRlcic7XHJcblx0XHRcdFx0XHRhdHRhY2htZW50Rm9sZGVyTmFtZSA9IGZvbGRlclBhdGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y3VycmVudFN0ZXA6IDAsXHJcblx0XHRcdHByb2plY3REZXRlY3Rpb246IHNhdmVkUHJvamVjdERldGVjdGlvbixcclxuXHRcdFx0Y29udGVudFR5cGVzOiBzZXR0aW5ncy5jb250ZW50VHlwZXMgfHwgW10sXHJcblx0XHRcdGZyb250bWF0dGVyUHJvcGVydGllczogc2V0dGluZ3MuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIHx8IHt9LFxyXG5cdFx0XHRkZWZhdWx0Q29udGVudFR5cGVJZDogc2V0dGluZ3MuZGVmYXVsdENvbnRlbnRUeXBlSWQsXHJcblx0XHRcdGF0dGFjaG1lbnRIYW5kbGluZ01vZGU6IGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgfHwgJ3N1YmZvbGRlcicsXHJcblx0XHRcdGF0dGFjaG1lbnRGb2xkZXJOYW1lOiBhdHRhY2htZW50Rm9sZGVyTmFtZSxcclxuXHRcdFx0cHJlc2V0OiBzZXR0aW5ncy5wcmVzZXQgfHwgJ3ZhbmlsbGEnLFxyXG5cdFx0XHRwcmVzZXROYW1lOiBzZXR0aW5ncy5wcmVzZXROYW1lIHx8ICcnLFxyXG5cdFx0XHRwcmVzZXRzUmVwbzogc2V0dGluZ3MucHJlc2V0c1JlcG8gfHwgJ2RhdmlkdmtpbWJhbGwvdmF1bHQtY21zLXByZXNldHMnLFxyXG5cdFx0XHRlbmFibGVFZGl0aW5nVG9vbGJhcjogc2V0dGluZ3MuZW5hYmxlRWRpdGluZ1Rvb2xiYXIgPz8gKHNldHRpbmdzIGFzIGFueSkuZW5hYmxlV1lTSVdZRyA/PyBmYWxzZSxcclxuXHRcdFx0ZW5hYmxlTWR4U3VwcG9ydDogc2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydCxcclxuXHRcdFx0ZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXM6IHNldHRpbmdzLmVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzLFxyXG5cdFx0XHRlbmFibGVkUGx1Z2luczogc2V0dGluZ3MuZW5hYmxlZFBsdWdpbnMgfHwgW10sXHJcblx0XHRcdGRpc2FibGVkUGx1Z2luczogc2V0dGluZ3MuZGlzYWJsZWRQbHVnaW5zIHx8IFtdLFxyXG5cdFx0XHR0aGVtZTogc2V0dGluZ3MudGhlbWUgfHwgJycsXHJcblx0XHRcdGJhc2VzQ01TQ29uZmlnOiBzZXR0aW5ncy5iYXNlc0NNU0NvbmZpZyB8fCB7IHZpZXdzOiBbXSB9LFxyXG5cdFx0XHRhc3Ryb0NvbXBvc2VyQ29uZmlnOiBzZXR0aW5ncy5hc3Ryb0NvbXBvc2VyQ29uZmlnIHx8IHtcclxuXHRcdFx0XHRjdXN0b21Db250ZW50VHlwZXM6IFtdLFxyXG5cdFx0XHRcdGRlZmF1bHRUZW1wbGF0ZTogJycsXHJcblx0XHRcdFx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdFx0XHRcdHRlcm1pbmFsUHJvamVjdFJvb3RQYXRoOiAnJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZW9Db25maWc6IHNldHRpbmdzLnNlb0NvbmZpZyB8fCB7XHJcblx0XHRcdFx0dGl0bGVQcm9wZXJ0eTogJ3RpdGxlJyxcclxuXHRcdFx0XHRzY2FuRGlyZWN0b3JpZXM6ICcnLFxyXG5cdFx0XHRcdHVzZUZpbGVuYW1lQXNUaXRsZTogZmFsc2UsXHJcblx0XHRcdFx0dXNlRmlsZW5hbWVBc1NsdWc6IHRydWUsXHJcblx0XHRcdFx0ZW5hYmxlTURYU3VwcG9ydDogc2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRwcm9wZXJ0eU92ZXJGaWxlTmFtZTogc2V0dGluZ3MucHJvcGVydHlPdmVyRmlsZU5hbWUgfHwgeyBwcm9wZXJ0eUtleTogJ3RpdGxlJyB9LFxyXG5cdFx0XHRpbWFnZU1hbmFnZXI6IHNldHRpbmdzLmltYWdlTWFuYWdlciB8fCB7fSxcclxuXHRcdFx0aG9tZUJhc2U6IHNldHRpbmdzLmhvbWVCYXNlIHx8IHt9LFxyXG5cdFx0XHRleHBsb3JlckZvY3VzOiBzZXR0aW5ncy5leHBsb3JlckZvY3VzIHx8IHt9LFxyXG5cdFx0XHRpZ25vcmVDb25maWc6IHNldHRpbmdzLmlnbm9yZUNvbmZpZyB8fCB7IGdpdElnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlLCB2aXRlSWdub3JlQ29uZmlndXJlZDogZmFsc2UgfSxcclxuXHRcdFx0Z2l0Q29uZmlnOiBzZXR0aW5ncy5naXRDb25maWcgfHwgeyBlbmFibGVkOiBmYWxzZSwgYXV0b0NvbmZpZ3VyZU9ic2lkaWFuR2l0OiB0cnVlIH1cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRnZXRTdGF0ZSgpOiBXaXphcmRTdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZVN0YXRlKHVwZGF0ZXM6IFBhcnRpYWw8V2l6YXJkU3RhdGU+KTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlID0geyAuLi50aGlzLnN0YXRlLCAuLi51cGRhdGVzIH07XHJcblx0fVxyXG5cclxuXHRzZXRTdGF0ZSh1cGRhdGVzOiBQYXJ0aWFsPFdpemFyZFN0YXRlPik6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHsgLi4udGhpcy5zdGF0ZSwgLi4udXBkYXRlcyB9O1xyXG5cdH1cclxuXHJcblx0bmV4dFN0ZXAodG90YWxTdGVwczogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBjdXJyZW50U3RlcCBpcyAwLWluZGV4ZWQsIHNvIHdlIGluY3JlbWVudCBpdCBidXQga2VlcCBpdCB3aXRoaW4gYm91bmRzXHJcblx0XHRpZiAodGhpcy5zdGF0ZS5jdXJyZW50U3RlcCA8IHRvdGFsU3RlcHMgLSAxKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudFN0ZXArKztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByZXZpb3VzU3RlcCgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnN0YXRlLmN1cnJlbnRTdGVwID4gMCkge1xyXG5cdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnRTdGVwLS07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjYW5Hb05leHQodG90YWxTdGVwczogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50U3RlcCA8IHRvdGFsU3RlcHMgLSAxO1xyXG5cdH1cclxuXHJcblx0Y2FuR29QcmV2aW91cygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRTdGVwID4gMDtcclxuXHR9XHJcblxyXG5cdGdldFByb2dyZXNzKHRvdGFsU3RlcHM6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAodG90YWxTdGVwcyA9PT0gMCkgcmV0dXJuIDA7XHJcblx0XHRyZXR1cm4gKCh0aGlzLnN0YXRlLmN1cnJlbnRTdGVwICsgMSkgLyB0b3RhbFN0ZXBzKSAqIDEwMDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHJlZnJlc2hTdGF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdC8vIFJlZnJlc2ggdGhlIHdpemFyZCBzdGF0ZSB3aXRoIGN1cnJlbnQgcGx1Z2luIHNldHRpbmdzXHJcblx0XHRjb25zdCBzZXR0aW5ncyA9ICh0aGlzLnBsdWdpbiBhcyBWYXVsdENNU1BsdWdpbikuc2V0dGluZ3M7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIHByb2plY3QgZGV0ZWN0aW9uXHJcblx0XHRpZiAoc2V0dGluZ3MucHJvamVjdFJvb3QgJiYgc2V0dGluZ3MuY29uZmlnRmlsZVBhdGgpIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uID0ge1xyXG5cdFx0XHRcdHByb2plY3RSb290OiBzZXR0aW5ncy5wcm9qZWN0Um9vdCxcclxuXHRcdFx0XHRjb25maWdGaWxlUGF0aDogc2V0dGluZ3MuY29uZmlnRmlsZVBhdGgsXHJcblx0XHRcdFx0dmF1bHRMb2NhdGlvbjogJ2NvbnRlbnQnXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24gPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGFsbCBvdGhlciBzZXR0aW5nc1xyXG5cdFx0dGhpcy5zdGF0ZS5jb250ZW50VHlwZXMgPSBzZXR0aW5ncy5jb250ZW50VHlwZXMgfHwgW107XHJcblx0XHR0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyA9IHNldHRpbmdzLmZyb250bWF0dGVyUHJvcGVydGllcyB8fCB7fTtcclxuXHRcdHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQgPSBzZXR0aW5ncy5kZWZhdWx0Q29udGVudFR5cGVJZDtcclxuXHJcblx0XHQvLyBVc2Ugc2F2ZWQgc2V0dGluZ3MgZm9yIGF0dGFjaG1lbnQgaGFuZGxpbmcsIG9yIGluZmVyIGZyb20gT2JzaWRpYW4gaWYgbm90IHNldFxyXG5cdFx0aWYgKHNldHRpbmdzLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUpIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID0gc2V0dGluZ3MuYXR0YWNobWVudEhhbmRsaW5nTW9kZTtcclxuXHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSA9IHNldHRpbmdzLmF0dGFjaG1lbnRGb2xkZXJOYW1lO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgdmF1bHQgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQgYXMgeyBjb25maWc/OiB7IG5ld0ZpbGVMb2NhdGlvbj86IHN0cmluZzsgbmV3RmlsZUZvbGRlclBhdGg/OiBzdHJpbmc7IGF0dGFjaG1lbnRGb2xkZXJQYXRoPzogc3RyaW5nOyBuZXdMaW5rRm9ybWF0Pzogc3RyaW5nIH0gfTtcclxuXHRcdFx0Y29uc3Qgb2JzaWRpYW5Db25maWcgPSB2YXVsdC5jb25maWc7XHJcblxyXG5cdFx0XHRpZiAob2JzaWRpYW5Db25maWc/LmF0dGFjaG1lbnRGb2xkZXJQYXRoKSB7XHJcblx0XHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IG9ic2lkaWFuQ29uZmlnLmF0dGFjaG1lbnRGb2xkZXJQYXRoO1xyXG5cdFx0XHRcdGlmIChmb2xkZXJQYXRoID09PSAnLi8nKSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc2FtZS1mb2xkZXInO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGZvbGRlclBhdGguc3RhcnRzV2l0aCgnLi8nKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID0gJ3N1YmZvbGRlcic7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gZm9sZGVyUGF0aC5zdWJzdHJpbmcoMik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9ICdzcGVjaWZpZWQtZm9sZGVyJztcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgPSBmb2xkZXJQYXRoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc3ViZm9sZGVyJztcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGF0ZS5wcmVzZXQgPSBzZXR0aW5ncy5wcmVzZXQgfHwgJ3ZhbmlsbGEnO1xyXG5cdFx0dGhpcy5zdGF0ZS5wcmVzZXROYW1lID0gc2V0dGluZ3MucHJlc2V0TmFtZSB8fCAnJztcclxuXHRcdHRoaXMuc3RhdGUucHJlc2V0c1JlcG8gPSBzZXR0aW5ncy5wcmVzZXRzUmVwbyB8fCAndmF1bHRjbXMvdmF1bHQtY21zLXByZXNldHMnO1xyXG5cclxuXHRcdC8vIFN5bmMgZW5hYmxlRWRpdGluZ1Rvb2xiYXIgd2l0aCBhY3R1YWwgcGx1Z2luIHN0YXRlXHJcblx0XHRjb25zdCBhY3R1YWxWaXNpYmlsaXR5ID0gYXdhaXQgdGhpcy5lZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvci5nZXRWaXNpYmlsaXR5KHRoaXMucGx1Z2luLmFwcCk7XHJcblx0XHRpZiAoYWN0dWFsVmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXIgPSBhY3R1YWxWaXNpYmlsaXR5O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVFZGl0aW5nVG9vbGJhciA9IHNldHRpbmdzLmVuYWJsZUVkaXRpbmdUb29sYmFyID8/IChzZXR0aW5ncyBhcyBhbnkpLmVuYWJsZVdZU0lXWUcgPz8gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID0gc2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydDtcclxuXHRcdHRoaXMuc3RhdGUuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMgPSBzZXR0aW5ncy5lbmFibGVFeHRlbmRlZEZpbGVUeXBlcztcclxuXHRcdHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMgPSBzZXR0aW5ncy5lbmFibGVkUGx1Z2lucyB8fCBbXTtcclxuXHRcdHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zID0gc2V0dGluZ3MuZGlzYWJsZWRQbHVnaW5zIHx8IFtdO1xyXG5cdFx0dGhpcy5zdGF0ZS50aGVtZSA9IHNldHRpbmdzLnRoZW1lIHx8ICcnO1xyXG5cdFx0dGhpcy5zdGF0ZS5iYXNlc0NNU0NvbmZpZyA9IHNldHRpbmdzLmJhc2VzQ01TQ29uZmlnIHx8IHsgdmlld3M6IFtdIH07XHJcblx0XHR0aGlzLnN0YXRlLmFzdHJvQ29tcG9zZXJDb25maWcgPSBzZXR0aW5ncy5hc3Ryb0NvbXBvc2VyQ29uZmlnIHx8IHtcclxuXHRcdFx0Y3VzdG9tQ29udGVudFR5cGVzOiBbXSxcclxuXHRcdFx0ZGVmYXVsdFRlbXBsYXRlOiAnJyxcclxuXHRcdFx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdFx0XHR0ZXJtaW5hbFByb2plY3RSb290UGF0aDogJydcclxuXHRcdH07XHJcblx0XHR0aGlzLnN0YXRlLnNlb0NvbmZpZyA9IHNldHRpbmdzLnNlb0NvbmZpZyB8fCB7XHJcblx0XHRcdHRpdGxlUHJvcGVydHk6ICd0aXRsZScsXHJcblx0XHRcdHNjYW5EaXJlY3RvcmllczogJycsXHJcblx0XHRcdHVzZUZpbGVuYW1lQXNUaXRsZTogZmFsc2UsXHJcblx0XHRcdHVzZUZpbGVuYW1lQXNTbHVnOiB0cnVlXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5zdGF0ZS5wcm9wZXJ0eU92ZXJGaWxlTmFtZSA9IHNldHRpbmdzLnByb3BlcnR5T3ZlckZpbGVOYW1lIHx8IHsgcHJvcGVydHlLZXk6ICd0aXRsZScgfTtcclxuXHRcdHRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cyA9IHNldHRpbmdzLmV4cGxvcmVyRm9jdXMgfHwge307XHJcblxyXG5cdFx0Ly8gTG9hZCBjb25maWdzIGZyb20gcGx1Z2luIGRhdGEuanNvbiBmaWxlcyBpZiB0aGV5J3JlIGVtcHR5XHJcblx0XHRpZiAoIXRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyIHx8IE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjb25zdCBpbWFnZU1hbmFnZXJDb25maWd1cmF0b3IgPSBuZXcgSW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yKHRoaXMucGx1Z2luLmFwcCk7XHJcblx0XHRcdFx0Y29uc3QgbG9hZGVkQ29uZmlnID0gYXdhaXQgaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yLmxvYWRDb25maWcoKTtcclxuXHRcdFx0XHRpZiAobG9hZGVkQ29uZmlnICYmIE9iamVjdC5rZXlzKGxvYWRlZENvbmZpZykubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5pbWFnZU1hbmFnZXIgPSBsb2FkZWRDb25maWc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyID0gc2V0dGluZ3MuaW1hZ2VNYW5hZ2VyIHx8IHt9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEltYWdlIE1hbmFnZXIgY29uZmlnIGR1cmluZyByZWZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmltYWdlTWFuYWdlciA9IHNldHRpbmdzLmltYWdlTWFuYWdlciB8fCB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5pbWFnZU1hbmFnZXIgPSBzZXR0aW5ncy5pbWFnZU1hbmFnZXIgfHwge307XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLnN0YXRlLmhvbWVCYXNlIHx8IE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuaG9tZUJhc2UpLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnN0IGhvbWVCYXNlQ29uZmlndXJhdG9yID0gbmV3IEhvbWVCYXNlQ29uZmlndXJhdG9yKHRoaXMucGx1Z2luLmFwcCk7XHJcblx0XHRcdFx0Y29uc3QgbG9hZGVkQ29uZmlnID0gYXdhaXQgaG9tZUJhc2VDb25maWd1cmF0b3IubG9hZENvbmZpZygpO1xyXG5cdFx0XHRcdGlmIChsb2FkZWRDb25maWcgJiYgT2JqZWN0LmtleXMobG9hZGVkQ29uZmlnKS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmhvbWVCYXNlID0gbG9hZGVkQ29uZmlnO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmhvbWVCYXNlID0gc2V0dGluZ3MuaG9tZUJhc2UgfHwge307XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgSG9tZSBCYXNlIGNvbmZpZyBkdXJpbmcgcmVmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5ob21lQmFzZSA9IHNldHRpbmdzLmhvbWVCYXNlIHx8IHt9O1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnN0YXRlLmhvbWVCYXNlID0gc2V0dGluZ3MuaG9tZUJhc2UgfHwge307XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXMgfHwgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjb25zdCBleHBsb3JlckZvY3VzQ29uZmlndXJhdG9yID0gbmV3IEV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3IodGhpcy5wbHVnaW4uYXBwKTtcclxuXHRcdFx0XHRjb25zdCBsb2FkZWRDb25maWcgPSBhd2FpdCBleHBsb3JlckZvY3VzQ29uZmlndXJhdG9yLmxvYWRDb25maWcoKTtcclxuXHRcdFx0XHRpZiAobG9hZGVkQ29uZmlnICYmIE9iamVjdC5rZXlzKGxvYWRlZENvbmZpZykubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzID0gbG9hZGVkQ29uZmlnO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXMgPSBzZXR0aW5ncy5leHBsb3JlckZvY3VzIHx8IHt9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEV4cGxvcmVyIEZvY3VzIGNvbmZpZyBkdXJpbmcgcmVmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzID0gc2V0dGluZ3MuZXhwbG9yZXJGb2N1cyB8fCB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzID0gc2V0dGluZ3MuZXhwbG9yZXJGb2N1cyB8fCB7fTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnN0YXRlLmdpdENvbmZpZyA9IHNldHRpbmdzLmdpdENvbmZpZyB8fCB7IGVuYWJsZWQ6IGZhbHNlLCBhdXRvQ29uZmlndXJlT2JzaWRpYW5HaXQ6IHRydWUgfTtcclxuXHRcdHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnID0gc2V0dGluZ3MuaWdub3JlQ29uZmlnIHx8IHsgZ2l0SWdub3JlQ29uZmlndXJlZDogZmFsc2UsIHZpdGVJZ25vcmVDb25maWd1cmVkOiBmYWxzZSB9O1xyXG5cdH1cclxuXHJcblx0YXN5bmMgYnVpbGRGaW5hbFNldHRpbmdzKCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Ly8gVXBkYXRlIHBsdWdpbi5zZXR0aW5ncyBkaXJlY3RseSBmcm9tIHdpemFyZCBzdGF0ZVxyXG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSAodGhpcy5wbHVnaW4gYXMgVmF1bHRDTVNQbHVnaW4pLnNldHRpbmdzO1xyXG5cclxuXHRcdHNldHRpbmdzLnByb2plY3RSb290ID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdCB8fCAnJztcclxuXHRcdHNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aCB8fCAnJztcclxuXHRcdHNldHRpbmdzLmNvbnRlbnRUeXBlcyA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzO1xyXG5cdFx0c2V0dGluZ3MuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzID0gdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXM7XHJcblx0XHRzZXR0aW5ncy5kZWZhdWx0Q29udGVudFR5cGVJZCA9IHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQ7XHJcblx0XHRzZXR0aW5ncy5hdHRhY2htZW50SGFuZGxpbmdNb2RlID0gdGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlO1xyXG5cdFx0c2V0dGluZ3MuYXR0YWNobWVudEZvbGRlck5hbWUgPSB0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lO1xyXG5cdFx0c2V0dGluZ3MucHJlc2V0ID0gdGhpcy5zdGF0ZS5wcmVzZXQ7XHJcblx0XHRzZXR0aW5ncy5wcmVzZXROYW1lID0gdGhpcy5zdGF0ZS5wcmVzZXROYW1lIHx8ICcnO1xyXG5cdFx0c2V0dGluZ3MucHJlc2V0c1JlcG8gPSB0aGlzLnN0YXRlLnByZXNldHNSZXBvIHx8ICdkYXZpZHZraW1iYWxsL3ZhdWx0LWNtcy1wcmVzZXRzJztcclxuXHRcdHNldHRpbmdzLmVuYWJsZUVkaXRpbmdUb29sYmFyID0gdGhpcy5zdGF0ZS5lbmFibGVFZGl0aW5nVG9vbGJhcjtcclxuXHJcblx0XHQvLyBDbGVhbiB1cCBvbGQgV1lTSVdZRyBzZXR0aW5nIG5hbWVcclxuXHRcdGlmICgoc2V0dGluZ3MgYXMgYW55KS5lbmFibGVXWVNJV1lHICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZGVsZXRlIChzZXR0aW5ncyBhcyBhbnkpLmVuYWJsZVdZU0lXWUc7XHJcblx0XHR9XHJcblx0XHRzZXR0aW5ncy5lbmFibGVNZHhTdXBwb3J0ID0gdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID8/IGZhbHNlO1xyXG5cdFx0c2V0dGluZ3MuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMgPSB0aGlzLnN0YXRlLmVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzID8/IGZhbHNlO1xyXG5cdFx0c2V0dGluZ3MuZW5hYmxlZFBsdWdpbnMgPSB0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zO1xyXG5cdFx0c2V0dGluZ3MuZGlzYWJsZWRQbHVnaW5zID0gdGhpcy5zdGF0ZS5kaXNhYmxlZFBsdWdpbnM7XHJcblx0XHRzZXR0aW5ncy50aGVtZSA9IHRoaXMuc3RhdGUudGhlbWU7XHJcblx0XHRzZXR0aW5ncy5iYXNlc0NNU0NvbmZpZyA9IHRoaXMuc3RhdGUuYmFzZXNDTVNDb25maWc7XHJcblx0XHRzZXR0aW5ncy5hc3Ryb0NvbXBvc2VyQ29uZmlnID0gdGhpcy5zdGF0ZS5hc3Ryb0NvbXBvc2VyQ29uZmlnO1xyXG5cdFx0c2V0dGluZ3Muc2VvQ29uZmlnID0gdGhpcy5zdGF0ZS5zZW9Db25maWc7XHJcblx0XHRzZXR0aW5ncy5wcm9wZXJ0eU92ZXJGaWxlTmFtZSA9IHRoaXMuc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWU7XHJcblx0XHQvLyBDbGVhbiB1cCBvbGQgc3RydWN0dXJlIGlmIGl0IGV4aXN0c1xyXG5cdFx0Y29uc3Qgc2V0dGluZ3NSZWNvcmQgPSBzZXR0aW5ncyBhcyB1bmtub3duIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0aWYgKHNldHRpbmdzUmVjb3JkLnVpVHdlYWtlcikge1xyXG5cdFx0XHRkZWxldGUgc2V0dGluZ3NSZWNvcmQudWlUd2Vha2VyO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHNldHRpbmdzUmVjb3JkLnRhYkJhckNvbW1hbmRzKSB7XHJcblx0XHRcdGRlbGV0ZSBzZXR0aW5nc1JlY29yZC50YWJCYXJDb21tYW5kcztcclxuXHRcdH1cclxuXHRcdGlmIChzZXR0aW5nc1JlY29yZC5jb21tYW5kZXJDb25maWcpIHtcclxuXHRcdFx0ZGVsZXRlIHNldHRpbmdzUmVjb3JkLmNvbW1hbmRlckNvbmZpZztcclxuXHRcdH1cclxuXHRcdGlmIChzZXR0aW5nc1JlY29yZC5pbWFnZUluc2VydGVyKSB7XHJcblx0XHRcdGRlbGV0ZSBzZXR0aW5nc1JlY29yZC5pbWFnZUluc2VydGVyO1xyXG5cdFx0fVxyXG5cdFx0c2V0dGluZ3MuaW1hZ2VNYW5hZ2VyID0gdGhpcy5zdGF0ZS5pbWFnZU1hbmFnZXI7XHJcblx0XHRzZXR0aW5ncy5ob21lQmFzZSA9IHRoaXMuc3RhdGUuaG9tZUJhc2U7XHJcblx0XHRzZXR0aW5ncy5leHBsb3JlckZvY3VzID0gdGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzO1xyXG5cdFx0c2V0dGluZ3MuaWdub3JlQ29uZmlnID0gdGhpcy5zdGF0ZS5pZ25vcmVDb25maWc7XHJcblx0XHRzZXR0aW5ncy5naXRDb25maWcgPSB7IC4uLnRoaXMuc3RhdGUuZ2l0Q29uZmlnIH07XHJcblx0XHQvLyBDQVVUSU9OOiBOZXZlciBwZXJzaXN0IHRoZSBQQVQgdG8gZGF0YS5qc29uIVxyXG5cdFx0ZGVsZXRlIHNldHRpbmdzLmdpdENvbmZpZy5wYXQ7XHJcblxyXG5cdFx0Ly8gU3luYyBpbWFnZSBwcm9wZXJ0eSB3aXRoIEltYWdlIE1hbmFnZXJcclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IGltYWdlTWFuYWdlckNvbmZpZ3VyYXRvciA9IG5ldyBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3IodGhpcy5wbHVnaW4uYXBwKTtcclxuXHRcdFx0YXdhaXQgaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yLnJlc29sdmVBbmRTeW5jSW1hZ2VQcm9wZXJ0eSh0aGlzLnN0YXRlKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignV2l6YXJkU3RhdGVNYW5hZ2VyOiBGYWlsZWQgdG8gc3luYyBpbWFnZSBwcm9wZXJ0eSB3aXRoIEltYWdlIE1hbmFnZXI6JywgZXJyb3IpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlV2l6YXJkU3RlcCB7XHJcblx0cHJvdGVjdGVkIGFwcDogQXBwO1xyXG5cdHByb3RlY3RlZCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQ7XHJcblx0cHJvdGVjdGVkIHN0YXRlOiBXaXphcmRTdGF0ZTtcclxuXHRwcm90ZWN0ZWQgb25OZXh0OiAoKSA9PiB2b2lkO1xyXG5cdHByb3RlY3RlZCBvbkJhY2s6ICgpID0+IHZvaWQ7XHJcblx0cHJvdGVjdGVkIG9uQ2FuY2VsOiAoKSA9PiB2b2lkO1xyXG5cdHB1YmxpYyBzaG93TmV4dEJ1dHRvbjogYm9vbGVhbiA9IHRydWU7XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0YXBwOiBBcHAsXHJcblx0XHRjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXHJcblx0XHRzdGF0ZTogV2l6YXJkU3RhdGUsXHJcblx0XHRvbk5leHQ6ICgpID0+IHZvaWQsXHJcblx0XHRvbkJhY2s6ICgpID0+IHZvaWQsXHJcblx0XHRvbkNhbmNlbDogKCkgPT4gdm9pZFxyXG5cdCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0XHR0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XHJcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XHJcblx0XHR0aGlzLm9uTmV4dCA9IG9uTmV4dDtcclxuXHRcdHRoaXMub25CYWNrID0gb25CYWNrO1xyXG5cdFx0dGhpcy5vbkNhbmNlbCA9IG9uQ2FuY2VsO1xyXG5cdH1cclxuXHJcblx0YWJzdHJhY3QgZGlzcGxheSgpOiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcclxuXHRhYnN0cmFjdCB2YWxpZGF0ZSgpOiBib29sZWFuO1xyXG5cdGFic3RyYWN0IGdldFRpdGxlKCk6IHN0cmluZztcclxuXHRhYnN0cmFjdCBnZXREZXNjcmlwdGlvbigpOiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgYWJzb2x1dGUgcGF0aCB0byByZWxhdGl2ZSBwYXRoIGZyb20gdmF1bHQgcm9vdFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCB0b1JlbGF0aXZlUGF0aChhYnNvbHV0ZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XHJcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHRcdGlmICghdmF1bHRQYXRoKSB7XHJcblx0XHRcdHJldHVybiBhYnNvbHV0ZVBhdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdmF1bHROb3JtYWxpemVkID0gdmF1bHRQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5yZXBsYWNlKC9cXC8kLywgJycpO1xyXG5cdFx0Y29uc3QgYWJzb2x1dGVOb3JtYWxpemVkID0gYWJzb2x1dGVQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5yZXBsYWNlKC9cXC8kLywgJycpO1xyXG5cclxuXHRcdC8vIElmIHRoZSBhYnNvbHV0ZSBwYXRoIGlzIHdpdGhpbiB0aGUgdmF1bHQsIHJldHVybiByZWxhdGl2ZSBwYXRoXHJcblx0XHRpZiAoYWJzb2x1dGVOb3JtYWxpemVkLnN0YXJ0c1dpdGgodmF1bHROb3JtYWxpemVkKSkge1xyXG5cdFx0XHRjb25zdCByZWxhdGl2ZSA9IGFic29sdXRlTm9ybWFsaXplZC5zbGljZSh2YXVsdE5vcm1hbGl6ZWQubGVuZ3RoKTtcclxuXHRcdFx0Ly8gUmVtb3ZlIGxlYWRpbmcgcGF0aCBzZXBhcmF0b3JcclxuXHRcdFx0Y29uc3QgdHJpbW1lZFJlbGF0aXZlID0gcmVsYXRpdmUuc3RhcnRzV2l0aCgnLycpID8gcmVsYXRpdmUuc2xpY2UoMSkgOiByZWxhdGl2ZTtcclxuXHRcdFx0cmV0dXJuIHRyaW1tZWRSZWxhdGl2ZSB8fCAnLic7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgcGF0aCBpcyBvdXRzaWRlIHZhdWx0LCBjYWxjdWxhdGUgcmVsYXRpdmUgcGF0aCBtYW51YWxseVxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gU3BsaXQgcGF0aHMgaW50byBwYXJ0c1xyXG5cdFx0XHRjb25zdCB2YXVsdFBhcnRzID0gdmF1bHROb3JtYWxpemVkLnNwbGl0KCcvJykuZmlsdGVyKHAgPT4gcCk7XHJcblx0XHRcdGNvbnN0IGFic29sdXRlUGFydHMgPSBhYnNvbHV0ZU5vcm1hbGl6ZWQuc3BsaXQoJy8nKS5maWx0ZXIocCA9PiBwKTtcclxuXHJcblx0XHRcdC8vIEZpbmQgY29tbW9uIHByZWZpeFxyXG5cdFx0XHRsZXQgY29tbW9uTGVuZ3RoID0gMDtcclxuXHRcdFx0d2hpbGUgKGNvbW1vbkxlbmd0aCA8IHZhdWx0UGFydHMubGVuZ3RoICYmIGNvbW1vbkxlbmd0aCA8IGFic29sdXRlUGFydHMubGVuZ3RoICYmIHZhdWx0UGFydHNbY29tbW9uTGVuZ3RoXSA9PT0gYWJzb2x1dGVQYXJ0c1tjb21tb25MZW5ndGhdKSB7XHJcblx0XHRcdFx0Y29tbW9uTGVuZ3RoKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSByZWxhdGl2ZSBwYXRoXHJcblx0XHRcdGNvbnN0IHVwTGV2ZWxzID0gdmF1bHRQYXJ0cy5sZW5ndGggLSBjb21tb25MZW5ndGg7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlUGFydHMgPSBhYnNvbHV0ZVBhcnRzLnNsaWNlKGNvbW1vbkxlbmd0aCk7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlID0gKHVwTGV2ZWxzID4gMCA/ICcuLi8nLnJlcGVhdCh1cExldmVscykgOiAnJykgKyByZWxhdGl2ZVBhcnRzLmpvaW4oJy8nKTtcclxuXHRcdFx0cmV0dXJuIHJlbGF0aXZlIHx8IGFic29sdXRlUGF0aDtcclxuXHRcdH0gY2F0Y2gge1xyXG5cdFx0XHQvLyBJZiByZWxhdGl2ZSBwYXRoIGNhbGN1bGF0aW9uIGZhaWxzLCByZXR1cm4gYWJzb2x1dGUgcGF0aFxyXG5cdFx0XHRyZXR1cm4gYWJzb2x1dGVQYXRoO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wc1xuICovXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuXHR9XG59XG5cbmludGVyZmFjZSBPYnNpZGlhblNldHRpbmcge1xuXHRvcGVuKCk6IHZvaWQ7XG5cdG9wZW5UYWJCeUlkKGlkOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgT2JzaWRpYW5BcHBXaXRoU2V0dGluZyB7XG5cdHNldHRpbmc6IE9ic2lkaWFuU2V0dGluZztcbn1cblxuZXhwb3J0IGNsYXNzIFdlbGNvbWVTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1dlbGNvbWUgdG8gVmF1bHQgQ01TJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcblx0XHRcdHRleHQ6ICdUaGlzIHdpemFyZCB3aWxsIGhlbHAgeW91IGNvbmZpZ3VyZSBWYXVsdCBDTVMgZm9yIHlvdXIgcHJvamVjdC4gV2VcXCdsbCBndWlkZSB5b3UgdGhyb3VnaDonXG5cdFx0fSk7XG5cblx0XHRjb25zdCBsaXN0ID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3VsJyk7XG5cdFx0bGlzdC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdEZXRlY3RpbmcgeW91ciBBc3RybyBwcm9qZWN0IHN0cnVjdHVyZScgfSk7XG5cdFx0bGlzdC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdJZGVudGlmeWluZyB5b3VyIGNvbnRlbnQgdHlwZXMnIH0pO1xuXHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnTWFwcGluZyBmcm9udG1hdHRlciBwcm9wZXJ0aWVzJyB9KTtcblx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ0NvbmZpZ3VyaW5nIHBsdWdpbnMgYW5kIHRoZW1lcycgfSk7XG5cdFx0bGlzdC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdTZXR0aW5nIHVwIEhvbWUgQmFzZSBjb250ZW50IHZpZXdzJyB9KTtcblx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ0NvbmZpZ3VyaW5nIEFzdHJvIENvbXBvc2VyIGFuZCBTRU8gcGx1Z2lucycgfSk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXG5cdFx0XHR0ZXh0OiAnQ2hvb3NlIGFuIG9wdGlvbiB0byBjb250aW51ZTonIFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgYnV0dG9uQ29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCd3aXphcmQtd2VsY29tZS1idXR0b25zJyk7XG5cdFx0c2V0Q3NzUHJvcHMoYnV0dG9uQ29udGFpbmVyLCB7XG5cdFx0XHRkaXNwbGF5OiAnZmxleCcsXG5cdFx0XHRnYXA6ICcxMHB4Jyxcblx0XHRcdG1hcmdpblRvcDogJzIwcHgnXG5cdFx0fSk7XG5cblx0XHRjb25zdCBnZXRTdGFydGVkQnRuID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7XG5cdFx0XHR0ZXh0OiAnR2V0IHN0YXJ0ZWQnLFxuXHRcdFx0Y2xzOiAnbW9kLWJ1dHRvbiBtb2QtY3RhJ1xuXHRcdH0pO1xuXHRcdGdldFN0YXJ0ZWRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG5cdFx0XHR0aGlzLm9uTmV4dCgpO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3Qgc2VsZWN0UHJlc2V0QnRuID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7XG5cdFx0XHR0ZXh0OiAnU2VsZWN0IHByZXNldCcsXG5cdFx0XHRjbHM6ICdtb2QtYnV0dG9uJ1xuXHRcdH0pO1xuXHRcdHNlbGVjdFByZXNldEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcblx0XHRcdC8vIENsb3NlIG1vZGFsIGFuZCBvcGVuIHNldHRpbmdzIHRhYlxuXHRcdFx0dGhpcy5vbkNhbmNlbCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBhcHBXaXRoU2V0dGluZyA9IHRoaXMuYXBwIGFzIHVua25vd24gYXMgT2JzaWRpYW5BcHBXaXRoU2V0dGluZztcblx0XHRcdGlmIChhcHBXaXRoU2V0dGluZy5zZXR0aW5nICYmIHR5cGVvZiBhcHBXaXRoU2V0dGluZy5zZXR0aW5nLm9wZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0YXBwV2l0aFNldHRpbmcuc2V0dGluZy5vcGVuKCk7XG5cdFx0XHRcdGlmICh0eXBlb2YgYXBwV2l0aFNldHRpbmcuc2V0dGluZy5vcGVuVGFiQnlJZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlblRhYkJ5SWQoJ3ZhdWx0LWNtcycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdXZWxjb21lJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdJbnRyb2R1Y3Rpb24gdG8gVmF1bHQgQ01TIHNldHVwJztcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZywgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzIChtYXkgbm90IGJlIGluIHR5cGVzIHlldClcbmZ1bmN0aW9uIHNldENzc1Byb3BzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG5cdH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBwYXRoIG9wZXJhdGlvbnNcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzIC0tIE5vZGUuanMgbW9kdWxlIG5lZWRlZCBmb3IgZmlsZSBvcGVyYXRpb25zXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBQcm9qZWN0RGV0ZWN0b3IgfSBmcm9tICcuLi8uLi91dGlscy9Qcm9qZWN0RGV0ZWN0b3InO1xuaW1wb3J0IHsgTWR4RGV0ZWN0b3IgfSBmcm9tICcuLi8uLi91dGlscy9NZHhEZXRlY3Rvcic7XG5pbXBvcnQgeyBDb250ZW50VHlwZURldGVjdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29udGVudFR5cGVEZXRlY3Rvcic7XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0RGV0ZWN0aW9uU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcblx0cHJpdmF0ZSBwcm9qZWN0RGV0ZWN0b3I6IFByb2plY3REZXRlY3Rvcjtcblx0cHJpdmF0ZSBtZHhEZXRlY3RvcjogTWR4RGV0ZWN0b3I7XG5cdHByaXZhdGUgY29udGVudFR5cGVEZXRlY3RvcjogQ29udGVudFR5cGVEZXRlY3Rvcjtcblx0cHJpdmF0ZSBkZXRlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwcml2YXRlIHByb2plY3RSb290RGlzcGxheTogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBjb25maWdGaWxlRGlzcGxheTogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xuXHRcdHN1cGVyKGFwcCwgY29udGFpbmVyRWwsIHN0YXRlLCBvbk5leHQsIG9uQmFjaywgb25DYW5jZWwpO1xuXHRcdHRoaXMucHJvamVjdERldGVjdG9yID0gbmV3IFByb2plY3REZXRlY3RvcihhcHApO1xuXHRcdHRoaXMubWR4RGV0ZWN0b3IgPSBuZXcgTWR4RGV0ZWN0b3IoYXBwKTtcblx0XHR0aGlzLmNvbnRlbnRUeXBlRGV0ZWN0b3IgPSBuZXcgQ29udGVudFR5cGVEZXRlY3RvcihhcHApO1xuXHR9XG5cblx0YXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcC5kaXNwbGF5OiBjYWxsZWQnKTtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBoYXZlIHNhdmVkIHByb2plY3QgZGV0ZWN0aW9uIHZhbHVlc1xuXHRcdGNvbnN0IGhhc1NhdmVkVmFsdWVzID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdCAmJiB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LmNvbmZpZ0ZpbGVQYXRoO1xuXHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwLmRpc3BsYXk6IGhhc1NhdmVkVmFsdWVzID0nLCBoYXNTYXZlZFZhbHVlcyk7XG5cdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAuZGlzcGxheTogY3VycmVudCBlbmFibGVNZHhTdXBwb3J0ID0nLCB0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQpO1xuXG5cdFx0aWYgKCFoYXNTYXZlZFZhbHVlcykge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUHJvamVjdCBkZXRlY3Rpb24nIH0pO1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHRcdHRleHQ6ICdEZXRlY3RpbmcgeW91ciBBc3RybyBwcm9qZWN0IHN0cnVjdHVyZS4uLidcblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnByb2plY3REZXRlY3Rvci5kZXRlY3RQcm9qZWN0KCk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcC5kaXNwbGF5OiBkZXRlY3Rpb24gcmVzdWx0ID0nLCByZXN1bHQpO1xuXG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdC8vIFN0b3JlIGFic29sdXRlIHBhdGhzIGZvciByZWxpYWJpbGl0eSB3aXRoaW4gaW50ZXJuYWwgbG9naWNcblx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uID0ge1xuXHRcdFx0XHRcdHByb2plY3RSb290OiByZXN1bHQucHJvamVjdFJvb3QsXG5cdFx0XHRcdFx0Y29uZmlnRmlsZVBhdGg6IHJlc3VsdC5jb25maWdGaWxlUGF0aCxcblx0XHRcdFx0XHR2YXVsdExvY2F0aW9uOiByZXN1bHQudmF1bHRMb2NhdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcC5kaXNwbGF5OiBzZXQgcHJvamVjdERldGVjdGlvbiA9JywgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcblx0XHRcdFx0dGhpcy5kZXRlY3RlZCA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBObyBkZXRlY3Rpb24sIHNob3cgbWFudWFsIHNlbGVjdGlvblxuXHRcdFx0XHR0aGlzLmRldGVjdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVzZSBzYXZlZCB2YWx1ZXNcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwLmRpc3BsYXk6IHVzaW5nIHNhdmVkIHByb2plY3REZXRlY3Rpb24gPScsIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbik7XG5cdFx0XHR0aGlzLmRldGVjdGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uICYmICh0aGlzLmRldGVjdGVkIHx8IGhhc1NhdmVkVmFsdWVzKSkge1xuXG5cdFx0XHQvLyBBZGQgc2xpZ2h0IGRlbGF5IGJlZm9yZSBzaG93aW5nIGRldGVjdGVkIGNvbnRlbnQgKGxpa2UgYXN0cm8tbW9kdWxhci1zZXR0aW5ncylcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblxuXHRcdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3QgZGV0ZWN0ZWQnIH0pO1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHRcdHRleHQ6ICdQcm9qZWN0IHN0cnVjdHVyZSBkZXRlY3RlZCBzdWNjZXNzZnVsbHkuIFlvdSBjYW4gbW9kaWZ5IHRoZSBwYXRocyBiZWxvdyBpZiBuZWVkZWQsIHRoZW4gY2xpY2sgXCJOZXh0XCIgdG8gY29udGludWUuJ1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFByb2plY3QgUm9vdCBwaWNrZXIgKHdpdGggYnJvd3NlIGJ1dHRvbiBldmVuIHdoZW4gZGV0ZWN0ZWQpXG5cdFx0XHRjb25zdCBwcm9qZWN0Um9vdFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ1Byb2plY3Qgcm9vdCcpXG5cdFx0XHRcdC5zZXREZXNjKCdTZWxlY3QgdGhlIGZvbGRlciBjb250YWluaW5nIHlvdXIgQXN0cm8gcHJvamVjdCByb290Jyk7XG5cblx0XHRcdC8vIERpc3BsYXkgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdHRoaXMucHJvamVjdFJvb3REaXNwbGF5ID0gcHJvamVjdFJvb3RTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoe1xuXHRcdFx0XHR0ZXh0OiB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QgPyB0aGlzLnRvUmVsYXRpdmVQYXRoKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCkgOiAnTm8gZm9sZGVyIHNlbGVjdGVkJyxcblx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLXBhdGgtZGlzcGxheSdcblx0XHRcdH0pO1xuXHRcdFx0c2V0Q3NzUHJvcHModGhpcy5wcm9qZWN0Um9vdERpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW5vcm1hbCknIH0pO1xuXG5cdFx0XHRwcm9qZWN0Um9vdFNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0Jyb3dzZS4uLicpXG5cdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0KCgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGVkUGF0aCA9IHRoaXMuc2VsZWN0Rm9sZGVyKCk7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0ZWRQYXRoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiEucHJvamVjdFJvb3QgPSBzZWxlY3RlZFBhdGg7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnByb2plY3RSb290RGlzcGxheSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvamVjdFJvb3REaXNwbGF5LnRleHRDb250ZW50ID0gdGhpcy50b1JlbGF0aXZlUGF0aChzZWxlY3RlZFBhdGgpO1xuXHRcdFx0XHRcdFx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgZGV0ZWN0ZWQgZmxhZyBpZiB1c2VyIGNoYW5nZXNcblx0XHRcdFx0XHRcdFx0dGhpcy5kZXRlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gQ29uZmlnIEZpbGUgcGlja2VyICh3aXRoIGJyb3dzZSBidXR0b24gZXZlbiB3aGVuIGRldGVjdGVkKVxuXHRcdFx0Y29uc3QgY29uZmlnRmlsZVNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ0NvbmZpZyBmaWxlJylcblx0XHRcdFx0LnNldERlc2MoJ1NlbGVjdCB5b3VyIEFzdHJvIGNvbmZpZyBmaWxlIChhc3Ryby5jb25maWcubWpzLCBhc3Ryby5jb25maWcuanMsIHNyYy9jb25maWcudHMsIGV0Yy4pJyk7XG5cblx0XHRcdC8vIERpc3BsYXkgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdHRoaXMuY29uZmlnRmlsZURpc3BsYXkgPSBjb25maWdGaWxlU2V0dGluZy5kZXNjRWwuY3JlYXRlRGl2KHtcblx0XHRcdFx0dGV4dDogdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoID8gdGhpcy50b1JlbGF0aXZlUGF0aCh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGgpIDogJ05vIGZpbGUgc2VsZWN0ZWQnLFxuXHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtcGF0aC1kaXNwbGF5J1xuXHRcdFx0fSk7XG5cdFx0XHRzZXRDc3NQcm9wcyh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblxuXHRcdFx0Y29uZmlnRmlsZVNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0Jyb3dzZS4uLicpXG5cdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0KCgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGRlZmF1bHRQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdCB8fCB0aGlzLmdldFZhdWx0UGF0aCgpO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRQYXRoID0gdGhpcy5zZWxlY3RDb25maWdGaWxlKGRlZmF1bHRQYXRoKTtcblx0XHRcdFx0XHRcdGlmIChzZWxlY3RlZFBhdGgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uIS5jb25maWdGaWxlUGF0aCA9IHNlbGVjdGVkUGF0aDtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuY29uZmlnRmlsZURpc3BsYXkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LnRleHRDb250ZW50ID0gdGhpcy50b1JlbGF0aXZlUGF0aChzZWxlY3RlZFBhdGgpO1xuXHRcdFx0XHRcdFx0XHRcdHNldENzc1Byb3BzKHRoaXMuY29uZmlnRmlsZURpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW5vcm1hbCknIH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIFVwZGF0ZSBkZXRlY3RlZCBmbGFnIGlmIHVzZXIgY2hhbmdlc1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRldGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0XHQvLyBNRFggU3VwcG9ydCBjaGVja2JveFxuXHRcdFx0Ly8gQXV0by1kZXRlY3QgTURYIGZpbGVzIGlmIHByb2plY3QgaXMgZGV0ZWN0ZWRcblx0XHRcdGxldCBhdXRvRGV0ZWN0ZWRNZHggPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogU3RhcnRpbmcgTURYIGRldGVjdGlvbicpO1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBwcm9qZWN0RGV0ZWN0aW9uID0nLCB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBleGlzdGluZyBjb250ZW50VHlwZXMgPScsIHRoaXMuc3RhdGUuY29udGVudFR5cGVzLmxlbmd0aCk7XG5cblx0XHRcdFx0XHQvLyBHZXQgY29udGVudCB0eXBlcyAtIHVzZSBleGlzdGluZyBvbmVzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGRldGVjdCB0aGVtXG5cdFx0XHRcdFx0bGV0IGNvbnRlbnRUeXBlc1RvVXNlID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXM7XG5cdFx0XHRcdFx0aWYgKGNvbnRlbnRUeXBlc1RvVXNlLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IE5vIGNvbnRlbnQgdHlwZXMgaW4gc3RhdGUsIGRldGVjdGluZyBub3cuLi4nKTtcblx0XHRcdFx0XHRcdC8vIENvbnRlbnQgdHlwZXMgbm90IGRldGVjdGVkIHlldCwgZGV0ZWN0IHRoZW0gbm93IGZvciBNRFggc2Nhbm5pbmdcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlc1RvVXNlID0gdGhpcy5jb250ZW50VHlwZURldGVjdG9yLmRldGVjdENvbnRlbnRUeXBlcyh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IERldGVjdGVkIGNvbnRlbnQgdHlwZXMgPScsIGNvbnRlbnRUeXBlc1RvVXNlLmxlbmd0aCwgY29udGVudFR5cGVzVG9Vc2UubWFwKGN0ID0+IGAke2N0Lm5hbWV9ICgke2N0LmZvbGRlcn0sIGVuYWJsZWQ6ICR7Y3QuZW5hYmxlZH0pYCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogVXNpbmcgZXhpc3RpbmcgY29udGVudCB0eXBlcyA9JywgY29udGVudFR5cGVzVG9Vc2UubWFwKGN0ID0+IGAke2N0Lm5hbWV9ICgke2N0LmZvbGRlcn0sIGVuYWJsZWQ6ICR7Y3QuZW5hYmxlZH0pYCkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChjb250ZW50VHlwZXNUb1VzZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogQ2FsbGluZyBtZHhEZXRlY3Rvci5kZXRlY3RNZHhVc2FnZS4uLicpO1xuXHRcdFx0XHRcdFx0YXV0b0RldGVjdGVkTWR4ID0gdGhpcy5tZHhEZXRlY3Rvci5kZXRlY3RNZHhVc2FnZShcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHRjb250ZW50VHlwZXNUb1VzZVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBNRFggZGV0ZWN0aW9uIHJlc3VsdCA9JywgYXV0b0RldGVjdGVkTWR4KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IE5vIGNvbnRlbnQgdHlwZXMgdG8gc2NhbicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHQvLyBJZiBkZXRlY3Rpb24gZmFpbHMsIGRlZmF1bHQgdG8gZmFsc2Vcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogTURYIGRldGVjdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuXHRcdFx0XHRcdGF1dG9EZXRlY3RlZE1keCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogTm8gcHJvamVjdERldGVjdGlvbiwgc2tpcHBpbmcgTURYIGRldGVjdGlvbicpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbHdheXMgdXBkYXRlIGVuYWJsZU1keFN1cHBvcnQgd2l0aCBhdXRvLWRldGVjdGlvbiByZXN1bHQgaWYgaXQgaGFzbid0IGJlZW4gc2V0L2RldGVjdGVkIHlldFxuXHRcdFx0Ly8gVGhpcyBlbnN1cmVzIGRldGVjdGlvbiBydW5zIG9uIGZpcnN0IHJ1biBidXQgcmVtZW1iZXJzIHVzZXIncyBtYW51YWwgY2hvaWNlIHRoZXJlYWZ0ZXJcblx0XHRcdGlmICh0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPSBhdXRvRGV0ZWN0ZWRNZHg7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBTZXQgZW5hYmxlTWR4U3VwcG9ydCB0bycsIGF1dG9EZXRlY3RlZE1keCwgJ2Jhc2VkIG9uIGF1dG8tZGV0ZWN0aW9uJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogZW5hYmxlTWR4U3VwcG9ydCBhbHJlYWR5IHNldCB0bycsIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCwgJywgc2tpcHBpbmcgYXV0by1kZXRlY3Rpb24gb3ZlcndyaXRlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1keFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ01EWCBmaWxlIHN1cHBvcnQnKVxuXHRcdFx0XHQuc2V0RGVzYygnRW5hYmxlIE1EWCBmaWxlIHN1cHBvcnQgZm9yIEFzdHJvIENvbXBvc2VyLCBQcm9wZXJ0eSBPdmVyIEZpbGUgTmFtZSwgU0VPLCBhbmQgVUkgVHdlYWtlciBwbHVnaW5zLicpO1xuXG5cdFx0XHRtZHhTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xuXHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID8/IGZhbHNlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBTaG93IGF1dG8tZGV0ZWN0aW9uIG1lc3NhZ2UgaWYgTURYIHdhcyBkZXRlY3RlZFxuXHRcdFx0XHRpZiAoYXV0b0RldGVjdGVkTWR4ICYmIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCkge1xuXHRcdFx0XHRcdGNvbnN0IGF1dG9EZXRlY3RNc2cgPSBtZHhTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoe1xuXHRcdFx0XHRcdFx0dGV4dDogJ01EWCBmaWxlcyBkZXRlY3RlZCBpbiBjb250ZW50IGZvbGRlcnMnLFxuXHRcdFx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLWF1dG8tZGV0ZWN0LW1zZydcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRDc3NQcm9wcyhhdXRvRGV0ZWN0TXNnLCB7XG5cdFx0XHRcdFx0XHRjb2xvcjogJ3ZhcigtLXRleHQtbXV0ZWQpJyxcblx0XHRcdFx0XHRcdGZvbnRTaXplOiAnMC45ZW0nLFxuXHRcdFx0XHRcdFx0bWFyZ2luVG9wOiAnNHB4J1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRXh0ZW5kZWQgRmlsZSBUeXBlcyBzdXBwb3J0IChKU09OLCBBc3Rybylcblx0XHRcdGNvbnN0IGV4dGVuZGVkRmlsZVR5cGVzU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnRXh0ZW5kZWQgZmlsZSB0eXBlcycpXG5cdFx0XHRcdC5zZXREZXNjKCdFbmFibGUgc3VwcG9ydCB0byB2aWV3LCBlZGl0LCBhbmQgY3JlYXRlIC5qc29uIGFuZCAuYXN0cm8gZmlsZXMgdmlhIHRoZSBEYXRhIEZpbGVzIEVkaXRvciBwbHVnaW4uJyk7XG5cblx0XHRcdGV4dGVuZGVkRmlsZVR5cGVzU2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHtcblx0XHRcdFx0dG9nZ2xlXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMgPz8gZmFsc2UpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMgPSB2YWx1ZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUHJvamVjdCBkZXRlY3Rpb24gZmFpbGVkJyB9KTtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0XHR0ZXh0OiAnQ291bGQgbm90IGRldGVjdCBBc3RybyBwcm9qZWN0IHN0cnVjdHVyZS4gUGxlYXNlIHNlbGVjdCB5b3VyIEFzdHJvIHByb2plY3Qgcm9vdCBhbmQgY29uZmlnIGZpbGUgbWFudWFsbHkuJ1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgc3RhdGUgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIXRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24gPSB7XG5cdFx0XHRcdFx0cHJvamVjdFJvb3Q6ICcnLFxuXHRcdFx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiAnJyxcblx0XHRcdFx0XHR2YXVsdExvY2F0aW9uOiAncm9vdCdcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJvamVjdCBSb290IHBpY2tlclxuXHRcdFx0Y29uc3QgcHJvamVjdFJvb3RTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdQcm9qZWN0IHJvb3QnKVxuXHRcdFx0XHQuc2V0RGVzYygnU2VsZWN0IHRoZSBmb2xkZXIgY29udGFpbmluZyB5b3VyIEFzdHJvIHByb2plY3Qgcm9vdCcpO1xuXG5cdFx0XHQvLyBEaXNwbGF5IGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHR0aGlzLnByb2plY3RSb290RGlzcGxheSA9IHByb2plY3RSb290U2V0dGluZy5kZXNjRWwuY3JlYXRlRGl2KHtcblx0XHRcdFx0dGV4dDogdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290ID8gdGhpcy50b1JlbGF0aXZlUGF0aCh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpIDogJ05vIGZvbGRlciBzZWxlY3RlZCcsXG5cdFx0XHRcdGNsczogJ3ZhdWx0LWNtcy1wYXRoLWRpc3BsYXknXG5cdFx0XHR9KTtcblx0XHRcdGlmICh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpIHtcblx0XHRcdFx0c2V0Q3NzUHJvcHModGhpcy5wcm9qZWN0Um9vdERpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW5vcm1hbCknIH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0Q3NzUHJvcHModGhpcy5wcm9qZWN0Um9vdERpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW11dGVkKScgfSk7XG5cdFx0XHR9XG5cblx0XHRcdHByb2plY3RSb290U2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnQnJvd3NlLi4uJylcblx0XHRcdFx0LnNldEN0YSgpXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRQYXRoID0gdGhpcy5zZWxlY3RGb2xkZXIoKTtcblx0XHRcdFx0XHRcdGlmIChzZWxlY3RlZFBhdGgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uIS5wcm9qZWN0Um9vdCA9IHNlbGVjdGVkUGF0aDtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMucHJvamVjdFJvb3REaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wcm9qZWN0Um9vdERpc3BsYXkudGV4dENvbnRlbnQgPSB0aGlzLnRvUmVsYXRpdmVQYXRoKHNlbGVjdGVkUGF0aCk7XG5cdFx0XHRcdFx0XHRcdFx0c2V0Q3NzUHJvcHModGhpcy5wcm9qZWN0Um9vdERpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW5vcm1hbCknIH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0XHQvLyBDb25maWcgRmlsZSBwaWNrZXJcblx0XHRcdGNvbnN0IGNvbmZpZ0ZpbGVTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdDb25maWcgZmlsZScpXG5cdFx0XHRcdC5zZXREZXNjKCdTZWxlY3QgeW91ciBBc3RybyBjb25maWcgZmlsZSAoYXN0cm8uY29uZmlnLm1qcywgYXN0cm8uY29uZmlnLmpzLCBzcmMvY29uZmlnLnRzLCBldGMuKScpO1xuXG5cdFx0XHQvLyBEaXNwbGF5IGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHR0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5ID0gY29uZmlnRmlsZVNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdih7XG5cdFx0XHRcdHRleHQ6IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aCA/IHRoaXMudG9SZWxhdGl2ZVBhdGgodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoKSA6ICdObyBmaWxlIHNlbGVjdGVkJyxcblx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLXBhdGgtZGlzcGxheSdcblx0XHRcdH0pO1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldENzc1Byb3BzKHRoaXMuY29uZmlnRmlsZURpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW11dGVkKScgfSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbmZpZ0ZpbGVTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdCcm93c2UuLi4nKVxuXHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWZhdWx0UGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3QgfHwgdGhpcy5nZXRWYXVsdFBhdGgoKTtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGVkUGF0aCA9IHRoaXMuc2VsZWN0Q29uZmlnRmlsZShkZWZhdWx0UGF0aCk7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0ZWRQYXRoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiEuY29uZmlnRmlsZVBhdGggPSBzZWxlY3RlZFBhdGg7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jb25maWdGaWxlRGlzcGxheS50ZXh0Q29udGVudCA9IHRoaXMudG9SZWxhdGl2ZVBhdGgoc2VsZWN0ZWRQYXRoKTtcblx0XHRcdFx0XHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gTURYIFN1cHBvcnQgY2hlY2tib3ggKGZvciBtYW51YWwgcHJvamVjdCBzZWxlY3Rpb24pXG5cdFx0XHQvLyBUcnkgdG8gYXV0by1kZXRlY3QgTURYIGlmIHdlIGhhdmUgcHJvamVjdCBkZXRlY3Rpb25cblx0XHRcdGxldCBhdXRvRGV0ZWN0ZWRNZHggPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24gJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290ICYmIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0XHQvLyBUcnkgdG8gZGV0ZWN0IGNvbnRlbnQgdHlwZXMgZmlyc3Rcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZENvbnRlbnRUeXBlcyA9IHRoaXMuY29udGVudFR5cGVEZXRlY3Rvci5kZXRlY3RDb250ZW50VHlwZXModGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcblx0XHRcdFx0XHRpZiAoZGV0ZWN0ZWRDb250ZW50VHlwZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0YXV0b0RldGVjdGVkTWR4ID0gdGhpcy5tZHhEZXRlY3Rvci5kZXRlY3RNZHhVc2FnZShcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHRkZXRlY3RlZENvbnRlbnRUeXBlc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIElmIGRldGVjdGlvbiBmYWlscywgZGVmYXVsdCB0byBmYWxzZVxuXHRcdFx0XHRcdGF1dG9EZXRlY3RlZE1keCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsd2F5cyB1cGRhdGUgZW5hYmxlTWR4U3VwcG9ydCB3aXRoIGF1dG8tZGV0ZWN0aW9uIHJlc3VsdCBpZiBpdCBoYXNuJ3QgYmVlbiBzZXQvZGV0ZWN0ZWQgeWV0XG5cdFx0XHQvLyBUaGlzIGVuc3VyZXMgZGV0ZWN0aW9uIHJ1bnMgb24gZmlyc3QgcnVuIGJ1dCByZW1lbWJlcnMgdXNlcidzIG1hbnVhbCBjaG9pY2UgdGhlcmVhZnRlclxuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9IGF1dG9EZXRlY3RlZE1keDtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAgKG1hbnVhbCk6IFNldCBlbmFibGVNZHhTdXBwb3J0IHRvJywgYXV0b0RldGVjdGVkTWR4LCAnYmFzZWQgb24gYXV0by1kZXRlY3Rpb24nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwIChtYW51YWwpOiBlbmFibGVNZHhTdXBwb3J0IGFscmVhZHkgc2V0IHRvJywgdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0LCAnLCBza2lwcGluZyBhdXRvLWRldGVjdGlvbiBvdmVyd3JpdGUnKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbWR4U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnTURYIGZpbGUgc3VwcG9ydCcpXG5cdFx0XHRcdC5zZXREZXNjKCdFbmFibGUgTURYIGZpbGUgc3VwcG9ydCBmb3IgQXN0cm8gQ29tcG9zZXIsIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lLCBTRU8sIGFuZCBVSSBUd2Vha2VyIHBsdWdpbnMuJyk7XG5cblx0XHRcdG1keFNldHRpbmcuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB7XG5cdFx0XHRcdHRvZ2dsZVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPz8gZmFsc2UpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9IHZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFNob3cgYXV0by1kZXRlY3Rpb24gbWVzc2FnZSBpZiBNRFggd2FzIGRldGVjdGVkXG5cdFx0XHRcdGlmIChhdXRvRGV0ZWN0ZWRNZHggJiYgdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0KSB7XG5cdFx0XHRcdFx0Y29uc3QgYXV0b0RldGVjdE1zZyA9IG1keFNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdih7XG5cdFx0XHRcdFx0XHR0ZXh0OiAnTURYIGZpbGVzIGRldGVjdGVkIGluIGNvbnRlbnQgZm9sZGVycycsXG5cdFx0XHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtYXV0by1kZXRlY3QtbXNnJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHNldENzc1Byb3BzKGF1dG9EZXRlY3RNc2csIHtcblx0XHRcdFx0XHRcdGNvbG9yOiAndmFyKC0tdGV4dC1tdXRlZCknLFxuXHRcdFx0XHRcdFx0Zm9udFNpemU6ICcwLjllbScsXG5cdFx0XHRcdFx0XHRtYXJnaW5Ub3A6ICc0cHgnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBFeHRlbmRlZCBGaWxlIFR5cGVzIHN1cHBvcnQgKEpTT04sIEFzdHJvKVxuXHRcdFx0Y29uc3QgZXh0ZW5kZWRGaWxlVHlwZXNTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdFeHRlbmRlZCBmaWxlIHR5cGVzJylcblx0XHRcdFx0LnNldERlc2MoJ0VuYWJsZSBzdXBwb3J0IHRvIHZpZXcsIGVkaXQsIGFuZCBjcmVhdGUgLmpzb24gYW5kIC5hc3RybyBmaWxlcyB2aWEgdGhlIERhdGEgRmlsZXMgRWRpdG9yIHBsdWdpbi4nKTtcblxuXHRcdFx0ZXh0ZW5kZWRGaWxlVHlwZXNTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xuXHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zdGF0ZS5lbmFibGVFeHRlbmRlZEZpbGVUeXBlcyA/PyBmYWxzZSlcblx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVFeHRlbmRlZEZpbGVUeXBlcyA9IHZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW4gbmF0aXZlIGZvbGRlciBwaWNrZXIgZGlhbG9nXG5cdCAqL1xuXHRwcml2YXRlIHNlbGVjdEZvbGRlcigpOiBzdHJpbmcgfCBudWxsIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gVHJ5IG11bHRpcGxlIHdheXMgdG8gYWNjZXNzIEVsZWN0cm9uIGRpYWxvZyBBUElcblx0XHRcdGxldCBkaWFsb2c6IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB8IG51bGwgPSBudWxsO1xuXG5cdFx0XHQvLyBNZXRob2QgMTogVHJ5IEBlbGVjdHJvbi9yZW1vdGUgKG5ld2VyIEVsZWN0cm9uIHZlcnNpb25zKVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0Y29uc3QgZWxlY3Ryb25SZW1vdGUgPSByZXF1aXJlKCdAZWxlY3Ryb24vcmVtb3RlJykgYXMgeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfTtcblx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb25SZW1vdGU/LmRpYWxvZyB8fCBudWxsO1xuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBNZXRob2QgMjogVHJ5IGVsZWN0cm9uLnJlbW90ZS5kaWFsb2cgKG9sZGVyIEVsZWN0cm9uIHZlcnNpb25zKVxuXHRcdFx0aWYgKCFkaWFsb2cpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgbm8tdW5kZWYgLS0gZHluYW1pYyByZXF1aXJlIGZvciBFbGVjdHJvblxuXHRcdFx0XHRcdGNvbnN0IGVsZWN0cm9uID0gKCh3aW5kb3cgYXMgeyByZXF1aXJlPzogKG1vZHVsZTogc3RyaW5nKSA9PiB1bmtub3duIH0pLnJlcXVpcmU/LignZWxlY3Ryb24nKSB8fCByZXF1aXJlKCdlbGVjdHJvbicpKSBhcyB7IHJlbW90ZT86IHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH0gfTtcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8ucmVtb3RlPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gTm90IGF2YWlsYWJsZSwgdHJ5IG5leHQgbWV0aG9kXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0aG9kIDM6IFRyeSBlbGVjdHJvbi5kaWFsb2cgZGlyZWN0bHkgKG1haW4gcHJvY2VzcywgbWF5IG5vdCB3b3JrKVxuXHRcdFx0aWYgKCFkaWFsb2cpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgbm8tdW5kZWYgLS0gZHluYW1pYyByZXF1aXJlIGZvciBFbGVjdHJvblxuXHRcdFx0XHRcdGNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKSBhcyB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9O1xuXHRcdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gTm90IGF2YWlsYWJsZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGlhbG9nIHx8IHR5cGVvZiBkaWFsb2cuc2hvd09wZW5EaWFsb2dTeW5jICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRWxlY3Ryb24gZGlhbG9nIEFQSSBub3QgYXZhaWxhYmxlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuZ2V0VmF1bHRQYXRoKCk7XG5cdFx0XHRsZXQgZGVmYXVsdFBhdGggPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290IHx8IHZhdWx0UGF0aDtcblxuXHRcdFx0Ly8gQ29udmVydCByZWxhdGl2ZSBwYXRoIHRvIGFic29sdXRlIGlmIG5lZWRlZFxuXHRcdFx0aWYgKGRlZmF1bHRQYXRoICYmICFwYXRoLmlzQWJzb2x1dGUoZGVmYXVsdFBhdGgpKSB7XG5cdFx0XHRcdGRlZmF1bHRQYXRoID0gcGF0aC5yZXNvbHZlKHZhdWx0UGF0aCwgZGVmYXVsdFBhdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBkaWFsb2cuc2hvd09wZW5EaWFsb2dTeW5jKHtcblx0XHRcdFx0dGl0bGU6ICdTZWxlY3QgQXN0cm8gUHJvamVjdCBSb290IEZvbGRlcicsXG5cdFx0XHRcdGRlZmF1bHRQYXRoOiBkZWZhdWx0UGF0aCxcblx0XHRcdFx0cHJvcGVydGllczogWydvcGVuRGlyZWN0b3J5J11cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldHVybiBwYXRoLm5vcm1hbGl6ZShyZXN1bHRbMF0pO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBvcGVuaW5nIGZvbGRlciBwaWNrZXI6JywgZXJyb3IpO1xuXHRcdFx0Ly8gU2hvdyB1c2VyLWZyaWVuZGx5IGVycm9yXG5cdFx0XHRuZXcgTm90aWNlKCdVbmFibGUgdG8gb3BlbiBmb2xkZXIgcGlja2VyLiBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgT2JzaWRpYW4gb24gZGVza3RvcC4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBPcGVuIG5hdGl2ZSBmaWxlIHBpY2tlciBkaWFsb2cgZm9yIGNvbmZpZyBmaWxlXG5cdCAqL1xuXHRwcml2YXRlIHNlbGVjdENvbmZpZ0ZpbGUoZGVmYXVsdFBhdGg/OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gVHJ5IG11bHRpcGxlIHdheXMgdG8gYWNjZXNzIEVsZWN0cm9uIGRpYWxvZyBBUElcblx0XHRcdGxldCBkaWFsb2c6IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgZmlsdGVycz86IEFycmF5PHsgbmFtZTogc3RyaW5nOyBleHRlbnNpb25zOiBzdHJpbmdbXSB9PjsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB8IG51bGwgPSBudWxsO1xuXG5cdFx0XHQvLyBNZXRob2QgMTogVHJ5IEBlbGVjdHJvbi9yZW1vdGUgKG5ld2VyIEVsZWN0cm9uIHZlcnNpb25zKVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0Y29uc3QgZWxlY3Ryb25SZW1vdGUgPSByZXF1aXJlKCdAZWxlY3Ryb24vcmVtb3RlJykgYXMgeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IGZpbHRlcnM/OiBBcnJheTx7IG5hbWU6IHN0cmluZzsgZXh0ZW5zaW9uczogc3RyaW5nW10gfT47IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfTtcblx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb25SZW1vdGU/LmRpYWxvZyB8fCBudWxsO1xuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBNZXRob2QgMjogVHJ5IGVsZWN0cm9uLnJlbW90ZS5kaWFsb2cgKG9sZGVyIEVsZWN0cm9uIHZlcnNpb25zKVxuXHRcdFx0aWYgKCFkaWFsb2cpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgbm8tdW5kZWYgLS0gZHluYW1pYyByZXF1aXJlIGZvciBFbGVjdHJvblxuXHRcdFx0XHRcdGNvbnN0IGVsZWN0cm9uID0gKCh3aW5kb3cgYXMgeyByZXF1aXJlPzogKG1vZHVsZTogc3RyaW5nKSA9PiB1bmtub3duIH0pLnJlcXVpcmU/LignZWxlY3Ryb24nKSB8fCByZXF1aXJlKCdlbGVjdHJvbicpKSBhcyB7IHJlbW90ZT86IHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBmaWx0ZXJzPzogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IGV4dGVuc2lvbnM6IHN0cmluZ1tdIH0+OyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH0gfTtcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8ucmVtb3RlPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gTm90IGF2YWlsYWJsZSwgdHJ5IG5leHQgbWV0aG9kXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0aG9kIDM6IFRyeSBlbGVjdHJvbi5kaWFsb2cgZGlyZWN0bHkgKG1haW4gcHJvY2VzcywgbWF5IG5vdCB3b3JrKVxuXHRcdFx0aWYgKCFkaWFsb2cpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgbm8tdW5kZWYgLS0gZHluYW1pYyByZXF1aXJlIGZvciBFbGVjdHJvblxuXHRcdFx0XHRcdGNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKSBhcyB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgZmlsdGVycz86IEFycmF5PHsgbmFtZTogc3RyaW5nOyBleHRlbnNpb25zOiBzdHJpbmdbXSB9PjsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9O1xuXHRcdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gTm90IGF2YWlsYWJsZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGlhbG9nIHx8IHR5cGVvZiBkaWFsb2cuc2hvd09wZW5EaWFsb2dTeW5jICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRWxlY3Ryb24gZGlhbG9nIEFQSSBub3QgYXZhaWxhYmxlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuZ2V0VmF1bHRQYXRoKCk7XG5cdFx0XHRsZXQgc3RhcnRQYXRoID0gZGVmYXVsdFBhdGggfHwgdmF1bHRQYXRoO1xuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgZGV0ZWN0ZWQgY29uZmlnIGZpbGUgcGF0aCwgdXNlIGl0cyBkaXJlY3Rvcnlcblx0XHRcdGlmICghZGVmYXVsdFBhdGggJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0XHRjb25zdCBjb25maWdQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoO1xuXHRcdFx0XHRpZiAocGF0aC5pc0Fic29sdXRlKGNvbmZpZ1BhdGgpKSB7XG5cdFx0XHRcdFx0c3RhcnRQYXRoID0gcGF0aC5kaXJuYW1lKGNvbmZpZ1BhdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXJ0UGF0aCA9IHBhdGguZGlybmFtZShwYXRoLnJlc29sdmUodmF1bHRQYXRoLCBjb25maWdQYXRoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZGVmYXVsdFBhdGggJiYgIXBhdGguaXNBYnNvbHV0ZShkZWZhdWx0UGF0aCkpIHtcblx0XHRcdFx0Ly8gQ29udmVydCByZWxhdGl2ZSBwYXRoIHRvIGFic29sdXRlIGlmIG5lZWRlZFxuXHRcdFx0XHRzdGFydFBhdGggPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCBkZWZhdWx0UGF0aCk7XG5cdFx0XHRcdC8vIElmIGl0J3MgYSBmaWxlIHBhdGgsIHVzZSBpdHMgZGlyZWN0b3J5XG5cdFx0XHRcdGlmIChwYXRoLmV4dG5hbWUoc3RhcnRQYXRoKSkge1xuXHRcdFx0XHRcdHN0YXJ0UGF0aCA9IHBhdGguZGlybmFtZShzdGFydFBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGRlZmF1bHRQYXRoICYmIHBhdGguaXNBYnNvbHV0ZShkZWZhdWx0UGF0aCkpIHtcblx0XHRcdFx0Ly8gSWYgaXQncyBhIGZpbGUgcGF0aCwgdXNlIGl0cyBkaXJlY3Rvcnlcblx0XHRcdFx0aWYgKHBhdGguZXh0bmFtZShkZWZhdWx0UGF0aCkpIHtcblx0XHRcdFx0XHRzdGFydFBhdGggPSBwYXRoLmRpcm5hbWUoZGVmYXVsdFBhdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXJ0UGF0aCA9IGRlZmF1bHRQYXRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3VsdCA9IGRpYWxvZy5zaG93T3BlbkRpYWxvZ1N5bmMoe1xuXHRcdFx0XHR0aXRsZTogJ1NlbGVjdCBBc3RybyBDb25maWcgRmlsZScsXG5cdFx0XHRcdGRlZmF1bHRQYXRoOiBzdGFydFBhdGgsXG5cdFx0XHRcdGZpbHRlcnM6IFtcblx0XHRcdFx0XHR7IG5hbWU6ICdBc3RybyBDb25maWcgRmlsZXMnLCBleHRlbnNpb25zOiBbJ3RzJywgJ21qcycsICdqcycsICdtdHMnLCAnY2pzJywgJ3ltbCcsICd5YW1sJ10gfSxcblx0XHRcdFx0XHR7IG5hbWU6ICdBbGwgRmlsZXMnLCBleHRlbnNpb25zOiBbJyonXSB9XG5cdFx0XHRcdF0sXG5cdFx0XHRcdHByb3BlcnRpZXM6IFsnb3BlbkZpbGUnXVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cmV0dXJuIHBhdGgubm9ybWFsaXplKHJlc3VsdFswXSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9wZW5pbmcgZmlsZSBwaWNrZXI6JywgZXJyb3IpO1xuXHRcdFx0Ly8gU2hvdyB1c2VyLWZyaWVuZGx5IGVycm9yXG5cdFx0XHRuZXcgTm90aWNlKCdVbmFibGUgdG8gb3BlbiBmaWxlIHBpY2tlci4gUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIE9ic2lkaWFuIG9uIGRlc2t0b3AuJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSB2YXVsdCBwYXRoXG5cdCAqL1xuXHRwcml2YXRlIGdldFZhdWx0UGF0aCgpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIHsgYmFzZVBhdGg/OiBzdHJpbmc7IHBhdGg/OiBzdHJpbmcgfTtcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcblx0XHQvLyBSZXNvbHZlIHBhdGggKGNvbnZlcnQgcmVsYXRpdmUgdG8gYWJzb2x1dGUsIG5vcm1hbGl6ZSBzZXBhcmF0b3JzKVxuXHRcdGlmICh2YXVsdFBhdGgpIHtcblx0XHRcdC8vIElmIGFscmVhZHkgYWJzb2x1dGUsIHJldHVybiBhcy1pcyAobm9ybWFsaXplZClcblx0XHRcdGlmICh2YXVsdFBhdGguc3RhcnRzV2l0aCgnLycpIHx8IC9eW0EtWl06Ly50ZXN0KHZhdWx0UGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHZhdWx0UGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBGb3IgcmVsYXRpdmUgcGF0aHMsIHdlJ2QgbmVlZCB0byByZXNvbHZlLCBidXQgaW4gT2JzaWRpYW4gY29udGV4dCwgYmFzZVBhdGggc2hvdWxkIGJlIGFic29sdXRlXG5cdFx0XHRyZXR1cm4gdmF1bHRQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblx0XHR9XG5cdFx0Ly8gRmFsbGJhY2sgLSBpbiBPYnNpZGlhbiBjb250ZXh0IHRoaXMgc2hvdWxkbid0IGhhcHBlblxuXHRcdHJldHVybiAnLyc7XG5cdH1cblxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdGlmICh0aGlzLmRldGVjdGVkKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWYWxpZGF0ZSB0aGF0IGJvdGggcGF0aHMgYXJlIHNldCBhbmQgZXhpc3Rcblx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3Q7XG5cdFx0Y29uc3QgY29uZmlnRmlsZVBhdGggPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LmNvbmZpZ0ZpbGVQYXRoO1xuXG5cdFx0aWYgKCFwcm9qZWN0Um9vdCB8fCAhY29uZmlnRmlsZVBhdGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiBwYXRocyBleGlzdCAocmVzb2x2ZSByZWxhdGl2ZSBwYXRocyB0byBhYnNvbHV0ZSlcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgdmF1bHRQYXRoID0gdGhpcy5nZXRWYXVsdFBhdGgoKTtcblx0XHRcdGNvbnN0IHJlc29sdmVkUHJvamVjdFJvb3QgPSBwYXRoLmlzQWJzb2x1dGUocHJvamVjdFJvb3QpID8gcHJvamVjdFJvb3QgOiBwYXRoLmpvaW4odmF1bHRQYXRoLCBwcm9qZWN0Um9vdCk7XG5cdFx0XHRjb25zdCByZXNvbHZlZENvbmZpZ0ZpbGVQYXRoID0gcGF0aC5pc0Fic29sdXRlKGNvbmZpZ0ZpbGVQYXRoKSA/IGNvbmZpZ0ZpbGVQYXRoIDogcGF0aC5qb2luKHZhdWx0UGF0aCwgY29uZmlnRmlsZVBhdGgpO1xuXG5cdFx0XHRpZiAoIWZzLmV4aXN0c1N5bmMocmVzb2x2ZWRQcm9qZWN0Um9vdCkgfHwgIWZzLnN0YXRTeW5jKHJlc29sdmVkUHJvamVjdFJvb3QpLmlzRGlyZWN0b3J5KCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFmcy5leGlzdHNTeW5jKHJlc29sdmVkQ29uZmlnRmlsZVBhdGgpIHx8ICFmcy5zdGF0U3luYyhyZXNvbHZlZENvbmZpZ0ZpbGVQYXRoKS5pc0ZpbGUoKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnUHJvamVjdCBkZXRlY3Rpb24nO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ0RldGVjdCBBc3RybyBwcm9qZWN0IHN0cnVjdHVyZSc7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlcyAtLSBOb2RlLmpzIG1vZHVsZSBuZWVkZWQgZm9yIHBhdGggb3BlcmF0aW9uc1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzIC0tIE5vZGUuanMgbW9kdWxlIG5lZWRlZCBmb3IgZmlsZSBvcGVyYXRpb25zXHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgUHJvamVjdERldGVjdGlvblJlc3VsdCB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9qZWN0RGV0ZWN0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGRldGVjdFByb2plY3QoKTogUHJvamVjdERldGVjdGlvblJlc3VsdCB8IG51bGwge1xyXG5cdFx0Y29uc3QgdmF1bHQgPSB0aGlzLmFwcC52YXVsdDtcclxuXHRcdGNvbnN0IGFkYXB0ZXIgPSB2YXVsdC5hZGFwdGVyIGFzIHsgYmFzZVBhdGg/OiBzdHJpbmc7IHBhdGg/OiBzdHJpbmcgfTtcclxuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xyXG5cclxuXHRcdGlmICghdmF1bHRQYXRoKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNlYXJjaCB1cHdhcmQgZnJvbSB2YXVsdCBwYXRoIGZvciBhc3Ryby5jb25maWcgZmlsZXNcclxuXHRcdGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IHRoaXMuc2VhcmNoVXB3YXJkRm9yQ29uZmlnKHZhdWx0UGF0aCk7XHJcblxyXG5cdFx0aWYgKCFjb25maWdSZXN1bHQpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIHZhdWx0IGxvY2F0aW9uIHJlbGF0aXZlIHRvIHByb2plY3RcclxuXHRcdGNvbnN0IHZhdWx0TG9jYXRpb24gPSB0aGlzLmRldGVjdFZhdWx0TG9jYXRpb24odmF1bHRQYXRoLCBjb25maWdSZXN1bHQucHJvamVjdFJvb3QpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHByb2plY3RSb290OiBjb25maWdSZXN1bHQucHJvamVjdFJvb3QsXHJcblx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiBjb25maWdSZXN1bHQuY29uZmlnRmlsZVBhdGgsXHJcblx0XHRcdHZhdWx0TG9jYXRpb25cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZWFyY2ggdXB3YXJkIGZyb20gdGhlIHZhdWx0IHBhdGggdG8gZmluZCBhbiBBc3RybyBjb25maWcgZmlsZS5cclxuXHQgKiBUaGlzIGFsbG93cyB0aGUgdmF1bHQgdG8gYmUgYW55d2hlcmUgd2l0aGluIHRoZSBBc3RybyBwcm9qZWN0IHN0cnVjdHVyZS5cclxuXHQgKiBCaWFzIHRvd2FyZHMgc3JjL2NvbmZpZy50cyBpZiBpdCBleGlzdHMgYWxvbmdzaWRlIGEgcm9vdCBjb25maWcgZmlsZS5cclxuXHQgKi9cclxuXHRwcml2YXRlIHNlYXJjaFVwd2FyZEZvckNvbmZpZyhzdGFydFBhdGg6IHN0cmluZyk6IHsgcHJvamVjdFJvb3Q6IHN0cmluZzsgY29uZmlnRmlsZVBhdGg6IHN0cmluZyB9IHwgbnVsbCB7XHJcblx0XHRjb25zdCByb290Q29uZmlnRmlsZU5hbWVzID0gW1xyXG5cdFx0XHQnYXN0cm8uY29uZmlnLm1qcycsXHJcblx0XHRcdCdhc3Ryby5jb25maWcudHMnLFxyXG5cdFx0XHQnYXN0cm8uY29uZmlnLmpzJyxcclxuXHRcdFx0J2FzdHJvLmNvbmZpZy5tdHMnLFxyXG5cdFx0XHQnYXN0cm8uY29uZmlnLmNqcycsXHJcblx0XHRcdCdhc3Ryby5jb25maWcueW1sJyxcclxuXHRcdFx0J2FzdHJvLmNvbmZpZy55YW1sJ1xyXG5cdFx0XTtcclxuXHRcdGNvbnN0IHNyY0NvbmZpZ0ZpbGVOYW1lID0gJ3NyYy9jb25maWcudHMnO1xyXG5cclxuXHRcdGxldCBjdXJyZW50RGlyID0gcGF0aC5yZXNvbHZlKHN0YXJ0UGF0aCk7XHJcblx0XHRjb25zdCByb290ID0gcGF0aC5wYXJzZShjdXJyZW50RGlyKS5yb290O1xyXG5cclxuXHRcdC8vIFdhbGsgdXAgdGhlIGRpcmVjdG9yeSB0cmVlXHJcblx0XHR3aGlsZSAoY3VycmVudERpciAhPT0gcm9vdCkge1xyXG5cdFx0XHQvLyAxLiBDaGVjayBmb3Igc3JjL2NvbmZpZy50cyBmaXJzdCAodGhlIHByaW9yaXRpemVkIGNob2ljZSlcclxuXHRcdFx0Y29uc3Qgc3JjQ29uZmlnUGF0aCA9IHBhdGguam9pbihjdXJyZW50RGlyLCBzcmNDb25maWdGaWxlTmFtZSk7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0aWYgKGZzLmV4aXN0c1N5bmMoc3JjQ29uZmlnUGF0aCkgJiYgZnMuc3RhdFN5bmMoc3JjQ29uZmlnUGF0aCkuaXNGaWxlKCkpIHtcclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHByb2plY3RSb290OiBjdXJyZW50RGlyLFxyXG5cdFx0XHRcdFx0XHRjb25maWdGaWxlUGF0aDogc3JjQ29uZmlnUGF0aFxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gY2F0Y2gge1xyXG5cdFx0XHRcdC8vIENvbnRpbnVlIHRvIGNoZWNrIHJvb3QgY29uZmlncyBpZiBzcmMgY2hlY2sgZmFpbHNcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gMi4gQ2hlY2sgZm9yIHJvb3QtbGV2ZWwgY29uZmlnIGZpbGVzIChwcmlvcml0aXppbmcgLm1qcylcclxuXHRcdFx0Zm9yIChjb25zdCBmaWxlTmFtZSBvZiByb290Q29uZmlnRmlsZU5hbWVzKSB7XHJcblx0XHRcdFx0Y29uc3QgY29uZmlnUGF0aCA9IHBhdGguam9pbihjdXJyZW50RGlyLCBmaWxlTmFtZSk7XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRpZiAoZnMuZXhpc3RzU3luYyhjb25maWdQYXRoKSAmJiBmcy5zdGF0U3luYyhjb25maWdQYXRoKS5pc0ZpbGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHByb2plY3RSb290OiBjdXJyZW50RGlyLFxyXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiBjb25maWdQYXRoXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaCB7XHJcblx0XHRcdFx0XHQvLyBDb250aW51ZSBzZWFyY2hpbmdcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE1vdmUgdXAgb25lIGRpcmVjdG9yeVxyXG5cdFx0XHRjb25zdCBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoY3VycmVudERpcik7XHJcblx0XHRcdGlmIChwYXJlbnREaXIgPT09IGN1cnJlbnREaXIpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRjdXJyZW50RGlyID0gcGFyZW50RGlyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lIHZhdWx0IGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBkZXRlY3RlZCBwcm9qZWN0IHJvb3QuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBkZXRlY3RWYXVsdExvY2F0aW9uKHZhdWx0UGF0aDogc3RyaW5nLCBwcm9qZWN0Um9vdDogc3RyaW5nKTogJ2NvbnRlbnQnIHwgJ25lc3RlZC1jb250ZW50JyB8ICdyb290JyB7XHJcblx0XHRjb25zdCBub3JtYWxpemVkVmF1bHRQYXRoID0gcGF0aC5ub3JtYWxpemUodmF1bHRQYXRoKTtcclxuXHRcdGNvbnN0IG5vcm1hbGl6ZWRQcm9qZWN0Um9vdCA9IHBhdGgubm9ybWFsaXplKHByb2plY3RSb290KTtcclxuXHJcblx0XHQvLyBDaGVjayBpZiB2YXVsdCBpcyB3aXRoaW4gcHJvamVjdCByb290XHJcblx0XHRpZiAoIW5vcm1hbGl6ZWRWYXVsdFBhdGguc3RhcnRzV2l0aChub3JtYWxpemVkUHJvamVjdFJvb3QpKSB7XHJcblx0XHRcdHJldHVybiAncm9vdCc7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gR2V0IHJlbGF0aXZlIHBhdGggZnJvbSBwcm9qZWN0IHJvb3QgdG8gdmF1bHRcclxuXHRcdGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUobm9ybWFsaXplZFByb2plY3RSb290LCBub3JtYWxpemVkVmF1bHRQYXRoKTtcclxuXHRcdGNvbnN0IHBhdGhQYXJ0cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKHBhcnQgPT4gcGFydC5sZW5ndGggPiAwKTtcclxuXHJcblx0XHQvLyBDaGVjayBpZiB2YXVsdCBpcyBpbiBhIGZvbGRlciBuYW1lZCBcImNvbnRlbnRcIiB3aXRoIHBhcmVudCBcInNyY1wiXHJcblx0XHRjb25zdCBjb250ZW50SW5kZXggPSBwYXRoUGFydHMuZmluZEluZGV4KHBhcnQgPT4gcGFydC50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudCcpO1xyXG5cdFx0aWYgKGNvbnRlbnRJbmRleCA+IDApIHtcclxuXHRcdFx0Y29uc3QgcGFyZW50SW5kZXggPSBjb250ZW50SW5kZXggLSAxO1xyXG5cdFx0XHRpZiAocGFyZW50SW5kZXggPj0gMCAmJiBwYXRoUGFydHNbcGFyZW50SW5kZXhdLnRvTG93ZXJDYXNlKCkgPT09ICdzcmMnKSB7XHJcblx0XHRcdFx0cmV0dXJuICdjb250ZW50JztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGZvciBuZXN0ZWQgY29udGVudCBmb2xkZXJzIChzcmMvY29udGVudC9wb3N0cywgZXRjLilcclxuXHRcdGNvbnN0IHNyY0luZGV4ID0gcGF0aFBhcnRzLmZpbmRJbmRleChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSA9PT0gJ3NyYycpO1xyXG5cdFx0aWYgKHNyY0luZGV4ID49IDAgJiYgc3JjSW5kZXggPCBwYXRoUGFydHMubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRjb25zdCBuZXh0UGFydCA9IHBhdGhQYXJ0c1tzcmNJbmRleCArIDFdO1xyXG5cdFx0XHRpZiAobmV4dFBhcnQudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQnKSB7XHJcblx0XHRcdFx0cmV0dXJuICduZXN0ZWQtY29udGVudCc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJ3Jvb3QnO1xyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlcyAtLSBOb2RlLmpzIG1vZHVsZSBuZWVkZWQgZm9yIHBhdGggb3BlcmF0aW9uc1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzIC0tIE5vZGUuanMgbW9kdWxlIG5lZWRlZCBmb3IgZmlsZSBvcGVyYXRpb25zXHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgUHJvamVjdERldGVjdGlvblJlc3VsdCwgQ29udGVudFR5cGVDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgTWR4RGV0ZWN0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVjdCBpZiBNRFggZmlsZXMgYXJlIHByZXNlbnQgaW4gdGhlIGNvbnRlbnQgZm9sZGVyc1xyXG5cdCAqIFNjYW5zIGFsbCBjb250ZW50IHR5cGUgZm9sZGVycyAocG9zdHMsIHBhZ2VzLCBldGMuKSBmb3IgLm1keCBmaWxlc1xyXG5cdCAqL1xyXG5cdGRldGVjdE1keFVzYWdlKFxyXG5cdFx0cHJvamVjdERldGVjdGlvbjogUHJvamVjdERldGVjdGlvblJlc3VsdCxcclxuXHRcdGNvbnRlbnRUeXBlczogQ29udGVudFR5cGVDb25maWdbXVxyXG5cdCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3IuZGV0ZWN0TWR4VXNhZ2U6IGNhbGxlZCB3aXRoJywge1xyXG5cdFx0XHRwcm9qZWN0Um9vdDogcHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3QsXHJcblx0XHRcdHZhdWx0TG9jYXRpb246IHByb2plY3REZXRlY3Rpb24/LnZhdWx0TG9jYXRpb24sXHJcblx0XHRcdGNvbnRlbnRUeXBlc0NvdW50OiBjb250ZW50VHlwZXM/Lmxlbmd0aFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFwcm9qZWN0RGV0ZWN0aW9uKSB7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBObyBwcm9qZWN0RGV0ZWN0aW9uLCByZXR1cm5pbmcgZmFsc2UnKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XHJcblx0XHRjb25zdCBhZGFwdGVyID0gdmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XHJcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHRcdFxyXG5cdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IHZhdWx0UGF0aCA9JywgdmF1bHRQYXRoKTtcclxuXHRcdFxyXG5cdFx0aWYgKCF2YXVsdFBhdGgpIHtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IE5vIHZhdWx0UGF0aCwgcmV0dXJuaW5nIGZhbHNlJyk7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBHZXQgcHJvamVjdCByb290IHBhdGhcclxuXHRcdGNvbnN0IHByb2plY3RSb290ID0gcHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdDtcclxuXHRcdGxldCBwcm9qZWN0Um9vdFBhdGg6IHN0cmluZztcclxuXHRcdFxyXG5cdFx0aWYgKHBhdGguaXNBYnNvbHV0ZShwcm9qZWN0Um9vdCkpIHtcclxuXHRcdFx0cHJvamVjdFJvb3RQYXRoID0gcHJvamVjdFJvb3Q7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBSZXNvbHZlIHJlbGF0aXZlIHBhdGggZnJvbSB2YXVsdCByb290XHJcblx0XHRcdHByb2plY3RSb290UGF0aCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIHByb2plY3RSb290KTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IHByb2plY3RSb290UGF0aCA9JywgcHJvamVjdFJvb3RQYXRoKTtcclxuXHJcblx0XHQvLyBEZXRlcm1pbmUgY29udGVudCBkaXJlY3RvcnkgYmFzZWQgb24gdmF1bHQgbG9jYXRpb25cclxuXHRcdGxldCBjb250ZW50QmFzZVBhdGg6IHN0cmluZztcclxuXHRcdGlmIChwcm9qZWN0RGV0ZWN0aW9uLnZhdWx0TG9jYXRpb24gPT09ICdjb250ZW50Jykge1xyXG5cdFx0XHQvLyBWYXVsdCBpcyBhdCBzcmMvY29udGVudCwgc28gY29udGVudCBpcyBhdCB2YXVsdCByb290XHJcblx0XHRcdGNvbnRlbnRCYXNlUGF0aCA9IHZhdWx0UGF0aDtcclxuXHRcdH0gZWxzZSBpZiAocHJvamVjdERldGVjdGlvbi52YXVsdExvY2F0aW9uID09PSAnbmVzdGVkLWNvbnRlbnQnKSB7XHJcblx0XHRcdC8vIFZhdWx0IGlzIG5lc3RlZCBpbiBzcmMvY29udGVudC9zb21ldGhpbmcsIGdvIHVwIHRvIHNyYy9jb250ZW50XHJcblx0XHRcdGNvbnRlbnRCYXNlUGF0aCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsICcuLicpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gVmF1bHQgaXMgYXQgcm9vdCwgY29udGVudCBzaG91bGQgYmUgYXQgcHJvamVjdFJvb3Qvc3JjL2NvbnRlbnRcclxuXHRcdFx0Y29udGVudEJhc2VQYXRoID0gcGF0aC5qb2luKHByb2plY3RSb290UGF0aCwgJ3NyYycsICdjb250ZW50Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IGNvbnRlbnRCYXNlUGF0aCA9JywgY29udGVudEJhc2VQYXRoKTtcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiB2YXVsdExvY2F0aW9uID0nLCBwcm9qZWN0RGV0ZWN0aW9uLnZhdWx0TG9jYXRpb24pO1xyXG5cdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IGNvbnRlbnRUeXBlcyB0byBzY2FuID0nLCBjb250ZW50VHlwZXMubWFwKGN0ID0+IGAke2N0Lm5hbWV9ICgke2N0LmZvbGRlcn0pYCkpO1xyXG5cclxuXHRcdC8vIFNjYW4gZWFjaCBjb250ZW50IHR5cGUgZm9sZGVyIGZvciAubWR4IGZpbGVzIChjaGVjayBib3RoIGVuYWJsZWQgYW5kIGRpc2FibGVkKVxyXG5cdFx0Ly8gV2Ugc2NhbiBhbGwgY29udGVudCB0eXBlcyBiZWNhdXNlIE1EWCBmaWxlcyBtaWdodCBleGlzdCBldmVuIGlmIHRoZSB0eXBlIGlzIGRpc2FibGVkXHJcblx0XHRmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIGNvbnRlbnRUeXBlcykge1xyXG5cdFx0XHRsZXQgY29udGVudFR5cGVQYXRoOiBzdHJpbmc7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJZiBjb250ZW50VHlwZS5mb2xkZXIgYWxyZWFkeSBjb250YWlucyBzcmMvY29udGVudCAodmF1bHQgYXQgcHJvamVjdCByb290KSxcclxuXHRcdFx0Ly8gdXNlIGl0IHJlbGF0aXZlIHRvIHByb2plY3Qgcm9vdC4gT3RoZXJ3aXNlLCB1c2UgaXQgcmVsYXRpdmUgdG8gY29udGVudEJhc2VQYXRoLlxyXG5cdFx0XHRpZiAoY29udGVudFR5cGUuZm9sZGVyLnN0YXJ0c1dpdGgoJ3NyYy9jb250ZW50LycpKSB7XHJcblx0XHRcdFx0Y29udGVudFR5cGVQYXRoID0gcGF0aC5qb2luKHByb2plY3RSb290UGF0aCwgY29udGVudFR5cGUuZm9sZGVyKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb250ZW50VHlwZVBhdGggPSBwYXRoLmpvaW4oY29udGVudEJhc2VQYXRoLCBjb250ZW50VHlwZS5mb2xkZXIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3Rvcjogc2Nhbm5pbmcnLCBjb250ZW50VHlwZVBhdGgsICcoZW5hYmxlZDonLCBjb250ZW50VHlwZS5lbmFibGVkLCAnKScpO1xyXG5cdFx0XHRcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRpZiAoZnMuZXhpc3RzU3luYyhjb250ZW50VHlwZVBhdGgpICYmIGZzLnN0YXRTeW5jKGNvbnRlbnRUeXBlUGF0aCkuaXNEaXJlY3RvcnkoKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgZm91bmRNZHggPSB0aGlzLnNjYW5EaXJlY3RvcnlGb3JNZHgoY29udGVudFR5cGVQYXRoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBmb3VuZCBNRFggaW4nLCBjb250ZW50VHlwZVBhdGgsICc9JywgZm91bmRNZHgpO1xyXG5cdFx0XHRcdFx0aWYgKGZvdW5kTWR4KSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlOyAvLyBGb3VuZCBhdCBsZWFzdCBvbmUgLm1keCBmaWxlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBwYXRoIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhIGRpcmVjdG9yeTonLCBjb250ZW50VHlwZVBhdGgsICdleGlzdHM6JywgZnMuZXhpc3RzU3luYyhjb250ZW50VHlwZVBhdGgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRcdFx0Ly8gQ29udGludWUgdG8gbmV4dCBmb2xkZXIgaWYgdGhpcyBvbmUgZmFpbHNcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogZXJyb3Igc2Nhbm5pbmcnLCBjb250ZW50VHlwZVBhdGgsIGVycm9yKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBubyBNRFggZmlsZXMgZm91bmQnKTtcclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWN1cnNpdmVseSBzY2FuIGEgZGlyZWN0b3J5IGZvciAubWR4IGZpbGVzXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzY2FuRGlyZWN0b3J5Rm9yTWR4KGRpclBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgZW50cmllcyA9IGZzLnJlYWRkaXJTeW5jKGRpclBhdGgsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcclxuXHRcdFx0XHJcblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG5cdFx0XHRcdGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpclBhdGgsIGVudHJ5Lm5hbWUpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChlbnRyeS5pc0ZpbGUoKSAmJiBlbnRyeS5uYW1lLmVuZHNXaXRoKCcubWR4JykpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlOyAvLyBGb3VuZCBhbiAubWR4IGZpbGVcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0XHRcdC8vIFJlY3Vyc2l2ZWx5IHNjYW4gc3ViZGlyZWN0b3JpZXNcclxuXHRcdFx0XHRcdGlmICh0aGlzLnNjYW5EaXJlY3RvcnlGb3JNZHgoZnVsbFBhdGgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCB7XHJcblx0XHRcdC8vIElmIHdlIGNhbid0IHJlYWQgdGhlIGRpcmVjdG9yeSwgcmV0dXJuIGZhbHNlXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURm9sZGVyIH0gZnJvbSAnb2JzaWRpYW4nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlcyAtLSBOb2RlLmpzIG1vZHVsZSBuZWVkZWQgZm9yIHBhdGggb3BlcmF0aW9uc1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBmaWxlIG9wZXJhdGlvbnNcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IENvbnRlbnRUeXBlQ29uZmlnLCBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGVEZXRlY3RvciB7XG5cdHByaXZhdGUgYXBwOiBBcHA7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcblx0XHR0aGlzLmFwcCA9IGFwcDtcblx0fVxuXG5cdGRldGVjdENvbnRlbnRUeXBlcyhwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCk6IENvbnRlbnRUeXBlQ29uZmlnW10ge1xuXHRcdC8vIEZpbmQgdGhlIGNvcnJlY3Qgc3JjL2NvbnRlbnQgZGlyZWN0b3J5XG5cdFx0Y29uc3QgY29udGVudEZvbGRlciA9IHRoaXMuZmluZENvbnRlbnREaXJlY3RvcnkocHJvamVjdERldGVjdGlvbik7XG5cdFx0XG5cdFx0aWYgKCFjb250ZW50Rm9sZGVyKSB7XG5cdFx0XHQvLyBGYWxsYmFjayB0byBvbGQgYmVoYXZpb3IgaWYgd2UgY2FuJ3QgZmluZCBzcmMvY29udGVudFxuXHRcdFx0cmV0dXJuIHRoaXMuZGV0ZWN0Q29udGVudFR5cGVzRnJvbVZhdWx0Um9vdCgpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbnRlbnRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IFtdO1xuXHRcdGNvbnN0IGZvbGRlcnMgPSB0aGlzLmdldFRvcExldmVsRm9sZGVycyhjb250ZW50Rm9sZGVyKTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBmb2xkZXJzKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IHRoaXMuZGV0ZWN0Q29udGVudFR5cGUoZm9sZGVyKTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRjb250ZW50VHlwZXMucHVzaChjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBjb250ZW50VHlwZXM7XG5cdH1cblxuXHQvKipcblx0ICogRmluZCB0aGUgc3JjL2NvbnRlbnQgZGlyZWN0b3J5IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIHZhdWx0IGlzIGxvY2F0ZWQuXG5cdCAqIEhhbmRsZXMgY2FzZXMgd2hlcmUgdmF1bHQgaXMgYXQ6XG5cdCAqIC0gc3JjIGxldmVsIChuZWVkIHRvIGdvIGludG8gc3JjL2NvbnRlbnQpXG5cdCAqIC0gc3JjL2NvbnRlbnQgbGV2ZWwgKGFscmVhZHkgdGhlcmUpXG5cdCAqIC0gc3JjL2NvbnRlbnQvcG9zdCBsZXZlbCAodmF1bHQgaXMgaW5zaWRlIGEgY29udGVudCB0eXBlLCBjYW4ndCBhY2Nlc3MgcGFyZW50LCByZXR1cm4gbnVsbCB0byB1c2UgZmFsbGJhY2spXG5cdCAqL1xuXHRwcml2YXRlIGZpbmRDb250ZW50RGlyZWN0b3J5KHByb2plY3REZXRlY3Rpb24/OiBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0KTogVEZvbGRlciB8IG51bGwge1xuXHRcdGlmICghcHJvamVjdERldGVjdGlvbiB8fCAhcHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdmF1bHQgPSB0aGlzLmFwcC52YXVsdDtcblx0XHRjb25zdCBhZGFwdGVyID0gdmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XG5cdFx0Y29uc3QgdmF1bHRQYXRoID0gYWRhcHRlci5iYXNlUGF0aCB8fCBhZGFwdGVyLnBhdGg7XG5cdFx0XG5cdFx0aWYgKCF2YXVsdFBhdGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIFJlc29sdmUgcHJvamVjdCByb290IHRvIGFic29sdXRlIHBhdGhcblx0XHQvLyBIYW5kbGUgYm90aCBhYnNvbHV0ZSBhbmQgcmVsYXRpdmUgcGF0aHNcblx0XHRsZXQgcHJvamVjdFJvb3Q6IHN0cmluZztcblx0XHRpZiAocGF0aC5pc0Fic29sdXRlKHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpKSB7XG5cdFx0XHRwcm9qZWN0Um9vdCA9IHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3Q7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFJlbGF0aXZlIHBhdGggLSByZXNvbHZlIHJlbGF0aXZlIHRvIHZhdWx0XG5cdFx0XHRwcm9qZWN0Um9vdCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc3JjL2NvbnRlbnQgcGF0aFxuXHRcdGNvbnN0IGV4cGVjdGVkQ29udGVudFBhdGggPSBwYXRoLmpvaW4ocHJvamVjdFJvb3QsICdzcmMnLCAnY29udGVudCcpO1xuXHRcdFxuXHRcdC8vIENoZWNrIGlmIHNyYy9jb250ZW50IGV4aXN0cyBpbiB0aGUgZmlsZSBzeXN0ZW1cblx0XHRpZiAoIWZzLmV4aXN0c1N5bmMoZXhwZWN0ZWRDb250ZW50UGF0aCkgfHwgIWZzLnN0YXRTeW5jKGV4cGVjdGVkQ29udGVudFBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcblx0XHRcdC8vIHNyYy9jb250ZW50IGRvZXNuJ3QgZXhpc3QsIGNhbid0IGZpbmQgaXRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIE5vdyBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIFRGb2xkZXIgaW4gT2JzaWRpYW4ncyB2YXVsdCBzdHJ1Y3R1cmVcblx0XHQvLyBXZSBuZWVkIHRvIG5hdmlnYXRlIGZyb20gdmF1bHQgcm9vdCB0byBzcmMvY29udGVudFxuXHRcdGNvbnN0IHZhdWx0Um9vdCA9IHZhdWx0LmdldFJvb3QoKTtcblx0XHRpZiAoISh2YXVsdFJvb3QgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHJlbGF0aXZlIHBhdGggZnJvbSB2YXVsdCB0byBzcmMvY29udGVudFxuXHRcdGNvbnN0IHZhdWx0Tm9ybWFsaXplZCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0Y29uc3QgY29udGVudE5vcm1hbGl6ZWQgPSBwYXRoLnJlc29sdmUoZXhwZWN0ZWRDb250ZW50UGF0aCkudG9Mb3dlckNhc2UoKTtcblx0XHRcblx0XHQvLyBJZiBzcmMvY29udGVudCBpcyB3aXRoaW4gdGhlIHZhdWx0LCBmaW5kIGl0IGJ5IHBhdGhcblx0XHRpZiAoY29udGVudE5vcm1hbGl6ZWQuc3RhcnRzV2l0aCh2YXVsdE5vcm1hbGl6ZWQpKSB7XG5cdFx0XHRjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgpLCBwYXRoLnJlc29sdmUoZXhwZWN0ZWRDb250ZW50UGF0aCkpO1xuXHRcdFx0Ly8gTm9ybWFsaXplIHRvIHVzZSBmb3J3YXJkIHNsYXNoZXMgZm9yIE9ic2lkaWFuXG5cdFx0XHRjb25zdCBub3JtYWxpemVkUmVsYXRpdmVQYXRoID0gcmVsYXRpdmVQYXRoLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJyk7XG5cdFx0XHRjb25zdCBwYXRoUGFydHMgPSBub3JtYWxpemVkUmVsYXRpdmVQYXRoLnNwbGl0KCcvJykuZmlsdGVyKHBhcnQgPT4gcGFydC5sZW5ndGggPiAwKTtcblx0XHRcdFxuXHRcdFx0Ly8gSWYgcmVsYXRpdmUgcGF0aCBpcyBlbXB0eSwgdmF1bHQgcm9vdCBJUyBzcmMvY29udGVudFxuXHRcdFx0aWYgKHBhdGhQYXJ0cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIHZhdWx0Um9vdDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gTmF2aWdhdGUgZnJvbSB2YXVsdCByb290IHRvIHNyYy9jb250ZW50XG5cdFx0XHRsZXQgY3VycmVudEZvbGRlcjogVEZvbGRlciA9IHZhdWx0Um9vdDtcblx0XHRcdGZvciAoY29uc3QgcGFydCBvZiBwYXRoUGFydHMpIHtcblx0XHRcdFx0aWYgKCFjdXJyZW50Rm9sZGVyLmNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY3VycmVudEZvbGRlci5jaGlsZHJlbi5maW5kKGMgPT4gYyBpbnN0YW5jZW9mIFRGb2xkZXIgJiYgYy5uYW1lID09PSBwYXJ0KTtcblx0XHRcdFx0aWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjdXJyZW50Rm9sZGVyID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjdXJyZW50Rm9sZGVyO1xuXHRcdH1cblxuXHRcdC8vIElmIHNyYy9jb250ZW50IGlzIG91dHNpZGUvYWJvdmUgdGhlIHZhdWx0IChlLmcuLCB2YXVsdCBpcyBhdCBzcmMvY29udGVudC9wb3N0KSxcblx0XHQvLyB3ZSBjYW4ndCBhY2Nlc3MgaXQgdmlhIE9ic2lkaWFuJ3MgQVBJLiBSZXR1cm4gbnVsbCB0byB1c2UgZmFsbGJhY2sgYmVoYXZpb3IuXG5cdFx0Ly8gVGhlIGZhbGxiYWNrIHdpbGwgc2NhbiB0aGUgdmF1bHQgcm9vdCwgd2hpY2ggaW4gdGhpcyBjYXNlIHdvdWxkIGJlIGEgY29udGVudCB0eXBlIGZvbGRlci5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBGYWxsYmFjazogZGV0ZWN0IGNvbnRlbnQgdHlwZXMgZnJvbSB2YXVsdCByb290IChvbGQgYmVoYXZpb3IpXG5cdCAqIFRoaXMgaXMgdXNlZCB3aGVuIHdlIGNhbid0IGZpbmQgc3JjL2NvbnRlbnQsIGUuZy4sIHdoZW4gdmF1bHQgaXMgaW5zaWRlIGEgY29udGVudCB0eXBlIGZvbGRlclxuXHQgKi9cblx0cHJpdmF0ZSBkZXRlY3RDb250ZW50VHlwZXNGcm9tVmF1bHRSb290KCk6IENvbnRlbnRUeXBlQ29uZmlnW10ge1xuXHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XG5cdFx0Y29uc3Qgcm9vdCA9IHZhdWx0LmdldFJvb3QoKTtcblx0XHRcblx0XHRpZiAoIShyb290IGluc3RhbmNlb2YgVEZvbGRlcikpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHRjb25zdCBjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10gPSBbXTtcblx0XHRjb25zdCBmb2xkZXJzID0gdGhpcy5nZXRUb3BMZXZlbEZvbGRlcnMocm9vdCk7XG5cdFx0XG5cdFx0Ly8gSWYgdmF1bHQgcm9vdCBoYXMgZm9sZGVycywgdHJlYXQgdGhlbSBhcyBjb250ZW50IHR5cGVzXG5cdFx0Ly8gKFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSB2YXVsdCBpcyBhdCBzcmMvY29udGVudC9wb3N0IGFuZCBwb3N0IGhhcyBzdWJmb2xkZXJzKVxuXHRcdGZvciAoY29uc3QgZm9sZGVyIG9mIGZvbGRlcnMpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5kZXRlY3RDb250ZW50VHlwZShmb2xkZXIpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGNvbnRlbnRUeXBlcy5wdXNoKGNvbnRlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gSWYgbm8gZm9sZGVycyBmb3VuZCBidXQgd2UgaGF2ZSBhIHZhdWx0IHJvb3Qgd2l0aCBhIG1lYW5pbmdmdWwgbmFtZSxcblx0XHQvLyBhbmQgaXQncyBsaWtlbHkgYSBjb250ZW50IHR5cGUgZm9sZGVyIChlLmcuLCB2YXVsdCBpcyBhdCBzcmMvY29udGVudC9wb3N0KSxcblx0XHQvLyB3ZSBjb3VsZCB0cmVhdCB0aGUgdmF1bHQgcm9vdCBpdHNlbGYgYXMgYSBjb250ZW50IHR5cGUuXG5cdFx0Ly8gSG93ZXZlciwgdGhpcyBpcyB0cmlja3kgYmVjYXVzZSB3ZSBkb24ndCBrbm93IHRoZSB2YXVsdCByb290J3MgbmFtZSBpbiByZWxhdGlvbiB0byB0aGUgcHJvamVjdC5cblx0XHQvLyBGb3Igbm93LCB3ZSdsbCBvbmx5IGRldGVjdCBmb2xkZXJzIHdpdGhpbiB0aGUgdmF1bHQgcm9vdC5cblx0XHRcblx0XHRyZXR1cm4gY29udGVudFR5cGVzO1xuXHR9XG5cblx0cHJpdmF0ZSBnZXRUb3BMZXZlbEZvbGRlcnMoZm9sZGVyOiBURm9sZGVyKTogVEZvbGRlcltdIHtcblx0XHRjb25zdCBmb2xkZXJzOiBURm9sZGVyW10gPSBbXTtcblx0XHRcblx0XHRpZiAoIWZvbGRlci5jaGlsZHJlbikge1xuXHRcdFx0cmV0dXJuIGZvbGRlcnM7XG5cdFx0fVxuXHRcdFxuXHRcdGZvciAoY29uc3QgY2hpbGQgb2YgZm9sZGVyLmNoaWxkcmVuKSB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdC8vIFNraXAgc3BlY2lhbCBmb2xkZXJzXG5cdFx0XHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcjtcblx0XHRcdFx0aWYgKCFjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJy4nKSAmJiBcblx0XHRcdFx0XHRjaGlsZC5uYW1lICE9PSAnYmFzZXMnICYmIFxuXHRcdFx0XHRcdGNoaWxkLm5hbWUgIT09ICdfYmFzZXMnICYmXG5cdFx0XHRcdFx0Y2hpbGQubmFtZSAhPT0gJ25vZGVfbW9kdWxlcycgJiZcblx0XHRcdFx0XHRjaGlsZC5uYW1lICE9PSBjb25maWdEaXIpIHtcblx0XHRcdFx0XHRmb2xkZXJzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmb2xkZXJzO1xuXHR9XG5cblx0cHJpdmF0ZSBkZXRlY3RDb250ZW50VHlwZShmb2xkZXI6IFRGb2xkZXIpOiBDb250ZW50VHlwZUNvbmZpZyB8IG51bGwge1xuXHRcdGNvbnN0IG5hbWUgPSB0aGlzLmNhcGl0YWxpemVGaXJzdChmb2xkZXIubmFtZSk7XG5cdFx0XG5cdFx0Ly8gQWxsIGRpc2NvdmVyZWQgY29udGVudCBmb2xkZXJzIGFyZSBlbmFibGVkIGJ5IGRlZmF1bHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0aWQ6IGBjb250ZW50LXR5cGUtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMSl9YCxcblx0XHRcdG5hbWUsXG5cdFx0XHRmb2xkZXI6IGZvbGRlci5wYXRoLCAvLyBVc2UgdmF1bHQtcmVsYXRpdmUgcGF0aCBpbnN0ZWFkIG9mIGp1c3QgdGhlIGZvbGRlciBuYW1lXG5cdFx0XHRmaWxlT3JnYW5pemF0aW9uOiAnZmlsZScsXG5cdFx0XHRlbmFibGVkOiB0cnVlLCAvLyBFbmFibGUgYWxsIGRpc2NvdmVyZWQgY29udGVudCB0eXBlcyBieSBkZWZhdWx0XG5cdFx0XHRpbmRleEZpbGVOYW1lOiAnaW5kZXgnXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgY2FwaXRhbGl6ZUZpcnN0KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXHR9XG59XG5cbiIsICJpbXBvcnQgeyBBcHAsIFNldHRpbmcsIE5vdGljZSwgVEZvbGRlciwgVEZpbGUsIEFic3RyYWN0SW5wdXRTdWdnZXN0LCBzZXRJY29uIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzIChtYXkgbm90IGJlIGluIHR5cGVzIHlldClcbmZ1bmN0aW9uIHNldENzc1Byb3BzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG5cdH1cbn1cbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSwgQ29udGVudFR5cGVDb25maWcgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBDb250ZW50VHlwZURldGVjdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29udGVudFR5cGVEZXRlY3Rvcic7XG5pbXBvcnQgeyBBc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvQXN0cm9Db21wb3NlckNvbmZpZyc7XG5cbi8vIEZvbGRlciBuYW1lIHN1Z2dlc3RlciBmb3IgYXR0YWNobWVudCBmb2xkZXJcbmNsYXNzIEZvbGRlck5hbWVTdWdnZXN0IGV4dGVuZHMgQWJzdHJhY3RJbnB1dFN1Z2dlc3Q8c3RyaW5nPiB7XG5cdHByaXZhdGUgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudDtcblx0cHJpdmF0ZSBtb2RlOiAnc3BlY2lmaWVkLWZvbGRlcicgfCAnc3ViZm9sZGVyJztcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudCwgbW9kZTogJ3NwZWNpZmllZC1mb2xkZXInIHwgJ3N1YmZvbGRlcicpIHtcblx0XHRzdXBlcihhcHAsIGlucHV0RWwpO1xuXHRcdHRoaXMuaW5wdXRFbCA9IGlucHV0RWw7XG5cdFx0dGhpcy5tb2RlID0gbW9kZTtcblx0fVxuXG5cdGdldFN1Z2dlc3Rpb25zKGlucHV0U3RyOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3Qgc3VnZ2VzdGlvbnM6IHN0cmluZ1tdID0gW107XG5cdFx0Y29uc3QgbG93ZXJJbnB1dCA9IGlucHV0U3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XG5cdFx0aWYgKHRoaXMubW9kZSA9PT0gJ3N1YmZvbGRlcicpIHtcblx0XHRcdC8vIEZvciBzdWJmb2xkZXIgbW9kZSwgc3VnZ2VzdCBmb2xkZXIgbmFtZXMgb25seVxuXHRcdFx0Ly8gQWx3YXlzIHN1Z2dlc3QgXCJhdHRhY2htZW50c1wiIGlmIGl0IG1hdGNoZXNcblx0XHRcdGlmICgnYXR0YWNobWVudHMnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobG93ZXJJbnB1dCkpIHtcblx0XHRcdFx0c3VnZ2VzdGlvbnMucHVzaCgnYXR0YWNobWVudHMnKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gR2V0IGZvbGRlciBuYW1lcyBmcm9tIHZhdWx0XG5cdFx0XHRjb25zdCBhbGxGaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEFsbExvYWRlZEZpbGVzKCk7XG5cdFx0XHRjb25zdCBmb2xkZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgYWxsRmlsZXMpIHtcblx0XHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IGZpbGUubmFtZTtcblx0XHRcdFx0XHRpZiAoZm9sZGVyTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGxvd2VySW5wdXQpICYmIGZvbGRlck5hbWUgIT09ICdhdHRhY2htZW50cycpIHtcblx0XHRcdFx0XHRcdGZvbGRlck5hbWVzLmFkZChmb2xkZXJOYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0c3VnZ2VzdGlvbnMucHVzaCguLi5BcnJheS5mcm9tKGZvbGRlck5hbWVzKS5zbGljZSgwLCAxMCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBGb3Igc3BlY2lmaWVkLWZvbGRlciBtb2RlLCBzdWdnZXN0IGZ1bGwgcGF0aHNcblx0XHRcdGNvbnN0IGFsbEZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0QWxsTG9hZGVkRmlsZXMoKTtcblx0XHRcdGNvbnN0IHBhdGhzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZmlsZSBvZiBhbGxGaWxlcykge1xuXHRcdFx0XHRpZiAoZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xuXHRcdFx0XHRcdGlmIChwYXRoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobG93ZXJJbnB1dCkpIHtcblx0XHRcdFx0XHRcdHBhdGhzLmFkZChwYXRoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0c3VnZ2VzdGlvbnMucHVzaCguLi5BcnJheS5mcm9tKHBhdGhzKS5zbGljZSgwLCAxMCkpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gc3VnZ2VzdGlvbnM7XG5cdH1cblxuXHRyZW5kZXJTdWdnZXN0aW9uKHN1Z2dlc3Rpb246IHN0cmluZywgZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG5cdFx0ZWwuc2V0VGV4dChzdWdnZXN0aW9uKTtcblx0fVxuXG5cdHNlbGVjdFN1Z2dlc3Rpb24oc3VnZ2VzdGlvbjogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy5pbnB1dEVsLnZhbHVlID0gc3VnZ2VzdGlvbjtcblx0XHR0aGlzLmlucHV0RWwudHJpZ2dlcignaW5wdXQnKTtcblx0XHR0aGlzLmNsb3NlKCk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRUeXBlU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcblx0cHJpdmF0ZSBjb250ZW50VHlwZURldGVjdG9yOiBDb250ZW50VHlwZURldGVjdG9yO1xuXHRwcml2YXRlIGFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3I6IEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3I7XG5cdHByaXZhdGUgZGV0ZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xuXHRcdHN1cGVyKGFwcCwgY29udGFpbmVyRWwsIHN0YXRlLCBvbk5leHQsIG9uQmFjaywgb25DYW5jZWwpO1xuXHRcdHRoaXMuY29udGVudFR5cGVEZXRlY3RvciA9IG5ldyBDb250ZW50VHlwZURldGVjdG9yKGFwcCk7XG5cdFx0dGhpcy5hc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yID0gbmV3IEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IoYXBwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbXBvcnQgY29udGVudCB0eXBlcyBmcm9tIEFzdHJvIENvbXBvc2VyIGRhdGEuanNvbiBpZiBpdCBleGlzdHNcblx0ICogRmlyc3QgdHJpZXMgcGx1Z2luIEFQSSwgdGhlbiBmYWxscyBiYWNrIHRvIGZpbGUgcmVhZGluZ1xuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBpbXBvcnRGcm9tQXN0cm9Db21wb3NlcigpOiBQcm9taXNlPENvbnRlbnRUeXBlQ29uZmlnW10+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gRmlyc3QgdHJ5IHRvIHVzZSBwbHVnaW4gQVBJIChsaWtlIGhvdyB3ZSBzYXZlKVxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiB7IHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCB7IHNldHRpbmdzPzogeyBjb250ZW50VHlwZXM/OiB1bmtub3duW10gfSB9PiB9IH0pLnBsdWdpbnM7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IENoZWNraW5nIHBsdWdpbnMgQVBJOicsICEhcGx1Z2lucyk7XG5cdFx0XHRcblx0XHRcdGlmIChwbHVnaW5zKSB7XG5cdFx0XHRcdGNvbnN0IGFzdHJvQ29tcG9zZXJQbHVnaW4gPSBwbHVnaW5zLnBsdWdpbnM/LlsnYXN0cm8tY29tcG9zZXInXTtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBBc3RybyBDb21wb3NlciBwbHVnaW4gZm91bmQ6JywgISFhc3Ryb0NvbXBvc2VyUGx1Z2luKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhc3Ryb0NvbXBvc2VyUGx1Z2luKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBQbHVnaW4gc2V0dGluZ3MgYXZhaWxhYmxlOicsICEhYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncyk7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBQbHVnaW4gc2V0dGluZ3Mga2V5czonLCBhc3Ryb0NvbXBvc2VyUGx1Z2luLnNldHRpbmdzID8gT2JqZWN0LmtleXMoYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncykgOiAnbm9uZScpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChhc3Ryb0NvbXBvc2VyUGx1Z2luLnNldHRpbmdzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjb250ZW50VHlwZXMgPSBhc3Ryb0NvbXBvc2VyUGx1Z2luLnNldHRpbmdzLmNvbnRlbnRUeXBlcztcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogY29udGVudFR5cGVzIGZyb20gcGx1Z2luOicsIGNvbnRlbnRUeXBlcyA/IGBBcnJheSB3aXRoICR7Y29udGVudFR5cGVzLmxlbmd0aH0gaXRlbXNgIDogJ25vdCBmb3VuZCcpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjb250ZW50VHlwZXMpICYmIGNvbnRlbnRUeXBlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogSW1wb3J0aW5nJywgY29udGVudFR5cGVzLmxlbmd0aCwgJ2NvbnRlbnQgdHlwZXMgZnJvbSBBc3RybyBDb21wb3NlciAodmlhIHBsdWdpbiBBUEkpJyk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBDb252ZXJ0IEFzdHJvIENvbXBvc2VyIGNvbnRlbnQgdHlwZXMgdG8gb3VyIGZvcm1hdFxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbXBvcnRlZFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gY29udGVudFR5cGVzLm1hcCgoY3Q6IHsgaWQ/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGZvbGRlcjogc3RyaW5nOyBjcmVhdGlvbk1vZGU/OiBzdHJpbmc7IGluZGV4RmlsZU5hbWU/OiBzdHJpbmc7IGxpbmtCYXNlUGF0aD86IHN0cmluZzsgZW5hYmxlZD86IGJvb2xlYW4gfSkgPT4gKHtcblx0XHRcdFx0XHRcdFx0XHRpZDogY3QuaWQgfHwgYGNvbnRlbnQtdHlwZS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDExKX1gLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGN0Lm5hbWUgfHwgdGhpcy5jYXBpdGFsaXplRmlyc3QoY3QuZm9sZGVyKSxcblx0XHRcdFx0XHRcdFx0XHRmb2xkZXI6IGN0LmZvbGRlcixcblx0XHRcdFx0XHRcdFx0XHRmaWxlT3JnYW5pemF0aW9uOiBjdC5jcmVhdGlvbk1vZGUgPT09ICdmb2xkZXInID8gJ2ZvbGRlcicgOiAnZmlsZScsXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXhGaWxlTmFtZTogY3QuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnLFxuXHRcdFx0XHRcdFx0XHRcdGxpbmtCYXNlUGF0aDogY3QubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZWQ6IGN0LmVuYWJsZWQgIT09IGZhbHNlIC8vIERlZmF1bHQgdG8gZW5hYmxlZCBpZiBub3Qgc3BlY2lmaWVkXG5cdFx0XHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaW1wb3J0ZWRUeXBlcztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSByZWFkaW5nXG5cdFx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XG5cdFx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy9hc3Ryby1jb21wb3Nlci9kYXRhLmpzb25gO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBUcnlpbmcgdG8gcmVhZCBmaWxlOicsIHBsdWdpbkRhdGFQYXRoKTtcblx0XHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogRmlsZSBmb3VuZDonLCAhIWRhdGFGaWxlLCBkYXRhRmlsZSA/IGBUeXBlOiAke2RhdGFGaWxlLmNvbnN0cnVjdG9yLm5hbWV9YCA6ICdub3QgZm91bmQnKTtcblx0XHRcdFxuXHRcdFx0aWYgKCFkYXRhRmlsZSB8fCAhKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRcdC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXRoc1xuXHRcdFx0XHRjb25zdCBhbHRQYXRocyA9IFtcblx0XHRcdFx0XHRgJHtjb25maWdEaXJ9L3BsdWdpbnMvYXN0cm8tY29tcG9zZXIvZGF0YS5qc29uYCxcblx0XHRcdFx0XHRgb2JzaWRpYW4vcGx1Z2lucy9hc3Ryby1jb21wb3Nlci9kYXRhLmpzb25gXG5cdFx0XHRcdF07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGFsdFBhdGggb2YgYWx0UGF0aHMpIHtcblx0XHRcdFx0XHRjb25zdCBhbHRGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGFsdFBhdGgpO1xuXHRcdFx0XHRcdGlmIChhbHRGaWxlICYmIGFsdEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBGb3VuZCBmaWxlIGF0IGFsdGVybmF0aXZlIHBhdGg6JywgYWx0UGF0aCk7XG5cdFx0XHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChhbHRGaWxlKTtcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIHsgY29udGVudFR5cGVzPzogdW5rbm93bltdIH07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChkYXRhLmNvbnRlbnRUeXBlcyAmJiBBcnJheS5pc0FycmF5KGRhdGEuY29udGVudFR5cGVzKSkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IEltcG9ydGluZycsIGRhdGEuY29udGVudFR5cGVzLmxlbmd0aCwgJ2NvbnRlbnQgdHlwZXMgZnJvbSBBc3RybyBDb21wb3NlciAodmlhIGZpbGUgYXQnLCBhbHRQYXRoLCAnKScpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW1wb3J0ZWRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IGRhdGEuY29udGVudFR5cGVzLm1hcCgoY3Q6IHsgaWQ/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGZvbGRlcjogc3RyaW5nOyBjcmVhdGlvbk1vZGU/OiBzdHJpbmc7IGluZGV4RmlsZU5hbWU/OiBzdHJpbmc7IGxpbmtCYXNlUGF0aD86IHN0cmluZzsgZW5hYmxlZD86IGJvb2xlYW4gfSkgPT4gKHtcblx0XHRcdFx0XHRcdFx0XHRpZDogY3QuaWQgfHwgYGNvbnRlbnQtdHlwZS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDExKX1gLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGN0Lm5hbWUgfHwgdGhpcy5jYXBpdGFsaXplRmlyc3QoY3QuZm9sZGVyKSxcblx0XHRcdFx0XHRcdFx0XHRmb2xkZXI6IGN0LmZvbGRlcixcblx0XHRcdFx0XHRcdFx0XHRmaWxlT3JnYW5pemF0aW9uOiBjdC5jcmVhdGlvbk1vZGUgPT09ICdmb2xkZXInID8gJ2ZvbGRlcicgOiAnZmlsZScsXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXhGaWxlTmFtZTogY3QuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnLFxuXHRcdFx0XHRcdFx0XHRcdGxpbmtCYXNlUGF0aDogY3QubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZWQ6IGN0LmVuYWJsZWQgIT09IGZhbHNlXG5cdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbXBvcnRlZFR5cGVzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBObyBBc3RybyBDb21wb3NlciBkYXRhLmpzb24gZm91bmQsIHdpbGwgc2NhbiBmb2xkZXJzJyk7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpO1xuXHRcdFx0Y29uc3QgZGF0YSA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgeyBjb250ZW50VHlwZXM/OiB1bmtub3duW10gfTtcblx0XHRcdFxuXHRcdFx0aWYgKCFkYXRhLmNvbnRlbnRUeXBlcyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLmNvbnRlbnRUeXBlcykpIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBBc3RybyBDb21wb3NlciBkYXRhLmpzb24gaGFzIG5vIGNvbnRlbnRUeXBlcyBhcnJheS4gRGF0YSBrZXlzOicsIE9iamVjdC5rZXlzKGRhdGEpKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IEltcG9ydGluZycsIGRhdGEuY29udGVudFR5cGVzLmxlbmd0aCwgJ2NvbnRlbnQgdHlwZXMgZnJvbSBBc3RybyBDb21wb3NlciAodmlhIGZpbGUpJyk7XG5cdFx0XHRcblx0XHRcdC8vIENvbnZlcnQgQXN0cm8gQ29tcG9zZXIgY29udGVudCB0eXBlcyB0byBvdXIgZm9ybWF0XG5cdFx0XHRjb25zdCBpbXBvcnRlZFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gZGF0YS5jb250ZW50VHlwZXMubWFwKChjdDogeyBpZD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgZm9sZGVyOiBzdHJpbmc7IGNyZWF0aW9uTW9kZT86IHN0cmluZzsgaW5kZXhGaWxlTmFtZT86IHN0cmluZzsgbGlua0Jhc2VQYXRoPzogc3RyaW5nOyBlbmFibGVkPzogYm9vbGVhbiB9KSA9PiAoe1xuXHRcdFx0XHRpZDogY3QuaWQgfHwgYGNvbnRlbnQtdHlwZS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDExKX1gLFxuXHRcdFx0XHRuYW1lOiBjdC5uYW1lIHx8IHRoaXMuY2FwaXRhbGl6ZUZpcnN0KGN0LmZvbGRlciksXG5cdFx0XHRcdGZvbGRlcjogY3QuZm9sZGVyLFxuXHRcdFx0XHRmaWxlT3JnYW5pemF0aW9uOiBjdC5jcmVhdGlvbk1vZGUgPT09ICdmb2xkZXInID8gJ2ZvbGRlcicgOiAnZmlsZScsXG5cdFx0XHRcdGluZGV4RmlsZU5hbWU6IGN0LmluZGV4RmlsZU5hbWUgfHwgJ2luZGV4Jyxcblx0XHRcdFx0bGlua0Jhc2VQYXRoOiBjdC5saW5rQmFzZVBhdGgsXG5cdFx0XHRcdGVuYWJsZWQ6IGN0LmVuYWJsZWQgIT09IGZhbHNlIC8vIERlZmF1bHQgdG8gZW5hYmxlZCBpZiBub3Qgc3BlY2lmaWVkXG5cdFx0XHR9KSk7XG5cblx0XHRcdHJldHVybiBpbXBvcnRlZFR5cGVzO1xuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb250ZW50VHlwZVN0ZXA6IEZhaWxlZCB0byBpbXBvcnQgZnJvbSBBc3RybyBDb21wb3NlcjonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdFxuXHRcdC8vIEZpbmQgb3IgY3JlYXRlIGNvbnRlbnQgd3JhcHBlciAocHJlc2VydmUgZm9vdGVyIGlmIGl0IGV4aXN0cylcblx0XHRsZXQgc3RlcENvbnRlbnRXcmFwcGVyID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignLmNvbnRlbnQtdHlwZS1zdGVwLWNvbnRlbnQnKSBhcyBIVE1MRWxlbWVudDtcblx0XHRcblx0XHRpZiAoIXN0ZXBDb250ZW50V3JhcHBlcikge1xuXHRcdFx0Ly8gRmlyc3QgdGltZSAtIGNsZWFyIGV2ZXJ5dGhpbmcgYW5kIGNyZWF0ZSB3cmFwcGVyXG5cdFx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXHRcdFx0c3RlcENvbnRlbnRXcmFwcGVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnY29udGVudC10eXBlLXN0ZXAtY29udGVudCcgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFJlLXJlbmRlcmluZyAtIGp1c3QgY2xlYXIgdGhlIHdyYXBwZXIgY29udGVudCwgcHJlc2VydmUgZm9vdGVyXG5cdFx0XHRzdGVwQ29udGVudFdyYXBwZXIuZW1wdHkoKTtcblx0XHR9XG5cblx0XHRzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnQ29udGVudCB0eXBlcycgfSk7XG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdHRleHQ6ICdEZXRlY3RpbmcgY29udGVudCB0eXBlcyBpbiB5b3VyIHZhdWx0Li4uJyBcblx0XHR9KTtcblxuXHRcdGlmICghdGhpcy5kZXRlY3RlZCkge1xuXHRcdFx0Ly8gR2V0IHNhdmVkIGNvbnRlbnQgdHlwZXMgZnJvbSBzdGF0ZSAocHJlc2VydmVzIGVuYWJsZWQgc3RhdGUgZnJvbSBwcmV2aW91cyB3aXphcmQgcnVucylcblx0XHRcdGNvbnN0IHNhdmVkQ29udGVudFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMgfHwgW107XG5cdFx0XHRjb25zdCBzYXZlZENvbnRlbnRUeXBlc01hcCA9IG5ldyBNYXAoc2F2ZWRDb250ZW50VHlwZXMubWFwKGN0ID0+IFtjdC5mb2xkZXIsIGN0XSkpO1xuXHRcdFx0XG5cdFx0XHQvLyBGaXJzdCwgdHJ5IHRvIGltcG9ydCBmcm9tIEFzdHJvIENvbXBvc2VyIGlmIGl0IGV4aXN0c1xuXHRcdFx0Y29uc3QgaW1wb3J0ZWRUeXBlcyA9IGF3YWl0IHRoaXMuaW1wb3J0RnJvbUFzdHJvQ29tcG9zZXIoKTtcblx0XHRcdFxuXHRcdFx0Ly8gVGhlbiBzY2FuIGZvciBuZXcgZm9sZGVycyB0aGF0IGFyZW4ndCBhbHJlYWR5IG1hcHBlZFxuXHRcdFx0Ly8gUGFzcyBwcm9qZWN0IGRldGVjdGlvbiBpbmZvIHNvIGl0IGNhbiBmaW5kIHNyYy9jb250ZW50IGRpcmVjdG9yeSBjb3JyZWN0bHlcblx0XHRcdGNvbnN0IHNjYW5uZWRUeXBlcyA9IHRoaXMuY29udGVudFR5cGVEZXRlY3Rvci5kZXRlY3RDb250ZW50VHlwZXModGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29tYmluZSBpbXBvcnRlZCBhbmQgc2Nhbm5lZCB0eXBlc1xuXHRcdFx0Ly8gUmVjb25jaWxlOiBpZiB3ZSBoYXZlIGJvdGggYSBzaG9ydCBwYXRoIGFuZCBhIGxvbmcgcGF0aCB0aGF0IGVuZHMgd2l0aCBpdCwgcHJlZmVyIHRoZSBsb25nIHBhdGhcblx0XHRcdGNvbnN0IGFsbERldGVjdGVkVHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gMS4gU3RhcnQgd2l0aCBhbGwgaW1wb3J0ZWQgdHlwZXNcblx0XHRcdGNvbnN0IGltcG9ydGVkID0gWy4uLmltcG9ydGVkVHlwZXNdO1xuXHRcdFx0XG5cdFx0XHQvLyAyLiBDaGVjayBlYWNoIHNjYW5uZWQgdHlwZVxuXHRcdFx0Zm9yIChjb25zdCBzY2FubmVkIG9mIHNjYW5uZWRUeXBlcykge1xuXHRcdFx0XHRjb25zdCBtYXRjaGluZ0ltcG9ydGVkSW5kZXggPSBpbXBvcnRlZC5maW5kSW5kZXgoaXQgPT4gXG5cdFx0XHRcdFx0c2Nhbm5lZC5mb2xkZXIgPT09IGl0LmZvbGRlciB8fCBcblx0XHRcdFx0XHRzY2FubmVkLmZvbGRlci5lbmRzV2l0aChgLyR7aXQuZm9sZGVyfWApIHx8XG5cdFx0XHRcdFx0aXQuZm9sZGVyLmVuZHNXaXRoKGAvJHtzY2FubmVkLmZvbGRlcn1gKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG1hdGNoaW5nSW1wb3J0ZWRJbmRleCA+PSAwKSB7XG5cdFx0XHRcdFx0Ly8gUmVjb25jaWxlOiB1cGRhdGUgdGhlIGltcG9ydGVkIG9uZSB3aXRoIHRoZSBsb25nZXIgZm9sZGVyIHBhdGggaWYgaXQncyBhIG1hdGNoXG5cdFx0XHRcdFx0Y29uc3QgaW1wb3J0ZWRUeXBlID0gaW1wb3J0ZWRbbWF0Y2hpbmdJbXBvcnRlZEluZGV4XTtcblx0XHRcdFx0XHRpZiAoc2Nhbm5lZC5mb2xkZXIubGVuZ3RoID4gaW1wb3J0ZWRUeXBlLmZvbGRlci5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoYENvbnRlbnRUeXBlU3RlcDogVXBkYXRpbmcgaW1wb3J0ZWQgdHlwZSBcIiR7aW1wb3J0ZWRUeXBlLm5hbWV9XCIgZm9sZGVyIGZyb20gXCIke2ltcG9ydGVkVHlwZS5mb2xkZXJ9XCIgdG8gXCIke3NjYW5uZWQuZm9sZGVyfVwiYCk7XG5cdFx0XHRcdFx0XHRpbXBvcnRlZFttYXRjaGluZ0ltcG9ydGVkSW5kZXhdID0ge1xuXHRcdFx0XHRcdFx0XHQuLi5pbXBvcnRlZFR5cGUsXG5cdFx0XHRcdFx0XHRcdGZvbGRlcjogc2Nhbm5lZC5mb2xkZXJcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vdCBmb3VuZCBpbiBpbXBvcnRlZCwgYWRkIGFzIG5ldyBkZXRlY3RlZCB0eXBlXG5cdFx0XHRcdFx0YWxsRGV0ZWN0ZWRUeXBlcy5wdXNoKHNjYW5uZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIENvbWJpbmUgcmVjb25jaWxlZCBpbXBvcnRlZCB0eXBlcyB3aXRoIG5ldyBkZXRlY3RlZCB0eXBlc1xuXHRcdFx0YWxsRGV0ZWN0ZWRUeXBlcy5wdXNoKC4uLmltcG9ydGVkKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZGV0ZWN0ZWRUeXBlc01hcCA9IG5ldyBNYXAoYWxsRGV0ZWN0ZWRUeXBlcy5tYXAoY3QgPT4gW2N0LmZvbGRlciwgY3RdKSk7XG5cdFx0XHRcblx0XHRcdC8vIE1lcmdlIHdpdGggc2F2ZWQgY29udGVudCB0eXBlcywgcHJlc2VydmluZyBlbmFibGVkIHN0YXRlIGZyb20gc2F2ZWQgc2V0dGluZ3Ncblx0XHRcdGNvbnN0IG1lcmdlZFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gW107XG5cdFx0XHRjb25zdCBwcm9jZXNzZWRGb2xkZXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0XHRcblx0XHRcdC8vIFByb2Nlc3MgYWxsIGZvbGRlcnMgKGJvdGggc2F2ZWQgYW5kIGRldGVjdGVkKVxuXHRcdFx0Y29uc3QgYWxsRm9sZGVycyA9IG5ldyBTZXQoW1xuXHRcdFx0XHQuLi5zYXZlZENvbnRlbnRUeXBlcy5tYXAoY3QgPT4gY3QuZm9sZGVyKSxcblx0XHRcdFx0Li4uYWxsRGV0ZWN0ZWRUeXBlcy5tYXAoY3QgPT4gY3QuZm9sZGVyKVxuXHRcdFx0XSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZm9sZGVyIG9mIGFsbEZvbGRlcnMpIHtcblx0XHRcdFx0aWYgKHByb2Nlc3NlZEZvbGRlcnMuaGFzKGZvbGRlcikpIGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IHNhdmVkVHlwZSA9IHNhdmVkQ29udGVudFR5cGVzTWFwLmdldChmb2xkZXIpO1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZFR5cGUgPSBkZXRlY3RlZFR5cGVzTWFwLmdldChmb2xkZXIpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gUkVDT05DSUxJQVRJT046IElmIHdlIGhhdmUgYSBzYXZlZCB0eXBlIHRoYXQgd2Fzbid0IGRldGVjdGVkLCBjaGVjayBpZiBpdCdzIGJlY2F1c2Vcblx0XHRcdFx0Ly8gaXQgd2FzIHNhdmVkIHdpdGggYSBzaG9ydCBwYXRoIChlLmcuIFwicG9zdHNcIikgYnV0IG5vdyBkZXRlY3RlZCB3aXRoIGEgZnVsbCBwYXRoIChlLmcuIFwic3JjL2NvbnRlbnQvcG9zdHNcIilcblx0XHRcdFx0aWYgKHNhdmVkVHlwZSAmJiAhZGV0ZWN0ZWRUeXBlKSB7XG5cdFx0XHRcdFx0Ly8gVHJ5IHRvIGZpbmQgaWYgdGhpcyBzYXZlZCB0eXBlJ3MgZm9sZGVyIG5hbWUgbWF0Y2hlcyB0aGUgZW5kIG9mIGFueSBkZXRlY3RlZCBmb2xkZXJcblx0XHRcdFx0XHRjb25zdCBtYXRjaGluZ0RldGVjdGVkID0gYWxsRGV0ZWN0ZWRUeXBlcy5maW5kKGR0ID0+IFxuXHRcdFx0XHRcdFx0ZHQuZm9sZGVyLmVuZHNXaXRoKGAvJHtmb2xkZXJ9YCkgfHwgZHQuZm9sZGVyID09PSBmb2xkZXJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtYXRjaGluZ0RldGVjdGVkICYmICFwcm9jZXNzZWRGb2xkZXJzLmhhcyhtYXRjaGluZ0RldGVjdGVkLmZvbGRlcikpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoYENvbnRlbnRUeXBlU3RlcDogUmVjb25jaWxpbmcgc2F2ZWQgZm9sZGVyIFwiJHtmb2xkZXJ9XCIgd2l0aCBkZXRlY3RlZCBmb2xkZXIgXCIke21hdGNoaW5nRGV0ZWN0ZWQuZm9sZGVyfVwiYCk7XG5cdFx0XHRcdFx0XHQvLyBNaWdyYXRlIHNhdmVkIHNldHRpbmdzIHRvIHRoZSBjb3JyZWN0IGRldGVjdGVkIGZvbGRlciBwYXRoXG5cdFx0XHRcdFx0XHRtZXJnZWRUeXBlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0Li4uc2F2ZWRUeXBlLFxuXHRcdFx0XHRcdFx0XHRmb2xkZXI6IG1hdGNoaW5nRGV0ZWN0ZWQuZm9sZGVyXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHByb2Nlc3NlZEZvbGRlcnMuYWRkKGZvbGRlcik7XG5cdFx0XHRcdFx0XHRwcm9jZXNzZWRGb2xkZXJzLmFkZChtYXRjaGluZ0RldGVjdGVkLmZvbGRlcik7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzYXZlZFR5cGUpIHtcblx0XHRcdFx0XHQvLyBVc2Ugc2F2ZWQgdHlwZSB0byBwcmVzZXJ2ZSBlbmFibGVkIHN0YXRlLCBjdXN0b20gbmFtZSwgYW5kIGFsbCBvdGhlciBzZXR0aW5nc1xuXHRcdFx0XHRcdC8vIElmIHRoZXJlJ3MgYWxzbyBhIGRldGVjdGVkIHR5cGUsIG1lcmdlIGluIGFueSBuZXcgaW5mbyB3aGlsZSBwcmVzZXJ2aW5nIHNhdmVkIHNldHRpbmdzXG5cdFx0XHRcdFx0aWYgKGRldGVjdGVkVHlwZSkge1xuXHRcdFx0XHRcdFx0bWVyZ2VkVHlwZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdC4uLnNhdmVkVHlwZSwgLy8gUHJlc2VydmUgYWxsIHNhdmVkIHNldHRpbmdzIChlbmFibGVkLCBjdXN0b20gbmFtZSwgbGlua0Jhc2VQYXRoLCBldGMuKVxuXHRcdFx0XHRcdFx0XHQvLyBBbHdheXMgcHJlc2VydmUgc2F2ZWQgZm9sZGVyIGFuZCBuYW1lICh1c2VyIG1heSBoYXZlIGN1c3RvbWl6ZWQgdGhlIG5hbWUpXG5cdFx0XHRcdFx0XHRcdGZvbGRlcjogc2F2ZWRUeXBlLmZvbGRlcixcblx0XHRcdFx0XHRcdFx0bmFtZTogc2F2ZWRUeXBlLm5hbWUgLy8gQWx3YXlzIHVzZSBzYXZlZCBuYW1lIChtYXkgYmUgY3VzdG9taXplZClcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBTYXZlZCB0eXBlIG5vdCBkZXRlY3RlZCAtIGtlZXAgaXQgYXMgaXMgKHVzZXIgbWlnaHQgaGF2ZSBkZWxldGVkIHRoZSBmb2xkZXIpXG5cdFx0XHRcdFx0XHRtZXJnZWRUeXBlcy5wdXNoKHNhdmVkVHlwZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGRldGVjdGVkVHlwZSkge1xuXHRcdFx0XHRcdC8vIE5ldyB0eXBlIG5vdCBpbiBzYXZlZCBzZXR0aW5ncyAtIGFkZCBpdCAoZGVmYXVsdCB0byBlbmFibGVkIGZvciBuZXcgdHlwZXMpXG5cdFx0XHRcdFx0Ly8gVXNlIGF1dG8tZGV0ZWN0ZWQgbmFtZSBhcyBzdGFydGluZyBwb2ludCAodXNlciBjYW4gY3VzdG9taXplIGl0KVxuXHRcdFx0XHRcdG1lcmdlZFR5cGVzLnB1c2goZGV0ZWN0ZWRUeXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cHJvY2Vzc2VkRm9sZGVycy5hZGQoZm9sZGVyKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gU29ydCBhbHBoYWJldGljYWxseSBieSBuYW1lXG5cdFx0XHRtZXJnZWRUeXBlcy5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zdGF0ZS5jb250ZW50VHlwZXMgPSBtZXJnZWRUeXBlcztcblx0XHRcdHRoaXMuZGV0ZWN0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5lbXB0eSgpO1xuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdDb250ZW50IHR5cGVzJyB9KTtcblx0XHRzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ3AnLCB7IFxuXHRcdFx0dGV4dDogJ1NlbGVjdCBhbmQgY29uZmlndXJlIHlvdXIgY29udGVudCB0eXBlczonIFxuXHRcdH0pO1xuXG5cdFx0Ly8gR2xvYmFsIGF0dGFjaG1lbnQgaGFuZGxpbmcgYXQgdGhlIHRvcFxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdBdHRhY2htZW50IGhhbmRsaW5nJywgY2xzOiAndmF1bHQtY21zLXNlY3Rpb24taGVhZGVyJyB9KTtcblx0XHRzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ3AnLCB7IFxuXHRcdFx0dGV4dDogJ0hvdyBzaG91bGQgYXR0YWNobWVudHMgYmUgc3RvcmVkIGdsb2JhbGx5PycsXG5cdFx0XHRjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1kZXNjJ1xuXHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoc3RlcENvbnRlbnRXcmFwcGVyKVxuXHRcdFx0LnNldE5hbWUoJ0hvdyBhcmUgYXR0YWNobWVudHMgaGFuZGxlZD8nKVxuXHRcdFx0LnNldERlc2MoJ0Nob29zZSBob3cgYXR0YWNobWVudHMgYXJlIHN0b3JlZCBmb3IgYWxsIGNvbnRlbnQgdHlwZXMnKVxuXHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdC5hZGRPcHRpb24oJ3NhbWUtZm9sZGVyJywgJ1NhbWUgZm9sZGVyIGFzIGN1cnJlbnQgZmlsZScpXG5cdFx0XHRcdC5hZGRPcHRpb24oJ3NwZWNpZmllZC1mb2xkZXInLCAnSW4gdGhlIHNwZWNpZmllZCBmb2xkZXInKVxuXHRcdFx0XHQuYWRkT3B0aW9uKCdzdWJmb2xkZXInLCAnSW4gc3ViZm9sZGVyIHVuZGVyIGN1cnJlbnQgZm9sZGVyJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSB8fCAnc3ViZm9sZGVyJylcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSB2YWx1ZSBhcyAnc3BlY2lmaWVkLWZvbGRlcicgfCAnc2FtZS1mb2xkZXInIHwgJ3N1YmZvbGRlcic7XG5cdFx0XHRcdFx0Ly8gQ2xlYXIgZm9sZGVyIG5hbWUgaWYgc3dpdGNoaW5nIHRvIHNhbWUtZm9sZGVyXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSAnc2FtZS1mb2xkZXInKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBSZS1yZW5kZXIgdG8gc2hvdy9oaWRlIGZvbGRlciBuYW1lIGlucHV0XG5cdFx0XHRcdFx0dm9pZCB0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0Ly8gU2hvdyBmb2xkZXIgbmFtZSBpbnB1dCBmb3Igc3BlY2lmaWVkLWZvbGRlciBvciBzdWJmb2xkZXIgbW9kZXNcblx0XHRpZiAodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc3BlY2lmaWVkLWZvbGRlcicgfHwgdGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc3ViZm9sZGVyJykge1xuXHRcdFx0Y29uc3QgZGVzY1RleHQgPSB0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzcGVjaWZpZWQtZm9sZGVyJyBcblx0XHRcdFx0PyAnRW50ZXIgdGhlIGV4YWN0IHBhdGggdG8gdGhlIGZvbGRlciBmb3IgYXR0YWNobWVudHMgKGUuZy4sIFwiYXR0YWNobWVudHNcIiBvciBcImltYWdlcy9hdHRhY2htZW50c1wiKS4gTGVhdmUgYmxhbmsgdG8gdXNlIFwiYXR0YWNobWVudHNcIiBhcyBkZWZhdWx0Lidcblx0XHRcdFx0OiAnRW50ZXIgdGhlIG5hbWUgb2YgdGhlIHN1YmZvbGRlciBmb3IgYXR0YWNobWVudHMgKGUuZy4sIFwiYXR0YWNobWVudHNcIikuIExlYXZlIGJsYW5rIHRvIHVzZSBcImF0dGFjaG1lbnRzXCIgYXMgZGVmYXVsdC4nO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBmb2xkZXJOYW1lU2V0dGluZyA9IG5ldyBTZXR0aW5nKHN0ZXBDb250ZW50V3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0F0dGFjaG1lbnQgZm9sZGVyJylcblx0XHRcdFx0LnNldERlc2MoZGVzY1RleHQpO1xuXG5cdFx0XHRmb2xkZXJOYW1lU2V0dGluZy5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdhdHRhY2htZW50cycpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgfHwgJycpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgYXV0b2NvbXBsZXRlIHN1Z2dlc3RlciB3aXRoIG1vZGUgKG9ubHkgaWYgbm90IHNhbWUtZm9sZGVyKVxuXHRcdFx0XHRpZiAodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlICE9PSAnc2FtZS1mb2xkZXInKSB7XG5cdFx0XHRcdFx0bmV3IEZvbGRlck5hbWVTdWdnZXN0KHRoaXMuYXBwLCB0ZXh0LmlucHV0RWwsIHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaHInLCB7IGNsczogJ3ZhdWx0LWNtcy1kaXZpZGVyJyB9KTtcblxuXHRcdC8vIENvbnRlbnQgdHlwZXMgc2VjdGlvblxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdDb250ZW50IHR5cGVzJywgY2xzOiAndmF1bHQtY21zLXNlY3Rpb24taGVhZGVyJyB9KTtcblxuXHRcdGZvciAoY29uc3QgY29udGVudFR5cGUgb2YgdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMpIHtcblx0XHRcdGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhzdGVwQ29udGVudFdyYXBwZXIpO1xuXHRcdFx0XG5cdFx0XHQvLyBDcmVhdGUgY2xpY2stdG8tZWRpdCBuYW1lIGVsZW1lbnQgd2l0aCBpY29uXG5cdFx0XHRjb25zdCBuYW1lQ29udGFpbmVyID0gc2V0dGluZy5uYW1lRWwuY3JlYXRlRGl2KHsgY2xzOiAndmF1bHQtY21zLWVkaXRhYmxlLW5hbWUnIH0pO1xuXHRcdFx0c2V0Q3NzUHJvcHMobmFtZUNvbnRhaW5lciwgeyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBnYXA6ICcwLjVyZW0nIH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBGdW5jdGlvbiB0byBjcmVhdGUgdGhlIGRpc3BsYXkgZWxlbWVudCB3aXRoIGNsaWNrIGhhbmRsZXJcblx0XHRcdGNvbnN0IGNyZWF0ZU5hbWVEaXNwbGF5ID0gKG5hbWU6IHN0cmluZykgPT4ge1xuXHRcdFx0XHQvLyBDbGVhciBjb250YWluZXIgZmlyc3Rcblx0XHRcdFx0bmFtZUNvbnRhaW5lci5lbXB0eSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZGlzcGxheSA9IG5hbWVDb250YWluZXIuY3JlYXRlU3Bhbih7IFxuXHRcdFx0XHRcdHRleHQ6IG5hbWUsXG5cdFx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLW5hbWUtZGlzcGxheSdcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgcGVuY2lsIGljb25cblx0XHRcdFx0Y29uc3QgaWNvbkNvbnRhaW5lciA9IG5hbWVDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAndmF1bHQtY21zLWVkaXQtaWNvbicgfSk7XG5cdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgb3BhY2l0eTogJzAuNicgfSk7XG5cdFx0XHRcdHNldEljb24oaWNvbkNvbnRhaW5lciwgJ2x1Y2lkZS1wZW5jaWwtbGluZScpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTWFrZSBuYW1lIGFuZCBpY29uIGVkaXRhYmxlIG9uIGNsaWNrXG5cdFx0XHRcdGNvbnN0IHN0YXJ0RWRpdCA9ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50TmFtZSA9IGNvbnRlbnRUeXBlLm5hbWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQ2xlYXIgY29udGFpbmVyXG5cdFx0XHRcdFx0bmFtZUNvbnRhaW5lci5lbXB0eSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIENyZWF0ZSBpbnB1dCB1c2luZyBuYXRpdmUgT2JzaWRpYW4gc3R5bGluZ1xuXHRcdFx0XHRcdGNvbnN0IG5hbWVJbnB1dCA9IG5hbWVDb250YWluZXIuY3JlYXRlRWwoJ2lucHV0Jywge1xuXHRcdFx0XHRcdFx0dHlwZTogJ3RleHQnLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGN1cnJlbnROYW1lXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBPYnNpZGlhbiBpbnB1dCBzdHlsaW5nIGNsYXNzIChzYW1lIGFzIFNldHRpbmcuYWRkVGV4dCB1c2VzKVxuXHRcdFx0XHRcdG5hbWVJbnB1dC5hZGRDbGFzcygnbW9kLXRleHQtaW5wdXQnKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBGb2N1cyBhbmQgc2VsZWN0IHRleHRcblx0XHRcdFx0XHRuYW1lSW5wdXQuZm9jdXMoKTtcblx0XHRcdFx0XHRuYW1lSW5wdXQuc2VsZWN0KCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gU2F2ZSBvbiBibHVyXG5cdFx0XHRcdFx0Y29uc3Qgc2F2ZU5hbWUgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgYmx1ciBsaXN0ZW5lciB0byBwcmV2ZW50IGRvdWJsZSBleGVjdXRpb25cblx0XHRcdFx0XHRcdG5hbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgc2F2ZU5hbWUpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRsZXQgbmV3TmFtZSA9IG5hbWVJbnB1dC52YWx1ZS50cmltKCk7XG5cdFx0XHRcdFx0XHQvLyBWYWxpZGF0ZTogZW5zdXJlIG5hbWUgaXMgbm90IGVtcHR5XG5cdFx0XHRcdFx0XHRpZiAoIW5ld05hbWUpIHtcblx0XHRcdFx0XHRcdFx0bmV3TmFtZSA9IGN1cnJlbnROYW1lOyAvLyBSZXZlcnQgdG8gb3JpZ2luYWwgaWYgZW1wdHlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIFZhbGlkYXRlOiByZW1vdmUgYW55IHByb2JsZW1hdGljIGNoYXJhY3RlcnMgdGhhdCBtaWdodCBicmVhayBBc3RybyBDb21wb3NlclxuXHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXggLS0gaW50ZW50aW9uYWxseSBtYXRjaGluZyBjb250cm9sIGNoYXJzXG5cdFx0XHRcdFx0XHRuZXdOYW1lID0gbmV3TmFtZS5yZXBsYWNlKC9bPD46XCIvXFxcXHw/KlxceDAwLVxceDFGXS9nLCAnJyk7XG5cdFx0XHRcdFx0XHQvLyBFbnN1cmUgaXQncyBzdGlsbCBub3QgZW1wdHkgYWZ0ZXIgY2xlYW5pbmdcblx0XHRcdFx0XHRcdGlmICghbmV3TmFtZS50cmltKCkpIHtcblx0XHRcdFx0XHRcdFx0bmV3TmFtZSA9IGN1cnJlbnROYW1lOyAvLyBSZXZlcnQgdG8gb3JpZ2luYWwgaWYgZW1wdHkgYWZ0ZXIgY2xlYW5pbmdcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ld05hbWUgPSBuZXdOYW1lLnRyaW0oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlLm5hbWUgPSBuZXdOYW1lO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBSZS1yZW5kZXIgdG8gdXBkYXRlIGFsbCByZWZlcmVuY2VzIHRvIHRoZSBuYW1lXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjYWxsIGNyZWF0ZU5hbWVEaXNwbGF5IGhlcmUgYXMgZGlzcGxheSgpIHdpbGwgcmVjcmVhdGUgZXZlcnl0aGluZ1xuXHRcdFx0XHRcdFx0dm9pZCB0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFNhdmUgb24gRW50ZXJcblx0XHRcdFx0XHRuYW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRzYXZlTmFtZSgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHQvLyBDYW5jZWw6IHJldmVydCB0byBvcmlnaW5hbFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVOYW1lRGlzcGxheShjdXJyZW50TmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gU2F2ZSBvbiBibHVyXG5cdFx0XHRcdFx0bmFtZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBzYXZlTmFtZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgY2xpY2sgaGFuZGxlcnMgdG8gYm90aCBuYW1lIGFuZCBpY29uXG5cdFx0XHRcdGRpc3BsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdGFydEVkaXQpO1xuXHRcdFx0XHRpY29uQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3RhcnRFZGl0KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFkZCBob3ZlciBlZmZlY3QgdG8gaWNvblxuXHRcdFx0XHRpY29uQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoaWNvbkNvbnRhaW5lciwgeyBvcGFjaXR5OiAnMScgfSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpY29uQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoaWNvbkNvbnRhaW5lciwgeyBvcGFjaXR5OiAnMC42JyB9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZGlzcGxheTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBpbml0aWFsIGRpc3BsYXlcblx0XHRcdGNyZWF0ZU5hbWVEaXNwbGF5KGNvbnRlbnRUeXBlLm5hbWUpO1xuXHRcdFx0XG5cdFx0XHRzZXR0aW5nLnNldERlc2MoYEZvbGRlcjogJHtjb250ZW50VHlwZS5mb2xkZXJ9YClcblx0XHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdFx0LnNldFZhbHVlKGNvbnRlbnRUeXBlLmVuYWJsZWQpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlLmVuYWJsZWQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9KSk7XG5cblx0XHRcdC8vIEZpbGUgb3JnYW5pemF0aW9uIGRyb3Bkb3duXG5cdFx0XHRuZXcgU2V0dGluZyhzdGVwQ29udGVudFdyYXBwZXIpXG5cdFx0XHRcdC5zZXROYW1lKGAke2NvbnRlbnRUeXBlLm5hbWV9IC0gRmlsZSBvcmdhbml6YXRpb25gKVxuXHRcdFx0XHQuc2V0RGVzYygnQ2hvb3NlIGhvdyBjb250ZW50IGlzIG9yZ2FuaXplZCBmb3IgdGhpcyBjb250ZW50IHR5cGUnKVxuXHRcdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cblx0XHRcdFx0XHQuYWRkT3B0aW9uKCdmaWxlJywgJ0ZpbGUtYmFzZWQnKVxuXHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZvbGRlcicsICdGb2xkZXItYmFzZWQnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZShjb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uIHx8ICdmaWxlJylcblx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0Y29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbiA9IHZhbHVlIGFzICdmaWxlJyB8ICdmb2xkZXInO1xuXHRcdFx0XHRcdFx0Ly8gUmUtcmVuZGVyIHRvIHNob3cvaGlkZSBpbmRleCBmaWxlIG5hbWUgc2V0dGluZ1xuXHRcdFx0XHRcdFx0dm9pZCB0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0XHR9KSk7XG5cblx0XHRcdC8vIFNob3cgaW5kZXggZmlsZSBuYW1lIGZvciBmb2xkZXItYmFzZWQgb3JnYW5pemF0aW9uXG5cdFx0XHRpZiAoY29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbiA9PT0gJ2ZvbGRlcicpIHtcblx0XHRcdFx0bmV3IFNldHRpbmcoc3RlcENvbnRlbnRXcmFwcGVyKVxuXHRcdFx0XHRcdC5zZXROYW1lKGAke2NvbnRlbnRUeXBlLm5hbWV9IC0gSW5kZXggZmlsZSBuYW1lYClcblx0XHRcdFx0XHQuc2V0RGVzYygnTmFtZSBvZiB0aGUgaW5kZXggZmlsZSBpbiBmb2xkZXItYmFzZWQgb3JnYW5pemF0aW9uJylcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZShjb250ZW50VHlwZS5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCcpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRjb250ZW50VHlwZS5pbmRleEZpbGVOYW1lID0gdmFsdWUgfHwgJ2luZGV4Jztcblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTGluayBiYXNlIHBhdGggZm9yIEFzdHJvIENvbXBvc2VyXG5cdFx0XHQvLyBFeHRyYWN0IGZvbGRlciBuYW1lIGZyb20gcGF0aCAoZS5nLiwgXCJzcmMvY29udGVudC9wb3N0c1wiIC0+IFwicG9zdHNcIilcblx0XHRcdGNvbnN0IHBhdGhQYXJ0cyA9IGNvbnRlbnRUeXBlLmZvbGRlci5zcGxpdCgnLycpLmZpbHRlcihwID0+IHAubGVuZ3RoID4gMCk7XG5cdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXSB8fCBjb250ZW50VHlwZS5mb2xkZXI7XG5cdFx0XHRjb25zdCBkZWZhdWx0TGlua0Jhc2VQYXRoID0gYC8ke2ZvbGRlck5hbWV9L2A7XG5cdFx0XHRuZXcgU2V0dGluZyhzdGVwQ29udGVudFdyYXBwZXIpXG5cdFx0XHRcdC5zZXROYW1lKGAke2NvbnRlbnRUeXBlLm5hbWV9IC0gTGluayBiYXNlIHBhdGhgKVxuXHRcdFx0XHQuc2V0RGVzYyhgVVJMIHBhdGggZm9yIHRoaXMgY29udGVudCB0eXBlIChlLmcuLCBcIi9wb3N0cy9cIiBvciBcIi9cIiBmb3Igcm9vdCkuIExlYXZlIGJsYW5rIHRvIHVzZSBkZWZhdWx0OiAke2RlZmF1bHRMaW5rQmFzZVBhdGh9YClcblx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKGRlZmF1bHRMaW5rQmFzZVBhdGgpXG5cdFx0XHRcdFx0LnNldFZhbHVlKGNvbnRlbnRUeXBlLmxpbmtCYXNlUGF0aCB8fCAnJylcblx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0Y29udGVudFR5cGUubGlua0Jhc2VQYXRoID0gdmFsdWUgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH0pKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgQWRkaXRpb25hbCBDb250ZW50IFR5cGUgYnV0dG9uXG5cdFx0Y29uc3QgYWRkQnV0dG9uID0gc3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IFxuXHRcdFx0dGV4dDogJ0FkZCBhZGRpdGlvbmFsIGNvbnRlbnQgdHlwZScsXG5cdFx0XHRjbHM6ICdtb2QtY3RhJ1xuXHRcdH0pO1xuXHRcdHNldENzc1Byb3BzKGFkZEJ1dHRvbiwgeyBtYXJnaW5Ub3A6ICcyMHB4JywgbWFyZ2luQm90dG9tOiAnMzBweCcgfSk7XG5cdFx0YWRkQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuXHRcdFx0dm9pZCAoYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBzZWxlY3RlZEZvbGRlciA9IHRoaXMuc2VsZWN0Q29udGVudFR5cGVGb2xkZXIoKTtcblx0XHRcdFx0aWYgKHNlbGVjdGVkRm9sZGVyKSB7XG5cdFx0XHRcdFx0Ly8gQ2FsY3VsYXRlIHJlbGF0aXZlIHBhdGggZnJvbSB2YXVsdCByb290XG5cdFx0XHRcdFx0Y29uc3QgdmF1bHRQYXRoID0gdGhpcy5nZXRWYXVsdFBhdGgoKTtcblx0XHRcdFx0XHRsZXQgZm9sZGVyUGF0aCA9IHNlbGVjdGVkRm9sZGVyO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIElmIHNlbGVjdGVkIGZvbGRlciBpcyBpbnNpZGUgdGhlIHZhdWx0LCBtYWtlIGl0IHJlbGF0aXZlXG5cdFx0XHRcdFx0aWYgKHNlbGVjdGVkRm9sZGVyLnN0YXJ0c1dpdGgodmF1bHRQYXRoKSkge1xuXHRcdFx0XHRcdFx0Zm9sZGVyUGF0aCA9IHNlbGVjdGVkRm9sZGVyLnN1YnN0cmluZyh2YXVsdFBhdGgubGVuZ3RoKS5yZXBsYWNlKC9eWy9cXFxcXSsvLCAnJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCBmb2xkZXIgbmFtZSBmcm9tIHBhdGggKGxhc3Qgc2VnbWVudCkgZm9yIHRoZSBkaXNwbGF5IG5hbWVcblx0XHRcdFx0XHRjb25zdCBwYXRoUGFydHMgPSBmb2xkZXJQYXRoLnNwbGl0KC9bL1xcXFxdLykuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcblx0XHRcdFx0XHRjb25zdCBsZWFmRm9sZGVyTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV0gfHwgZm9sZGVyUGF0aDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBuZXdUeXBlOiBDb250ZW50VHlwZUNvbmZpZyA9IHtcblx0XHRcdFx0XHRcdGlkOiBgY29udGVudC10eXBlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTEpfWAsXG5cdFx0XHRcdFx0XHRuYW1lOiB0aGlzLmNhcGl0YWxpemVGaXJzdChsZWFmRm9sZGVyTmFtZSksXG5cdFx0XHRcdFx0XHRmb2xkZXI6IGZvbGRlclBhdGgsXG5cdFx0XHRcdFx0XHRmaWxlT3JnYW5pemF0aW9uOiAnZmlsZScsXG5cdFx0XHRcdFx0XHRlbmFibGVkOiB0cnVlLCAvLyBFbmFibGUgYnkgZGVmYXVsdCBzbyBpdCBzaG93cyB1cCBpbiBTdGVwIDVcblx0XHRcdFx0XHRcdGluZGV4RmlsZU5hbWU6ICdpbmRleCdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUuY29udGVudFR5cGVzLnB1c2gobmV3VHlwZSk7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5kaXNwbGF5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0IGZvbGRlciBmb3IgYWRkaXRpb25hbCBjb250ZW50IHR5cGVcblx0ICovXG5cdHByaXZhdGUgc2VsZWN0Q29udGVudFR5cGVGb2xkZXIoKTogc3RyaW5nIHwgbnVsbCB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSBtdWx0aXBsZSB3YXlzIHRvIGFjY2VzcyBFbGVjdHJvbiBkaWFsb2cgQVBJXG5cdFx0XHRsZXQgZGlhbG9nOiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfCBudWxsID0gbnVsbDtcblxuXHRcdFx0Ly8gTWV0aG9kIDE6IFRyeSBAZWxlY3Ryb24vcmVtb3RlIChuZXdlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZiAtLSBkeW5hbWljIHJlcXVpcmUgZm9yIEVsZWN0cm9uXG5cdFx0XHRcdGNvbnN0IGVsZWN0cm9uUmVtb3RlID0gcmVxdWlyZSgnQGVsZWN0cm9uL3JlbW90ZScpIGFzIHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH07XG5cdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uUmVtb3RlPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlLCB0cnkgbmV4dCBtZXRob2Rcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0aG9kIDI6IFRyeSBlbGVjdHJvbi5yZW1vdGUuZGlhbG9nIChvbGRlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9ICgod2luZG93IGFzIHsgcmVxdWlyZT86IChtb2R1bGU6IHN0cmluZykgPT4gdW5rbm93biB9KS5yZXF1aXJlPy4oJ2VsZWN0cm9uJykgfHwgcmVxdWlyZSgnZWxlY3Ryb24nKSkgYXMgeyByZW1vdGU/OiB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9IH07XG5cdFx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb24/LnJlbW90ZT8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ldGhvZCAzOiBUcnkgZWxlY3Ryb24uZGlhbG9nIGRpcmVjdGx5IChtYWluIHByb2Nlc3MsIG1heSBub3Qgd29yaylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJykgYXMgeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfTtcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRpYWxvZyB8fCB0eXBlb2YgZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIGRpYWxvZyBBUEkgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSB0aGlzLmdldFZhdWx0UGF0aCgpO1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBkaWFsb2cuc2hvd09wZW5EaWFsb2dTeW5jKHtcblx0XHRcdFx0dGl0bGU6ICdTZWxlY3QgQ29udGVudCBUeXBlIEZvbGRlcicsXG5cdFx0XHRcdGRlZmF1bHRQYXRoOiB2YXVsdFBhdGgsXG5cdFx0XHRcdHByb3BlcnRpZXM6IFsnb3BlbkRpcmVjdG9yeSddXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBOb3JtYWxpemUgcGF0aCAocmVwbGFjZSBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmQgc2xhc2hlcywgcmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMpXG5cdFx0XHRcdHJldHVybiByZXN1bHRbMF0ucmVwbGFjZSgvXFxcXC9nLCAnLycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9wZW5pbmcgZm9sZGVyIHBpY2tlcjonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKCdVbmFibGUgdG8gb3BlbiBmb2xkZXIgcGlja2VyLiBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgT2JzaWRpYW4gb24gZGVza3RvcC4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHZhdWx0IHBhdGhcblx0ICovXG5cdHByaXZhdGUgZ2V0VmF1bHRQYXRoKCk6IHN0cmluZyB7XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xuXHRcdC8vIFJlc29sdmUgcGF0aCAoY29udmVydCByZWxhdGl2ZSB0byBhYnNvbHV0ZSwgbm9ybWFsaXplIHNlcGFyYXRvcnMpXG5cdFx0aWYgKHZhdWx0UGF0aCkge1xuXHRcdFx0Ly8gSWYgYWxyZWFkeSBhYnNvbHV0ZSwgcmV0dXJuIGFzLWlzIChub3JtYWxpemVkKVxuXHRcdFx0aWYgKHZhdWx0UGF0aC5zdGFydHNXaXRoKCcvJykgfHwgL15bQS1aXTovLnRlc3QodmF1bHRQYXRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdmF1bHRQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblx0XHRcdH1cblx0XHRcdC8vIEZvciByZWxhdGl2ZSBwYXRocywgd2UnZCBuZWVkIHRvIHJlc29sdmUsIGJ1dCBpbiBPYnNpZGlhbiBjb250ZXh0LCBiYXNlUGF0aCBzaG91bGQgYmUgYWJzb2x1dGVcblx0XHRcdHJldHVybiB2YXVsdFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXHRcdH1cblx0XHQvLyBGYWxsYmFjayAtIGluIE9ic2lkaWFuIGNvbnRleHQgdGhpcyBzaG91bGRuJ3QgaGFwcGVuXG5cdFx0cmV0dXJuICcvJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYXBpdGFsaXplIGZpcnN0IGxldHRlclxuXHQgKi9cblx0cHJpdmF0ZSBjYXBpdGFsaXplRmlyc3Qoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuc29tZShjdCA9PiBjdC5lbmFibGVkKTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb250ZW50IHR5cGVzJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb25maWd1cmUgY29udGVudCB0eXBlcyc7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBwYXRoIG9wZXJhdGlvbnNcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgUHJvamVjdERldGVjdGlvblJlc3VsdCB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGNsYXNzIHRvIHJlc29sdmUgY29udGVudCB0eXBlIGZvbGRlciBwYXRocyByZWxhdGl2ZSB0byB2YXVsdCByb290XHJcbiAqIGFuZCBwcm9qZWN0IHJvb3QsIGFjY291bnRpbmcgZm9yIGRpZmZlcmVudCB2YXVsdCBsb2NhdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGF0aFJlc29sdmVyIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGZvbGRlciBwYXRoIGZyb20gdmF1bHQgcm9vdCB0byB0aGUgY29udGVudCB0eXBlIGZvbGRlci5cclxuXHQgKiBUaGlzIGlzIHVzZWQgYnkgQmFzZXMgQ01TIGZpbHRlcnMgYW5kIEFzdHJvIENvbXBvc2VyIGZvbGRlciBzZXR0aW5ncy5cclxuXHQgKiBcclxuXHQgKiBFeGFtcGxlczpcclxuXHQgKiAtIFZhdWx0IGF0IHNyYyBsZXZlbCwgY29udGVudCB0eXBlIFwiZG9jc1wiOiByZXR1cm5zIFwiY29udGVudC9kb2NzXCJcclxuXHQgKiAtIFZhdWx0IGF0IHNyYy9jb250ZW50IGxldmVsLCBjb250ZW50IHR5cGUgXCJkb2NzXCI6IHJldHVybnMgXCJkb2NzXCJcclxuXHQgKiAtIFZhdWx0IGF0IHNyYy9jb250ZW50L3Bvc3QgbGV2ZWwsIGNvbnRlbnQgdHlwZSBcImRvY3NcIjogcmV0dXJucyBcIi4uL2RvY3NcIiAoaWYgYWNjZXNzaWJsZSkgb3IgXCJkb2NzXCIgKGlmIHZhdWx0IGlzIHRoZSBjb250ZW50IHR5cGUgZm9sZGVyKVxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBmb2xkZXJOYW1lIFRoZSBjb250ZW50IHR5cGUgZm9sZGVyIG5hbWUgKGUuZy4sIFwiZG9jc1wiLCBcInBvc3RzXCIpXHJcblx0ICogQHBhcmFtIHByb2plY3REZXRlY3Rpb24gUHJvamVjdCBkZXRlY3Rpb24gcmVzdWx0IHdpdGggcHJvamVjdCByb290IGFuZCB2YXVsdCBsb2NhdGlvblxyXG5cdCAqIEByZXR1cm5zIFBhdGggZnJvbSB2YXVsdCByb290IHRvIGNvbnRlbnQgdHlwZSBmb2xkZXIsIG9yIG51bGwgaWYgY2Fubm90IGJlIGRldGVybWluZWRcclxuXHQgKi9cclxuXHRnZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChmb2xkZXJOYW1lOiBzdHJpbmcsIHByb2plY3REZXRlY3Rpb24/OiBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0KTogc3RyaW5nIHtcclxuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIHsgYmFzZVBhdGg/OiBzdHJpbmc7IHBhdGg/OiBzdHJpbmcgfTtcclxuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xyXG5cclxuXHRcdC8vIDEuIENoZWNrIGlmIGZvbGRlck5hbWUgaXMgYWxyZWFkeSBhIHZhbGlkIHBhdGggaW4gdGhlIHZhdWx0LlxyXG5cdFx0Ly8gVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIGZvbGRlck5hbWUgaXMgYWxyZWFkeSBhIHZhdWx0LXJlbGF0aXZlIHBhdGggKGUuZy4sIFwic3JjL2NvbnRlbnQvcG9zdHNcIlxyXG5cdFx0Ly8gb3IgYSBtYW51YWxseSBzZWxlY3RlZCBmb2xkZXIgbGlrZSBcImJsb2ctcG9zdHNcIikgYW5kIHByb2plY3QgZGV0ZWN0aW9uIG1pZ2h0IG5vdCBiZSBuZWVkZWQuXHJcblx0XHQvLyBXZSBwcmlvcml0aXplIHRoaXMgZm9yIG1hbnVhbGx5IGFkZGVkIGZvbGRlcnMgdGhhdCBhcmUgYWxyZWFkeSBjb3JyZWN0bHkgcmVzb2x2ZWQuXHJcblx0XHRjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlck5hbWUpO1xyXG5cdFx0aWYgKGZpbGUpIHtcclxuXHRcdFx0cmV0dXJuIGZvbGRlck5hbWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gMi4gSWYgcHJvamVjdCBkZXRlY3Rpb24gaXMgYXZhaWxhYmxlLCB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBleGFjdCBpbnRlbmRlZCBwYXRoXHJcblx0XHQvLyBUaGlzIGlzIHByZWZlcnJlZCBmb3IgYXV0by1kZXRlY3RlZCBmb2xkZXJzIGJlY2F1c2UgaXQgaGFuZGxlcyB0aGUgXCJ2YXVsdCBhdCBwcm9qZWN0IHJvb3RcIiBjYXNlIGNvcnJlY3RseVxyXG5cdFx0Ly8gZXZlbiBpZiB0aGVyZSBhcmUgZm9sZGVycyB3aXRoIG1hdGNoaW5nIG5hbWVzIGVsc2V3aGVyZSBpbiB0aGUgdmF1bHQuXHJcblx0XHRpZiAocHJvamVjdERldGVjdGlvbiAmJiBwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290ICYmIHZhdWx0UGF0aCkge1xyXG5cdFx0XHQvLyBSZXNvbHZlIHByb2plY3Qgcm9vdCB0byBhYnNvbHV0ZSBwYXRoXHJcblx0XHRcdGNvbnN0IHByb2plY3RSb290ID0gcGF0aC5pc0Fic29sdXRlKHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpIFxyXG5cdFx0XHRcdD8gcHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCBcclxuXHRcdFx0XHQ6IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpO1xyXG5cclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBpbnRlbmRlZCBjb250ZW50IHR5cGUgZm9sZGVyXHJcblx0XHRcdC8vIElmIGZvbGRlck5hbWUgYWxyZWFkeSBsb29rcyBsaWtlIGEgcGF0aCBmcm9tIHByb2plY3Qgcm9vdCAoZS5nLiBzdGFydHMgd2l0aCBzcmMvY29udGVudCksIHVzZSBpdCBhcy1pc1xyXG5cdFx0XHRsZXQgY29udGVudFR5cGVBYnNvbHV0ZVBhdGg6IHN0cmluZztcclxuXHRcdFx0aWYgKGZvbGRlck5hbWUuc3RhcnRzV2l0aCgnc3JjL2NvbnRlbnQvJykgfHwgZm9sZGVyTmFtZS5pbmNsdWRlcygnL3NyYy9jb250ZW50LycpKSB7XHJcblx0XHRcdFx0Y29udGVudFR5cGVBYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUocHJvamVjdFJvb3QsIGZvbGRlck5hbWUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnRlbnRUeXBlQWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKHByb2plY3RSb290LCAnc3JjJywgJ2NvbnRlbnQnLCBmb2xkZXJOYW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHJlbGF0aXZlIHBhdGggZnJvbSB2YXVsdCB0byBjb250ZW50IHR5cGUgZm9sZGVyXHJcblx0XHRcdGNvbnN0IHZhdWx0QWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKHZhdWx0UGF0aCk7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUodmF1bHRBYnNvbHV0ZVBhdGgsIGNvbnRlbnRUeXBlQWJzb2x1dGVQYXRoKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIElmIHJlbGF0aXZlUGF0aCBpcyB3aXRoaW4gdGhlIHZhdWx0IChkb2Vzbid0IHN0YXJ0IHdpdGggJy4uJyksIHVzZSBpdFxyXG5cdFx0XHRpZiAoIXJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpICYmICFwYXRoLmlzQWJzb2x1dGUocmVsYXRpdmVQYXRoKSkge1xyXG5cdFx0XHRcdC8vIE5vcm1hbGl6ZSB0byB1c2UgZm9yd2FyZCBzbGFzaGVzICh3b3JrcyBvbiBXaW5kb3dzIHRvbylcclxuXHRcdFx0XHRyZXR1cm4gcmVsYXRpdmVQYXRoLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJykgfHwgJy4nO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gMy4gTGFzdCByZXNvcnQgZmFsbGJhY2s6IHJldHVybiBmb2xkZXIgbmFtZSBhcy1pc1xyXG5cdFx0cmV0dXJuIGZvbGRlck5hbWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGZvbGRlciBwYXRoIGZyb20gcHJvamVjdCByb290IHRvIHRoZSBjb250ZW50IHR5cGUgZm9sZGVyLlxyXG5cdCAqIFRoaXMgaXMgYWx3YXlzIFwic3JjL2NvbnRlbnQve2ZvbGRlck5hbWV9XCIgcmVsYXRpdmUgdG8gcHJvamVjdCByb290LlxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBmb2xkZXJOYW1lIFRoZSBjb250ZW50IHR5cGUgZm9sZGVyIG5hbWUgKGUuZy4sIFwiZG9jc1wiLCBcInBvc3RzXCIpXHJcblx0ICogQHJldHVybnMgUGF0aCBmcm9tIHByb2plY3Qgcm9vdCAoZS5nLiwgXCJzcmMvY29udGVudC9kb2NzXCIpXHJcblx0ICovXHJcblx0Z2V0Rm9sZGVyUGF0aEZyb21Qcm9qZWN0Um9vdChmb2xkZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGBzcmMvY29udGVudC8ke2ZvbGRlck5hbWV9YDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgZm9sZGVyIHBhdGggZm9yIEFzdHJvIENvbXBvc2VyLCB3aGljaCBuZWVkcyB0aGUgcGF0aCByZWxhdGl2ZSB0byB2YXVsdCByb290XHJcblx0ICogYnV0IHNob3VsZCB3b3JrIGNvcnJlY3RseSByZWdhcmRsZXNzIG9mIHZhdWx0IGxvY2F0aW9uLlxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBmb2xkZXJOYW1lIFRoZSBjb250ZW50IHR5cGUgZm9sZGVyIG5hbWVcclxuXHQgKiBAcGFyYW0gcHJvamVjdERldGVjdGlvbiBQcm9qZWN0IGRldGVjdGlvbiByZXN1bHRcclxuXHQgKiBAcmV0dXJucyBQYXRoIGZyb20gdmF1bHQgcm9vdCB0byBjb250ZW50IHR5cGUgZm9sZGVyXHJcblx0ICovXHJcblx0Z2V0QXN0cm9Db21wb3NlckZvbGRlclBhdGgoZm9sZGVyTmFtZTogc3RyaW5nLCBwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChmb2xkZXJOYW1lLCBwcm9qZWN0RGV0ZWN0aW9uKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgZm9sZGVyIHBhdGggZm9yIEJhc2VzIENNUyBmaWx0ZXIsIHdoaWNoIG5lZWRzIHRvIG1hdGNoIGZpbGVzXHJcblx0ICogaW4gdGhlIGNvbnRlbnQgdHlwZSBmb2xkZXIgcmVnYXJkbGVzcyBvZiB2YXVsdCBsb2NhdGlvbi5cclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZm9sZGVyTmFtZSBUaGUgY29udGVudCB0eXBlIGZvbGRlciBuYW1lXHJcblx0ICogQHBhcmFtIHByb2plY3REZXRlY3Rpb24gUHJvamVjdCBkZXRlY3Rpb24gcmVzdWx0XHJcblx0ICogQHJldHVybnMgUGF0aCBmcm9tIHZhdWx0IHJvb3QgdG8gY29udGVudCB0eXBlIGZvbGRlciAoZm9yIHVzZSBpbiBmaWxlLmZvbGRlci5zdGFydHNXaXRoIGZpbHRlcilcclxuXHQgKi9cclxuXHRnZXRCYXNlc0NNU0ZvbGRlclBhdGgoZm9sZGVyTmFtZTogc3RyaW5nLCBwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChmb2xkZXJOYW1lLCBwcm9qZWN0RGV0ZWN0aW9uKTtcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbi8qKlxuICogVXRpbGl0eSBmb3Igc2FmZWx5IHJlYWRpbmcgYW5kIHdyaXRpbmcgcGx1Z2luIGNvbmZpZ3VyYXRpb24gZmlsZXNcbiAqIHdpdGggYmFja3VwIGNyZWF0aW9uLCBKU09OIHZhbGlkYXRpb24sIGFuZCBlcnJvciBoYW5kbGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNhZmVDb25maWdXcml0ZXIge1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIEpTT04gb2JqZWN0XG5cdCAqL1xuXHRwcml2YXRlIHZhbGlkYXRlSlNPTihkYXRhOiB1bmtub3duKTogYm9vbGVhbiB7XG5cdFx0aWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSB0byBzdHJpbmdpZnkgYW5kIHBhcnNlIHRvIGVuc3VyZSBpdCdzIHZhbGlkIEpTT05cblx0XHRcdEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiYWNrdXAgb2YgYSBwbHVnaW4ncyBkYXRhLmpzb24gZmlsZVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBjcmVhdGVCYWNrdXAocGx1Z2luSWQ6IHN0cmluZywgb3JpZ2luYWxGaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChvcmlnaW5hbEZpbGUpO1xuXHRcdFx0Y29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6Ll0vZywgJy0nKTtcblx0XHRcdGNvbnN0IGJhY2t1cFBhdGggPSBgJHt0aGlzLmFwcC52YXVsdC5jb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uLmJhY2t1cC0ke3RpbWVzdGFtcH1gO1xuXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYmFja3VwUGF0aCwgY29udGVudCk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKGBTYWZlQ29uZmlnV3JpdGVyOiBDcmVhdGVkIGJhY2t1cCBhdCAke2JhY2t1cFBhdGh9YCk7XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUud2FybihgU2FmZUNvbmZpZ1dyaXRlcjogRmFpbGVkIHRvIGNyZWF0ZSBiYWNrdXAgZm9yICR7cGx1Z2luSWR9OmAsIGVycm9yKTtcblx0XHRcdC8vIERvbid0IHRocm93IC0gYmFja3VwIGZhaWx1cmUgc2hvdWxkbid0IGJsb2NrIHRoZSBvcGVyYXRpb25cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2FmZWx5IHJlYWRzIGEgcGx1Z2luJ3MgZGF0YS5qc29uIGZpbGVcblx0ICovXG5cdGFzeW5jIHJlYWRDb25maWcocGx1Z2luSWQ6IHN0cmluZyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsPiB7XG5cdFx0Y29uc3QgY29uZmlnUGF0aCA9IGAke3RoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGNvbmZpZ1BhdGgpO1xuXG5cdFx0aWYgKCFkYXRhRmlsZSB8fCAhKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRjb25zb2xlLmRlYnVnKGBTYWZlQ29uZmlnV3JpdGVyOiBDb25maWcgZmlsZSBub3QgZm91bmQgZm9yICR7cGx1Z2luSWR9YCk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpO1xuXHRcdFx0Y29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyB1bmtub3duO1xuXG5cdFx0XHRpZiAoIXRoaXMudmFsaWRhdGVKU09OKHBhcnNlZCkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihgU2FmZUNvbmZpZ1dyaXRlcjogSW52YWxpZCBKU09OIHN0cnVjdHVyZSBpbiAke3BsdWdpbklkfSBjb25maWdgKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXJzZWQgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYFNhZmVDb25maWdXcml0ZXI6IEZhaWxlZCB0byByZWFkL3BhcnNlIGNvbmZpZyBmb3IgJHtwbHVnaW5JZH06YCwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNhZmVseSB3cml0ZXMgdG8gYSBwbHVnaW4ncyBkYXRhLmpzb24gZmlsZSB3aXRoIGJhY2t1cCBhbmQgdmFsaWRhdGlvblxuXHQgKi9cblx0YXN5bmMgd3JpdGVDb25maWcoXG5cdFx0cGx1Z2luSWQ6IHN0cmluZyxcblx0XHRkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcblx0XHRvcHRpb25zOiB7IHNob3dOb3RpY2U/OiBib29sZWFuOyBjcmVhdGVCYWNrdXA/OiBib29sZWFuIH0gPSB7fVxuXHQpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zdCB7IHNob3dOb3RpY2UgPSB0cnVlLCBjcmVhdGVCYWNrdXAgPSB0cnVlIH0gPSBvcHRpb25zO1xuXG5cdFx0Ly8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlXG5cdFx0aWYgKCF0aGlzLnZhbGlkYXRlSlNPTihkYXRhKSkge1xuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGBJbnZhbGlkIGNvbmZpZ3VyYXRpb24gZGF0YSBmb3IgJHtwbHVnaW5JZH1gO1xuXHRcdFx0Y29uc29sZS5lcnJvcihgU2FmZUNvbmZpZ1dyaXRlcjogJHttZXNzYWdlfWApO1xuXHRcdFx0aWYgKHNob3dOb3RpY2UpIHtcblx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHNhdmUgJHtwbHVnaW5JZH0gc2V0dGluZ3M6IEludmFsaWQgZGF0YWApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbmZpZ1BhdGggPSBgJHt0aGlzLmFwcC52YXVsdC5jb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBDaGVjayBpZiBmaWxlIGV4aXN0c1xuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY29uZmlnUGF0aCk7XG5cblx0XHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdC8vIENyZWF0ZSBiYWNrdXAgYmVmb3JlIG1vZGlmeWluZ1xuXHRcdFx0XHRpZiAoY3JlYXRlQmFja3VwKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVCYWNrdXAocGx1Z2luSWQsIGRhdGFGaWxlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vZGlmeSBleGlzdGluZyBmaWxlXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBjb250ZW50KTtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgU2FmZUNvbmZpZ1dyaXRlcjogU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgJHtwbHVnaW5JZH0gY29uZmlnYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBDcmVhdGUgbmV3IGZpbGVcblx0XHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7dGhpcy5hcHAudmF1bHQuY29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcblx0XHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EaXIpO1xuXG5cdFx0XHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoY29uZmlnUGF0aCwgY29udGVudCk7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYFNhZmVDb25maWdXcml0ZXI6IFN1Y2Nlc3NmdWxseSBjcmVhdGVkICR7cGx1Z2luSWR9IGNvbmZpZ2ApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYFNhZmVDb25maWdXcml0ZXI6IEZhaWxlZCB0byB3cml0ZSBjb25maWcgZm9yICR7cGx1Z2luSWR9OmAsIGVycm9yKTtcblxuXHRcdFx0aWYgKHNob3dOb3RpY2UpIHtcblx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHNhdmUgJHtwbHVnaW5JZH0gc2V0dGluZ3M6ICR7bWVzc2FnZX1gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTYWZlbHkgbWVyZ2VzIG5ldyBzZXR0aW5ncyBpbnRvIGV4aXN0aW5nIHBsdWdpbiBjb25maWdcblx0ICovXG5cdGFzeW5jIG1lcmdlQ29uZmlnKFxuXHRcdHBsdWdpbklkOiBzdHJpbmcsXG5cdFx0dXBkYXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG5cdFx0b3B0aW9uczogeyBzaG93Tm90aWNlPzogYm9vbGVhbjsgY3JlYXRlQmFja3VwPzogYm9vbGVhbiB9ID0ge31cblx0KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc3QgZXhpc3RpbmdDb25maWcgPSBhd2FpdCB0aGlzLnJlYWRDb25maWcocGx1Z2luSWQpIHx8IHt9O1xuXHRcdGNvbnN0IG1lcmdlZENvbmZpZyA9IHsgLi4uZXhpc3RpbmdDb25maWcsIC4uLnVwZGF0ZXMgfTtcblx0XHRyZXR1cm4gdGhpcy53cml0ZUNvbmZpZyhwbHVnaW5JZCwgbWVyZ2VkQ29uZmlnLCBvcHRpb25zKTtcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEFzdHJvQ29tcG9zZXJDb25maWcsIENvbnRlbnRUeXBlQ29uZmlnLCBGcm9udG1hdHRlclByb3BlcnRpZXMsIFByb2plY3REZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBQYXRoUmVzb2x2ZXIgfSBmcm9tICcuL1BhdGhSZXNvbHZlcic7XG5pbXBvcnQgeyBTYWZlQ29uZmlnV3JpdGVyIH0gZnJvbSAnLi9TYWZlQ29uZmlnV3JpdGVyJztcblxudHlwZSBQbHVnaW5XaXRoU2V0dGluZ3MgPSB7XG5cdHNldHRpbmdzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XG59O1xuXG50eXBlIFBsdWdpbnNBUEkgPSB7XG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBQbHVnaW5XaXRoU2V0dGluZ3M+O1xufTtcblxuZXhwb3J0IGNsYXNzIEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3Ige1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXHRwcml2YXRlIGZyb250bWF0dGVyUHJvcGVydGllcz86IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEZyb250bWF0dGVyUHJvcGVydGllcyB9O1xuXHRwcml2YXRlIGNvbnRlbnRUeXBlcz86IENvbnRlbnRUeXBlQ29uZmlnW107XG5cdHByaXZhdGUgcGF0aFJlc29sdmVyOiBQYXRoUmVzb2x2ZXI7XG5cdHByaXZhdGUgc2FmZVdyaXRlcjogU2FmZUNvbmZpZ1dyaXRlcjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMucGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcihhcHApO1xuXHRcdHRoaXMuc2FmZVdyaXRlciA9IG5ldyBTYWZlQ29uZmlnV3JpdGVyKGFwcCk7XG5cdH1cblxuXHRjb25maWd1cmVBc3Ryb0NvbXBvc2VyKFxuXHRcdGNvbnRlbnRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSxcblx0XHRmcm9udG1hdHRlclByb3BlcnRpZXM6IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEZyb250bWF0dGVyUHJvcGVydGllcyB9LFxuXHRcdHByb2plY3RSb290OiBzdHJpbmcsXG5cdFx0Y29uZmlnRmlsZVBhdGg6IHN0cmluZyxcblx0XHRkZWZhdWx0Q29udGVudFR5cGVJZD86IHN0cmluZyxcblx0XHRwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCxcblx0XHRlbmFibGVNZHhTdXBwb3J0PzogYm9vbGVhblxuXHQpOiBQcm9taXNlPEFzdHJvQ29tcG9zZXJDb25maWc+IHtcblx0XHQvLyBTdG9yZSBmcm9udG1hdHRlclByb3BlcnRpZXMgYW5kIGNvbnRlbnRUeXBlcyBmb3IgdXNlIGluIHNhdmVDb25maWdcblx0XHR0aGlzLmZyb250bWF0dGVyUHJvcGVydGllcyA9IGZyb250bWF0dGVyUHJvcGVydGllcztcblx0XHR0aGlzLmNvbnRlbnRUeXBlcyA9IGNvbnRlbnRUeXBlcztcblx0XHRcblx0XHRjb25zdCBjb25maWc6IEFzdHJvQ29tcG9zZXJDb25maWcgPSB7XG5cdFx0XHRjdXN0b21Db250ZW50VHlwZXM6IFtdLFxuXHRcdFx0ZGVmYXVsdFRlbXBsYXRlOiAnJyxcblx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiB0aGlzLnJlbGF0aXZlUGF0aChjb25maWdGaWxlUGF0aCksXG5cdFx0XHR0ZXJtaW5hbFByb2plY3RSb290UGF0aDogdGhpcy5yZWxhdGl2ZVBhdGgocHJvamVjdFJvb3QpLFxuXHRcdFx0c2hvd01keEZpbGVzSW5FeHBsb3JlcjogZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZVxuXHRcdH07XG5cblx0XHQvLyBBZGQgYWxsIGVuYWJsZWQgY29udGVudCB0eXBlcyB0byBjdXN0b21Db250ZW50VHlwZXMgKG5ldyB1bmlmaWVkIHN0cnVjdHVyZSlcblx0XHQvLyBTZXBhcmF0ZSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBmcm9tIG90aGVycyB0byBwdXQgaXQgZmlyc3Rcblx0XHRjb25zdCBkZWZhdWx0Q29udGVudFR5cGUgPSBkZWZhdWx0Q29udGVudFR5cGVJZCA/IGNvbnRlbnRUeXBlcy5maW5kKGN0ID0+IGN0LmlkID09PSBkZWZhdWx0Q29udGVudFR5cGVJZCAmJiBjdC5lbmFibGVkKSA6IG51bGw7XG5cdFx0Y29uc3Qgb3RoZXJDb250ZW50VHlwZXMgPSBjb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQgJiYgKCFkZWZhdWx0Q29udGVudFR5cGVJZCB8fCBjdC5pZCAhPT0gZGVmYXVsdENvbnRlbnRUeXBlSWQpKTtcblxuXHRcdC8vIEFkZCBkZWZhdWx0IGNvbnRlbnQgdHlwZSBmaXJzdCBpZiBpdCBleGlzdHNcblx0XHRpZiAoZGVmYXVsdENvbnRlbnRUeXBlKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGZyb250bWF0dGVyUHJvcGVydGllc1tkZWZhdWx0Q29udGVudFR5cGUuaWRdO1xuXHRcdFx0bGV0IGxpbmtCYXNlUGF0aCA9IGRlZmF1bHRDb250ZW50VHlwZS5saW5rQmFzZVBhdGg7XG5cdFx0XHRpZiAobGlua0Jhc2VQYXRoID09PSB1bmRlZmluZWQgfHwgbGlua0Jhc2VQYXRoID09PSAnJykge1xuXHRcdFx0XHQvLyBVc2Ugb25seSB0aGUgZm9sZGVyIG5hbWUgZm9yIHRoZSBkZWZhdWx0IGxpbmsgYmFzZSBwYXRoIChlLmcuIFwic3JjL2NvbnRlbnQvcG9zdHNcIiAtPiBcIi9wb3N0cy9cIilcblx0XHRcdFx0Y29uc3QgcGF0aFBhcnRzID0gZGVmYXVsdENvbnRlbnRUeXBlLmZvbGRlci5zcGxpdCgnLycpLmZpbHRlcihwID0+IHAubGVuZ3RoID4gMCk7XG5cdFx0XHRcdGNvbnN0IGZvbGRlck5hbWUgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdIHx8IGRlZmF1bHRDb250ZW50VHlwZS5mb2xkZXI7XG5cdFx0XHRcdGxpbmtCYXNlUGF0aCA9IGAvJHtmb2xkZXJOYW1lfS9gO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBmb2xkZXJQYXRoID0gdGhpcy5wYXRoUmVzb2x2ZXIuZ2V0QXN0cm9Db21wb3NlckZvbGRlclBhdGgoZGVmYXVsdENvbnRlbnRUeXBlLmZvbGRlciwgcHJvamVjdERldGVjdGlvbik7XG5cdFx0XHRjb25maWcuY3VzdG9tQ29udGVudFR5cGVzLnB1c2goe1xuXHRcdFx0XHRpZDogZGVmYXVsdENvbnRlbnRUeXBlLmlkLFxuXHRcdFx0XHRuYW1lOiBkZWZhdWx0Q29udGVudFR5cGUubmFtZSxcblx0XHRcdFx0Zm9sZGVyOiBmb2xkZXJQYXRoLFxuXHRcdFx0XHR0ZW1wbGF0ZTogcHJvcHM/LnRlbXBsYXRlIHx8IHRoaXMuZ2VuZXJhdGVUZW1wbGF0ZShwcm9wcyksXG5cdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdGxpbmtCYXNlUGF0aDogbGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRjcmVhdGlvbk1vZGU6IGRlZmF1bHRDb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uLFxuXHRcdFx0XHRpbmRleEZpbGVOYW1lOiBkZWZhdWx0Q29udGVudFR5cGUuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gU2V0IGxlZ2FjeSBmaWVsZHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHVzaW5nIHRoZSBkZWZhdWx0IGNvbnRlbnQgdHlwZVxuXHRcdFx0Y29uZmlnLnBvc3RzRm9sZGVyID0gZm9sZGVyUGF0aDtcblx0XHRcdGNvbmZpZy5wb3N0c0NyZWF0aW9uTW9kZSA9IGRlZmF1bHRDb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uO1xuXHRcdFx0Y29uZmlnLnBvc3RzSW5kZXhGaWxlTmFtZSA9IGRlZmF1bHRDb250ZW50VHlwZS5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCc7XG5cdFx0XHRjb25maWcuZGVmYXVsdFRlbXBsYXRlID0gcHJvcHM/LnRlbXBsYXRlIHx8IHRoaXMuZ2VuZXJhdGVUZW1wbGF0ZShwcm9wcyk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIG90aGVyIGNvbnRlbnQgdHlwZXNcblx0XHRmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIG90aGVyQ29udGVudFR5cGVzKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF07XG5cdFx0XHQvLyBEZXRlcm1pbmUgbGlua0Jhc2VQYXRoOiB1c2Ugc3BlY2lmaWVkLCBvciBkZWZhdWx0IHRvIC9mb2xkZXJOYW1lL1xuXHRcdFx0Ly8gSWYgYmxhbmssIGRlZmF1bHQgdG8gL2ZvbGRlck5hbWUvLiBJZiBcIi9cIiwgdXNlIFwiL1wiIGZvciByb290LlxuXHRcdFx0bGV0IGxpbmtCYXNlUGF0aCA9IGNvbnRlbnRUeXBlLmxpbmtCYXNlUGF0aDtcblx0XHRcdGlmIChsaW5rQmFzZVBhdGggPT09IHVuZGVmaW5lZCB8fCBsaW5rQmFzZVBhdGggPT09ICcnKSB7XG5cdFx0XHRcdC8vIFVzZSBvbmx5IHRoZSBmb2xkZXIgbmFtZSBmb3IgdGhlIGRlZmF1bHQgbGluayBiYXNlIHBhdGggKGUuZy4gXCJzcmMvY29udGVudC9wb3N0c1wiIC0+IFwiL3Bvc3RzL1wiKVxuXHRcdFx0XHRjb25zdCBwYXRoUGFydHMgPSBjb250ZW50VHlwZS5mb2xkZXIuc3BsaXQoJy8nKS5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuXHRcdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXSB8fCBjb250ZW50VHlwZS5mb2xkZXI7XG5cdFx0XHRcdGxpbmtCYXNlUGF0aCA9IGAvJHtmb2xkZXJOYW1lfS9gO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdXNlciBzcGVjaWZpZWQgXCIvXCIsIGtlZXAgaXQgYXMgXCIvXCIgZm9yIHJvb3Rcblx0XHRcdFxuXHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IHRoaXMucGF0aFJlc29sdmVyLmdldEFzdHJvQ29tcG9zZXJGb2xkZXJQYXRoKGNvbnRlbnRUeXBlLmZvbGRlciwgcHJvamVjdERldGVjdGlvbik7XG5cdFx0XHRjb25maWcuY3VzdG9tQ29udGVudFR5cGVzLnB1c2goe1xuXHRcdFx0XHRpZDogY29udGVudFR5cGUuaWQsXG5cdFx0XHRcdG5hbWU6IGNvbnRlbnRUeXBlLm5hbWUsXG5cdFx0XHRcdGZvbGRlcjogZm9sZGVyUGF0aCxcblx0XHRcdFx0Ly8gVXNlIHRlbXBsYXRlIGZyb20gcHJvcHMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZ2VuZXJhdGVcblx0XHRcdFx0dGVtcGxhdGU6IHByb3BzPy50ZW1wbGF0ZSB8fCB0aGlzLmdlbmVyYXRlVGVtcGxhdGUocHJvcHMpLFxuXHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRsaW5rQmFzZVBhdGg6IGxpbmtCYXNlUGF0aCxcblx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBjb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uLFxuXHRcdFx0XHRpbmRleEZpbGVOYW1lOiBjb250ZW50VHlwZS5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVUZW1wbGF0ZShwcm9wczogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcblx0XHQvLyBVc2UgdGVtcGxhdGUgZnJvbSBwcm9wcyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBnZW5lcmF0ZSBkZWZhdWx0XG5cdFx0aWYgKHByb3BzPy50ZW1wbGF0ZSkge1xuXHRcdFx0cmV0dXJuIHByb3BzLnRlbXBsYXRlO1xuXHRcdH1cblxuXHRcdGlmICghcHJvcHMpIHtcblx0XHRcdHJldHVybiAnLS0tXFxudGl0bGU6IFwie3t0aXRsZX19XCJcXG4tLS1cXG4nO1xuXHRcdH1cblxuXHRcdGxldCB0ZW1wbGF0ZSA9ICctLS1cXG4nO1xuXHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLnRpdGxlUHJvcGVydHkgfHwgJ3RpdGxlJ306IFwie3t0aXRsZX19XCJcXG5gO1xuXHRcdFxuXHRcdGlmIChwcm9wcy5kYXRlUHJvcGVydHkpIHtcblx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRhdGVQcm9wZXJ0eX06IHt7ZGF0ZX19XFxuYDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9OiBcIlwiXFxuYDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHByb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMudGFnc1Byb3BlcnR5fTogW11cXG5gO1xuXHRcdH1cblx0XHRcblx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSkge1xuXHRcdFx0Y29uc3QgZHJhZnRWYWx1ZSA9IHByb3BzLmRyYWZ0TG9naWMgPT09ICdmYWxzZS1kcmFmdCcgPyAnZmFsc2UnIDogJ3RydWUnO1xuXHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMuZHJhZnRQcm9wZXJ0eX06ICR7ZHJhZnRWYWx1ZX1cXG5gO1xuXHRcdH1cblx0XHRcblx0XHR0ZW1wbGF0ZSArPSAnLS0tXFxuJztcblxuXHRcdHJldHVybiB0ZW1wbGF0ZTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0Q3JlYXRpb25Nb2RlRnJvbUF0dGFjaG1lbnRIYW5kbGluZyhtb2RlOiAnc3BlY2lmaWVkLWZvbGRlcicgfCAnc2FtZS1mb2xkZXInIHwgJ3N1YmZvbGRlcicpOiAnZmlsZScgfCAnZm9sZGVyJyB7XG5cdFx0Ly8gc2FtZS1mb2xkZXIgbWVhbnMgYXR0YWNobWVudHMgYXJlIGluIHRoZSBzYW1lIGZvbGRlciBhcyB0aGUgZmlsZSAoZm9sZGVyLWJhc2VkIGFwcHJvYWNoKVxuXHRcdC8vIHNwZWNpZmllZC1mb2xkZXIgYW5kIHN1YmZvbGRlciBtZWFuIGF0dGFjaG1lbnRzIGFyZSBpbiBzZXBhcmF0ZSBmb2xkZXJzIChmaWxlLWJhc2VkIGFwcHJvYWNoKVxuXHRcdHJldHVybiBtb2RlID09PSAnc2FtZS1mb2xkZXInID8gJ2ZvbGRlcicgOiAnZmlsZSc7XG5cdH1cblxuXHRwcml2YXRlIHJlbGF0aXZlUGF0aChpbnB1dFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0Ly8gSWYgcGF0aCBpcyBhbHJlYWR5IHJlbGF0aXZlLCByZXR1cm4gYXMtaXMgKG5vIGxlYWRpbmcgLyBvciBkcml2ZSBsZXR0ZXIpXG5cdFx0aWYgKCFpbnB1dFBhdGguc3RhcnRzV2l0aCgnLycpICYmICEvXltBLVpdOi8udGVzdChpbnB1dFBhdGgpKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXRQYXRoO1xuXHRcdH1cblx0XHRcblx0XHQvLyBDb252ZXJ0IGFic29sdXRlIHBhdGggdG8gcmVsYXRpdmUgZnJvbSB2YXVsdCByb290XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xuXHRcdGlmICghdmF1bHRQYXRoKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXRQYXRoO1xuXHRcdH1cblx0XHRcblx0XHQvLyBOb3JtYWxpemUgcGF0aHMgKHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMsIHJlbW92ZSB0cmFpbGluZyBzbGFzaGVzKVxuXHRcdGNvbnN0IHZhdWx0Tm9ybWFsaXplZCA9IHZhdWx0UGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0XHRjb25zdCBhYnNvbHV0ZU5vcm1hbGl6ZWQgPSBpbnB1dFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdFx0XG5cdFx0aWYgKGFic29sdXRlTm9ybWFsaXplZC5zdGFydHNXaXRoKHZhdWx0Tm9ybWFsaXplZCkpIHtcblx0XHRcdGNvbnN0IHJlbGF0aXZlID0gYWJzb2x1dGVOb3JtYWxpemVkLnNsaWNlKHZhdWx0Tm9ybWFsaXplZC5sZW5ndGgpO1xuXHRcdFx0Ly8gUmVtb3ZlIGxlYWRpbmcgcGF0aCBzZXBhcmF0b3Jcblx0XHRcdHJldHVybiByZWxhdGl2ZS5zdGFydHNXaXRoKCcvJykgPyByZWxhdGl2ZS5zbGljZSgxKSA6IHJlbGF0aXZlO1xuXHRcdH1cblx0XHRcblx0XHQvLyBQYXRoIGlzIG91dHNpZGUgdmF1bHQsIHJldHVybiBhcy1pc1xuXHRcdHJldHVybiBpbnB1dFBhdGg7XG5cdH1cblxuXHRhc3luYyBzYXZlQ29uZmlnKGNvbmZpZzogQXN0cm9Db21wb3NlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBVc2UgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZCBsaWtlIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgZG9lc1xuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XG5cdFx0XHRjb25zdCBhc3Ryb0NvbXBvc2VyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uWydhc3Ryby1jb21wb3NlciddO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWFzdHJvQ29tcG9zZXJQbHVnaW4pIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdBc3Ryb0NvbXBvc2VyQ29uZmlnOiBBc3RybyBDb21wb3NlciBwbHVnaW4gbm90IGZvdW5kLCB1c2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICghYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncykge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0FzdHJvQ29tcG9zZXJDb25maWc6IEFzdHJvIENvbXBvc2VyIHBsdWdpbiBzZXR0aW5ncyBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBsdWdpblNldHRpbmdzID0gYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncztcblx0XHRcdFxuXHRcdFx0Ly8gVXBkYXRlIHRlbXBsYXRlcyBmcm9tIGNvbmZpZ1xuXHRcdFx0aWYgKGNvbmZpZy5kZWZhdWx0VGVtcGxhdGUpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZGVmYXVsdFRlbXBsYXRlID0gY29uZmlnLmRlZmF1bHRUZW1wbGF0ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucGFnZVRlbXBsYXRlKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLnBhZ2VUZW1wbGF0ZSA9IGNvbmZpZy5wYWdlVGVtcGxhdGU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFVwZGF0ZSBwb3N0cy9wYWdlcyBmb2xkZXIgc2V0dGluZ3Ncblx0XHRcdGlmIChjb25maWcucG9zdHNGb2xkZXIpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MucG9zdHNGb2xkZXIgPSBjb25maWcucG9zdHNGb2xkZXI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnBvc3RzQ3JlYXRpb25Nb2RlKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmNyZWF0aW9uTW9kZSA9IGNvbmZpZy5wb3N0c0NyZWF0aW9uTW9kZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucG9zdHNJbmRleEZpbGVOYW1lKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmluZGV4RmlsZU5hbWUgPSBjb25maWcucG9zdHNJbmRleEZpbGVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5lbmFibGVQYWdlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmVuYWJsZVBhZ2VzID0gY29uZmlnLmVuYWJsZVBhZ2VzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5wYWdlc0ZvbGRlcikge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5wYWdlc0ZvbGRlciA9IGNvbmZpZy5wYWdlc0ZvbGRlcjtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucGFnZXNDcmVhdGlvbk1vZGUpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MucGFnZXNDcmVhdGlvbk1vZGUgPSBjb25maWcucGFnZXNDcmVhdGlvbk1vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnBhZ2VzSW5kZXhGaWxlTmFtZSkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5wYWdlc0luZGV4RmlsZU5hbWUgPSBjb25maWcucGFnZXNJbmRleEZpbGVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBVcGRhdGUgY29uZmlnIHBhdGhzXG5cdFx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoID0gY29uZmlnLmNvbmZpZ0ZpbGVQYXRoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy50ZXJtaW5hbFByb2plY3RSb290UGF0aCA9IGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRW5zdXJlIGNvbW1hbmRzIGFyZSBlbmFibGVkIG9ubHkgaWYgcGF0aHMgYXJlIHByZXNlbnRcblx0XHRcdGlmIChjb25maWcuY29uZmlnRmlsZVBhdGggJiYgY29uZmlnLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmVuYWJsZU9wZW5UZXJtaW5hbENvbW1hbmQgPSB0cnVlO1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVPcGVuQ29uZmlnRmlsZUNvbW1hbmQgPSB0cnVlO1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVUZXJtaW5hbFJpYmJvbkljb24gPSB0cnVlO1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVDb25maWdSaWJib25JY29uID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVXBkYXRlIE1EWCBzdXBwb3J0IGZsYWdcblx0XHRcdGlmIChjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3JlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLnNob3dNZHhGaWxlc0luRXhwbG9yZXIgPSBjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3Jlcjtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQXN0cm9Db21wb3NlckNvbmZpZzogU2V0IHNob3dNZHhGaWxlc0luRXhwbG9yZXIgdG8nLCBjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3Jlcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdBc3Ryb0NvbXBvc2VyQ29uZmlnOiBzaG93TWR4RmlsZXNJbkV4cGxvcmVyIGlzIHVuZGVmaW5lZCwgbm90IHVwZGF0aW5nJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFVwZGF0ZSBjb250ZW50VHlwZXMgYXJyYXkgKG5ldyB1bmlmaWVkIHN0cnVjdHVyZSlcblx0XHRcdC8vIEluaXRpYWxpemUgY29udGVudFR5cGVzIGFycmF5IGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShwbHVnaW5TZXR0aW5ncy5jb250ZW50VHlwZXMpKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmNvbnRlbnRUeXBlcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBNZXJnZS91cGRhdGUgY29udGVudFR5cGVzIGFycmF5IC0gbWF0Y2ggYnkgSUQgZmlyc3QsIHRoZW4gZmFsbGJhY2sgdG8gbmFtZStmb2xkZXJcblx0XHRcdGZvciAoY29uc3QgbmV3VHlwZSBvZiBjb25maWcuY3VzdG9tQ29udGVudFR5cGVzKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgZnJvbnRtYXR0ZXIgcHJvcGVydGllcyB0byBjaGVjayBkcmFmdCBzdGF0dXNcblx0XHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSB0aGlzLmNvbnRlbnRUeXBlcz8uZmluZChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRcdGNvbnN0IHByb3BzID0gY29udGVudFR5cGUgJiYgdGhpcy5mcm9udG1hdHRlclByb3BlcnRpZXMgPyB0aGlzLmZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF0gOiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHVuZGVyc2NvcmUgcHJlZml4IHNob3VsZCBiZSBlbmFibGVkXG5cdFx0XHRcdC8vIEVuYWJsZSBpZiBoYXNEcmFmdFN0YXR1cyBpcyB0cnVlIGJ1dCBkcmFmdFByb3BlcnR5IGlzIGJsYW5rL3VuZGVmaW5lZFxuXHRcdFx0XHRjb25zdCBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4ID0gcHJvcHM/Lmhhc0RyYWZ0U3RhdHVzID09PSB0cnVlICYmICFwcm9wcz8uZHJhZnRQcm9wZXJ0eTtcblxuXHRcdFx0XHQvLyBGaW5kIGV4aXN0aW5nIGVudHJ5IC0gcHJlZmVyIElEIG1hdGNoaW5nLCBmYWxsYmFjayB0byBuYW1lK2ZvbGRlciBmb3IgZHVwbGljYXRlIGRldGVjdGlvblxuXHRcdFx0XHRjb25zdCBjb250ZW50VHlwZXMgPSAocGx1Z2luU2V0dGluZ3MuY29udGVudFR5cGVzIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW107XG5cdFx0XHRcdGxldCBleGlzdGluZ0luZGV4ID0gLTE7XG5cdFx0XHRcdGxldCBtYXRjaGVkQnlJZCA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIEZpcnN0LCB0cnkgdG8gbWF0Y2ggYnkgSUQgKHByZWZlcnJlZCAtIHVuaXF1ZSBpZGVudGlmaWVyKVxuXHRcdFx0XHRpZiAobmV3VHlwZS5pZCkge1xuXHRcdFx0XHRcdGV4aXN0aW5nSW5kZXggPSBjb250ZW50VHlwZXMuZmluZEluZGV4KChjdDogeyBpZD86IHN0cmluZyB9KSA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRcdFx0aWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZEJ5SWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZhbGxiYWNrIHRvIG5hbWUrZm9sZGVyIGZvciBkdXBsaWNhdGUgZGV0ZWN0aW9uIChwcmV2ZW50cyBjcmVhdGluZyBkdXBsaWNhdGVzKVxuXHRcdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA8IDApIHtcblx0XHRcdFx0XHRleGlzdGluZ0luZGV4ID0gY29udGVudFR5cGVzLmZpbmRJbmRleCgoY3Q6IHsgbmFtZT86IHN0cmluZzsgZm9sZGVyPzogc3RyaW5nIH0pID0+XG5cdFx0XHRcdFx0XHRjdC5uYW1lID09PSBuZXdUeXBlLm5hbWUgJiYgY3QuZm9sZGVyID09PSBuZXdUeXBlLmZvbGRlclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZyBlbnRyeSAtIHByZXNlcnZlIG90aGVyIHByb3BlcnRpZXMgbGlrZSBpZ25vcmVTdWJmb2xkZXJzLCBlbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdFx0Ly8gSU1QT1JUQU5UOiBQcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgSUQgd2hlbiBtYXRjaGVkIGJ5IG5hbWUrZm9sZGVyIChkb24ndCBvdmVyd3JpdGUgd2l0aCBuZXcgSUQpXG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdFbnRyeSA9IGNvbnRlbnRUeXBlc1tleGlzdGluZ0luZGV4XSBhcyB7IGlkPzogc3RyaW5nIH07XG5cdFx0XHRcdFx0Y29udGVudFR5cGVzW2V4aXN0aW5nSW5kZXhdID0ge1xuXHRcdFx0XHRcdFx0Li4uZXhpc3RpbmdFbnRyeSxcblx0XHRcdFx0XHRcdC8vIE9ubHkgdXBkYXRlIElEIGlmIHdlIG1hdGNoZWQgYnkgSUQsIG90aGVyd2lzZSBrZWVwIGV4aXN0aW5nIElEIGZvciBjb25zaXN0ZW5jeVxuXHRcdFx0XHRcdFx0aWQ6IG1hdGNoZWRCeUlkID8gbmV3VHlwZS5pZCA6IChleGlzdGluZ0VudHJ5LmlkIHx8IG5ld1R5cGUuaWQpLFxuXHRcdFx0XHRcdFx0bmFtZTogbmV3VHlwZS5uYW1lLFxuXHRcdFx0XHRcdFx0Zm9sZGVyOiBuZXdUeXBlLmZvbGRlcixcblx0XHRcdFx0XHRcdGxpbmtCYXNlUGF0aDogbmV3VHlwZS5saW5rQmFzZVBhdGgsXG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogbmV3VHlwZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdGVuYWJsZWQ6IG5ld1R5cGUuZW5hYmxlZCxcblx0XHRcdFx0XHRcdGNyZWF0aW9uTW9kZTogbmV3VHlwZS5jcmVhdGlvbk1vZGUsXG5cdFx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBuZXdUeXBlLmluZGV4RmlsZU5hbWUsXG5cdFx0XHRcdFx0XHRlbmFibGVVbmRlcnNjb3JlUHJlZml4OiBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBBZGQgbmV3IGVudHJ5IHdpdGggYWxsIHJlcXVpcmVkIHByb3BlcnRpZXNcblx0XHRcdFx0XHRjb250ZW50VHlwZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRpZDogbmV3VHlwZS5pZCxcblx0XHRcdFx0XHRcdG5hbWU6IG5ld1R5cGUubmFtZSxcblx0XHRcdFx0XHRcdGZvbGRlcjogbmV3VHlwZS5mb2xkZXIsXG5cdFx0XHRcdFx0XHRsaW5rQmFzZVBhdGg6IG5ld1R5cGUubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IG5ld1R5cGUudGVtcGxhdGUsXG5cdFx0XHRcdFx0XHRlbmFibGVkOiBuZXdUeXBlLmVuYWJsZWQsXG5cdFx0XHRcdFx0XHRjcmVhdGlvbk1vZGU6IG5ld1R5cGUuY3JlYXRpb25Nb2RlLFxuXHRcdFx0XHRcdFx0aW5kZXhGaWxlTmFtZTogbmV3VHlwZS5pbmRleEZpbGVOYW1lLFxuXHRcdFx0XHRcdFx0aWdub3JlU3ViZm9sZGVyczogZmFsc2UsXG5cdFx0XHRcdFx0XHRlbmFibGVVbmRlcnNjb3JlUHJlZml4OiBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQWxzbyB1cGRhdGUgbGVnYWN5IGN1c3RvbUNvbnRlbnRUeXBlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdHBsdWdpblNldHRpbmdzLmN1c3RvbUNvbnRlbnRUeXBlcyA9IHRoaXMubWVyZ2VDdXN0b21Db250ZW50VHlwZXMoXG5cdFx0XHRcdChwbHVnaW5TZXR0aW5ncy5jdXN0b21Db250ZW50VHlwZXMgYXMgQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KSB8fCBbXSxcblx0XHRcdFx0KGNvbmZpZy5jdXN0b21Db250ZW50VHlwZXMgYXMgdW5rbm93biBhcyBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4pIHx8IFtdXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHQvLyBTYXZlIHRoZSBzZXR0aW5ncyB1c2luZyBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kXG5cdFx0XHRpZiAodHlwZW9mIGFzdHJvQ29tcG9zZXJQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGF3YWl0IGFzdHJvQ29tcG9zZXJQbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0FzdHJvQ29tcG9zZXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0FzdHJvQ29tcG9zZXJDb25maWc6IFBsdWdpbiBzYXZlU2V0dGluZ3Mgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2snKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgQXN0cm8gQ29tcG9zZXIgY29uZmlnIHZpYSBwbHVnaW4gbWV0aG9kOicsIGVycm9yKTtcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogQXN0cm9Db21wb3NlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHBsdWdpbklkID0gJ2FzdHJvLWNvbXBvc2VyJztcblxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgZGF0YSBzYWZlbHlcblx0XHRsZXQgZXhpc3RpbmdEYXRhID0gYXdhaXQgdGhpcy5zYWZlV3JpdGVyLnJlYWRDb25maWcocGx1Z2luSWQpO1xuXHRcdGlmICghZXhpc3RpbmdEYXRhKSB7XG5cdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gTWVyZ2UgY29uZmlnIGludG8gZXhpc3RpbmcgZGF0YVxuXHRcdGlmIChjb25maWcuZGVmYXVsdFRlbXBsYXRlKSBleGlzdGluZ0RhdGEuZGVmYXVsdFRlbXBsYXRlID0gY29uZmlnLmRlZmF1bHRUZW1wbGF0ZTtcblx0XHRpZiAoY29uZmlnLnBhZ2VUZW1wbGF0ZSkgZXhpc3RpbmdEYXRhLnBhZ2VUZW1wbGF0ZSA9IGNvbmZpZy5wYWdlVGVtcGxhdGU7XG5cdFx0aWYgKGNvbmZpZy5wb3N0c0ZvbGRlcikgZXhpc3RpbmdEYXRhLnBvc3RzRm9sZGVyID0gY29uZmlnLnBvc3RzRm9sZGVyO1xuXHRcdGlmIChjb25maWcucG9zdHNDcmVhdGlvbk1vZGUpIGV4aXN0aW5nRGF0YS5jcmVhdGlvbk1vZGUgPSBjb25maWcucG9zdHNDcmVhdGlvbk1vZGU7XG5cdFx0aWYgKGNvbmZpZy5wb3N0c0luZGV4RmlsZU5hbWUpIGV4aXN0aW5nRGF0YS5pbmRleEZpbGVOYW1lID0gY29uZmlnLnBvc3RzSW5kZXhGaWxlTmFtZTtcblx0XHRpZiAoY29uZmlnLmVuYWJsZVBhZ2VzICE9PSB1bmRlZmluZWQpIGV4aXN0aW5nRGF0YS5lbmFibGVQYWdlcyA9IGNvbmZpZy5lbmFibGVQYWdlcztcblx0XHRpZiAoY29uZmlnLnBhZ2VzRm9sZGVyKSBleGlzdGluZ0RhdGEucGFnZXNGb2xkZXIgPSBjb25maWcucGFnZXNGb2xkZXI7XG5cdFx0aWYgKGNvbmZpZy5wYWdlc0NyZWF0aW9uTW9kZSkgZXhpc3RpbmdEYXRhLnBhZ2VzQ3JlYXRpb25Nb2RlID0gY29uZmlnLnBhZ2VzQ3JlYXRpb25Nb2RlO1xuXHRcdGlmIChjb25maWcucGFnZXNJbmRleEZpbGVOYW1lKSBleGlzdGluZ0RhdGEucGFnZXNJbmRleEZpbGVOYW1lID0gY29uZmlnLnBhZ2VzSW5kZXhGaWxlTmFtZTtcblx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoKSBleGlzdGluZ0RhdGEuY29uZmlnRmlsZVBhdGggPSBjb25maWcuY29uZmlnRmlsZVBhdGg7XG5cdFx0aWYgKGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkgZXhpc3RpbmdEYXRhLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoID0gY29uZmlnLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoO1xuXHRcdGlmIChjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3JlciAhPT0gdW5kZWZpbmVkKSBleGlzdGluZ0RhdGEuc2hvd01keEZpbGVzSW5FeHBsb3JlciA9IGNvbmZpZy5zaG93TWR4RmlsZXNJbkV4cGxvcmVyO1xuXG5cdFx0Ly8gRW5zdXJlIGNvbW1hbmRzIGFyZSBlbmFibGVkIG9ubHkgaWYgcGF0aHMgYXJlIHByZXNlbnRcblx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoICYmIGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkge1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmVuYWJsZU9wZW5UZXJtaW5hbENvbW1hbmQgPSB0cnVlO1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmVuYWJsZU9wZW5Db25maWdGaWxlQ29tbWFuZCA9IHRydWU7XG5cdFx0XHRleGlzdGluZ0RhdGEuZW5hYmxlVGVybWluYWxSaWJib25JY29uID0gdHJ1ZTtcblx0XHRcdGV4aXN0aW5nRGF0YS5lbmFibGVDb25maWdSaWJib25JY29uID0gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gVXBkYXRlIGNvbnRlbnRUeXBlcyBhcnJheSAobmV3IHVuaWZpZWQgc3RydWN0dXJlKVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShleGlzdGluZ0RhdGEuY29udGVudFR5cGVzKSkge1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmNvbnRlbnRUeXBlcyA9IFtdO1xuXHRcdH1cblx0XHRcblx0XHQvLyBNZXJnZS91cGRhdGUgY29udGVudFR5cGVzIGFycmF5IC0gbWF0Y2ggYnkgSUQgZmlyc3QsIHRoZW4gZmFsbGJhY2sgdG8gbmFtZStmb2xkZXJcblx0XHRmb3IgKGNvbnN0IG5ld1R5cGUgb2YgY29uZmlnLmN1c3RvbUNvbnRlbnRUeXBlcykge1xuXHRcdFx0Ly8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBmcm9udG1hdHRlciBwcm9wZXJ0aWVzIHRvIGNoZWNrIGRyYWZ0IHN0YXR1c1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSB0aGlzLmNvbnRlbnRUeXBlcz8uZmluZChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGNvbnRlbnRUeXBlICYmIHRoaXMuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzID8gdGhpcy5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdIDogdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgdW5kZXJzY29yZSBwcmVmaXggc2hvdWxkIGJlIGVuYWJsZWRcblx0XHRcdC8vIEVuYWJsZSBpZiBoYXNEcmFmdFN0YXR1cyBpcyB0cnVlIGJ1dCBkcmFmdFByb3BlcnR5IGlzIGJsYW5rL3VuZGVmaW5lZFxuXHRcdFx0Y29uc3Qgc2hvdWxkRW5hYmxlVW5kZXJzY29yZVByZWZpeCA9IHByb3BzPy5oYXNEcmFmdFN0YXR1cyA9PT0gdHJ1ZSAmJiAhcHJvcHM/LmRyYWZ0UHJvcGVydHk7XG5cblx0XHRcdC8vIEZpbmQgZXhpc3RpbmcgZW50cnkgLSBwcmVmZXIgSUQgbWF0Y2hpbmcsIGZhbGxiYWNrIHRvIG5hbWUrZm9sZGVyIGZvciBkdXBsaWNhdGUgZGV0ZWN0aW9uXG5cdFx0XHRjb25zdCBjb250ZW50VHlwZXMgPSAoZXhpc3RpbmdEYXRhLmNvbnRlbnRUeXBlcyBhcyBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4pIHx8IFtdO1xuXHRcdFx0bGV0IGV4aXN0aW5nSW5kZXggPSAtMTtcblx0XHRcdGxldCBtYXRjaGVkQnlJZCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBGaXJzdCwgdHJ5IHRvIG1hdGNoIGJ5IElEIChwcmVmZXJyZWQgLSB1bmlxdWUgaWRlbnRpZmllcilcblx0XHRcdGlmIChuZXdUeXBlLmlkKSB7XG5cdFx0XHRcdGV4aXN0aW5nSW5kZXggPSBjb250ZW50VHlwZXMuZmluZEluZGV4KChjdDogeyBpZD86IHN0cmluZyB9KSA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRcdGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcblx0XHRcdFx0XHRtYXRjaGVkQnlJZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gbmFtZStmb2xkZXIgZm9yIGR1cGxpY2F0ZSBkZXRlY3Rpb24gKHByZXZlbnRzIGNyZWF0aW5nIGR1cGxpY2F0ZXMpXG5cdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA8IDApIHtcblx0XHRcdFx0ZXhpc3RpbmdJbmRleCA9IGNvbnRlbnRUeXBlcy5maW5kSW5kZXgoKGN0OiB7IG5hbWU/OiBzdHJpbmc7IGZvbGRlcj86IHN0cmluZyB9KSA9PlxuXHRcdFx0XHRcdGN0Lm5hbWUgPT09IG5ld1R5cGUubmFtZSAmJiBjdC5mb2xkZXIgPT09IG5ld1R5cGUuZm9sZGVyXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZyBlbnRyeSAtIHByZXNlcnZlIG90aGVyIHByb3BlcnRpZXNcblx0XHRcdFx0Ly8gSU1QT1JUQU5UOiBQcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgSUQgd2hlbiBtYXRjaGVkIGJ5IG5hbWUrZm9sZGVyIChkb24ndCBvdmVyd3JpdGUgd2l0aCBuZXcgSUQpXG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nRW50cnkgPSBjb250ZW50VHlwZXNbZXhpc3RpbmdJbmRleF0gYXMgeyBpZD86IHN0cmluZyB9O1xuXHRcdFx0XHRjb250ZW50VHlwZXNbZXhpc3RpbmdJbmRleF0gPSB7XG5cdFx0XHRcdFx0Li4uZXhpc3RpbmdFbnRyeSxcblx0XHRcdFx0XHQvLyBPbmx5IHVwZGF0ZSBJRCBpZiB3ZSBtYXRjaGVkIGJ5IElELCBvdGhlcndpc2Uga2VlcCBleGlzdGluZyBJRCBmb3IgY29uc2lzdGVuY3lcblx0XHRcdFx0XHRpZDogbWF0Y2hlZEJ5SWQgPyBuZXdUeXBlLmlkIDogKGV4aXN0aW5nRW50cnkuaWQgfHwgbmV3VHlwZS5pZCksXG5cdFx0XHRcdFx0bmFtZTogbmV3VHlwZS5uYW1lLFxuXHRcdFx0XHRcdGZvbGRlcjogbmV3VHlwZS5mb2xkZXIsXG5cdFx0XHRcdFx0bGlua0Jhc2VQYXRoOiBuZXdUeXBlLmxpbmtCYXNlUGF0aCxcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmV3VHlwZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRlbmFibGVkOiBuZXdUeXBlLmVuYWJsZWQsXG5cdFx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBuZXdUeXBlLmNyZWF0aW9uTW9kZSxcblx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBuZXdUeXBlLmluZGV4RmlsZU5hbWUsXG5cdFx0XHRcdFx0ZW5hYmxlVW5kZXJzY29yZVByZWZpeDogc2hvdWxkRW5hYmxlVW5kZXJzY29yZVByZWZpeFxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQWRkIG5ldyBlbnRyeVxuXHRcdFx0XHRjb250ZW50VHlwZXMucHVzaCh7XG5cdFx0XHRcdFx0aWQ6IG5ld1R5cGUuaWQsXG5cdFx0XHRcdFx0bmFtZTogbmV3VHlwZS5uYW1lLFxuXHRcdFx0XHRcdGZvbGRlcjogbmV3VHlwZS5mb2xkZXIsXG5cdFx0XHRcdFx0bGlua0Jhc2VQYXRoOiBuZXdUeXBlLmxpbmtCYXNlUGF0aCxcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmV3VHlwZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRlbmFibGVkOiBuZXdUeXBlLmVuYWJsZWQsXG5cdFx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBuZXdUeXBlLmNyZWF0aW9uTW9kZSxcblx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBuZXdUeXBlLmluZGV4RmlsZU5hbWUsXG5cdFx0XHRcdFx0aWdub3JlU3ViZm9sZGVyczogZmFsc2UsXG5cdFx0XHRcdFx0ZW5hYmxlVW5kZXJzY29yZVByZWZpeDogc2hvdWxkRW5hYmxlVW5kZXJzY29yZVByZWZpeFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gQWxzbyB1cGRhdGUgbGVnYWN5IGN1c3RvbUNvbnRlbnRUeXBlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRleGlzdGluZ0RhdGEuY3VzdG9tQ29udGVudFR5cGVzID0gdGhpcy5tZXJnZUN1c3RvbUNvbnRlbnRUeXBlcyhcblx0XHRcdChleGlzdGluZ0RhdGEuY3VzdG9tQ29udGVudFR5cGVzIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW10sXG5cdFx0XHQoY29uZmlnLmN1c3RvbUNvbnRlbnRUeXBlcyBhcyB1bmtub3duIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW11cblx0XHQpO1xuXG5cdFx0Ly8gV3JpdGUgY29uZmlnIHNhZmVseSB3aXRoIGJhY2t1cCBhbmQgdmFsaWRhdGlvblxuXHRcdGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnNhZmVXcml0ZXIud3JpdGVDb25maWcocGx1Z2luSWQsIGV4aXN0aW5nRGF0YSwge1xuXHRcdFx0c2hvd05vdGljZTogdHJ1ZSxcblx0XHRcdGNyZWF0ZUJhY2t1cDogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFzdWNjZXNzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEFzdHJvIENvbXBvc2VyIGNvbmZpZ3VyYXRpb24nKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG1lcmdlQ3VzdG9tQ29udGVudFR5cGVzKGV4aXN0aW5nOiBBcnJheTx7IGlkPzogc3RyaW5nOyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0+LCBuZXdUeXBlczogQXJyYXk8eyBpZD86IHN0cmluZzsgW2tleTogc3RyaW5nXTogdW5rbm93biB9Pik6IEFycmF5PHsgaWQ/OiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IHVua25vd24gfT4ge1xuXHRcdGNvbnN0IG1lcmdlZCA9IFsuLi5leGlzdGluZ107XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBuZXdUeXBlIG9mIG5ld1R5cGVzKSB7XG5cdFx0XHRjb25zdCBleGlzdGluZ0luZGV4ID0gbWVyZ2VkLmZpbmRJbmRleChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZ1xuXHRcdFx0XHRtZXJnZWRbZXhpc3RpbmdJbmRleF0gPSB7IC4uLm1lcmdlZFtleGlzdGluZ0luZGV4XSwgLi4ubmV3VHlwZSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQWRkIG5ld1xuXHRcdFx0XHRtZXJnZWQucHVzaChuZXdUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG1lcmdlZDtcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5cbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q29udGVudFR5cGVTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0RlZmF1bHQgY29udGVudCB0eXBlJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXG5cdFx0XHR0ZXh0OiAnU2VsZWN0IHdoaWNoIGNvbnRlbnQgdHlwZSBzaG91bGQgYmUgdXNlZCBhcyB0aGUgZGVmYXVsdC4gVGhpcyB3aWxsOicgXG5cdFx0fSk7XG5cdFx0Y29uc3QgdWwgPSBjb250YWluZXJFbC5jcmVhdGVFbCgndWwnKTtcblx0XHR1bC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdTZXQgYXMgdGhlIGRlZmF1bHQgQmFzZXMgQ01TIHZpZXcnIH0pO1xuXHRcdHVsLmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ0NvbmZpZ3VyZSBPYnNpZGlhblxcJ3MgXCJEZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgbm90ZXNcIiB0byB0aGF0IGZvbGRlci4nIH0pO1xuXG5cdFx0Y29uc3QgZW5hYmxlZFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xuXHRcdFxuXHRcdGlmIChlbmFibGVkVHlwZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXG5cdFx0XHRcdHRleHQ6ICdObyBlbmFibGVkIGNvbnRlbnQgdHlwZXMgZm91bmQuIFBsZWFzZSBnbyBiYWNrIGFuZCBlbmFibGUgYXQgbGVhc3Qgb25lIGNvbnRlbnQgdHlwZS4nIFxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIGVuc3VyZSBkZWZhdWx0Q29udGVudFR5cGVJZCBpcyBzZXQgdG8gZmlyc3QgZW5hYmxlZCB0eXBlXG5cdFx0aWYgKCF0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkIHx8IGVuYWJsZWRUeXBlcy5maW5kSW5kZXgoY3QgPT4gY3QuaWQgPT09IHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQpID09PSAtMSkge1xuXHRcdFx0dGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCA9IGVuYWJsZWRUeXBlc1swXS5pZDtcblx0XHR9XG5cblx0XHRjb25zdCBzZWxlY3RlZFZhbHVlID0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZDtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0RlZmF1bHQgY29udGVudCB0eXBlJylcblx0XHRcdC5zZXREZXNjKCdDaG9vc2UgdGhlIGRlZmF1bHQgY29udGVudCB0eXBlIGZvciBuZXcgbm90ZXMnKVxuXHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcblx0XHRcdFx0ZW5hYmxlZFR5cGVzLmZvckVhY2goY3QgPT4ge1xuXHRcdFx0XHRcdGRyb3Bkb3duLmFkZE9wdGlvbihjdC5pZCwgY3QubmFtZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBTZXQgdGhlIHZhbHVlIGV4cGxpY2l0bHkgdG8gZW5zdXJlIGl0J3MgcHJlLXBvcHVsYXRlZFxuXHRcdFx0XHRkcm9wZG93bi5zZXRWYWx1ZShzZWxlY3RlZFZhbHVlKTtcblx0XHRcdFx0ZHJvcGRvd24ub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQgPSB2YWx1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiAhIXRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQ7XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnRGVmYXVsdCBjb250ZW50IHR5cGUnO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ1NlbGVjdCBkZWZhdWx0IGNvbnRlbnQgdHlwZSc7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wcyAobWF5IG5vdCBiZSBpbiB0eXBlcyB5ZXQpXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuXHR9XG59XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUsIEV4YW1wbGVGcm9udG1hdHRlciB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IEZyb250bWF0dGVyQW5hbHl6ZXIgfSBmcm9tICcuLi8uLi91dGlscy9Gcm9udG1hdHRlckFuYWx5emVyJztcbmltcG9ydCB7IFBhdGhSZXNvbHZlciB9IGZyb20gJy4uLy4uL3V0aWxzL1BhdGhSZXNvbHZlcic7XG5cbmV4cG9ydCBjbGFzcyBGcm9udG1hdHRlclByb3BlcnRpZXNTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRwcml2YXRlIGZyb250bWF0dGVyQW5hbHl6ZXI6IEZyb250bWF0dGVyQW5hbHl6ZXI7XG5cdHByaXZhdGUgZXhhbXBsZXM6IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEV4YW1wbGVGcm9udG1hdHRlciB8IHVuZGVmaW5lZCB9ID0ge307XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHAsIGNvbnRhaW5lckVsLCBzdGF0ZSwgb25OZXh0LCBvbkJhY2ssIG9uQ2FuY2VsKTtcblx0XHR0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIgPSBuZXcgRnJvbnRtYXR0ZXJBbmFseXplcihhcHApO1xuXHR9XG5cblx0YXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG5cdFx0Ly8gQ2xlYXIgb25seSB0aGUgc3RlcCBjb250ZW50LCBwcmVzZXJ2ZSBuYXZpZ2F0aW9uIGZvb3RlclxuXHRcdGNvbnN0IGV4aXN0aW5nV3JhcHBlciA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5mcm9udG1hdHRlci1zdGVwLWNvbnRlbnQnKTtcblx0XHRpZiAoZXhpc3RpbmdXcmFwcGVyKSB7XG5cdFx0XHRleGlzdGluZ1dyYXBwZXIucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3RlcENvbnRlbnRXcmFwcGVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnZnJvbnRtYXR0ZXItc3RlcC1jb250ZW50JyB9KTtcblxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdGcm9udG1hdHRlciBwcm9wZXJ0aWVzJyB9KTtcblx0XHRzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnTWFwIGZyb250bWF0dGVyIHByb3BlcnRpZXMgZm9yIGVhY2ggY29udGVudCB0eXBlLiBXZVxcJ2xsIGZpbmQgZXhhbXBsZSBmaWxlcyB0byBoZWxwIHlvdS4nXG5cdFx0fSk7XG5cblx0XHRmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIHRoaXMuc3RhdGUuY29udGVudFR5cGVzKSB7XG5cdFx0XHRpZiAoIWNvbnRlbnRUeXBlLmVuYWJsZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBhIHdyYXBwZXIgZm9yIHRoaXMgY29udGVudCB0eXBlJ3Mgc2V0dGluZ3Ncblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlV3JhcHBlciA9IHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVEaXYoeyBjbHM6ICdjb250ZW50LXR5cGUtc2V0dGluZ3MnIH0pO1xuXG5cdFx0XHQvLyBGaW5kIGV4YW1wbGUgZmlsZSBhbmQgYWxsIHByb3BlcnRpZXNcblx0XHRcdGNvbnN0IHBhdGhSZXNvbHZlciA9IG5ldyBQYXRoUmVzb2x2ZXIodGhpcy5hcHApO1xuXHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IHBhdGhSZXNvbHZlci5nZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChjb250ZW50VHlwZS5mb2xkZXIsIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbik7XG5cblx0XHRcdGlmICghdGhpcy5leGFtcGxlc1tjb250ZW50VHlwZS5pZF0pIHtcblx0XHRcdFx0Y29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5maW5kRXhhbXBsZUZpbGUoZm9sZGVyUGF0aCwgdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0KTtcblx0XHRcdFx0aWYgKGV4YW1wbGUpIHtcblx0XHRcdFx0XHR0aGlzLmV4YW1wbGVzW2NvbnRlbnRUeXBlLmlkXSA9IGV4YW1wbGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXhhbXBsZSA9IHRoaXMuZXhhbXBsZXNbY29udGVudFR5cGUuaWRdO1xuXG5cdFx0XHQvLyBHZXQgQUxMIHByb3BlcnRpZXMgaW4gdGhpcyBmb2xkZXIgZm9yIGJldHRlciBhdXRvLWRldGVjdGlvblxuXHRcdFx0Y29uc3QgYWdncmVnYXRlUHJvcHMgPSBhd2FpdCB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuZ2V0UHJvcGVydGllc0luRm9sZGVyKGZvbGRlclBhdGgsIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCk7XG5cdFx0XHQvLyBDcmVhdGUgYSBkdW1teSBmcm9udG1hdHRlciBvYmplY3QgZnJvbSBhbGwgZm91bmQga2V5cyBmb3IgZGV0ZWN0b3IgZnVuY3Rpb25zXG5cdFx0XHRjb25zdCBkdW1teUZyb250bWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuXHRcdFx0YWdncmVnYXRlUHJvcHMuZm9yRWFjaChrZXkgPT4gZHVtbXlGcm9udG1hdHRlcltrZXldID0gbnVsbCk7XG5cblx0XHRcdGNvbnRlbnRUeXBlV3JhcHBlci5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6IGNvbnRlbnRUeXBlLm5hbWUgfSk7XG5cblx0XHRcdGlmIChleGFtcGxlKSB7XG5cdFx0XHRcdGNvbnRlbnRUeXBlV3JhcHBlci5jcmVhdGVFbCgncCcsIHsgdGV4dDogYEV4YW1wbGUgZmlsZTogJHtleGFtcGxlLmZpbGV9YCB9KTtcblx0XHRcdFx0Y29uc3QgcHJlRWwgPSBjb250ZW50VHlwZVdyYXBwZXIuY3JlYXRlRWwoJ3ByZScsIHtcblx0XHRcdFx0XHR0ZXh0OiBleGFtcGxlLnJhd1lhbWwsXG5cdFx0XHRcdFx0Y2xzOiAnZnJvbnRtYXR0ZXItZXhhbXBsZSdcblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIFN0eWxlIHRoZSBwcmUgZWxlbWVudCBmb3IgYmV0dGVyIGRpc3BsYXlcblx0XHRcdFx0c2V0Q3NzUHJvcHMocHJlRWwsIHtcblx0XHRcdFx0XHRmb250RmFtaWx5OiAndmFyKC0tZm9udC1tb25vc3BhY2UpJyxcblx0XHRcdFx0XHRmb250U2l6ZTogJzAuODVlbScsXG5cdFx0XHRcdFx0d2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcblx0XHRcdFx0XHRvdmVyZmxvd1dyYXA6ICdicmVhay13b3JkJyxcblx0XHRcdFx0XHRtYXhXaWR0aDogJzEwMCUnLFxuXHRcdFx0XHRcdHBhZGRpbmc6ICcxMHB4Jyxcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1iYWNrZ3JvdW5kLXNlY29uZGFyeSknLFxuXHRcdFx0XHRcdGJvcmRlclJhZGl1czogJzRweCcsXG5cdFx0XHRcdFx0Ym9yZGVyOiAnMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKSdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXRpYWxpemUgcHJvcGVydGllcyBpZiBub3QgZXhpc3RzXG5cdFx0XHRpZiAoIXRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXSkge1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZERyYWZ0ID0gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REcmFmdFByb3BlcnR5KGR1bW15RnJvbnRtYXR0ZXIpO1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZFRhZ3MgPSB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdFRhZ3NQcm9wZXJ0eShkdW1teUZyb250bWF0dGVyKTtcblx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWRJbWFnZSA9IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0SW1hZ2VQcm9wZXJ0eShkdW1teUZyb250bWF0dGVyKTtcblx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWREZXNjID0gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REZXNjcmlwdGlvblByb3BlcnR5KGR1bW15RnJvbnRtYXR0ZXIpO1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZFRpdGxlID0gZHVtbXlGcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eSgndGl0bGUnKSA/ICd0aXRsZScgOiBudWxsO1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZERhdGUgPSB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERhdGVQcm9wZXJ0eShkdW1teUZyb250bWF0dGVyKTtcblxuXHRcdFx0XHQvLyBDaGVjayBmb3IgdW5kZXJzY29yZS1wcmVmaXhlZCBmaWxlc1xuXHRcdFx0XHRjb25zdCBoYXNVbmRlcnNjb3JlRmlsZXMgPSBhd2FpdCB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuaGFzVW5kZXJzY29yZUZpbGVzKGZvbGRlclBhdGgpO1xuXG5cdFx0XHRcdHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXSA9IHtcblx0XHRcdFx0XHR0aXRsZVByb3BlcnR5OiBkZXRlY3RlZFRpdGxlIHx8IHVuZGVmaW5lZCwgLy8gT25seSBzZXQgaWYgZGV0ZWN0ZWQsIG90aGVyd2lzZSBibGFua1xuXHRcdFx0XHRcdGRhdGVQcm9wZXJ0eTogZGV0ZWN0ZWREYXRlIHx8IHVuZGVmaW5lZCwgLy8gT25seSBzZXQgaWYgZGV0ZWN0ZWQsIG90aGVyd2lzZSBibGFua1xuXHRcdFx0XHRcdGRlc2NyaXB0aW9uUHJvcGVydHk6IGRldGVjdGVkRGVzYyB8fCB1bmRlZmluZWQsXG5cdFx0XHRcdFx0dGFnc1Byb3BlcnR5OiBkZXRlY3RlZFRhZ3MgfHwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdGRyYWZ0UHJvcGVydHk6IGRldGVjdGVkRHJhZnQ/LnByb3BlcnR5LFxuXHRcdFx0XHRcdGRyYWZ0TG9naWM6IGRldGVjdGVkRHJhZnQ/LnByb3BlcnR5ID09PSAncHVibGlzaGVkJyA/ICdmYWxzZS1kcmFmdCcgOiAoZGV0ZWN0ZWREcmFmdCA/ICd0cnVlLWRyYWZ0JyA6IHVuZGVmaW5lZCksXG5cdFx0XHRcdFx0aGFzRHJhZnRTdGF0dXM6ICEhZGV0ZWN0ZWREcmFmdD8ucHJvcGVydHkgfHwgaGFzVW5kZXJzY29yZUZpbGVzLCAvLyBUcmFjayBpZiBkcmFmdCBzdGF0dXMgaXMgZW5hYmxlZFxuXHRcdFx0XHRcdGltYWdlUHJvcGVydHk6IGRldGVjdGVkSW1hZ2UgfHwgdW5kZWZpbmVkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByb3BzID0gdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdO1xuXG5cdFx0XHRuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdUaXRsZSBwcm9wZXJ0eScpXG5cdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgdGl0bGUgKGUuZy4sIHRpdGxlLCBuYW1lLCBoZWFkaW5nKS4gTGVhdmUgYmxhbmsgdG8gdXNlIGZ1bGwgZmlsZSBuYW1lIGluc3RlYWQuJylcblx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSAndGl0bGUnO1xuXHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQpXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMudGl0bGVQcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdHByb3BzLnRpdGxlUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdEYXRlIHByb3BlcnR5Jylcblx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBkYXRlIChlLmcuLCBkYXRlLCBwdWJEYXRlLCBwdWJsaXNoZWREYXRlLCBwdWJsaXNoRGF0ZSkuIExlYXZlIGJsYW5rIHRvIHVzZSBmaWxlIGNyZWF0ZWQgZGF0ZSBpbnN0ZWFkLicpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RGF0ZVByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkIHx8ICdkYXRlJylcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kYXRlUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy5kYXRlUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBkZXNjU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0hhcyBkZXNjcmlwdGlvbi9zdW1tYXJ5PycpXG5cdFx0XHRcdC5zZXREZXNjKCdEb2VzIHRoaXMgY29udGVudCB0eXBlIGhhdmUgYSBkZXNjcmlwdGlvbiBvciBzdW1tYXJ5IGZpZWxkPycpO1xuXG5cdFx0XHRsZXQgZGVzY1RleHRTZXR0aW5nOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cblx0XHRcdGRlc2NTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSghIXByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmICFwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5ID0gZXhhbXBsZSA/XG5cdFx0XHRcdFx0XHRcdHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RGVzY3JpcHRpb25Qcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSB8fCAnZGVzY3JpcHRpb24nIDpcblx0XHRcdFx0XHRcdFx0J2Rlc2NyaXB0aW9uJztcblx0XHRcdFx0XHRcdC8vIFNob3cgdGV4dCBmaWVsZFxuXHRcdFx0XHRcdFx0aWYgKCFkZXNjVGV4dFNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXROYW1lKCdEZXNjcmlwdGlvbiBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiAoZS5nLiwgZGVzY3JpcHRpb24sIHN1bW1hcnksIGV4Y2VycHQsIGludHJvLCBzbmlwcGV0LCBibHVyYiknKVxuXHRcdFx0XHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSB0b2dnbGUgc2V0dGluZ1xuXHRcdFx0XHRcdFx0XHRkZXNjVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRkZXNjU2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRlc2NUZXh0U2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0Ly8gSGlkZSB0ZXh0IGZpZWxkXG5cdFx0XHRcdFx0XHRpZiAoZGVzY1RleHRTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGRlc2NUZXh0U2V0dGluZyA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdGRlc2NUZXh0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHQuc2V0TmFtZSgnRGVzY3JpcHRpb24gcHJvcGVydHknKVxuXHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gKGUuZy4sIGRlc2NyaXB0aW9uLCBzdW1tYXJ5LCBleGNlcnB0LCBpbnRybywgc25pcHBldCwgYmx1cmIpJylcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0cHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgdG9nZ2xlIHNldHRpbmdcblx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0ZGVzY1NldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBkZXNjVGV4dFNldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFzIFRhZ3M/XG5cdFx0XHRjb25zdCB0YWdzU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0hhcyB0YWdzPycpXG5cdFx0XHRcdC5zZXREZXNjKCdEb2VzIHRoaXMgY29udGVudCB0eXBlIGhhdmUgdGFncz8nKTtcblxuXHRcdFx0bGV0IHRhZ3NUZXh0U2V0dGluZzogU2V0dGluZyB8IG51bGwgPSBudWxsO1xuXG5cdFx0XHR0YWdzU2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuXHRcdFx0XHQuc2V0VmFsdWUoISFwcm9wcy50YWdzUHJvcGVydHkpXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmICFwcm9wcy50YWdzUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdHByb3BzLnRhZ3NQcm9wZXJ0eSA9IGRldGVjdGVkIHx8ICd0YWdzJztcblx0XHRcdFx0XHRcdC8vIFNob3cgdGV4dCBmaWVsZFxuXHRcdFx0XHRcdFx0aWYgKCF0YWdzVGV4dFNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0dGFnc1RleHRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXROYW1lKCdUYWdzIHByb3BlcnR5Jylcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGFncyAoZS5nLiwgdGFncywgdGFnLCBjYXRlZ29yaWVzLCBjYXRlZ29yeSkuIExlYXZlIGJsYW5rIGlmIG5vdCBhcHBsaWNhYmxlLicpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZCA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdFRhZ3NQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkIHx8ICd0YWdzJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLnRhZ3NQcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy50YWdzUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSB0b2dnbGUgc2V0dGluZ1xuXHRcdFx0XHRcdFx0XHR0YWdzVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHR0YWdzU2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHRhZ3NUZXh0U2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdFx0XHRwcm9wcy50YWdzUHJvcGVydHkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHQvLyBIaWRlIHRleHQgZmllbGRcblx0XHRcdFx0XHRcdGlmICh0YWdzVGV4dFNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0dGFnc1RleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0dGFnc1RleHRTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0aWYgKHByb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0XHR0YWdzVGV4dFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0LnNldE5hbWUoJ1RhZ3MgcHJvcGVydHknKVxuXHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0YWdzIChlLmcuLCB0YWdzLCB0YWcsIGNhdGVnb3JpZXMsIGNhdGVnb3J5KS4gTGVhdmUgYmxhbmsgaWYgbm90IGFwcGxpY2FibGUuJylcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQgfHwgJ3RhZ3MnKVxuXHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMudGFnc1Byb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BzLnRhZ3NQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdHRhZ3NUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdHRhZ3NTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgdGFnc1RleHRTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhcyBEcmFmdCBTdGF0dXM/XG5cdFx0XHRjb25zdCBkcmFmdFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdIYXMgZHJhZnQgc3RhdHVzPycpXG5cdFx0XHRcdC5zZXREZXNjKCdEb2VzIHRoaXMgY29udGVudCB0eXBlIGhhdmUgZHJhZnQgc3RhdHVzPycpO1xuXG5cdFx0XHRsZXQgZHJhZnRQcm9wZXJ0eVNldHRpbmc6IFNldHRpbmcgfCBudWxsID0gbnVsbDtcblx0XHRcdGxldCBkcmFmdExvZ2ljU2V0dGluZzogU2V0dGluZyB8IG51bGwgPSBudWxsO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIGhhc0RyYWZ0U3RhdHVzIGlmIG5vdCBzZXQgKGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcblx0XHRcdGlmIChwcm9wcy5oYXNEcmFmdFN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHByb3BzLmhhc0RyYWZ0U3RhdHVzID0gISFwcm9wcy5kcmFmdFByb3BlcnR5O1xuXHRcdFx0fVxuXG5cdFx0XHRkcmFmdFNldHRpbmcuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmhhc0RyYWZ0U3RhdHVzID8/ICEhcHJvcHMuZHJhZnRQcm9wZXJ0eSlcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRwcm9wcy5oYXNEcmFmdFN0YXR1cyA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiAhcHJvcHMuZHJhZnRQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWREcmFmdCA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERyYWZ0UHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRQcm9wZXJ0eSA9IGRldGVjdGVkRHJhZnQ/LnByb3BlcnR5IHx8ICdkcmFmdCc7XG5cdFx0XHRcdFx0XHQvLyBGaXggbG9naWM6IGlmIHByb3BlcnR5IGlzIFwiZHJhZnRcIiwgdXNlIFwidHJ1ZS1kcmFmdFwiLCBpZiBcInB1Ymxpc2hlZFwiIHVzZSBcImZhbHNlLWRyYWZ0XCJcblx0XHRcdFx0XHRcdGlmIChkZXRlY3RlZERyYWZ0Py5wcm9wZXJ0eSA9PT0gJ3B1Ymxpc2hlZCcpIHtcblx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9ICdmYWxzZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gJ3RydWUtZHJhZnQnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gU2hvdyBmaWVsZHNcblx0XHRcdFx0XHRcdGlmICghZHJhZnRQcm9wZXJ0eVNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0RyYWZ0IHByb3BlcnR5Jylcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgZHJhZnQgc3RhdHVzLiBMZWF2ZSBibGFuayB0byB1c2UgYW4gdW5kZXJzY29yZSBwcmVmaXggaW5zdGVhZC4nKVxuXHRcdFx0XHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REcmFmdFByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQ/LnByb3BlcnR5IHx8ICdkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kcmFmdFByb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0UHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFVwZGF0ZSBsb2dpYyBiYXNlZCBvbiBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID09PSAncHVibGlzaGVkJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9ICdmYWxzZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9ICd0cnVlLWRyYWZ0Jztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU2hvdy9oaWRlIGxvZ2ljIGRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmICFkcmFmdExvZ2ljU2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXROYW1lKCdEcmFmdCBsb2dpYycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdIb3cgZHJhZnQgc3RhdHVzIGlzIHJlcHJlc2VudGVkJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZE9wdGlvbigndHJ1ZS1kcmFmdCcsICd0cnVlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZhbHNlLWRyYWZ0JywgJ2ZhbHNlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kcmFmdExvZ2ljIHx8ICd0cnVlLWRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UoZHJvcGRvd25WYWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gZHJvcGRvd25WYWx1ZSBhcyAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUgJiYgZHJhZnRMb2dpY1NldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0ZHJhZnRTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIFNob3cgbG9naWMgZHJvcGRvd24gaWYgcHJvcGVydHkgaXMgc2V0XG5cdFx0XHRcdFx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSAmJiAhZHJhZnRMb2dpY1NldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0RyYWZ0IGxvZ2ljJylcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnSG93IGRyYWZ0IHN0YXR1cyBpcyByZXByZXNlbnRlZCcpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCd0cnVlLWRyYWZ0JywgJ3RydWUgPSBkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCdmYWxzZS1kcmFmdCcsICdmYWxzZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kcmFmdExvZ2ljIHx8ICd0cnVlLWRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSB2YWx1ZSBhcyAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIGRyYWZ0IHByb3BlcnR5IHNldHRpbmdcblx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZHJhZnRQcm9wZXJ0eVNldHRpbmcgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRwcm9wcy5oYXNEcmFmdFN0YXR1cyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Ly8gSGlkZSBmaWVsZHNcblx0XHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChkcmFmdExvZ2ljU2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0aWYgKHByb3BzLmhhc0RyYWZ0U3RhdHVzKSB7XG5cdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdC5zZXROYW1lKCdEcmFmdCBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIGRyYWZ0IHN0YXR1cy4gTGVhdmUgYmxhbmsgdG8gdXNlIGFuIHVuZGVyc2NvcmUgcHJlZml4IGluc3RlYWQuJylcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RHJhZnRQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkPy5wcm9wZXJ0eSB8fCAnZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuZHJhZnRQcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdFByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgbG9naWMgYmFzZWQgb24gcHJvcGVydHkgbmFtZVxuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gJ3B1Ymxpc2hlZCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSAndHJ1ZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFNob3cvaGlkZSBsb2dpYyBkcm9wZG93blxuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiAhZHJhZnRMb2dpY1NldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0TmFtZSgnRHJhZnQgbG9naWMnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnSG93IGRyYWZ0IHN0YXR1cyBpcyByZXByZXNlbnRlZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ3RydWUtZHJhZnQnLCAndHJ1ZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCdmYWxzZS1kcmFmdCcsICdmYWxzZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuZHJhZnRMb2dpYyB8fCAndHJ1ZS1kcmFmdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGRyb3Bkb3duVmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9IGRyb3Bkb3duVmFsdWUgYXMgJ3RydWUtZHJhZnQnIHwgJ2ZhbHNlLWRyYWZ0Jztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZHJhZnRQcm9wZXJ0eVNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIXZhbHVlICYmIGRyYWZ0TG9naWNTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZyA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSB0b2dnbGUgc2V0dGluZ1xuXHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdGRyYWZ0U2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbCk7XG5cblx0XHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHRcdC5zZXROYW1lKCdEcmFmdCBsb2dpYycpXG5cdFx0XHRcdFx0XHQuc2V0RGVzYygnSG93IGRyYWZ0IHN0YXR1cyBpcyByZXByZXNlbnRlZCcpXG5cdFx0XHRcdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cblx0XHRcdFx0XHRcdFx0LmFkZE9wdGlvbigndHJ1ZS1kcmFmdCcsICd0cnVlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCdmYWxzZS1kcmFmdCcsICdmYWxzZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRyYWZ0TG9naWMgfHwgJ3RydWUtZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSB2YWx1ZSBhcyAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSBkcmFmdCBwcm9wZXJ0eSBzZXR0aW5nXG5cdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYXMgSW1hZ2UgUHJvcGVydHk/XG5cdFx0XHRjb25zdCBpbWFnZVNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdIYXMgaW1hZ2UvY292ZXIgcHJvcGVydHk/Jylcblx0XHRcdFx0LnNldERlc2MoJ0RvZXMgdGhpcyBjb250ZW50IHR5cGUgaGF2ZSBhbiBpbWFnZSBvciBjb3ZlciBwcm9wZXJ0eT8gVXNlZCBmb3IgQmFzZXMgQ01TIGNvdmVyIGltYWdlcyBhbmQgSW1hZ2UgTWFuYWdlci4nKTtcblxuXHRcdFx0bGV0IGltYWdlVGV4dFNldHRpbmc6IFNldHRpbmcgfCBudWxsID0gbnVsbDtcblxuXHRcdFx0aW1hZ2VTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSghIXByb3BzLmltYWdlUHJvcGVydHkpXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmICFwcm9wcy5pbWFnZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZCA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdEltYWdlUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0cHJvcHMuaW1hZ2VQcm9wZXJ0eSA9IGRldGVjdGVkIHx8ICdpbWFnZSc7XG5cdFx0XHRcdFx0XHQvLyBTaG93IHRleHQgZmllbGRcblx0XHRcdFx0XHRcdGlmICghaW1hZ2VUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRpbWFnZVRleHRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXROYW1lKCdJbWFnZSBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpbWFnZS9jb3ZlciAoZS5nLiwgaW1hZ2UsIGNvdmVyLCBjb3ZlckltYWdlLCB0aHVtYm5haWwsIGZlYXR1cmVkSW1hZ2UpLiBMZWF2ZSBibGFuayBpZiBub3QgYXBwbGljYWJsZS4nKVxuXHRcdFx0XHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RJbWFnZVByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQgfHwgJ2ltYWdlJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmltYWdlUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuaW1hZ2VQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdGltYWdlVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRpbWFnZVNldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBpbWFnZVRleHRTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUpIHtcblx0XHRcdFx0XHRcdHByb3BzLmltYWdlUHJvcGVydHkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHQvLyBIaWRlIHRleHQgZmllbGRcblx0XHRcdFx0XHRcdGlmIChpbWFnZVRleHRTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdGltYWdlVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRpbWFnZVRleHRTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0aWYgKHByb3BzLmltYWdlUHJvcGVydHkpIHtcblx0XHRcdFx0aW1hZ2VUZXh0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHQuc2V0TmFtZSgnSW1hZ2UgcHJvcGVydHknKVxuXHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaW1hZ2UvY292ZXIgKGUuZy4sIGltYWdlLCBjb3ZlciwgY292ZXJJbWFnZSwgdGh1bWJuYWlsLCBmZWF0dXJlZEltYWdlKS4gTGVhdmUgYmxhbmsgaWYgbm90IGFwcGxpY2FibGUuJylcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0SW1hZ2VQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkIHx8ICdpbWFnZScpXG5cdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5pbWFnZVByb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BzLmltYWdlUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSB0b2dnbGUgc2V0dGluZ1xuXHRcdFx0XHRpbWFnZVRleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0aW1hZ2VTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgaW1hZ2VUZXh0U2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUZW1wbGF0ZSBlZGl0b3Jcblx0XHRcdGNvbnRlbnRUeXBlV3JhcHBlci5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdUZW1wbGF0ZScgfSk7XG5cdFx0XHRjb250ZW50VHlwZVdyYXBwZXIuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHRcdHRleHQ6ICdFZGl0IHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyBmaWxlcyBvZiB0aGlzIGNvbnRlbnQgdHlwZS4gVXNlIHt7dGl0bGV9fSBhbmQge3tkYXRlfX0gYXMgdmFyaWFibGVzLiBOb3RlOiB7e3RpdGxlfX0gc2hvdWxkIGJlIGluIHF1b3RlcyAoZS5nLiwgdGl0bGU6IFwie3t0aXRsZX19XCIpLCB3aGlsZSB7e2RhdGV9fSBzaG91bGQgbm90IGJlIGluIHF1b3RlcyAoZS5nLiwgZGF0ZToge3tkYXRlfX0pLidcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHRlbXBsYXRlIGlmIG5vdCBleGlzdHNcblx0XHRcdGlmICghcHJvcHMudGVtcGxhdGUpIHtcblx0XHRcdFx0Ly8gR2V0IGNvcnJlY3QgZm9sZGVyIHBhdGggZm9yIGFnZ3JlZ2F0aW9uXG5cdFx0XHRcdGNvbnN0IHBhdGhSZXNvbHZlciA9IG5ldyBQYXRoUmVzb2x2ZXIodGhpcy5hcHApO1xuXHRcdFx0XHRjb25zdCBmb2xkZXJQYXRoID0gcGF0aFJlc29sdmVyLmdldEZvbGRlclBhdGhGcm9tVmF1bHRSb290KGNvbnRlbnRUeXBlLmZvbGRlciwgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcblx0XHRcdFx0Y29uc3QgYWdncmVnYXRlUHJvcHMgPSBhd2FpdCB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuZ2V0UHJvcGVydGllc0luRm9sZGVyKGZvbGRlclBhdGgsIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCk7XG5cblx0XHRcdFx0Ly8gR2VuZXJhdGUgZGVmYXVsdCB0ZW1wbGF0ZSBiYXNlZCBvbiBwcm9wZXJ0aWVzIGFuZCBBTEwgZm91bmQga2V5c1xuXHRcdFx0XHRwcm9wcy50ZW1wbGF0ZSA9IHRoaXMuZ2VuZXJhdGVEZWZhdWx0VGVtcGxhdGUocHJvcHMsIGV4YW1wbGUsIGFnZ3JlZ2F0ZVByb3BzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGVtcGxhdGVUZXh0QXJlYSA9IGNvbnRlbnRUeXBlV3JhcHBlci5jcmVhdGVFbCgndGV4dGFyZWEnLCB7XG5cdFx0XHRcdGNsczogJ3RlbXBsYXRlLWVkaXRvcicsXG5cdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRyb3dzOiAnMTAnLFxuXHRcdFx0XHRcdHN0eWxlOiAnd2lkdGg6IDEwMCU7IGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7Jyxcblx0XHRcdFx0XHRzcGVsbGNoZWNrOiAnZmFsc2UnXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGVtcGxhdGVUZXh0QXJlYS52YWx1ZSA9IHByb3BzLnRlbXBsYXRlIHx8ICcnO1xuXHRcdFx0dGVtcGxhdGVUZXh0QXJlYS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG5cdFx0XHRcdHByb3BzLnRlbXBsYXRlID0gdGFyZ2V0LnZhbHVlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBnZW5lcmF0ZURlZmF1bHRUZW1wbGF0ZShwcm9wczogeyB0aXRsZVByb3BlcnR5Pzogc3RyaW5nOyBkYXRlUHJvcGVydHk/OiBzdHJpbmc7IGRlc2NyaXB0aW9uUHJvcGVydHk/OiBzdHJpbmc7IHRhZ3NQcm9wZXJ0eT86IHN0cmluZzsgZHJhZnRQcm9wZXJ0eT86IHN0cmluZzsgZHJhZnRMb2dpYz86ICd0cnVlLWRyYWZ0JyB8ICdmYWxzZS1kcmFmdCc7IGltYWdlUHJvcGVydHk/OiBzdHJpbmcgfSwgZXhhbXBsZTogRXhhbXBsZUZyb250bWF0dGVyIHwgdW5kZWZpbmVkLCBhZ2dyZWdhdGVQcm9wczogU2V0PHN0cmluZz4pOiBzdHJpbmcge1xuXHRcdGxldCB0ZW1wbGF0ZSA9ICctLS1cXG4nO1xuXG5cdFx0Ly8gUGFyc2UgdGhlIG9yaWdpbmFsIFlBTUwgdG8gbWFpbnRhaW4gb3JkZXJcblx0XHRpZiAoZXhhbXBsZSAmJiBleGFtcGxlLnJhd1lhbWwpIHtcblx0XHRcdC8vIFBhcnNlIHRoZSByYXcgWUFNTCBsaW5lIGJ5IGxpbmUgdG8gbWFpbnRhaW4gb3JkZXJcblx0XHRcdGNvbnN0IGxpbmVzID0gZXhhbXBsZS5yYXdZYW1sLnNwbGl0KCdcXG4nKTtcblx0XHRcdGNvbnN0IHByb2Nlc3NlZFByb3BzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cblx0XHRcdC8vIEZpcnN0LCBhZGQgdGl0bGUgcHJvcGVydHkgaWYgaXQncyBkZXRlY3RlZC9lbmFibGVkIChBTFdBWVMgaW5jbHVkZSBpdClcblx0XHRcdGxldCB0aXRsZUFkZGVkID0gZmFsc2U7XG5cdFx0XHRpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdFx0XHRjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XG5cdFx0XHRcdFx0aWYgKCF0cmltbWVkIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnIycpKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbG9uSW5kZXggPSB0cmltbWVkLmluZGV4T2YoJzonKTtcblx0XHRcdFx0XHRpZiAoY29sb25JbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IHByb3AgPSB0cmltbWVkLnN1YnN0cmluZygwLCBjb2xvbkluZGV4KS50cmltKCk7XG5cdFx0XHRcdFx0XHRpZiAocHJvcCA9PT0gcHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy50aXRsZVByb3BlcnR5fTogXCJ7e3RpdGxlfX1cIlxcbmA7XG5cdFx0XHRcdFx0XHRcdHRpdGxlQWRkZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRwcm9jZXNzZWRQcm9wcy5hZGQocHJvcCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRpdGxlQWRkZWQpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy50aXRsZVByb3BlcnR5fTogXCJ7e3RpdGxlfX1cIlxcbmA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlbiBwcm9jZXNzIG90aGVyIGxpbmVzIGluIG9yZGVyXG5cdFx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdFx0Y29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xuXHRcdFx0XHRpZiAoIXRyaW1tZWQgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcjJykpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IGNvbG9uSW5kZXggPSB0cmltbWVkLmluZGV4T2YoJzonKTtcblx0XHRcdFx0aWYgKGNvbG9uSW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcHJvcCA9IHRyaW1tZWQuc3Vic3RyaW5nKDAsIGNvbG9uSW5kZXgpLnRyaW0oKTtcblxuXHRcdFx0XHRcdC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWRcblx0XHRcdFx0XHRpZiAocHJvY2Vzc2VkUHJvcHMuaGFzKHByb3ApKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTa2lwIHRpdGxlIChhbHJlYWR5IGFkZGVkKVxuXHRcdFx0XHRcdGlmIChwcm9wID09PSBwcm9wcy50aXRsZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgZGF0ZSBwcm9wZXJ0eSAtIEFMV0FZUyBpbmNsdWRlIGlmIGRldGVjdGVkL2VuYWJsZWRcblx0XHRcdFx0XHRpZiAocHJvcCA9PT0gcHJvcHMuZGF0ZVByb3BlcnR5ICYmIHByb3BzLmRhdGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMuZGF0ZVByb3BlcnR5fToge3tkYXRlfX1cXG5gO1xuXHRcdFx0XHRcdFx0cHJvY2Vzc2VkUHJvcHMuYWRkKHByb3ApO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGRlc2NyaXB0aW9uIHByb3BlcnR5XG5cdFx0XHRcdFx0aWYgKHByb3AgPT09IHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9OiBcIlwiXFxuYDtcblx0XHRcdFx0XHRcdHByb2Nlc3NlZFByb3BzLmFkZChwcm9wKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByb2Nlc3Mgb3RoZXIgcHJvcGVydGllc1xuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gZXhhbXBsZS5mcm9udG1hdHRlcltwcm9wXTtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06XFxuYDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTogW11cXG5gO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiAke3ZhbHVlfVxcbmA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHQvLyBNaXJyb3IgdGhlIGFjdHVhbCBudW1lcmljIHZhbHVlIGZyb20gdGhlIHNjYW5uZWQgZG9jdW1lbnRcblx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiAke3ZhbHVlfVxcbmA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpZiBpdCBsb29rcyBsaWtlIGEgZGF0ZSAoWVlZWS1NTS1ERCBmb3JtYXQpXG5cdFx0XHRcdFx0XHRpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdCh2YWx1ZSkgJiYgcHJvcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdkYXRlJykpIHtcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IHt7ZGF0ZX19XFxuYDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiBcIlwiXFxuYDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTogW11cXG5gO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06XFxuYDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcm9jZXNzZWRQcm9wcy5hZGQocHJvcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmluYWxseSwgYWRkIGFueSBtaXNzaW5nIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGZvdW5kIGluIHRoZSBmb2xkZXIgYnV0IHdlcmVuJ3QgaW4gdGhlIGV4YW1wbGVcblx0XHRcdGZvciAoY29uc3QgcHJvcCBvZiBhZ2dyZWdhdGVQcm9wcykge1xuXHRcdFx0XHRpZiAocHJvY2Vzc2VkUHJvcHMuaGFzKHByb3ApKSBjb250aW51ZTtcblxuXHRcdFx0XHRpZiAocHJvcCA9PT0gcHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiBcInt7dGl0bGV9fVwiXFxuYDtcblx0XHRcdFx0fSBlbHNlIGlmIChwcm9wID09PSBwcm9wcy5kYXRlUHJvcGVydHkpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfToge3tkYXRlfX1cXG5gO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByb3AgPT09IHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTogXCJcIlxcbmA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvcCA9PT0gcHJvcHMudGFnc1Byb3BlcnR5KSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IFtdXFxuYDtcblx0XHRcdFx0fSBlbHNlIGlmIChwcm9wID09PSBwcm9wcy5pbWFnZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IFwiXCJcXG5gO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByb3AgPT09IHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdFx0XHRjb25zdCBkcmFmdFZhbHVlID0gcHJvcHMuZHJhZnRMb2dpYyA9PT0gJ2ZhbHNlLWRyYWZ0JyA/ICdmYWxzZScgOiAndHJ1ZSc7XG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06ICR7ZHJhZnRWYWx1ZX1cXG5gO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEdlbmVyaWMgZmFsbGJhY2sgZm9yIG90aGVyIHByb3BlcnRpZXNcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTogXCJcIlxcbmA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvY2Vzc2VkUHJvcHMuYWRkKHByb3ApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEZWZhdWx0IHRlbXBsYXRlIGlmIG5vIGV4YW1wbGUgLSBvbmx5IGluY2x1ZGUgcHJvcGVydGllcyB0aGF0IGFyZSBzZXRcblx0XHRcdGlmIChwcm9wcy50aXRsZVByb3BlcnR5KSB7XG5cdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLnRpdGxlUHJvcGVydHl9OiBcInt7dGl0bGV9fVwiXFxuYDtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9wcy5kYXRlUHJvcGVydHkpIHtcblx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMuZGF0ZVByb3BlcnR5fToge3tkYXRlfX1cXG5gO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eX06IFwiXCJcXG5gO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy50YWdzUHJvcGVydHl9OiBbXVxcbmA7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSkge1xuXHRcdFx0XHRjb25zdCBkcmFmdFZhbHVlID0gcHJvcHMuZHJhZnRMb2dpYyA9PT0gJ2ZhbHNlLWRyYWZ0JyA/ICdmYWxzZScgOiAndHJ1ZSc7XG5cdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRyYWZ0UHJvcGVydHl9OiAke2RyYWZ0VmFsdWV9XFxuYDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZW1wbGF0ZSArPSAnLS0tXFxuJztcblx0XHRyZXR1cm4gdGVtcGxhdGU7XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHQvLyBWYWxpZGF0aW9uOiB0aXRsZVByb3BlcnR5IGlzIHJlcXVpcmVkIChidXQgY2FuIGJlIGVtcHR5IHN0cmluZywgd2lsbCB1c2UgZmlsZS5mdWxsbmFtZSlcblx0XHQvLyBBY3R1YWxseSwgdGl0bGVQcm9wZXJ0eSBjYW4gYmUgYmxhbmsgLSBpZiBibGFuaywgaXQgd2lsbCB1c2UgZmlsZS5mdWxsbmFtZSBhcyBmYWxsYmFja1xuXHRcdC8vIFNvIHZhbGlkYXRpb24gc2hvdWxkIGFsd2F5cyBwYXNzIC0gdGhlIHN0ZXAgaXMgb3B0aW9uYWxcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdGcm9udG1hdHRlciBwcm9wZXJ0aWVzJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdNYXAgZnJvbnRtYXR0ZXIgcHJvcGVydGllcyc7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUsIFRGb2xkZXIgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFeGFtcGxlRnJvbnRtYXR0ZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB5YW1sIGZyb20gJ3lhbWwnO1xuXG5leHBvcnQgY2xhc3MgRnJvbnRtYXR0ZXJBbmFseXplciB7XG5cdHByaXZhdGUgYXBwOiBBcHA7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcblx0XHR0aGlzLmFwcCA9IGFwcDtcblx0fVxuXG5cdGFzeW5jIGZpbmRFeGFtcGxlRmlsZShmb2xkZXJQYXRoOiBzdHJpbmcsIGluY2x1ZGVNZHg6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8RXhhbXBsZUZyb250bWF0dGVyIHwgbnVsbD4ge1xuXHRcdGNvbnN0IGZvbGRlciA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmb2xkZXJQYXRoKTtcblxuXHRcdGlmICghZm9sZGVyKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoZm9sZGVyIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdGNvbnN0IGV4dCA9IGZvbGRlci5leHRlbnNpb247XG5cdFx0XHRpZiAoZXh0ID09PSAnbWQnIHx8IChpbmNsdWRlTWR4ICYmIGV4dCA9PT0gJ21keCcpKSB7XG5cdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnBhcnNlRnJvbnRtYXR0ZXIoZm9sZGVyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIEl0J3MgYSBmb2xkZXIsIGdldCBmaWxlcyBmcm9tIGl0XG5cdFx0aWYgKCEoZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRsZXQgZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCBmYWxzZSwgdW5kZWZpbmVkLCAwLCBpbmNsdWRlTWR4KTsgLy8gZmFsc2UgPSBvbmx5IGltbWVkaWF0ZSBjaGlsZHJlblxuXG5cdFx0Ly8gSWYgbm8gZmlsZXMgZm91bmQgaW4gaW1tZWRpYXRlIGZvbGRlciwgc2VhcmNoIGRlZXBlciAob25lIGxldmVsIGF0IGEgdGltZSlcblx0XHRpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHQvLyBTZWFyY2ggb25lIGxldmVsIGRlZXBlclxuXHRcdFx0ZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCB0cnVlLCAxLCAwLCBpbmNsdWRlTWR4KTsgLy8gdHJ1ZSA9IHJlY3Vyc2l2ZSwgbWF4RGVwdGggPSAxXG5cblx0XHRcdC8vIElmIHN0aWxsIG5vIGZpbGVzLCBzZWFyY2ggdHdvIGxldmVscyBkZWVwZXJcblx0XHRcdGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0ZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCB0cnVlLCAyLCAwLCBpbmNsdWRlTWR4KTsgLy8gbWF4RGVwdGggPSAyXG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHN0aWxsIG5vIGZpbGVzLCBzZWFyY2ggYWxsIGxldmVscyAodW5saW1pdGVkIGRlcHRoKVxuXHRcdFx0aWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRmaWxlcyA9IHRoaXMuZ2V0TWFya2Rvd25GaWxlcyhmb2xkZXIsIHRydWUsIHVuZGVmaW5lZCwgMCwgaW5jbHVkZU1keCk7IC8vIHVubGltaXRlZCBkZXB0aFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuXHRcdFx0Y29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucGFyc2VGcm9udG1hdHRlcihmaWxlKTtcblx0XHRcdGlmIChleGFtcGxlKSB7XG5cdFx0XHRcdHJldHVybiBleGFtcGxlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNjYW5zIG11bHRpcGxlIGZpbGVzIGluIGEgZm9sZGVyIHRvIGFnZ3JlZ2F0ZSBhbGwgdW5pcXVlIGZyb250bWF0dGVyIHByb3BlcnRpZXMuXG5cdCAqIFRoaXMgZW5zdXJlcyBwcm9wZXJ0aWVzIGFyZW4ndCBtaXNzZWQganVzdCBiZWNhdXNlIHRoZXkncmUgbm90IGluIHRoZSBzaW5nbGUgXCJsYXRlc3RcIiBmaWxlLlxuXHQgKi9cblx0YXN5bmMgZ2V0UHJvcGVydGllc0luRm9sZGVyKGZvbGRlclBhdGg6IHN0cmluZywgaW5jbHVkZU1keDogYm9vbGVhbiA9IGZhbHNlLCBsaW1pdDogbnVtYmVyID0gNTApOiBQcm9taXNlPFNldDxzdHJpbmc+PiB7XG5cdFx0Y29uc3QgZm9sZGVyID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlclBhdGgpO1xuXHRcdGlmICghKGZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCB0cnVlLCB1bmRlZmluZWQsIDAsIGluY2x1ZGVNZHgpO1xuXHRcdGNvbnN0IGFnZ3JlZ2F0ZVByb3BzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cblx0XHQvLyBMaW1pdCB0aGUgbnVtYmVyIG9mIGZpbGVzIHdlIHNjYW4gdG8ga2VlcCBpdCBwZXJmb3JtYW50XG5cdFx0Y29uc3QgZmlsZXNUb1NjYW4gPSBmaWxlcy5zbGljZSgwLCBsaW1pdCk7XG5cblx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXNUb1NjYW4pIHtcblx0XHRcdGlmIChmaWxlLmV4dGVuc2lvbiA9PT0gJ21kJykge1xuXHRcdFx0XHQvLyBVc2UgT2JzaWRpYW4ncyBtZXRhZGF0YSBjYWNoZSBmb3Igc3RhbmRhcmQgbWFya2Rvd24gZmlsZXMgKHZlcnkgZmFzdClcblx0XHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcblx0XHRcdFx0aWYgKGNhY2hlICYmIGNhY2hlLmZyb250bWF0dGVyKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoY2FjaGUuZnJvbnRtYXR0ZXIpLmZvckVhY2goa2V5ID0+IGFnZ3JlZ2F0ZVByb3BzLmFkZChrZXkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChpbmNsdWRlTWR4ICYmIGZpbGUuZXh0ZW5zaW9uID09PSAnbWR4Jykge1xuXHRcdFx0XHQvLyBNRFggZmlsZXMgYXJlbid0IGluIE9ic2lkaWFuJ3MgbWV0YWRhdGEgY2FjaGUgbmF0aXZlbHksIHNvIHdlIGhhdmUgdG8gcGFyc2UgbWFudWFsbHlcblx0XHRcdFx0Y29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucGFyc2VGcm9udG1hdHRlcihmaWxlKTtcblx0XHRcdFx0aWYgKGV4YW1wbGUgJiYgZXhhbXBsZS5mcm9udG1hdHRlcikge1xuXHRcdFx0XHRcdE9iamVjdC5rZXlzKGV4YW1wbGUuZnJvbnRtYXR0ZXIpLmZvckVhY2goa2V5ID0+IGFnZ3JlZ2F0ZVByb3BzLmFkZChrZXkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBhZ2dyZWdhdGVQcm9wcztcblx0fVxuXG5cdGhhc1VuZGVyc2NvcmVGaWxlcyhmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zdCBmb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCk7XG5cblx0XHRpZiAoIShmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCB0cnVlKTtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGVzLnNvbWUoZmlsZSA9PiBmaWxlLm5hbWUuc3RhcnRzV2l0aCgnXycpKSk7XG5cdH1cblxuXHRwcml2YXRlIGdldE1hcmtkb3duRmlsZXMoZm9sZGVyOiBURm9sZGVyLCByZWN1cnNpdmU6IGJvb2xlYW4gPSB0cnVlLCBtYXhEZXB0aD86IG51bWJlciwgY3VycmVudERlcHRoOiBudW1iZXIgPSAwLCBpbmNsdWRlTWR4OiBib29sZWFuID0gZmFsc2UpOiBURmlsZVtdIHtcblx0XHRjb25zdCBmaWxlczogVEZpbGVbXSA9IFtdO1xuXG5cdFx0aWYgKCFmb2xkZXIuY2hpbGRyZW4pIHtcblx0XHRcdHJldHVybiBmaWxlcztcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB3ZSd2ZSBleGNlZWRlZCBtYXggZGVwdGhcblx0XHRpZiAobWF4RGVwdGggIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50RGVwdGggPj0gbWF4RGVwdGgpIHtcblx0XHRcdHJldHVybiBmaWxlcztcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IGNoaWxkIG9mIGZvbGRlci5jaGlsZHJlbikge1xuXHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmV4dGVuc2lvbiA9PT0gJ21kJyB8fCAoaW5jbHVkZU1keCAmJiBjaGlsZC5leHRlbnNpb24gPT09ICdtZHgnKSkge1xuXHRcdFx0XHRcdGZpbGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHJlY3Vyc2l2ZSAmJiBjaGlsZCBpbnN0YW5jZW9mIFRGb2xkZXIgJiYgY2hpbGQuY2hpbGRyZW4pIHtcblx0XHRcdFx0Ly8gUmVjdXJzaXZlbHkgc2VhcmNoIHN1YmZvbGRlcnNcblx0XHRcdFx0ZmlsZXMucHVzaCguLi50aGlzLmdldE1hcmtkb3duRmlsZXMoY2hpbGQsIHJlY3Vyc2l2ZSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCArIDEsIGluY2x1ZGVNZHgpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmlsZXM7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHBhcnNlRnJvbnRtYXR0ZXIoZmlsZTogVEZpbGUpOiBQcm9taXNlPEV4YW1wbGVGcm9udG1hdHRlciB8IG51bGw+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG5cdFx0XHRjb25zdCBmcm9udG1hdHRlclJlZ2V4ID0gL14tLS1cXHMqXFxuKFtcXHNcXFNdKj8pXFxuLS0tXFxzKlxcbi87XG5cdFx0XHRjb25zdCBtYXRjaCA9IGNvbnRlbnQubWF0Y2goZnJvbnRtYXR0ZXJSZWdleCk7XG5cblx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHlhbWxDb250ZW50ID0gbWF0Y2hbMV07XG5cdFx0XHRjb25zdCBmcm9udG1hdHRlciA9IHlhbWwucGFyc2UoeWFtbENvbnRlbnQpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbDtcblxuXHRcdFx0aWYgKCFmcm9udG1hdHRlciB8fCB0eXBlb2YgZnJvbnRtYXR0ZXIgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRmaWxlOiBmaWxlLnBhdGgsXG5cdFx0XHRcdGZyb250bWF0dGVyLFxuXHRcdFx0XHRyYXdZYW1sOiB5YW1sQ29udGVudFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGF1dG9EZXRlY3REYXRlUHJvcGVydHkoZnJvbnRtYXR0ZXI6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHwgbnVsbCB7XG5cdFx0Y29uc3QgZGF0ZVByb3BlcnRpZXMgPSBbJ2RhdGUnLCAncHViRGF0ZScsICdwdWJsaXNoZWREYXRlJywgJ3B1Ymxpc2hEYXRlJ107XG5cblx0XHRmb3IgKGNvbnN0IHByb3Agb2YgZGF0ZVByb3BlcnRpZXMpIHtcblx0XHRcdGlmIChmcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDsgLy8gUmV0dXJuIG51bGwgd2hlbiBub3QgZm91bmQsIGRvbid0IGRlZmF1bHQgdG8gJ2RhdGUnXG5cdH1cblxuXHRhdXRvRGV0ZWN0RGVzY3JpcHRpb25Qcm9wZXJ0eShmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcgfCBudWxsIHtcblx0XHRjb25zdCBkZXNjcmlwdGlvblByb3BlcnRpZXMgPSBbJ2Rlc2NyaXB0aW9uJywgJ3N1bW1hcnknLCAnZXhjZXJwdCcsICdpbnRybycsICdzbmlwcGV0JywgJ2JsdXJiJ107XG5cblx0XHRmb3IgKGNvbnN0IHByb3Agb2YgZGVzY3JpcHRpb25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRpZiAoZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0cmV0dXJuIHByb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGZyb250bWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB8IG51bGwge1xuXHRcdC8vIE9ubHkgbWF0Y2ggXCJ0YWdzXCIgLSBzdHJpY3QgbWF0Y2hpbmcsIG5vIGZ1enp5IG1hdGNoaW5nXG5cdFx0aWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KCd0YWdzJykpIHtcblx0XHRcdHJldHVybiAndGFncyc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhdXRvRGV0ZWN0RHJhZnRQcm9wZXJ0eShmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB7IHByb3BlcnR5OiBzdHJpbmc7IGxvZ2ljOiAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnIH0gfCBudWxsIHtcblx0XHRpZiAoZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkoJ2RyYWZ0JykpIHtcblx0XHRcdC8vIElmIHByb3BlcnR5IGlzIFwiZHJhZnRcIiwgbG9naWMgc2hvdWxkIGJlIFwidHJ1ZS1kcmFmdFwiXG5cdFx0XHRyZXR1cm4geyBwcm9wZXJ0eTogJ2RyYWZ0JywgbG9naWM6ICd0cnVlLWRyYWZ0JyB9O1xuXHRcdH1cblxuXHRcdGlmIChmcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eSgncHVibGlzaGVkJykpIHtcblx0XHRcdC8vIElmIHByb3BlcnR5IGlzIFwicHVibGlzaGVkXCIsIGxvZ2ljIHNob3VsZCBiZSBcImZhbHNlLWRyYWZ0XCJcblx0XHRcdHJldHVybiB7IHByb3BlcnR5OiAncHVibGlzaGVkJywgbG9naWM6ICdmYWxzZS1kcmFmdCcgfTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGF1dG9EZXRlY3RJbWFnZVByb3BlcnR5KGZyb250bWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB8IG51bGwge1xuXHRcdGNvbnN0IGltYWdlUHJvcGVydGllcyA9IFsnaW1hZ2UnLCAnY292ZXInLCAnY292ZXJJbWFnZScsICd0aHVtYm5haWwnLCAnZmVhdHVyZWRJbWFnZSddO1xuXG5cdFx0Zm9yIChjb25zdCBwcm9wIG9mIGltYWdlUHJvcGVydGllcykge1xuXHRcdFx0aWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cbiIsICJjb25zdCBBTElBUyA9IFN5bWJvbC5mb3IoJ3lhbWwuYWxpYXMnKTtcbmNvbnN0IERPQyA9IFN5bWJvbC5mb3IoJ3lhbWwuZG9jdW1lbnQnKTtcbmNvbnN0IE1BUCA9IFN5bWJvbC5mb3IoJ3lhbWwubWFwJyk7XG5jb25zdCBQQUlSID0gU3ltYm9sLmZvcigneWFtbC5wYWlyJyk7XG5jb25zdCBTQ0FMQVIgPSBTeW1ib2wuZm9yKCd5YW1sLnNjYWxhcicpO1xuY29uc3QgU0VRID0gU3ltYm9sLmZvcigneWFtbC5zZXEnKTtcbmNvbnN0IE5PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3lhbWwubm9kZS50eXBlJyk7XG5jb25zdCBpc0FsaWFzID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBBTElBUztcbmNvbnN0IGlzRG9jdW1lbnQgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IERPQztcbmNvbnN0IGlzTWFwID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBNQVA7XG5jb25zdCBpc1BhaXIgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IFBBSVI7XG5jb25zdCBpc1NjYWxhciA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gU0NBTEFSO1xuY29uc3QgaXNTZXEgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IFNFUTtcbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKVxuICAgICAgICBzd2l0Y2ggKG5vZGVbTk9ERV9UWVBFXSkge1xuICAgICAgICAgICAgY2FzZSBNQVA6XG4gICAgICAgICAgICBjYXNlIFNFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKVxuICAgICAgICBzd2l0Y2ggKG5vZGVbTk9ERV9UWVBFXSkge1xuICAgICAgICAgICAgY2FzZSBBTElBUzpcbiAgICAgICAgICAgIGNhc2UgTUFQOlxuICAgICAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICBjYXNlIFNFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IGhhc0FuY2hvciA9IChub2RlKSA9PiAoaXNTY2FsYXIobm9kZSkgfHwgaXNDb2xsZWN0aW9uKG5vZGUpKSAmJiAhIW5vZGUuYW5jaG9yO1xuXG5leHBvcnQgeyBBTElBUywgRE9DLCBNQVAsIE5PREVfVFlQRSwgUEFJUiwgU0NBTEFSLCBTRVEsIGhhc0FuY2hvciwgaXNBbGlhcywgaXNDb2xsZWN0aW9uLCBpc0RvY3VtZW50LCBpc01hcCwgaXNOb2RlLCBpc1BhaXIsIGlzU2NhbGFyLCBpc1NlcSB9O1xuIiwgImltcG9ydCB7IGlzRG9jdW1lbnQsIGlzTm9kZSwgaXNQYWlyLCBpc0NvbGxlY3Rpb24sIGlzTWFwLCBpc1NlcSwgaXNTY2FsYXIsIGlzQWxpYXMgfSBmcm9tICcuL25vZGVzL2lkZW50aXR5LmpzJztcblxuY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBub2RlJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhbiBBU1Qgbm9kZSBvciBkb2N1bWVudC5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSBgbm9kZWAsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICAtIGBrZXlgOiBGb3Igc2VxdWVuY2UgdmFsdWVzIGFuZCBtYXAgYFBhaXJgLCB0aGUgbm9kZSdzIGluZGV4IGluIHRoZVxuICogICAgIGNvbGxlY3Rpb24uIFdpdGhpbiBhIGBQYWlyYCwgYCdrZXknYCBvciBgJ3ZhbHVlJ2AsIGNvcnJlc3BvbmRpbmdseS5cbiAqICAgICBgbnVsbGAgZm9yIHRoZSByb290IG5vZGUuXG4gKiAgIC0gYG5vZGVgOiBUaGUgY3VycmVudCBub2RlLlxuICogICAtIGBwYXRoYDogVGhlIGFuY2VzdHJ5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsIGNvbnRpbnVlIHdpdGggbmV4dFxuICogICAgIHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgTm9kZWA6IFJlcGxhY2UgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSBieSB2aXNpdGluZyBpdFxuICogICAtIGBudW1iZXJgOiBXaGlsZSBpdGVyYXRpbmcgdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2Ugb3IgbWFwLCBzZXQgdGhlIGluZGV4XG4gKiAgICAgb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRcbiAqICAgICBub2RlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIElmIGB2aXNpdG9yYCBpcyBhIHNpbmdsZSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdmFsdWVzXG4gKiBlbmNvdW50ZXJlZCBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIGUuZy4gYG51bGxgIHZhbHVlcy4gQWx0ZXJuYXRpdmVseSxcbiAqIHNlcGFyYXRlIHZpc2l0b3IgZnVuY3Rpb25zIG1heSBiZSBkZWZpbmVkIGZvciBlYWNoIGBNYXBgLCBgUGFpcmAsIGBTZXFgLFxuICogYEFsaWFzYCBhbmQgYFNjYWxhcmAgbm9kZS4gVG8gZGVmaW5lIHRoZSBzYW1lIHZpc2l0b3IgZnVuY3Rpb24gZm9yIG1vcmUgdGhhblxuICogb25lIG5vZGUgdHlwZSwgdXNlIHRoZSBgQ29sbGVjdGlvbmAgKG1hcCBhbmQgc2VxKSwgYFZhbHVlYCAobWFwLCBzZXEgJiBzY2FsYXIpXG4gKiBhbmQgYE5vZGVgIChhbGlhcywgbWFwLCBzZXEgJiBzY2FsYXIpIHRhcmdldHMuIE9mIGFsbCB0aGVzZSwgb25seSB0aGUgbW9zdFxuICogc3BlY2lmaWMgZGVmaW5lZCBvbmUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCB2aXNpdG9yXyA9IGluaXRWaXNpdG9yKHZpc2l0b3IpO1xuICAgIGlmIChpc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gdmlzaXRfKG51bGwsIG5vZGUuY29udGVudHMsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtub2RlXSkpO1xuICAgICAgICBpZiAoY2QgPT09IFJFTU9WRSlcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHZpc2l0XyhudWxsLCBub2RlLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbmZ1bmN0aW9uIHZpc2l0XyhrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBjb25zdCBjdHJsID0gY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICBpZiAoaXNOb2RlKGN0cmwpIHx8IGlzUGFpcihjdHJsKSkge1xuICAgICAgICByZXBsYWNlTm9kZShrZXksIHBhdGgsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdmlzaXRfKGtleSwgY3RybCwgdmlzaXRvciwgcGF0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3RybCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2kgPSB2aXNpdF8oaSwgbm9kZS5pdGVtc1tpXSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjaSAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNrID0gdmlzaXRfKCdrZXknLCBub2RlLmtleSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY2sgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNrID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3YgPSB2aXNpdF8oJ3ZhbHVlJywgbm9kZS52YWx1ZSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY3YgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGN2ID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0cmw7XG59XG4vKipcbiAqIEFwcGx5IGFuIGFzeW5jIHZpc2l0b3IgdG8gYW4gQVNUIG5vZGUgb3IgZG9jdW1lbnQuXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gYG5vZGVgLCBjYWxsaW5nIGFcbiAqIGB2aXNpdG9yYCBmdW5jdGlvbiB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAgLSBga2V5YDogRm9yIHNlcXVlbmNlIHZhbHVlcyBhbmQgbWFwIGBQYWlyYCwgdGhlIG5vZGUncyBpbmRleCBpbiB0aGVcbiAqICAgICBjb2xsZWN0aW9uLiBXaXRoaW4gYSBgUGFpcmAsIGAna2V5J2Agb3IgYCd2YWx1ZSdgLCBjb3JyZXNwb25kaW5nbHkuXG4gKiAgICAgYG51bGxgIGZvciB0aGUgcm9vdCBub2RlLlxuICogICAtIGBub2RlYDogVGhlIGN1cnJlbnQgbm9kZS5cbiAqICAgLSBgcGF0aGA6IFRoZSBhbmNlc3RyeSBvZiB0aGUgY3VycmVudCBub2RlLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHZpc2l0b3IgbWF5IGJlIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhdmVyc2FsOlxuICogICAtIGBQcm9taXNlYDogTXVzdCByZXNvbHZlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlc1xuICogICAtIGB1bmRlZmluZWRgIChkZWZhdWx0KTogRG8gbm90aGluZyBhbmQgY29udGludWVcbiAqICAgLSBgdmlzaXQuU0tJUGA6IERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCBjb250aW51ZSB3aXRoIG5leHRcbiAqICAgICBzaWJsaW5nXG4gKiAgIC0gYHZpc2l0LkJSRUFLYDogVGVybWluYXRlIHRyYXZlcnNhbCBjb21wbGV0ZWx5XG4gKiAgIC0gYHZpc2l0LlJFTU9WRWA6IFJlbW92ZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgb25lXG4gKiAgIC0gYE5vZGVgOiBSZXBsYWNlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgYnkgdmlzaXRpbmcgaXRcbiAqICAgLSBgbnVtYmVyYDogV2hpbGUgaXRlcmF0aW5nIHRoZSBpdGVtcyBvZiBhIHNlcXVlbmNlIG9yIG1hcCwgc2V0IHRoZSBpbmRleFxuICogICAgIG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWYgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50XG4gKiAgICAgbm9kZSBoYXMgY2hhbmdlZC5cbiAqXG4gKiBJZiBgdmlzaXRvcmAgaXMgYSBzaW5nbGUgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHZhbHVlc1xuICogZW5jb3VudGVyZWQgaW4gdGhlIHRyZWUsIGluY2x1ZGluZyBlLmcuIGBudWxsYCB2YWx1ZXMuIEFsdGVybmF0aXZlbHksXG4gKiBzZXBhcmF0ZSB2aXNpdG9yIGZ1bmN0aW9ucyBtYXkgYmUgZGVmaW5lZCBmb3IgZWFjaCBgTWFwYCwgYFBhaXJgLCBgU2VxYCxcbiAqIGBBbGlhc2AgYW5kIGBTY2FsYXJgIG5vZGUuIFRvIGRlZmluZSB0aGUgc2FtZSB2aXNpdG9yIGZ1bmN0aW9uIGZvciBtb3JlIHRoYW5cbiAqIG9uZSBub2RlIHR5cGUsIHVzZSB0aGUgYENvbGxlY3Rpb25gIChtYXAgYW5kIHNlcSksIGBWYWx1ZWAgKG1hcCwgc2VxICYgc2NhbGFyKVxuICogYW5kIGBOb2RlYCAoYWxpYXMsIG1hcCwgc2VxICYgc2NhbGFyKSB0YXJnZXRzLiBPZiBhbGwgdGhlc2UsIG9ubHkgdGhlIG1vc3RcbiAqIHNwZWNpZmljIGRlZmluZWQgb25lIHdpbGwgYmUgdXNlZCBmb3IgZWFjaCBub2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiB2aXNpdEFzeW5jKG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCB2aXNpdG9yXyA9IGluaXRWaXNpdG9yKHZpc2l0b3IpO1xuICAgIGlmIChpc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZSwgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW10pKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXRBc3luYy5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5SRU1PVkUgPSBSRU1PVkU7XG5hc3luYyBmdW5jdGlvbiB2aXNpdEFzeW5jXyhrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBjb25zdCBjdHJsID0gYXdhaXQgY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICBpZiAoaXNOb2RlKGN0cmwpIHx8IGlzUGFpcihjdHJsKSkge1xuICAgICAgICByZXBsYWNlTm9kZShrZXksIHBhdGgsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdmlzaXRBc3luY18oa2V5LCBjdHJsLCB2aXNpdG9yLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHJsICE9PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IGF3YWl0IHZpc2l0QXN5bmNfKGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IGF3YWl0IHZpc2l0QXN5bmNfKCdrZXknLCBub2RlLmtleSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY2sgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNrID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3YgPSBhd2FpdCB2aXNpdEFzeW5jXygndmFsdWUnLCBub2RlLnZhbHVlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjdiA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3YgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3RybDtcbn1cbmZ1bmN0aW9uIGluaXRWaXNpdG9yKHZpc2l0b3IpIHtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgICh2aXNpdG9yLkNvbGxlY3Rpb24gfHwgdmlzaXRvci5Ob2RlIHx8IHZpc2l0b3IuVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIEFsaWFzOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLk5vZGVcbiAgICAgICAgfSwgdmlzaXRvci5WYWx1ZSAmJiB7XG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTY2FsYXI6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuVmFsdWVcbiAgICAgICAgfSwgdmlzaXRvci5Db2xsZWN0aW9uICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Db2xsZWN0aW9uLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLkNvbGxlY3Rpb25cbiAgICAgICAgfSwgdmlzaXRvcik7XG4gICAgfVxuICAgIHJldHVybiB2aXNpdG9yO1xufVxuZnVuY3Rpb24gY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlzaXRvcihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpc01hcChub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuTWFwPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaXNTZXEobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLlNlcT8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlzUGFpcihub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuUGFpcj8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlzU2NhbGFyKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5TY2FsYXI/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpc0FsaWFzKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5BbGlhcz8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50Lml0ZW1zW2tleV0gPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIocGFyZW50KSkge1xuICAgICAgICBpZiAoa2V5ID09PSAna2V5JylcbiAgICAgICAgICAgIHBhcmVudC5rZXkgPSBub2RlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0RvY3VtZW50KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LmNvbnRlbnRzID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHB0ID0gaXNBbGlhcyhwYXJlbnQpID8gJ2FsaWFzJyA6ICdzY2FsYXInO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXBsYWNlIG5vZGUgd2l0aCAke3B0fSBwYXJlbnRgKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHZpc2l0LCB2aXNpdEFzeW5jIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5cbmNvbnN0IGVzY2FwZUNoYXJzID0ge1xuICAgICchJzogJyUyMScsXG4gICAgJywnOiAnJTJDJyxcbiAgICAnWyc6ICclNUInLFxuICAgICddJzogJyU1RCcsXG4gICAgJ3snOiAnJTdCJyxcbiAgICAnfSc6ICclN0QnXG59O1xuY29uc3QgZXNjYXBlVGFnTmFtZSA9ICh0bikgPT4gdG4ucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBjaCA9PiBlc2NhcGVDaGFyc1tjaF0pO1xuY2xhc3MgRGlyZWN0aXZlcyB7XG4gICAgY29uc3RydWN0b3IoeWFtbCwgdGFncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBtYXJrZXIgYC0tLWAuIElmIGBudWxsYCwgYSBtYXJrZXIgbWF5IHN0aWxsIGJlXG4gICAgICAgICAqIGluY2x1ZGVkIGluIHRoZSBkb2N1bWVudCdzIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NTdGFydCA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgZG9jLWVuZCBtYXJrZXIgYC4uLmAuICAqL1xuICAgICAgICB0aGlzLmRvY0VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnlhbWwgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLCB5YW1sKTtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncywgdGFncyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBjb3B5LmRvY1N0YXJ0ID0gdGhpcy5kb2NTdGFydDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1cmluZyBwYXJzaW5nLCBnZXQgYSBEaXJlY3RpdmVzIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBhbmRcbiAgICAgKiB1cGRhdGUgdGhlIHN0cmVhbSBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbidzIHNwZWMuXG4gICAgICovXG4gICAgYXREb2N1bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMueWFtbC52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMS4yJzpcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sID0ge1xuICAgICAgICAgICAgICAgICAgICBleHBsaWNpdDogRGlyZWN0aXZlcy5kZWZhdWx0WWFtbC5leHBsaWNpdCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbkVycm9yIC0gTWF5IGJlIGNhbGxlZCBldmVuIGlmIHRoZSBhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzc1xuICAgICAqL1xuICAgIGFkZChsaW5lLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmF0TmV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnlhbWwgPSB7IGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LCB2ZXJzaW9uOiAnMS4xJyB9O1xuICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnRyaW0oKS5zcGxpdCgvWyBcXHRdKy8pO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICclVEFHJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcigwLCAnJVRBRyBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSB0d28gcGFydHMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJyVZQU1MJzoge1xuICAgICAgICAgICAgICAgIHRoaXMueWFtbC5leHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclWUFNTCBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcGFydCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFt2ZXJzaW9uXSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnMS4xJyB8fCB2ZXJzaW9uID09PSAnMS4yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC9eXFxkK1xcLlxcZCskLy50ZXN0KHZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDYsIGBVbnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gJHt2ZXJzaW9ufWAsIGlzVmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvbkVycm9yKDAsIGBVbmtub3duIGRpcmVjdGl2ZSAke25hbWV9YCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGEgdGFnLCBtYXRjaGluZyBoYW5kbGVzIHRvIHRob3NlIGRlZmluZWQgaW4gJVRBRyBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmVzb2x2ZWQgdGFnLCB3aGljaCBtYXkgYWxzbyBiZSB0aGUgbm9uLXNwZWNpZmljIHRhZyBgJyEnYCBvciBhXG4gICAgICogICBgJyFsb2NhbCdgIHRhZywgb3IgYG51bGxgIGlmIHVucmVzb2x2YWJsZS5cbiAgICAgKi9cbiAgICB0YWdOYW1lKHNvdXJjZSwgb25FcnJvcikge1xuICAgICAgICBpZiAoc291cmNlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gJyEnOyAvLyBub24tc3BlY2lmaWMgdGFnXG4gICAgICAgIGlmIChzb3VyY2VbMF0gIT09ICchJykge1xuICAgICAgICAgICAgb25FcnJvcihgTm90IGEgdmFsaWQgdGFnOiAke3NvdXJjZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VbMV0gPT09ICc8Jykge1xuICAgICAgICAgICAgY29uc3QgdmVyYmF0aW0gPSBzb3VyY2Uuc2xpY2UoMiwgLTEpO1xuICAgICAgICAgICAgaWYgKHZlcmJhdGltID09PSAnIScgfHwgdmVyYmF0aW0gPT09ICchIScpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGBWZXJiYXRpbSB0YWdzIGFyZW4ndCByZXNvbHZlZCwgc28gJHtzb3VyY2V9IGlzIGludmFsaWQuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPT0gJz4nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1ZlcmJhdGltIHRhZ3MgbXVzdCBlbmQgd2l0aCBhID4nKTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJiYXRpbTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbLCBoYW5kbGUsIHN1ZmZpeF0gPSBzb3VyY2UubWF0Y2goL14oLiohKShbXiFdKikkL3MpO1xuICAgICAgICBpZiAoIXN1ZmZpeClcbiAgICAgICAgICAgIG9uRXJyb3IoYFRoZSAke3NvdXJjZX0gdGFnIGhhcyBubyBzdWZmaXhgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy50YWdzW2hhbmRsZV07XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIGRlY29kZVVSSUNvbXBvbmVudChzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gc291cmNlOyAvLyBsb2NhbCB0YWdcbiAgICAgICAgb25FcnJvcihgQ291bGQgbm90IHJlc29sdmUgdGFnOiAke3NvdXJjZX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZnVsbHkgcmVzb2x2ZWQgdGFnLCByZXR1cm5zIGl0cyBwcmludGFibGUgc3RyaW5nIGZvcm0sXG4gICAgICogdGFraW5nIGludG8gYWNjb3VudCBjdXJyZW50IHRhZyBwcmVmaXhlcyBhbmQgZGVmYXVsdHMuXG4gICAgICovXG4gICAgdGFnU3RyaW5nKHRhZykge1xuICAgICAgICBmb3IgKGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy50YWdzKSkge1xuICAgICAgICAgICAgaWYgKHRhZy5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSArIGVzY2FwZVRhZ05hbWUodGFnLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ1swXSA9PT0gJyEnID8gdGFnIDogYCE8JHt0YWd9PmA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGRvYykge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMueWFtbC5leHBsaWNpdFxuICAgICAgICAgICAgPyBbYCVZQU1MICR7dGhpcy55YW1sLnZlcnNpb24gfHwgJzEuMid9YF1cbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IHRhZ0VudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpO1xuICAgICAgICBsZXQgdGFnTmFtZXM7XG4gICAgICAgIGlmIChkb2MgJiYgdGFnRW50cmllcy5sZW5ndGggPiAwICYmIGlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdzID0ge307XG4gICAgICAgICAgICB2aXNpdChkb2MuY29udGVudHMsIChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZShub2RlKSAmJiBub2RlLnRhZylcbiAgICAgICAgICAgICAgICAgICAgdGFnc1tub2RlLnRhZ10gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YWdOYW1lcyA9IE9iamVjdC5rZXlzKHRhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhZ05hbWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiB0YWdFbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlID09PSAnISEnICYmIHByZWZpeCA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWRvYyB8fCB0YWdOYW1lcy5zb21lKHRuID0+IHRuLnN0YXJ0c1dpdGgocHJlZml4KSkpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChgJVRBRyAke2hhbmRsZX0gJHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH1cbn1cbkRpcmVjdGl2ZXMuZGVmYXVsdFlhbWwgPSB7IGV4cGxpY2l0OiBmYWxzZSwgdmVyc2lvbjogJzEuMicgfTtcbkRpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MgPSB7ICchISc6ICd0YWc6eWFtbC5vcmcsMjAwMjonIH07XG5cbmV4cG9ydCB7IERpcmVjdGl2ZXMgfTtcbiIsICJpbXBvcnQgeyBpc1NjYWxhciwgaXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5cbi8qKlxuICogVmVyaWZ5IHRoYXQgdGhlIGlucHV0IHN0cmluZyBpcyBhIHZhbGlkIGFuY2hvci5cbiAqXG4gKiBXaWxsIHRocm93IG9uIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gYW5jaG9ySXNWYWxpZChhbmNob3IpIHtcbiAgICBpZiAoL1tcXHgwMC1cXHgxOVxccyxbXFxde31dLy50ZXN0KGFuY2hvcikpIHtcbiAgICAgICAgY29uc3Qgc2EgPSBKU09OLnN0cmluZ2lmeShhbmNob3IpO1xuICAgICAgICBjb25zdCBtc2cgPSBgQW5jaG9yIG11c3Qgbm90IGNvbnRhaW4gd2hpdGVzcGFjZSBvciBjb250cm9sIGNoYXJhY3RlcnM6ICR7c2F9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW5jaG9yTmFtZXMocm9vdCkge1xuICAgIGNvbnN0IGFuY2hvcnMgPSBuZXcgU2V0KCk7XG4gICAgdmlzaXQocm9vdCwge1xuICAgICAgICBWYWx1ZShfa2V5LCBub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hbmNob3IpXG4gICAgICAgICAgICAgICAgYW5jaG9ycy5hZGQobm9kZS5hbmNob3IpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFuY2hvcnM7XG59XG4vKiogRmluZCBhIG5ldyBhbmNob3IgbmFtZSB3aXRoIHRoZSBnaXZlbiBgcHJlZml4YCBhbmQgYSBvbmUtaW5kZXhlZCBzdWZmaXguICovXG5mdW5jdGlvbiBmaW5kTmV3QW5jaG9yKHByZWZpeCwgZXhjbHVkZSkge1xuICAgIGZvciAobGV0IGkgPSAxOyB0cnVlOyArK2kpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke3ByZWZpeH0ke2l9YDtcbiAgICAgICAgaWYgKCFleGNsdWRlLmhhcyhuYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVBbmNob3JzKGRvYywgcHJlZml4KSB7XG4gICAgY29uc3QgYWxpYXNPYmplY3RzID0gW107XG4gICAgY29uc3Qgc291cmNlT2JqZWN0cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgcHJldkFuY2hvcnMgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uQW5jaG9yOiAoc291cmNlKSA9PiB7XG4gICAgICAgICAgICBhbGlhc09iamVjdHMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgcHJldkFuY2hvcnMgPz8gKHByZXZBbmNob3JzID0gYW5jaG9yTmFtZXMoZG9jKSk7XG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBmaW5kTmV3QW5jaG9yKHByZWZpeCwgcHJldkFuY2hvcnMpO1xuICAgICAgICAgICAgcHJldkFuY2hvcnMuYWRkKGFuY2hvcik7XG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCBjaXJjdWxhciByZWZlcmVuY2VzLCB0aGUgc291cmNlIG5vZGUgaXMgb25seSByZXNvbHZlZCBhZnRlciBhbGxcbiAgICAgICAgICogb2YgaXRzIGNoaWxkIG5vZGVzIGFyZS4gVGhpcyBpcyB3aHkgYW5jaG9ycyBhcmUgc2V0IG9ubHkgYWZ0ZXIgYWxsIG9mXG4gICAgICAgICAqIHRoZSBub2RlcyBoYXZlIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldEFuY2hvcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGFsaWFzT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNvdXJjZU9iamVjdHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hbmNob3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzU2NhbGFyKHJlZi5ub2RlKSB8fCBpc0NvbGxlY3Rpb24ocmVmLm5vZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYubm9kZS5hbmNob3IgPSByZWYuYW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHJlcGVhdGVkIG9iamVjdCAodGhpcyBzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhbmNob3JJc1ZhbGlkLCBhbmNob3JOYW1lcywgY3JlYXRlTm9kZUFuY2hvcnMsIGZpbmROZXdBbmNob3IgfTtcbiIsICIvKipcbiAqIEFwcGxpZXMgdGhlIEpTT04ucGFyc2UgcmV2aXZlciBhbGdvcml0aG0gYXMgZGVmaW5lZCBpbiB0aGUgRUNNQS0yNjIgc3BlYyxcbiAqIGluIHNlY3Rpb24gMjQuNS4xLjEgXCJSdW50aW1lIFNlbWFudGljczogSW50ZXJuYWxpemVKU09OUHJvcGVydHlcIiBvZiB0aGVcbiAqIDIwMjEgZWRpdGlvbjogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnBhcnNlXG4gKlxuICogSW5jbHVkZXMgZXh0ZW5zaW9ucyBmb3IgaGFuZGxpbmcgTWFwIGFuZCBTZXQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlSZXZpdmVyKHJldml2ZXIsIG9iaiwga2V5LCB2YWwpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHZhbFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIFN0cmluZyhpKSwgdjApO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYXJyYXktZGVsZXRlXG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxbaV0gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWwuZ2V0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsLnNldChrLCB2MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYwIG9mIEFycmF5LmZyb20odmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgdjAsIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgICAgICB2YWwuYWRkKHYxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2MF0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2tdID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChvYmosIGtleSwgdmFsKTtcbn1cblxuZXhwb3J0IHsgYXBwbHlSZXZpdmVyIH07XG4iLCAiaW1wb3J0IHsgaGFzQW5jaG9yIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY29udmVydCBhbnkgbm9kZSBvciBpdHMgY29udGVudHMgdG8gbmF0aXZlIEphdmFTY3JpcHRcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaW5wdXQgdmFsdWVcbiAqIEBwYXJhbSBhcmcgLSBJZiBgdmFsdWVgIGRlZmluZXMgYSBgdG9KU09OKClgIG1ldGhvZCwgdXNlIHRoaXNcbiAqICAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKCkuIElmXG4gKiAgIGB7IGtlZXA6IHRydWUgfWAgaXMgbm90IHNldCwgb3V0cHV0IHNob3VsZCBiZSBzdWl0YWJsZSBmb3IgSlNPTlxuICogICBzdHJpbmdpZmljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvSlModmFsdWUsIGFyZywgY3R4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiB0b0pTKHYsIFN0cmluZyhpKSwgY3R4KSk7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICBpZiAoIWN0eCB8fCAhaGFzQW5jaG9yKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0pTT04oYXJnLCBjdHgpO1xuICAgICAgICBjb25zdCBkYXRhID0geyBhbGlhc0NvdW50OiAwLCBjb3VudDogMSwgcmVzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgY3R4LmFuY2hvcnMuc2V0KHZhbHVlLCBkYXRhKTtcbiAgICAgICAgY3R4Lm9uQ3JlYXRlID0gcmVzID0+IHtcbiAgICAgICAgICAgIGRhdGEucmVzID0gcmVzO1xuICAgICAgICAgICAgZGVsZXRlIGN0eC5vbkNyZWF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgaWYgKGN0eC5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyAmJiAhY3R4Py5rZWVwKVxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IHRvSlMgfTtcbiIsICJpbXBvcnQgeyBhcHBseVJldml2ZXIgfSBmcm9tICcuLi9kb2MvYXBwbHlSZXZpdmVyLmpzJztcbmltcG9ydCB7IE5PREVfVFlQRSwgaXNEb2N1bWVudCB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4vdG9KUy5qcyc7XG5cbmNsYXNzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBOT0RFX1RZUEUsIHsgdmFsdWU6IHR5cGUgfSk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZS4gICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGhpcykpO1xuICAgICAgICBpZiAodGhpcy5yYW5nZSlcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB0aGlzLnJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKiogQSBwbGFpbiBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS4gKi9cbiAgICB0b0pTKGRvYywgeyBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudChkb2MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBkb2N1bWVudCBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBhbmNob3JzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBrZWVwOiB0cnVlLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUyh0aGlzLCAnJywgY3R4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFuY2hvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBjb3VudCwgcmVzIH0gb2YgY3R4LmFuY2hvcnMudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgb25BbmNob3IocmVzLCBjb3VudCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcHBseVJldml2ZXIocmV2aXZlciwgeyAnJzogcmVzIH0sICcnLCByZXMpXG4gICAgICAgICAgICA6IHJlcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IE5vZGVCYXNlIH07XG4iLCAiaW1wb3J0IHsgYW5jaG9ySXNWYWxpZCB9IGZyb20gJy4uL2RvYy9hbmNob3JzLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuaW1wb3J0IHsgQUxJQVMsIGlzQWxpYXMsIGlzQ29sbGVjdGlvbiwgaXNQYWlyLCBoYXNBbmNob3IgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IE5vZGVCYXNlIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jbGFzcyBBbGlhcyBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoQUxJQVMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0YWcnLCB7XG4gICAgICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGlhcyBub2RlcyBjYW5ub3QgaGF2ZSB0YWdzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHRoZSB2YWx1ZSBvZiB0aGlzIGFsaWFzIHdpdGhpbiBgZG9jYCwgZmluZGluZyB0aGUgbGFzdFxuICAgICAqIGluc3RhbmNlIG9mIHRoZSBgc291cmNlYCBhbmNob3IgYmVmb3JlIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICByZXNvbHZlKGRvYywgY3R4KSB7XG4gICAgICAgIGxldCBub2RlcztcbiAgICAgICAgaWYgKGN0eD8uYWxpYXNSZXNvbHZlQ2FjaGUpIHtcbiAgICAgICAgICAgIG5vZGVzID0gY3R4LmFsaWFzUmVzb2x2ZUNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHZpc2l0KGRvYywge1xuICAgICAgICAgICAgICAgIE5vZGU6IChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FsaWFzKG5vZGUpIHx8IGhhc0FuY2hvcihub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY3R4KVxuICAgICAgICAgICAgICAgIGN0eC5hbGlhc1Jlc29sdmVDYWNoZSA9IG5vZGVzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3VuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChub2RlLmFuY2hvciA9PT0gdGhpcy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgdG9KU09OKF9hcmcsIGN0eCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiB7IHNvdXJjZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgY29uc3QgeyBhbmNob3JzLCBkb2MsIG1heEFsaWFzQ291bnQgfSA9IGN0eDtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvbHZlKGRvYywgY3R4KTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBVbnJlc29sdmVkIGFsaWFzICh0aGUgYW5jaG9yIG11c3QgYmUgc2V0IGJlZm9yZSB0aGUgYWxpYXMpOiAke3RoaXMuc291cmNlfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IGFuY2hvcnMuZ2V0KHNvdXJjZSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbmNob3JzIGZvciBOb2RlLnByb3RvdHlwZS50b0pTKClcbiAgICAgICAgICAgIHRvSlMoc291cmNlLCBudWxsLCBjdHgpO1xuICAgICAgICAgICAgZGF0YSA9IGFuY2hvcnMuZ2V0KHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChkYXRhPy5yZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ1RoaXMgc2hvdWxkIG5vdCBoYXBwZW46IEFsaWFzIGFuY2hvciB3YXMgbm90IHJlc29sdmVkPyc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4QWxpYXNDb3VudCA+PSAwKSB7XG4gICAgICAgICAgICBkYXRhLmNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoZGF0YS5hbGlhc0NvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgIGRhdGEuYWxpYXNDb3VudCA9IGdldEFsaWFzQ291bnQoZG9jLCBzb3VyY2UsIGFuY2hvcnMpO1xuICAgICAgICAgICAgaWYgKGRhdGEuY291bnQgKiBkYXRhLmFsaWFzQ291bnQgPiBtYXhBbGlhc0NvdW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ0V4Y2Vzc2l2ZSBhbGlhcyBjb3VudCBpbmRpY2F0ZXMgYSByZXNvdXJjZSBleGhhdXN0aW9uIGF0dGFjayc7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEucmVzO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIF9vbkNvbW1lbnQsIF9vbkNob21wS2VlcCkge1xuICAgICAgICBjb25zdCBzcmMgPSBgKiR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgYW5jaG9ySXNWYWxpZCh0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMudmVyaWZ5QWxpYXNPcmRlciAmJiAhY3R4LmFuY2hvcnMuaGFzKHRoaXMuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBVbnJlc29sdmVkIGFsaWFzICh0aGUgYW5jaG9yIG11c3QgYmUgc2V0IGJlZm9yZSB0aGUgYWxpYXMpOiAke3RoaXMuc291cmNlfWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4LmltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzcmN9IGA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBbGlhc0NvdW50KGRvYywgbm9kZSwgYW5jaG9ycykge1xuICAgIGlmIChpc0FsaWFzKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUucmVzb2x2ZShkb2MpO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBhbmNob3JzICYmIHNvdXJjZSAmJiBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICByZXR1cm4gYW5jaG9yID8gYW5jaG9yLmNvdW50ICogYW5jaG9yLmFsaWFzQ291bnQgOiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRBbGlhc0NvdW50KGRvYywgaXRlbSwgYW5jaG9ycyk7XG4gICAgICAgICAgICBpZiAoYyA+IGNvdW50KVxuICAgICAgICAgICAgICAgIGNvdW50ID0gYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGFpcihub2RlKSkge1xuICAgICAgICBjb25zdCBrYyA9IGdldEFsaWFzQ291bnQoZG9jLCBub2RlLmtleSwgYW5jaG9ycyk7XG4gICAgICAgIGNvbnN0IHZjID0gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUudmFsdWUsIGFuY2hvcnMpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoa2MsIHZjKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCB7IEFsaWFzIH07XG4iLCAiaW1wb3J0IHsgU0NBTEFSIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY29uc3QgaXNTY2FsYXJWYWx1ZSA9ICh2YWx1ZSkgPT4gIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG5jbGFzcyBTY2FsYXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoU0NBTEFSKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oYXJnLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGN0eD8ua2VlcCA/IHRoaXMudmFsdWUgOiB0b0pTKHRoaXMudmFsdWUsIGFyZywgY3R4KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfVxufVxuU2NhbGFyLkJMT0NLX0ZPTERFRCA9ICdCTE9DS19GT0xERUQnO1xuU2NhbGFyLkJMT0NLX0xJVEVSQUwgPSAnQkxPQ0tfTElURVJBTCc7XG5TY2FsYXIuUExBSU4gPSAnUExBSU4nO1xuU2NhbGFyLlFVT1RFX0RPVUJMRSA9ICdRVU9URV9ET1VCTEUnO1xuU2NhbGFyLlFVT1RFX1NJTkdMRSA9ICdRVU9URV9TSU5HTEUnO1xuXG5leHBvcnQgeyBTY2FsYXIsIGlzU2NhbGFyVmFsdWUgfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGlzTm9kZSwgaXNQYWlyLCBNQVAsIFNFUSwgaXNEb2N1bWVudCB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmNvbnN0IGRlZmF1bHRUYWdQcmVmaXggPSAndGFnOnlhbWwub3JnLDIwMDI6JztcbmZ1bmN0aW9uIGZpbmRUYWdPYmplY3QodmFsdWUsIHRhZ05hbWUsIHRhZ3MpIHtcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRhZ3MuZmlsdGVyKHQgPT4gdC50YWcgPT09IHRhZ05hbWUpO1xuICAgICAgICBjb25zdCB0YWdPYmogPSBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KSA/PyBtYXRjaFswXTtcbiAgICAgICAgaWYgKCF0YWdPYmopXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhZyAke3RhZ05hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgICByZXR1cm4gdGFnT2JqO1xuICAgIH1cbiAgICByZXR1cm4gdGFncy5maW5kKHQgPT4gdC5pZGVudGlmeT8uKHZhbHVlKSAmJiAhdC5mb3JtYXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnTmFtZSwgY3R4KSB7XG4gICAgaWYgKGlzRG9jdW1lbnQodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvbnRlbnRzO1xuICAgIGlmIChpc05vZGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKGlzUGFpcih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbWFwID0gY3R4LnNjaGVtYVtNQVBdLmNyZWF0ZU5vZGU/LihjdHguc2NoZW1hLCBudWxsLCBjdHgpO1xuICAgICAgICBtYXAuaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4gfHxcbiAgICAgICAgKHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQmlnSW50KSAvLyBub3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmVcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXJpYWxpemVqc29ucHJvcGVydHlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzLCBvbkFuY2hvciwgb25UYWdPYmosIHNjaGVtYSwgc291cmNlT2JqZWN0cyB9ID0gY3R4O1xuICAgIC8vIERldGVjdCBkdXBsaWNhdGUgcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBvYmplY3QgJiB1c2UgQWxpYXMgbm9kZXMgZm9yIGFsbFxuICAgIC8vIGFmdGVyIGZpcnN0LiBUaGUgYHJlZmAgd3JhcHBlciBhbGxvd3MgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZS5cbiAgICBsZXQgcmVmID0gdW5kZWZpbmVkO1xuICAgIGlmIChhbGlhc0R1cGxpY2F0ZU9iamVjdHMgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZWYgPSBzb3VyY2VPYmplY3RzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIHJlZi5hbmNob3IgPz8gKHJlZi5hbmNob3IgPSBvbkFuY2hvcih2YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGlhcyhyZWYuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZiA9IHsgYW5jaG9yOiBudWxsLCBub2RlOiBudWxsIH07XG4gICAgICAgICAgICBzb3VyY2VPYmplY3RzLnNldCh2YWx1ZSwgcmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZT8uc3RhcnRzV2l0aCgnISEnKSlcbiAgICAgICAgdGFnTmFtZSA9IGRlZmF1bHRUYWdQcmVmaXggKyB0YWdOYW1lLnNsaWNlKDIpO1xuICAgIGxldCB0YWdPYmogPSBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCBzY2hlbWEudGFncyk7XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVmKVxuICAgICAgICAgICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE1hcFxuICAgICAgICAgICAgICAgID8gc2NoZW1hW01BUF1cbiAgICAgICAgICAgICAgICA6IFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gc2NoZW1hW1NFUV1cbiAgICAgICAgICAgICAgICAgICAgOiBzY2hlbWFbTUFQXTtcbiAgICB9XG4gICAgaWYgKG9uVGFnT2JqKSB7XG4gICAgICAgIG9uVGFnT2JqKHRhZ09iaik7XG4gICAgICAgIGRlbGV0ZSBjdHgub25UYWdPYmo7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0YWdPYmo/LmNyZWF0ZU5vZGVcbiAgICAgICAgPyB0YWdPYmouY3JlYXRlTm9kZShjdHguc2NoZW1hLCB2YWx1ZSwgY3R4KVxuICAgICAgICA6IHR5cGVvZiB0YWdPYmo/Lm5vZGVDbGFzcz8uZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyB0YWdPYmoubm9kZUNsYXNzLmZyb20oY3R4LnNjaGVtYSwgdmFsdWUsIGN0eClcbiAgICAgICAgICAgIDogbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgaWYgKHRhZ05hbWUpXG4gICAgICAgIG5vZGUudGFnID0gdGFnTmFtZTtcbiAgICBlbHNlIGlmICghdGFnT2JqLmRlZmF1bHQpXG4gICAgICAgIG5vZGUudGFnID0gdGFnT2JqLnRhZztcbiAgICBpZiAocmVmKVxuICAgICAgICByZWYubm9kZSA9IG5vZGU7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU5vZGUgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi4vZG9jL2NyZWF0ZU5vZGUuanMnO1xuaW1wb3J0IHsgaXNOb2RlLCBpc1BhaXIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IE5vZGVCYXNlIH0gZnJvbSAnLi9Ob2RlLmpzJztcblxuZnVuY3Rpb24gY29sbGVjdGlvbkZyb21QYXRoKHNjaGVtYSwgcGF0aCwgdmFsdWUpIHtcbiAgICBsZXQgdiA9IHZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGsgPSBwYXRoW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoaykgJiYgayA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICBhW2tdID0gdjtcbiAgICAgICAgICAgIHYgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IG5ldyBNYXAoW1trLCB2XV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVOb2RlKHYsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbGlhc0R1cGxpY2F0ZU9iamVjdHM6IGZhbHNlLFxuICAgICAgICBrZWVwVW5kZWZpbmVkOiBmYWxzZSxcbiAgICAgICAgb25BbmNob3I6ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgcGxlYXNlIHJlcG9ydCBhIGJ1Zy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzb3VyY2VPYmplY3RzOiBuZXcgTWFwKClcbiAgICB9KTtcbn1cbi8vIFR5cGUgZ3VhcmQgaXMgaW50ZW50aW9uYWxseSBhIGxpdHRsZSB3cm9uZyBzbyBhcyB0byBiZSBtb3JlIHVzZWZ1bCxcbi8vIGFzIGl0IGRvZXMgbm90IGNvdmVyIHVudHlwYWJsZSBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlcyAoZS5nLiBbXSkuXG5jb25zdCBpc0VtcHR5UGF0aCA9IChwYXRoKSA9PiBwYXRoID09IG51bGwgfHxcbiAgICAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmICEhcGF0aFtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpLmRvbmUpO1xuY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIodHlwZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NoZW1hJywge1xuICAgICAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIElmIGRlZmluZWQsIG92ZXJ3cml0ZXMgdGhlIG9yaWdpbmFsJ3Mgc2NoZW1hXG4gICAgICovXG4gICAgY2xvbmUoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGhpcykpO1xuICAgICAgICBpZiAoc2NoZW1hKVxuICAgICAgICAgICAgY29weS5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIGNvcHkuaXRlbXMgPSBjb3B5Lml0ZW1zLm1hcChpdCA9PiBpc05vZGUoaXQpIHx8IGlzUGFpcihpdCkgPyBpdC5jbG9uZShzY2hlbWEpIDogaXQpO1xuICAgICAgICBpZiAodGhpcy5yYW5nZSlcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB0aGlzLnJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGNvbGxlY3Rpb24uIEZvciBgISFtYXBgIGFuZCBgISFvbWFwYCB0aGUgdmFsdWUgbXVzdFxuICAgICAqIGJlIGEgUGFpciBpbnN0YW5jZSBvciBhIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0LCB3aGljaCBtYXkgbm90IGhhdmUgYSBrZXlcbiAgICAgKiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgYWRkSW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgICAgICBub2RlLmFkZEluKHJlc3QsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBpdGVtIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBkZWxldGVJbihwYXRoKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZGVsZXRlSW4ocmVzdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBrZXlgLCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuIEJ5IGRlZmF1bHQgdW53cmFwc1xuICAgICAqIHNjYWxhciB2YWx1ZXMgZnJvbSB0aGVpciBzdXJyb3VuZGluZyBub2RlOyB0byBkaXNhYmxlIHNldCBga2VlcFNjYWxhcmAgdG9cbiAgICAgKiBgdHJ1ZWAgKGNvbGxlY3Rpb25zIGFyZSBhbHdheXMgcmV0dXJuZWQgaW50YWN0KS5cbiAgICAgKi9cbiAgICBnZXRJbihwYXRoLCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAha2VlcFNjYWxhciAmJiBpc1NjYWxhcihub2RlKSA/IG5vZGUudmFsdWUgOiBub2RlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKG5vZGUpID8gbm9kZS5nZXRJbihyZXN0LCBrZWVwU2NhbGFyKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzQWxsTnVsbFZhbHVlcyhhbGxvd1NjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5ldmVyeShub2RlID0+IHtcbiAgICAgICAgICAgIGlmICghaXNQYWlyKG5vZGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2RlLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIChuID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAoYWxsb3dTY2FsYXIgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNTY2FsYXIobikgJiZcbiAgICAgICAgICAgICAgICAgICAgbi52YWx1ZSA9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnRCZWZvcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4uY29tbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi50YWcpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKi9cbiAgICBoYXNJbihwYXRoKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKG5vZGUpID8gbm9kZS5oYXNJbihyZXN0KSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKi9cbiAgICBzZXRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRJbihyZXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb2xsZWN0aW9uLCBjb2xsZWN0aW9uRnJvbVBhdGgsIGlzRW1wdHlQYXRoIH07XG4iLCAiLyoqXG4gKiBTdHJpbmdpZmllcyBhIGNvbW1lbnQuXG4gKlxuICogRW1wdHkgY29tbWVudCBsaW5lcyBhcmUgbGVmdCBlbXB0eSxcbiAqIGxpbmVzIGNvbnNpc3Rpbmcgb2YgYSBzaW5nbGUgc3BhY2UgYXJlIHJlcGxhY2VkIGJ5IGAjYCxcbiAqIGFuZCBhbGwgb3RoZXIgbGluZXMgYXJlIHByZWZpeGVkIHdpdGggYSBgI2AuXG4gKi9cbmNvbnN0IHN0cmluZ2lmeUNvbW1lbnQgPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvXig/ISQpKD86ICQpPy9nbSwgJyMnKTtcbmZ1bmN0aW9uIGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KSB7XG4gICAgaWYgKC9eXFxuKyQvLnRlc3QoY29tbWVudCkpXG4gICAgICAgIHJldHVybiBjb21tZW50LnN1YnN0cmluZygxKTtcbiAgICByZXR1cm4gaW5kZW50ID8gY29tbWVudC5yZXBsYWNlKC9eKD8hICokKS9nbSwgaW5kZW50KSA6IGNvbW1lbnQ7XG59XG5jb25zdCBsaW5lQ29tbWVudCA9IChzdHIsIGluZGVudCwgY29tbWVudCkgPT4gc3RyLmVuZHNXaXRoKCdcXG4nKVxuICAgID8gaW5kZW50Q29tbWVudChjb21tZW50LCBpbmRlbnQpXG4gICAgOiBjb21tZW50LmluY2x1ZGVzKCdcXG4nKVxuICAgICAgICA/ICdcXG4nICsgaW5kZW50Q29tbWVudChjb21tZW50LCBpbmRlbnQpXG4gICAgICAgIDogKHN0ci5lbmRzV2l0aCgnICcpID8gJycgOiAnICcpICsgY29tbWVudDtcblxuZXhwb3J0IHsgaW5kZW50Q29tbWVudCwgbGluZUNvbW1lbnQsIHN0cmluZ2lmeUNvbW1lbnQgfTtcbiIsICJjb25zdCBGT0xEX0ZMT1cgPSAnZmxvdyc7XG5jb25zdCBGT0xEX0JMT0NLID0gJ2Jsb2NrJztcbmNvbnN0IEZPTERfUVVPVEVEID0gJ3F1b3RlZCc7XG4vKipcbiAqIFRyaWVzIHRvIGtlZXAgaW5wdXQgYXQgdXAgdG8gYGxpbmVXaWR0aGAgY2hhcmFjdGVycywgc3BsaXR0aW5nIG9ubHkgb24gc3BhY2VzXG4gKiBub3QgZm9sbG93ZWQgYnkgbmV3bGluZXMgb3Igc3BhY2VzIHVubGVzcyBgbW9kZWAgaXMgYCdxdW90ZWQnYC4gTGluZXMgYXJlXG4gKiB0ZXJtaW5hdGVkIHdpdGggYFxcbmAgYW5kIHN0YXJ0ZWQgd2l0aCBgaW5kZW50YC5cbiAqL1xuZnVuY3Rpb24gZm9sZEZsb3dMaW5lcyh0ZXh0LCBpbmRlbnQsIG1vZGUgPSAnZmxvdycsIHsgaW5kZW50QXRTdGFydCwgbGluZVdpZHRoID0gODAsIG1pbkNvbnRlbnRXaWR0aCA9IDIwLCBvbkZvbGQsIG9uT3ZlcmZsb3cgfSA9IHt9KSB7XG4gICAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgaWYgKGxpbmVXaWR0aCA8IG1pbkNvbnRlbnRXaWR0aClcbiAgICAgICAgbWluQ29udGVudFdpZHRoID0gMDtcbiAgICBjb25zdCBlbmRTdGVwID0gTWF0aC5tYXgoMSArIG1pbkNvbnRlbnRXaWR0aCwgMSArIGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGgpO1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSBlbmRTdGVwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBjb25zdCBmb2xkcyA9IFtdO1xuICAgIGNvbnN0IGVzY2FwZWRGb2xkcyA9IHt9O1xuICAgIGxldCBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5kZW50QXRTdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGluZGVudEF0U3RhcnQgPiBsaW5lV2lkdGggLSBNYXRoLm1heCgyLCBtaW5Db250ZW50V2lkdGgpKVxuICAgICAgICAgICAgZm9sZHMucHVzaCgwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50QXRTdGFydDtcbiAgICB9XG4gICAgbGV0IHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgIGxldCBwcmV2ID0gdW5kZWZpbmVkO1xuICAgIGxldCBvdmVyZmxvdyA9IGZhbHNlO1xuICAgIGxldCBpID0gLTE7XG4gICAgbGV0IGVzY1N0YXJ0ID0gLTE7XG4gICAgbGV0IGVzY0VuZCA9IC0xO1xuICAgIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKSB7XG4gICAgICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSwgaW5kZW50Lmxlbmd0aCk7XG4gICAgICAgIGlmIChpICE9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IGkgKyBlbmRTdGVwO1xuICAgIH1cbiAgICBmb3IgKGxldCBjaDsgKGNoID0gdGV4dFsoaSArPSAxKV0pOykge1xuICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgZXNjU3RhcnQgPSBpO1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0W2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY0VuZCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spXG4gICAgICAgICAgICAgICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpLCBpbmRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgIGVuZCA9IGkgKyBpbmRlbnQubGVuZ3RoICsgZW5kU3RlcDtcbiAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJ1xcbicgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIC8vIHNwYWNlIHN1cnJvdW5kZWQgYnkgbm9uLXNwYWNlIGNhbiBiZSByZXBsYWNlZCB3aXRoIG5ld2xpbmUgKyBpbmRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGV4dFtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gJyAnICYmIG5leHQgIT09ICdcXG4nICYmIG5leHQgIT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZHMucHVzaChzcGxpdCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHNwbGl0ICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlLXNwYWNlIGNvbGxlY3RlZCBhdCBlbmQgbWF5IHN0cmV0Y2ggcGFzdCBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHByZXYgPT09ICcgJyB8fCBwcmV2ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSB0ZXh0WyhpICs9IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciBuZXdsaW5lIGVzY2FwZSwgYnV0IGRvbid0IGJyZWFrIHByZWNlZGluZyBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaiA9IGkgPiBlc2NFbmQgKyAxID8gaSAtIDIgOiBlc2NTdGFydCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGlmIGxpbmVXaWR0aCAmIG1pbkNvbnRlbnRXaWR0aCBhcmUgc2hvcnRlciB0aGFuIGFuIGVzY2FwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRGb2xkc1tqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKGopO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkRm9sZHNbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBqICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBjaDtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93ICYmIG9uT3ZlcmZsb3cpXG4gICAgICAgIG9uT3ZlcmZsb3coKTtcbiAgICBpZiAoZm9sZHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBpZiAob25Gb2xkKVxuICAgICAgICBvbkZvbGQoKTtcbiAgICBsZXQgcmVzID0gdGV4dC5zbGljZSgwLCBmb2xkc1swXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBmb2xkID0gZm9sZHNbaV07XG4gICAgICAgIGNvbnN0IGVuZCA9IGZvbGRzW2kgKyAxXSB8fCB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGZvbGQgPT09IDApXG4gICAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKDAsIGVuZCl9YDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgZXNjYXBlZEZvbGRzW2ZvbGRdKVxuICAgICAgICAgICAgICAgIHJlcyArPSBgJHt0ZXh0W2ZvbGRdfVxcXFxgO1xuICAgICAgICAgICAgcmVzICs9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoZm9sZCArIDEsIGVuZCl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBQcmVzdW1lcyBgaSArIDFgIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmVcbiAqIEByZXR1cm5zIGluZGV4IG9mIGxhc3QgbmV3bGluZSBpbiBtb3JlLWluZGVudGVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpLCBpbmRlbnQpIHtcbiAgICBsZXQgZW5kID0gaTtcbiAgICBsZXQgc3RhcnQgPSBpICsgMTtcbiAgICBsZXQgY2ggPSB0ZXh0W3N0YXJ0XTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgaWYgKGkgPCBzdGFydCArIGluZGVudCkge1xuICAgICAgICAgICAgY2ggPSB0ZXh0WysraV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY2ggPSB0ZXh0WysraV07XG4gICAgICAgICAgICB9IHdoaWxlIChjaCAmJiBjaCAhPT0gJ1xcbicpO1xuICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBjaCA9IHRleHRbc3RhcnRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5cbmV4cG9ydCB7IEZPTERfQkxPQ0ssIEZPTERfRkxPVywgRk9MRF9RVU9URUQsIGZvbGRGbG93TGluZXMgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgZm9sZEZsb3dMaW5lcywgRk9MRF9GTE9XLCBGT0xEX1FVT1RFRCwgRk9MRF9CTE9DSyB9IGZyb20gJy4vZm9sZEZsb3dMaW5lcy5qcyc7XG5cbmNvbnN0IGdldEZvbGRPcHRpb25zID0gKGN0eCwgaXNCbG9jaykgPT4gKHtcbiAgICBpbmRlbnRBdFN0YXJ0OiBpc0Jsb2NrID8gY3R4LmluZGVudC5sZW5ndGggOiBjdHguaW5kZW50QXRTdGFydCxcbiAgICBsaW5lV2lkdGg6IGN0eC5vcHRpb25zLmxpbmVXaWR0aCxcbiAgICBtaW5Db250ZW50V2lkdGg6IGN0eC5vcHRpb25zLm1pbkNvbnRlbnRXaWR0aFxufSk7XG4vLyBBbHNvIGNoZWNrcyBmb3IgbGluZXMgc3RhcnRpbmcgd2l0aCAlLCBhcyBwYXJzaW5nIHRoZSBvdXRwdXQgYXMgWUFNTCAxLjEgd2lsbFxuLy8gcHJlc3VtZSB0aGF0J3Mgc3RhcnRpbmcgYSBuZXcgZG9jdW1lbnQuXG5jb25zdCBjb250YWluc0RvY3VtZW50TWFya2VyID0gKHN0cikgPT4gL14oJXwtLS18XFwuXFwuXFwuKS9tLnRlc3Qoc3RyKTtcbmZ1bmN0aW9uIGxpbmVMZW5ndGhPdmVyTGltaXQoc3RyLCBsaW5lV2lkdGgsIGluZGVudExlbmd0aCkge1xuICAgIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBsaW1pdCA9IGxpbmVXaWR0aCAtIGluZGVudExlbmd0aDtcbiAgICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICAgIGlmIChzdHJMZW4gPD0gbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgc3RhcnQgPSAwOyBpIDwgc3RyTGVuOyArK2kpIHtcbiAgICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmIChpIC0gc3RhcnQgPiBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoc3RyTGVuIC0gc3RhcnQgPD0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIGlmIChjdHgub3B0aW9ucy5kb3VibGVRdW90ZWRBc0pTT04pXG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXkgfSA9IGN0eDtcbiAgICBjb25zdCBtaW5NdWx0aUxpbmVMZW5ndGggPSBjdHgub3B0aW9ucy5kb3VibGVRdW90ZWRNaW5NdWx0aUxpbmVMZW5ndGg7XG4gICAgY29uc3QgaW5kZW50ID0gY3R4LmluZGVudCB8fCAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBjaCA9IGpzb25baV07IGNoOyBjaCA9IGpzb25bKytpXSkge1xuICAgICAgICBpZiAoY2ggPT09ICcgJyAmJiBqc29uW2kgKyAxXSA9PT0gJ1xcXFwnICYmIGpzb25baSArIDJdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIHNwYWNlIGJlZm9yZSBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcXFwgJztcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGNoID0gJ1xcXFwnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgc3dpdGNoIChqc29uW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0ganNvbi5zdWJzdHIoaSArIDIsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDA3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcYSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMGInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAxYic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDg1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwYTAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxfJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXEwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcyMDI5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcUCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLnN1YnN0cigwLCAyKSA9PT0gJzAwJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHgnICsgY29kZS5zdWJzdHIoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBqc29uLnN1YnN0cihpLCA2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgMl0gPT09ICdcIicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24ubGVuZ3RoIDwgbWluTXVsdGlMaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb2xkaW5nIHdpbGwgZWF0IGZpcnN0IG5ld2xpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGpzb25baSArIDJdID09PSAnXFxcXCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyAzXSA9PT0gJ24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgNF0gIT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlIGFmdGVyIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbltpICsgMl0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0ciA9IHN0YXJ0ID8gc3RyICsganNvbi5zbGljZShzdGFydCkgOiBqc29uO1xuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfUVVPVEVELCBnZXRGb2xkT3B0aW9ucyhjdHgsIGZhbHNlKSk7XG59XG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGlmIChjdHgub3B0aW9ucy5zaW5nbGVRdW90ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGN0eC5pbXBsaWNpdEtleSAmJiB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHx8XG4gICAgICAgIC9bIFxcdF1cXG58XFxuWyBcXHRdLy50ZXN0KHZhbHVlKSAvLyBzaW5nbGUgcXVvdGVkIHN0cmluZyBjYW4ndCBoYXZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBhcm91bmQgbmV3bGluZVxuICAgIClcbiAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgY29uc3QgcmVzID0gXCInXCIgKyB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKSArIFwiJ1wiO1xuICAgIHJldHVybiBjdHguaW1wbGljaXRLZXlcbiAgICAgICAgPyByZXNcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHJlcywgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QgeyBzaW5nbGVRdW90ZSB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgbGV0IHFzO1xuICAgIGlmIChzaW5nbGVRdW90ZSA9PT0gZmFsc2UpXG4gICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBoYXNEb3VibGUgPSB2YWx1ZS5pbmNsdWRlcygnXCInKTtcbiAgICAgICAgY29uc3QgaGFzU2luZ2xlID0gdmFsdWUuaW5jbHVkZXMoXCInXCIpO1xuICAgICAgICBpZiAoaGFzRG91YmxlICYmICFoYXNTaW5nbGUpXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZSBpZiAoaGFzU2luZ2xlICYmICFoYXNEb3VibGUpXG4gICAgICAgICAgICBxcyA9IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcXMgPSBzaW5nbGVRdW90ZSA/IHNpbmdsZVF1b3RlZFN0cmluZyA6IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIHFzKHZhbHVlLCBjdHgpO1xufVxuLy8gVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgYXZvaWRzIGEgcG9seW5vbWlhbCBzZWFyY2gsXG4vLyBidXQgaXNuJ3Qgc3VwcG9ydGVkIHlldCBvbiBTYWZhcmk6IGh0dHBzOi8vY2FuaXVzZS5jb20vanMtcmVnZXhwLWxvb2tiZWhpbmRcbmxldCBibG9ja0VuZE5ld2xpbmVzO1xudHJ5IHtcbiAgICBibG9ja0VuZE5ld2xpbmVzID0gbmV3IFJlZ0V4cCgnKF58KD88IVxcbikpXFxuKyg/IVxcbnwkKScsICdnJyk7XG59XG5jYXRjaCB7XG4gICAgYmxvY2tFbmROZXdsaW5lcyA9IC9cXG4rKD8hXFxufCQpL2c7XG59XG5mdW5jdGlvbiBibG9ja1N0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYmxvY2tRdW90ZSwgY29tbWVudFN0cmluZywgbGluZVdpZHRoIH0gPSBjdHgub3B0aW9ucztcbiAgICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gICAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICAgIGlmICghYmxvY2tRdW90ZSB8fCAvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHxcbiAgICAgICAgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCBsaXRlcmFsID0gYmxvY2tRdW90ZSA9PT0gJ2xpdGVyYWwnXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGJsb2NrUXVvdGUgPT09ICdmb2xkZWQnIHx8IHR5cGUgPT09IFNjYWxhci5CTE9DS19GT0xERURcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogdHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUxcbiAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICA6ICFsaW5lTGVuZ3RoT3ZlckxpbWl0KHZhbHVlLCBsaW5lV2lkdGgsIGluZGVudC5sZW5ndGgpO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiBsaXRlcmFsID8gJ3xcXG4nIDogJz5cXG4nO1xuICAgIC8vIGRldGVybWluZSBjaG9tcGluZyBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgZW5kXG4gICAgbGV0IGNob21wO1xuICAgIGxldCBlbmRTdGFydDtcbiAgICBmb3IgKGVuZFN0YXJ0ID0gdmFsdWUubGVuZ3RoOyBlbmRTdGFydCA+IDA7IC0tZW5kU3RhcnQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtlbmRTdGFydCAtIDFdO1xuICAgICAgICBpZiAoY2ggIT09ICdcXG4nICYmIGNoICE9PSAnXFx0JyAmJiBjaCAhPT0gJyAnKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBlbmQgPSB2YWx1ZS5zdWJzdHJpbmcoZW5kU3RhcnQpO1xuICAgIGNvbnN0IGVuZE5sUG9zID0gZW5kLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChlbmRObFBvcyA9PT0gLTEpIHtcbiAgICAgICAgY2hvbXAgPSAnLSc7IC8vIHN0cmlwXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID09PSBlbmQgfHwgZW5kTmxQb3MgIT09IGVuZC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNob21wID0gJysnOyAvLyBrZWVwXG4gICAgICAgIGlmIChvbkNob21wS2VlcClcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaG9tcCA9ICcnOyAvLyBjbGlwXG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAtZW5kLmxlbmd0aCk7XG4gICAgICAgIGlmIChlbmRbZW5kLmxlbmd0aCAtIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGVuZCA9IGVuZC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKGJsb2NrRW5kTmV3bGluZXMsIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgaW5kZW50IGluZGljYXRvciBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgc3RhcnRcbiAgICBsZXQgc3RhcnRXaXRoU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgc3RhcnRFbmQ7XG4gICAgbGV0IHN0YXJ0TmxQb3MgPSAtMTtcbiAgICBmb3IgKHN0YXJ0RW5kID0gMDsgc3RhcnRFbmQgPCB2YWx1ZS5sZW5ndGg7ICsrc3RhcnRFbmQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtzdGFydEVuZF07XG4gICAgICAgIGlmIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgc3RhcnRXaXRoU3BhY2UgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICBzdGFydE5sUG9zID0gc3RhcnRFbmQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc3RhcnRObFBvcyA8IHN0YXJ0RW5kID8gc3RhcnRObFBvcyArIDEgOiBzdGFydEVuZCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHN0YXJ0Lmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50U2l6ZSA9IGluZGVudCA/ICcyJyA6ICcxJzsgLy8gcm9vdCBpcyBhdCAtMVxuICAgIC8vIExlYWRpbmcgfCBvciA+IGlzIGFkZGVkIGxhdGVyXG4gICAgbGV0IGhlYWRlciA9IChzdGFydFdpdGhTcGFjZSA/IGluZGVudFNpemUgOiAnJykgKyBjaG9tcDtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBoZWFkZXIgKz0gJyAnICsgY29tbWVudFN0cmluZyhjb21tZW50LnJlcGxhY2UoLyA/W1xcclxcbl0rL2csICcgJykpO1xuICAgICAgICBpZiAob25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGlmICghbGl0ZXJhbCkge1xuICAgICAgICBjb25zdCBmb2xkZWRWYWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCAnXFxuJCYnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyg/Ol58XFxuKShbXFx0IF0uKikoPzooW1xcblxcdCBdKilcXG4oPyFbXFxuXFx0IF0pKT8vZywgJyQxJDInKSAvLyBtb3JlLWluZGVudGVkIGxpbmVzIGFyZW4ndCBmb2xkZWRcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIF4gbW9yZS1pbmQuIF4gZW1wdHkgICAgIF4gY2FwdHVyZSBuZXh0IGVtcHR5IGxpbmVzIG9ubHkgYXQgZW5kIG9mIGluZGVudFxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgICAgIGxldCBsaXRlcmFsRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZm9sZE9wdGlvbnMgPSBnZXRGb2xkT3B0aW9ucyhjdHgsIHRydWUpO1xuICAgICAgICBpZiAoYmxvY2tRdW90ZSAhPT0gJ2ZvbGRlZCcgJiYgdHlwZSAhPT0gU2NhbGFyLkJMT0NLX0ZPTERFRCkge1xuICAgICAgICAgICAgZm9sZE9wdGlvbnMub25PdmVyZmxvdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gZm9sZEZsb3dMaW5lcyhgJHtzdGFydH0ke2ZvbGRlZFZhbHVlfSR7ZW5kfWAsIGluZGVudCwgRk9MRF9CTE9DSywgZm9sZE9wdGlvbnMpO1xuICAgICAgICBpZiAoIWxpdGVyYWxGYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybiBgPiR7aGVhZGVyfVxcbiR7aW5kZW50fSR7Ym9keX1gO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgcmV0dXJuIGB8JHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHtzdGFydH0ke3ZhbHVlfSR7ZW5kfWA7XG59XG5mdW5jdGlvbiBwbGFpblN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBpdGVtO1xuICAgIGNvbnN0IHsgYWN0dWFsU3RyaW5nLCBpbXBsaWNpdEtleSwgaW5kZW50LCBpbmRlbnRTdGVwLCBpbkZsb3cgfSA9IGN0eDtcbiAgICBpZiAoKGltcGxpY2l0S2V5ICYmIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkgfHxcbiAgICAgICAgKGluRmxvdyAmJiAvW1tcXF17fSxdLy50ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKC9eW1xcblxcdCAsW1xcXXt9IyYqIXw+J1wiJUBgXXxeWz8tXSR8Xls/LV1bIFxcdF18W1xcbjpdWyBcXHRdfFsgXFx0XVxcbnxbXFxuXFx0IF0jfFtcXG5cXHQgOl0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAvLyBub3QgYWxsb3dlZDpcbiAgICAgICAgLy8gLSAnLScgb3IgJz8nXG4gICAgICAgIC8vIC0gc3RhcnQgd2l0aCBhbiBpbmRpY2F0b3IgY2hhcmFjdGVyIChleGNlcHQgWz86LV0pIG9yIC9bPy1dIC9cbiAgICAgICAgLy8gLSAnXFxuICcsICc6ICcgb3IgJyBcXG4nIGFueXdoZXJlXG4gICAgICAgIC8vIC0gJyMnIG5vdCBwcmVjZWRlZCBieSBhIG5vbi1zcGFjZSBjaGFyXG4gICAgICAgIC8vIC0gZW5kIHdpdGggJyAnIG9yICc6J1xuICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93IHx8ICF2YWx1ZS5pbmNsdWRlcygnXFxuJylcbiAgICAgICAgICAgID8gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpXG4gICAgICAgICAgICA6IGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxuICAgIGlmICghaW1wbGljaXRLZXkgJiZcbiAgICAgICAgIWluRmxvdyAmJlxuICAgICAgICB0eXBlICE9PSBTY2FsYXIuUExBSU4gJiZcbiAgICAgICAgdmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgIC8vIFdoZXJlIGFsbG93ZWQgJiB0eXBlIG5vdCBzZXQgZXhwbGljaXRseSwgcHJlZmVyIGJsb2NrIHN0eWxlIGZvciBtdWx0aWxpbmUgc3RyaW5nc1xuICAgICAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpKSB7XG4gICAgICAgIGlmIChpbmRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbXBsaWNpdEtleSAmJiBpbmRlbnQgPT09IGluZGVudFN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RyID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKTtcbiAgICAvLyBWZXJpZnkgdGhhdCBvdXRwdXQgd2lsbCBiZSBwYXJzZWQgYXMgYSBzdHJpbmcsIGFzIGUuZy4gcGxhaW4gbnVtYmVycyBhbmRcbiAgICAvLyBib29sZWFucyBnZXQgcGFyc2VkIHdpdGggdGhvc2UgdHlwZXMgaW4gdjEuMiAoZS5nLiAnNDInLCAndHJ1ZScgJiAnMC45ZS0zJyksXG4gICAgLy8gYW5kIG90aGVycyBpbiB2MS4xLlxuICAgIGlmIChhY3R1YWxTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgdGVzdCA9ICh0YWcpID0+IHRhZy5kZWZhdWx0ICYmIHRhZy50YWcgIT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInICYmIHRhZy50ZXN0Py50ZXN0KHN0cik7XG4gICAgICAgIGNvbnN0IHsgY29tcGF0LCB0YWdzIH0gPSBjdHguZG9jLnNjaGVtYTtcbiAgICAgICAgaWYgKHRhZ3Muc29tZSh0ZXN0KSB8fCBjb21wYXQ/LnNvbWUodGVzdCkpXG4gICAgICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5LCBpbkZsb3cgfSA9IGN0eDtcbiAgICBjb25zdCBzcyA9IHR5cGVvZiBpdGVtLnZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBpdGVtLCB7IHZhbHVlOiBTdHJpbmcoaXRlbS52YWx1ZSkgfSk7XG4gICAgbGV0IHsgdHlwZSB9ID0gaXRlbTtcbiAgICBpZiAodHlwZSAhPT0gU2NhbGFyLlFVT1RFX0RPVUJMRSkge1xuICAgICAgICAvLyBmb3JjZSBkb3VibGUgcXVvdGVzIG9uIGNvbnRyb2wgY2hhcmFjdGVycyAmIHVucGFpcmVkIHN1cnJvZ2F0ZXNcbiAgICAgICAgaWYgKC9bXFx4MDAtXFx4MDhcXHgwYi1cXHgxZlxceDdmLVxceDlmXFx1e0Q4MDB9LVxcdXtERkZGfV0vdS50ZXN0KHNzLnZhbHVlKSlcbiAgICAgICAgICAgIHR5cGUgPSBTY2FsYXIuUVVPVEVfRE9VQkxFO1xuICAgIH1cbiAgICBjb25zdCBfc3RyaW5naWZ5ID0gKF90eXBlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLkJMT0NLX0ZPTERFRDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLkJMT0NLX0xJVEVSQUw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvd1xuICAgICAgICAgICAgICAgICAgICA/IHF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KSAvLyBibG9ja3MgYXJlIG5vdCB2YWxpZCBpbnNpZGUgZmxvdyBjb250YWluZXJzXG4gICAgICAgICAgICAgICAgICAgIDogYmxvY2tTdHJpbmcoc3MsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5RVU9URV9ET1VCTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlFVT1RFX1NJTkdMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luZ2xlUXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUExBSU46XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYWluU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcyA9IF9zdHJpbmdpZnkodHlwZSk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRLZXlUeXBlLCBkZWZhdWx0U3RyaW5nVHlwZSB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHQgPSAoaW1wbGljaXRLZXkgJiYgZGVmYXVsdEtleVR5cGUpIHx8IGRlZmF1bHRTdHJpbmdUeXBlO1xuICAgICAgICByZXMgPSBfc3RyaW5naWZ5KHQpO1xuICAgICAgICBpZiAocmVzID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWZhdWx0IHN0cmluZyB0eXBlICR7dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH07XG4iLCAiaW1wb3J0IHsgYW5jaG9ySXNWYWxpZCB9IGZyb20gJy4uL2RvYy9hbmNob3JzLmpzJztcbmltcG9ydCB7IGlzUGFpciwgaXNBbGlhcywgaXNOb2RlLCBpc1NjYWxhciwgaXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuL3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJsb2NrUXVvdGU6IHRydWUsXG4gICAgICAgIGNvbW1lbnRTdHJpbmc6IHN0cmluZ2lmeUNvbW1lbnQsXG4gICAgICAgIGRlZmF1bHRLZXlUeXBlOiBudWxsLFxuICAgICAgICBkZWZhdWx0U3RyaW5nVHlwZTogJ1BMQUlOJyxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgZG91YmxlUXVvdGVkQXNKU09OOiBmYWxzZSxcbiAgICAgICAgZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoOiA0MCxcbiAgICAgICAgZmFsc2VTdHI6ICdmYWxzZScsXG4gICAgICAgIGZsb3dDb2xsZWN0aW9uUGFkZGluZzogdHJ1ZSxcbiAgICAgICAgaW5kZW50U2VxOiB0cnVlLFxuICAgICAgICBsaW5lV2lkdGg6IDgwLFxuICAgICAgICBtaW5Db250ZW50V2lkdGg6IDIwLFxuICAgICAgICBudWxsU3RyOiAnbnVsbCcsXG4gICAgICAgIHNpbXBsZUtleXM6IGZhbHNlLFxuICAgICAgICBzaW5nbGVRdW90ZTogbnVsbCxcbiAgICAgICAgdHJ1ZVN0cjogJ3RydWUnLFxuICAgICAgICB2ZXJpZnlBbGlhc09yZGVyOiB0cnVlXG4gICAgfSwgZG9jLnNjaGVtYS50b1N0cmluZ09wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGxldCBpbkZsb3c7XG4gICAgc3dpdGNoIChvcHQuY29sbGVjdGlvblN0eWxlKSB7XG4gICAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgICAgIGluRmxvdyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgaW5GbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW5GbG93ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW5jaG9yczogbmV3IFNldCgpLFxuICAgICAgICBkb2MsXG4gICAgICAgIGZsb3dDb2xsZWN0aW9uUGFkZGluZzogb3B0LmZsb3dDb2xsZWN0aW9uUGFkZGluZyA/ICcgJyA6ICcnLFxuICAgICAgICBpbmRlbnQ6ICcnLFxuICAgICAgICBpbmRlbnRTdGVwOiB0eXBlb2Ygb3B0LmluZGVudCA9PT0gJ251bWJlcicgPyAnICcucmVwZWF0KG9wdC5pbmRlbnQpIDogJyAgJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiBvcHRcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGFnT2JqZWN0KHRhZ3MsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS50YWcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSBpdGVtLnRhZyk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmZpbmQodCA9PiB0LmZvcm1hdCA9PT0gaXRlbS5mb3JtYXQpID8/IG1hdGNoWzBdO1xuICAgIH1cbiAgICBsZXQgdGFnT2JqID0gdW5kZWZpbmVkO1xuICAgIGxldCBvYmo7XG4gICAgaWYgKGlzU2NhbGFyKGl0ZW0pKSB7XG4gICAgICAgIG9iaiA9IGl0ZW0udmFsdWU7XG4gICAgICAgIGxldCBtYXRjaCA9IHRhZ3MuZmlsdGVyKHQgPT4gdC5pZGVudGlmeT8uKG9iaikpO1xuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdE1hdGNoID0gbWF0Y2guZmlsdGVyKHQgPT4gdC50ZXN0KTtcbiAgICAgICAgICAgIGlmICh0ZXN0TWF0Y2gubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0YWdPYmogPVxuICAgICAgICAgICAgbWF0Y2guZmluZCh0ID0+IHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdCkgPz8gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmogPSBpdGVtO1xuICAgICAgICB0YWdPYmogPSB0YWdzLmZpbmQodCA9PiB0Lm5vZGVDbGFzcyAmJiBvYmogaW5zdGFuY2VvZiB0Lm5vZGVDbGFzcyk7XG4gICAgfVxuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmo/LmNvbnN0cnVjdG9yPy5uYW1lID8/IChvYmogPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygb2JqKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgbm90IHJlc29sdmVkIGZvciAke25hbWV9IHZhbHVlYCk7XG4gICAgfVxuICAgIHJldHVybiB0YWdPYmo7XG59XG4vLyBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIHZhbHVlIHN0cmluZ2lmaWVyIHRvIGFsbG93IGZvciBjaXJjdWxhciBhbmNob3IgcmVmc1xuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCB7IGFuY2hvcnMsIGRvYyB9KSB7XG4gICAgaWYgKCFkb2MuZGlyZWN0aXZlcylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgY29uc3QgYW5jaG9yID0gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgbm9kZS5hbmNob3I7XG4gICAgaWYgKGFuY2hvciAmJiBhbmNob3JJc1ZhbGlkKGFuY2hvcikpIHtcbiAgICAgICAgYW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgcHJvcHMucHVzaChgJiR7YW5jaG9yfWApO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBub2RlLnRhZyA/PyAodGFnT2JqLmRlZmF1bHQgPyBudWxsIDogdGFnT2JqLnRhZyk7XG4gICAgaWYgKHRhZylcbiAgICAgICAgcHJvcHMucHVzaChkb2MuZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnKSk7XG4gICAgcmV0dXJuIHByb3BzLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBpZiAoaXNQYWlyKGl0ZW0pKVxuICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmIChpc0FsaWFzKGl0ZW0pKSB7XG4gICAgICAgIGlmIChjdHguZG9jLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZyhjdHgpO1xuICAgICAgICBpZiAoY3R4LnJlc29sdmVkQWxpYXNlcz8uaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IGNpcmN1bGFyIHN0cnVjdHVyZSB3aXRob3V0IGFsaWFzIG5vZGVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3R4LnJlc29sdmVkQWxpYXNlcylcbiAgICAgICAgICAgICAgICBjdHgucmVzb2x2ZWRBbGlhc2VzLmFkZChpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHgucmVzb2x2ZWRBbGlhc2VzID0gbmV3IFNldChbaXRlbV0pO1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucmVzb2x2ZShjdHguZG9jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGFnT2JqID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vZGUgPSBpc05vZGUoaXRlbSlcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogY3R4LmRvYy5jcmVhdGVOb2RlKGl0ZW0sIHsgb25UYWdPYmo6IG8gPT4gKHRhZ09iaiA9IG8pIH0pO1xuICAgIHRhZ09iaiA/PyAodGFnT2JqID0gZ2V0VGFnT2JqZWN0KGN0eC5kb2Muc2NoZW1hLnRhZ3MsIG5vZGUpKTtcbiAgICBjb25zdCBwcm9wcyA9IHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgY3R4KTtcbiAgICBpZiAocHJvcHMubGVuZ3RoID4gMClcbiAgICAgICAgY3R4LmluZGVudEF0U3RhcnQgPSAoY3R4LmluZGVudEF0U3RhcnQgPz8gMCkgKyBwcm9wcy5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiB0YWdPYmouc3RyaW5naWZ5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGFnT2JqLnN0cmluZ2lmeShub2RlLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgIDogaXNTY2FsYXIobm9kZSlcbiAgICAgICAgICAgID8gc3RyaW5naWZ5U3RyaW5nKG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogbm9kZS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIGlzU2NhbGFyKG5vZGUpIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snXG4gICAgICAgID8gYCR7cHJvcHN9ICR7c3RyfWBcbiAgICAgICAgOiBgJHtwcm9wc31cXG4ke2N0eC5pbmRlbnR9JHtzdHJ9YDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgaXNDb2xsZWN0aW9uLCBpc05vZGUsIGlzU2NhbGFyLCBpc1NlcSB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBsaW5lQ29tbWVudCwgaW5kZW50Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVBhaXIoeyBrZXksIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYWxsTnVsbFZhbHVlcywgZG9jLCBpbmRlbnQsIGluZGVudFN0ZXAsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZywgaW5kZW50U2VxLCBzaW1wbGVLZXlzIH0gfSA9IGN0eDtcbiAgICBsZXQga2V5Q29tbWVudCA9IChpc05vZGUoa2V5KSAmJiBrZXkuY29tbWVudCkgfHwgbnVsbDtcbiAgICBpZiAoc2ltcGxlS2V5cykge1xuICAgICAgICBpZiAoa2V5Q29tbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoIHNpbXBsZSBrZXlzLCBrZXkgbm9kZXMgY2Fubm90IGhhdmUgY29tbWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGtleSkgfHwgKCFpc05vZGUoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHNpbXBsZSBrZXlzLCBjb2xsZWN0aW9uIGNhbm5vdCBiZSB1c2VkIGFzIGEga2V5IHZhbHVlJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBleHBsaWNpdEtleSA9ICFzaW1wbGVLZXlzICYmXG4gICAgICAgICgha2V5IHx8XG4gICAgICAgICAgICAoa2V5Q29tbWVudCAmJiB2YWx1ZSA9PSBudWxsICYmICFjdHguaW5GbG93KSB8fFxuICAgICAgICAgICAgaXNDb2xsZWN0aW9uKGtleSkgfHxcbiAgICAgICAgICAgIChpc1NjYWxhcihrZXkpXG4gICAgICAgICAgICAgICAgPyBrZXkudHlwZSA9PT0gU2NhbGFyLkJMT0NLX0ZPTERFRCB8fCBrZXkudHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUxcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSk7XG4gICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7XG4gICAgICAgIGFsbE51bGxWYWx1ZXM6IGZhbHNlLFxuICAgICAgICBpbXBsaWNpdEtleTogIWV4cGxpY2l0S2V5ICYmIChzaW1wbGVLZXlzIHx8ICFhbGxOdWxsVmFsdWVzKSxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgKyBpbmRlbnRTdGVwXG4gICAgfSk7XG4gICAgbGV0IGtleUNvbW1lbnREb25lID0gZmFsc2U7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoa2V5LCBjdHgsICgpID0+IChrZXlDb21tZW50RG9uZSA9IHRydWUpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWN0eC5pbkZsb3cgJiYgc3RyLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgaWYgKHNpbXBsZUtleXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIHNpbmdsZSBsaW5lIHNjYWxhciBtdXN0IG5vdCBzcGFuIG1vcmUgdGhhbiAxMDI0IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3R4LmluRmxvdykge1xuICAgICAgICBpZiAoYWxsTnVsbFZhbHVlcyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5Q29tbWVudERvbmUgJiYgb25Db21tZW50KVxuICAgICAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ciA9PT0gJycgPyAnPycgOiBleHBsaWNpdEtleSA/IGA/ICR7c3RyfWAgOiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKGFsbE51bGxWYWx1ZXMgJiYgIXNpbXBsZUtleXMpIHx8ICh2YWx1ZSA9PSBudWxsICYmIGV4cGxpY2l0S2V5KSkge1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1gO1xuICAgICAgICBpZiAoa2V5Q29tbWVudCAmJiAha2V5Q29tbWVudERvbmUpIHtcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcClcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGlmIChrZXlDb21tZW50RG9uZSlcbiAgICAgICAga2V5Q29tbWVudCA9IG51bGw7XG4gICAgaWYgKGV4cGxpY2l0S2V5KSB7XG4gICAgICAgIGlmIChrZXlDb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgICAgIHN0ciA9IGA/ICR7c3RyfVxcbiR7aW5kZW50fTpgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyID0gYCR7c3RyfTpgO1xuICAgICAgICBpZiAoa2V5Q29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgIH1cbiAgICBsZXQgdnNiLCB2Y2IsIHZhbHVlQ29tbWVudDtcbiAgICBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICB2c2IgPSAhIXZhbHVlLnNwYWNlQmVmb3JlO1xuICAgICAgICB2Y2IgPSB2YWx1ZS5jb21tZW50QmVmb3JlO1xuICAgICAgICB2YWx1ZUNvbW1lbnQgPSB2YWx1ZS5jb21tZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdnNiID0gZmFsc2U7XG4gICAgICAgIHZjYiA9IG51bGw7XG4gICAgICAgIHZhbHVlQ29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdmFsdWUgPSBkb2MuY3JlYXRlTm9kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGN0eC5pbXBsaWNpdEtleSA9IGZhbHNlO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWtleUNvbW1lbnQgJiYgaXNTY2FsYXIodmFsdWUpKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGlmICghaW5kZW50U2VxICYmXG4gICAgICAgIGluZGVudFN0ZXAubGVuZ3RoID49IDIgJiZcbiAgICAgICAgIWN0eC5pbkZsb3cgJiZcbiAgICAgICAgIWV4cGxpY2l0S2V5ICYmXG4gICAgICAgIGlzU2VxKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWUuZmxvdyAmJlxuICAgICAgICAhdmFsdWUudGFnICYmXG4gICAgICAgICF2YWx1ZS5hbmNob3IpIHtcbiAgICAgICAgLy8gSWYgaW5kZW50U2VxID09PSBmYWxzZSwgY29uc2lkZXIgJy0gJyBhcyBwYXJ0IG9mIGluZGVudGF0aW9uIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGN0eC5pbmRlbnQgPSBjdHguaW5kZW50LnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlQ29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZVN0ciA9IHN0cmluZ2lmeSh2YWx1ZSwgY3R4LCAoKSA9PiAodmFsdWVDb21tZW50RG9uZSA9IHRydWUpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgIGxldCB3cyA9ICcgJztcbiAgICBpZiAoa2V5Q29tbWVudCB8fCB2c2IgfHwgdmNiKSB7XG4gICAgICAgIHdzID0gdnNiID8gJ1xcbicgOiAnJztcbiAgICAgICAgaWYgKHZjYikge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKHZjYik7XG4gICAgICAgICAgICB3cyArPSBgXFxuJHtpbmRlbnRDb21tZW50KGNzLCBjdHguaW5kZW50KX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZVN0ciA9PT0gJycgJiYgIWN0eC5pbkZsb3cpIHtcbiAgICAgICAgICAgIGlmICh3cyA9PT0gJ1xcbicgJiYgdmFsdWVDb21tZW50KVxuICAgICAgICAgICAgICAgIHdzID0gJ1xcblxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3cyArPSBgXFxuJHtjdHguaW5kZW50fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4cGxpY2l0S2V5ICYmIGlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdnMwID0gdmFsdWVTdHJbMF07XG4gICAgICAgIGNvbnN0IG5sMCA9IHZhbHVlU3RyLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICBjb25zdCBoYXNOZXdsaW5lID0gbmwwICE9PSAtMTtcbiAgICAgICAgY29uc3QgZmxvdyA9IGN0eC5pbkZsb3cgPz8gdmFsdWUuZmxvdyA/PyB2YWx1ZS5pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmIChoYXNOZXdsaW5lIHx8ICFmbG93KSB7XG4gICAgICAgICAgICBsZXQgaGFzUHJvcHNMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaGFzTmV3bGluZSAmJiAodnMwID09PSAnJicgfHwgdnMwID09PSAnIScpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNwMCA9IHZhbHVlU3RyLmluZGV4T2YoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAodnMwID09PSAnJicgJiZcbiAgICAgICAgICAgICAgICAgICAgc3AwICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzcDAgPCBubDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdHJbc3AwICsgMV0gPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICBzcDAgPSB2YWx1ZVN0ci5pbmRleE9mKCcgJywgc3AwICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcDAgPT09IC0xIHx8IG5sMCA8IHNwMClcbiAgICAgICAgICAgICAgICAgICAgaGFzUHJvcHNMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzUHJvcHNMaW5lKVxuICAgICAgICAgICAgICAgIHdzID0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlU3RyID09PSAnJyB8fCB2YWx1ZVN0clswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgd3MgPSAnJztcbiAgICB9XG4gICAgc3RyICs9IHdzICsgdmFsdWVTdHI7XG4gICAgaWYgKGN0eC5pbkZsb3cpIHtcbiAgICAgICAgaWYgKHZhbHVlQ29tbWVudERvbmUgJiYgb25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlQ29tbWVudCAmJiAhdmFsdWVDb21tZW50RG9uZSkge1xuICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKHZhbHVlQ29tbWVudCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaG9tcEtlZXAgJiYgb25DaG9tcEtlZXApIHtcbiAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5UGFpciB9O1xuIiwgImZ1bmN0aW9uIGRlYnVnKGxvZ0xldmVsLCAuLi5tZXNzYWdlcykge1xuICAgIGlmIChsb2dMZXZlbCA9PT0gJ2RlYnVnJylcbiAgICAgICAgY29uc29sZS5sb2coLi4ubWVzc2FnZXMpO1xufVxuZnVuY3Rpb24gd2Fybihsb2dMZXZlbCwgd2FybmluZykge1xuICAgIGlmIChsb2dMZXZlbCA9PT0gJ2RlYnVnJyB8fCBsb2dMZXZlbCA9PT0gJ3dhcm4nKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGRlYnVnLCB3YXJuIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIsIGlzQWxpYXMsIGlzU2VxLCBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbi8vIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBtZXJnZSBrZXkgaXMgYSBzaW5nbGUgbWFwcGluZyBub2RlLCBlYWNoIG9mXG4vLyBpdHMga2V5L3ZhbHVlIHBhaXJzIGlzIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgbWFwcGluZywgdW5sZXNzIHRoZSBrZXlcbi8vIGFscmVhZHkgZXhpc3RzIGluIGl0LiBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXJnZSBrZXkgaXMgYVxuLy8gc2VxdWVuY2UsIHRoZW4gdGhpcyBzZXF1ZW5jZSBpcyBleHBlY3RlZCB0byBjb250YWluIG1hcHBpbmcgbm9kZXMgYW5kIGVhY2hcbi8vIG9mIHRoZXNlIG5vZGVzIGlzIG1lcmdlZCBpbiB0dXJuIGFjY29yZGluZyB0byBpdHMgb3JkZXIgaW4gdGhlIHNlcXVlbmNlLlxuLy8gS2V5cyBpbiBtYXBwaW5nIG5vZGVzIGVhcmxpZXIgaW4gdGhlIHNlcXVlbmNlIG92ZXJyaWRlIGtleXMgc3BlY2lmaWVkIGluXG4vLyBsYXRlciBtYXBwaW5nIG5vZGVzLiAtLSBodHRwOi8veWFtbC5vcmcvdHlwZS9tZXJnZS5odG1sXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuY29uc3QgbWVyZ2UgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBNRVJHRV9LRVkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgJiYgdmFsdWUuZGVzY3JpcHRpb24gPT09IE1FUkdFX0tFWSksXG4gICAgZGVmYXVsdDogJ2tleScsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLFxuICAgIHRlc3Q6IC9ePDwkLyxcbiAgICByZXNvbHZlOiAoKSA9PiBPYmplY3QuYXNzaWduKG5ldyBTY2FsYXIoU3ltYm9sKE1FUkdFX0tFWSkpLCB7XG4gICAgICAgIGFkZFRvSlNNYXA6IGFkZE1lcmdlVG9KU01hcFxuICAgIH0pLFxuICAgIHN0cmluZ2lmeTogKCkgPT4gTUVSR0VfS0VZXG59O1xuY29uc3QgaXNNZXJnZUtleSA9IChjdHgsIGtleSkgPT4gKG1lcmdlLmlkZW50aWZ5KGtleSkgfHxcbiAgICAoaXNTY2FsYXIoa2V5KSAmJlxuICAgICAgICAoIWtleS50eXBlIHx8IGtleS50eXBlID09PSBTY2FsYXIuUExBSU4pICYmXG4gICAgICAgIG1lcmdlLmlkZW50aWZ5KGtleS52YWx1ZSkpKSAmJlxuICAgIGN0eD8uZG9jLnNjaGVtYS50YWdzLnNvbWUodGFnID0+IHRhZy50YWcgPT09IG1lcmdlLnRhZyAmJiB0YWcuZGVmYXVsdCk7XG5mdW5jdGlvbiBhZGRNZXJnZVRvSlNNYXAoY3R4LCBtYXAsIHZhbHVlKSB7XG4gICAgdmFsdWUgPSBjdHggJiYgaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKGlzU2VxKHZhbHVlKSlcbiAgICAgICAgZm9yIChjb25zdCBpdCBvZiB2YWx1ZS5pdGVtcylcbiAgICAgICAgICAgIG1lcmdlVmFsdWUoY3R4LCBtYXAsIGl0KTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgZm9yIChjb25zdCBpdCBvZiB2YWx1ZSlcbiAgICAgICAgICAgIG1lcmdlVmFsdWUoY3R4LCBtYXAsIGl0KTtcbiAgICBlbHNlXG4gICAgICAgIG1lcmdlVmFsdWUoY3R4LCBtYXAsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWUoY3R4LCBtYXAsIHZhbHVlKSB7XG4gICAgY29uc3Qgc291cmNlID0gY3R4ICYmIGlzQWxpYXModmFsdWUpID8gdmFsdWUucmVzb2x2ZShjdHguZG9jKSA6IHZhbHVlO1xuICAgIGlmICghaXNNYXAoc291cmNlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXJnZSBzb3VyY2VzIG11c3QgYmUgbWFwcyBvciBtYXAgYWxpYXNlcycpO1xuICAgIGNvbnN0IHNyY01hcCA9IHNvdXJjZS50b0pTT04obnVsbCwgY3R4LCBNYXApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNyY01hcCkge1xuICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgbWFwLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZXhwb3J0IHsgYWRkTWVyZ2VUb0pTTWFwLCBpc01lcmdlS2V5LCBtZXJnZSB9O1xuIiwgImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9sb2cuanMnO1xuaW1wb3J0IHsgaXNNZXJnZUtleSwgYWRkTWVyZ2VUb0pTTWFwIH0gZnJvbSAnLi4vc2NoZW1hL3lhbWwtMS4xL21lcmdlLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4vdG9KUy5qcyc7XG5cbmZ1bmN0aW9uIGFkZFBhaXJUb0pTTWFwKGN0eCwgbWFwLCB7IGtleSwgdmFsdWUgfSkge1xuICAgIGlmIChpc05vZGUoa2V5KSAmJiBrZXkuYWRkVG9KU01hcClcbiAgICAgICAga2V5LmFkZFRvSlNNYXAoY3R4LCBtYXAsIHZhbHVlKTtcbiAgICAvLyBUT0RPOiBTaG91bGQgZHJvcCB0aGlzIHNwZWNpYWwgY2FzZSBmb3IgYmFyZSA8PCBoYW5kbGluZ1xuICAgIGVsc2UgaWYgKGlzTWVyZ2VLZXkoY3R4LCBrZXkpKVxuICAgICAgICBhZGRNZXJnZVRvSlNNYXAoY3R4LCBtYXAsIHZhbHVlKTtcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QganNLZXkgPSB0b0pTKGtleSwgJycsIGN0eCk7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIG1hcC5zZXQoanNLZXksIHRvSlModmFsdWUsIGpzS2V5LCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIG1hcC5hZGQoanNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nS2V5ID0gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBqc1ZhbHVlID0gdG9KUyh2YWx1ZSwgc3RyaW5nS2V5LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ0tleSBpbiBtYXApXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgc3RyaW5nS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBqc1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWFwW3N0cmluZ0tleV0gPSBqc1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlLZXkoa2V5LCBqc0tleSwgY3R4KSB7XG4gICAgaWYgKGpzS2V5ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1iYXNlLXRvLXN0cmluZ1xuICAgIGlmICh0eXBlb2YganNLZXkgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gU3RyaW5nKGpzS2V5KTtcbiAgICBpZiAoaXNOb2RlKGtleSkgJiYgY3R4Py5kb2MpIHtcbiAgICAgICAgY29uc3Qgc3RyQ3R4ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChjdHguZG9jLCB7fSk7XG4gICAgICAgIHN0ckN0eC5hbmNob3JzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3R4LmFuY2hvcnMua2V5cygpKVxuICAgICAgICAgICAgc3RyQ3R4LmFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgc3RyQ3R4LmluRmxvdyA9IHRydWU7XG4gICAgICAgIHN0ckN0eC5pblN0cmluZ2lmeUtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IGtleS50b1N0cmluZyhzdHJDdHgpO1xuICAgICAgICBpZiAoIWN0eC5tYXBLZXlXYXJuZWQpIHtcbiAgICAgICAgICAgIGxldCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyS2V5KTtcbiAgICAgICAgICAgIGlmIChqc29uU3RyLmxlbmd0aCA+IDQwKVxuICAgICAgICAgICAgICAgIGpzb25TdHIgPSBqc29uU3RyLnN1YnN0cmluZygwLCAzNikgKyAnLi4uXCInO1xuICAgICAgICAgICAgd2FybihjdHguZG9jLm9wdGlvbnMubG9nTGV2ZWwsIGBLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9uczogJHtqc29uU3RyfS4gU2V0IG1hcEFzTWFwOiB0cnVlIHRvIHVzZSBvYmplY3Qga2V5cy5gKTtcbiAgICAgICAgICAgIGN0eC5tYXBLZXlXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJLZXk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc0tleSk7XG59XG5cbmV4cG9ydCB7IGFkZFBhaXJUb0pTTWFwIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVBhaXIgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyc7XG5pbXBvcnQgeyBhZGRQYWlyVG9KU01hcCB9IGZyb20gJy4vYWRkUGFpclRvSlNNYXAuanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBQQUlSLCBpc05vZGUgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuZnVuY3Rpb24gY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCBrID0gY3JlYXRlTm9kZShrZXksIHVuZGVmaW5lZCwgY3R4KTtcbiAgICBjb25zdCB2ID0gY3JlYXRlTm9kZSh2YWx1ZSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbn1cbmNsYXNzIFBhaXIge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBOT0RFX1RZUEUsIHsgdmFsdWU6IFBBSVIgfSk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBsZXQgeyBrZXksIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNOb2RlKGtleSkpXG4gICAgICAgICAgICBrZXkgPSBrZXkuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlzTm9kZSh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlyID0gY3R4Py5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgICAgICByZXR1cm4gYWRkUGFpclRvSlNNYXAoY3R4LCBwYWlyLCB0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIHJldHVybiBjdHg/LmRvY1xuICAgICAgICAgICAgPyBzdHJpbmdpZnlQYWlyKHRoaXMsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYWlyLCBjcmVhdGVQYWlyIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlLCBpc1BhaXIgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBsaW5lQ29tbWVudCwgaW5kZW50Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmxvdyA9IGN0eC5pbkZsb3cgPz8gY29sbGVjdGlvbi5mbG93O1xuICAgIGNvbnN0IHN0cmluZ2lmeSA9IGZsb3cgPyBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbiA6IHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbjtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbGxlY3Rpb24sIGN0eCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCbG9ja0NvbGxlY3Rpb24oeyBjb21tZW50LCBpdGVtcyB9LCBjdHgsIHsgYmxvY2tJdGVtUHJlZml4LCBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQsIG9uQ2hvbXBLZWVwLCBvbkNvbW1lbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9ID0gY3R4O1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgaW5kZW50OiBpdGVtSW5kZW50LCB0eXBlOiBudWxsIH0pO1xuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTsgLy8gZmxhZyBmb3IgdGhlIHByZWNlZGluZyBub2RlJ3Mgc3RhdHVzXG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpdGVtLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpdGVtLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpay5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpay5jb21tZW50QmVmb3JlLCBjaG9tcEtlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RyID0gc3RyaW5naWZ5KGl0ZW0sIGl0ZW1DdHgsICgpID0+IChjb21tZW50ID0gbnVsbCksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudFN0cmluZyhjb21tZW50KSk7XG4gICAgICAgIGlmIChjaG9tcEtlZXAgJiYgY29tbWVudClcbiAgICAgICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsaW5lcy5wdXNoKGJsb2NrSXRlbVByZWZpeCArIHN0cik7XG4gICAgfVxuICAgIGxldCBzdHI7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBmbG93Q2hhcnMuc3RhcnQgKyBmbG93Q2hhcnMuZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyID0gbGluZXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nICsgaW5kZW50Q29tbWVudChjb21tZW50U3RyaW5nKGNvbW1lbnQpLCBpbmRlbnQpO1xuICAgICAgICBpZiAob25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcClcbiAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Rmxvd0NvbGxlY3Rpb24oeyBpdGVtcyB9LCBjdHgsIHsgZmxvd0NoYXJzLCBpdGVtSW5kZW50IH0pIHtcbiAgICBjb25zdCB7IGluZGVudCwgaW5kZW50U3RlcCwgZmxvd0NvbGxlY3Rpb25QYWRkaW5nOiBmY1BhZGRpbmcsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgaXRlbUluZGVudCArPSBpbmRlbnRTdGVwO1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgaW5kZW50OiBpdGVtSW5kZW50LFxuICAgICAgICBpbkZsb3c6IHRydWUsXG4gICAgICAgIHR5cGU6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgcmVxTmV3bGluZSA9IGZhbHNlO1xuICAgIGxldCBsaW5lc0F0VmFsdWUgPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGxldCBjb21tZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzTm9kZShpdGVtKSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudClcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgaWsgPSBpc05vZGUoaXRlbS5rZXkpID8gaXRlbS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGlrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaWsuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdiA9IGlzTm9kZShpdGVtLnZhbHVlKSA/IGl0ZW0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdi5jb21tZW50O1xuICAgICAgICAgICAgICAgIGlmIChpdi5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udmFsdWUgPT0gbnVsbCAmJiBpaz8uY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpay5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSk7XG4gICAgICAgIGlmIChpIDwgaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHN0ciArPSAnLCc7XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudFN0cmluZyhjb21tZW50KSk7XG4gICAgICAgIGlmICghcmVxTmV3bGluZSAmJiAobGluZXMubGVuZ3RoID4gbGluZXNBdFZhbHVlIHx8IHN0ci5pbmNsdWRlcygnXFxuJykpKVxuICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgIGxpbmVzLnB1c2goc3RyKTtcbiAgICAgICAgbGluZXNBdFZhbHVlID0gbGluZXMubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGZsb3dDaGFycztcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFydCArIGVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghcmVxTmV3bGluZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbGluZXMucmVkdWNlKChzdW0sIGxpbmUpID0+IHN1bSArIGxpbmUubGVuZ3RoICsgMiwgMik7XG4gICAgICAgICAgICByZXFOZXdsaW5lID0gY3R4Lm9wdGlvbnMubGluZVdpZHRoID4gMCAmJiBsZW4gPiBjdHgub3B0aW9ucy5saW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcU5ld2xpbmUpIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBzdGFydDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcylcbiAgICAgICAgICAgICAgICBzdHIgKz0gbGluZSA/IGBcXG4ke2luZGVudFN0ZXB9JHtpbmRlbnR9JHtsaW5lfWAgOiAnXFxuJztcbiAgICAgICAgICAgIHJldHVybiBgJHtzdHJ9XFxuJHtpbmRlbnR9JHtlbmR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtzdGFydH0ke2ZjUGFkZGluZ30ke2xpbmVzLmpvaW4oJyAnKX0ke2ZjUGFkZGluZ30ke2VuZH1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQ29tbWVudEJlZm9yZSh7IGluZGVudCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSwgbGluZXMsIGNvbW1lbnQsIGNob21wS2VlcCkge1xuICAgIGlmIChjb21tZW50ICYmIGNob21wS2VlcClcbiAgICAgICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXlxcbisvLCAnJyk7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgaWMgPSBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGxpbmVzLnB1c2goaWMudHJpbVN0YXJ0KCkpOyAvLyBBdm9pZCBkb3VibGUgaW5kZW50IG9uIGZpcnN0IGxpbmVcbiAgICB9XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgYWRkUGFpclRvSlNNYXAgfSBmcm9tICcuL2FkZFBhaXJUb0pTTWFwLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgTUFQLCBpc1BhaXIsIGlzU2NhbGFyIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBQYWlyLCBjcmVhdGVQYWlyIH0gZnJvbSAnLi9QYWlyLmpzJztcbmltcG9ydCB7IGlzU2NhbGFyVmFsdWUgfSBmcm9tICcuL1NjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIGZpbmRQYWlyKGl0ZW1zLCBrZXkpIHtcbiAgICBjb25zdCBrID0gaXNTY2FsYXIoa2V5KSA/IGtleS52YWx1ZSA6IGtleTtcbiAgICBmb3IgKGNvbnN0IGl0IG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpc1BhaXIoaXQpKSB7XG4gICAgICAgICAgICBpZiAoaXQua2V5ID09PSBrZXkgfHwgaXQua2V5ID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgICAgIGlmIChpc1NjYWxhcihpdC5rZXkpICYmIGl0LmtleS52YWx1ZSA9PT0gaylcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFlBTUxNYXAgZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgICBzdGF0aWMgZ2V0IHRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJztcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKE1BUCwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGdlbmVyaWMgY29sbGVjdGlvbiBwYXJzaW5nIG1ldGhvZCB0aGF0IGNhbiBiZSBleHRlbmRlZFxuICAgICAqIHRvIG90aGVyIG5vZGUgY2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbSBZQU1MTWFwXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc2NoZW1hLCBvYmosIGN0eCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQsIHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyB0aGlzKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGFkZCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbChvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikgJiYgIXJlcGxhY2VyLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwga2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaChjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopXG4gICAgICAgICAgICAgICAgYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSlcbiAgICAgICAgICAgICAgICBhZGQoa2V5LCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuc29ydE1hcEVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5zb3J0KHNjaGVtYS5zb3J0TWFwRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIElmIG5vdCBzZXQgYHRydWVgLCB1c2luZyBhIGtleSB0aGF0IGlzIGFscmVhZHkgaW4gdGhlXG4gICAgICogICBjb2xsZWN0aW9uIHdpbGwgdGhyb3cuIE90aGVyd2lzZSwgb3ZlcndyaXRlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAgICovXG4gICAgYWRkKHBhaXIsIG92ZXJ3cml0ZSkge1xuICAgICAgICBsZXQgX3BhaXI7XG4gICAgICAgIGlmIChpc1BhaXIocGFpcikpXG4gICAgICAgICAgICBfcGFpciA9IHBhaXI7XG4gICAgICAgIGVsc2UgaWYgKCFwYWlyIHx8IHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0JyB8fCAhKCdrZXknIGluIHBhaXIpKSB7XG4gICAgICAgICAgICAvLyBJbiBUeXBlU2NyaXB0LCB0aGlzIG5ldmVyIGhhcHBlbnMuXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyKHBhaXIsIHBhaXI/LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyKHBhaXIua2V5LCBwYWlyLnZhbHVlKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIF9wYWlyLmtleSk7XG4gICAgICAgIGNvbnN0IHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWE/LnNvcnRNYXBFbnRyaWVzO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKCFvdmVyd3JpdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHtfcGFpci5rZXl9IGFscmVhZHkgc2V0YCk7XG4gICAgICAgICAgICAvLyBGb3Igc2NhbGFycywga2VlcCB0aGUgb2xkIG5vZGUgJiBpdHMgY29tbWVudHMgYW5kIGFuY2hvcnNcbiAgICAgICAgICAgIGlmIChpc1NjYWxhcihwcmV2LnZhbHVlKSAmJiBpc1NjYWxhclZhbHVlKF9wYWlyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlLnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IF9wYWlyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvcnRFbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBzb3J0RW50cmllcyhfcGFpciwgaXRlbSkgPCAwKTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goX3BhaXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIF9wYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGlmICghaXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihpdCksIDEpO1xuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gaXQ/LnZhbHVlO1xuICAgICAgICByZXR1cm4gKCFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGUpID8/IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZChuZXcgUGFpcihrZXksIHZhbHVlKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjdHggLSBDb252ZXJzaW9uIGNvbnRleHQsIG9yaWdpbmFsbHkgc2V0IGluIERvY3VtZW50I3RvSlMoKVxuICAgICAqIEBwYXJhbSB7Q2xhc3N9IFR5cGUgLSBJZiBzZXQsIGZvcmNlcyB0aGUgcmV0dXJuZWQgY29sbGVjdGlvbiB0eXBlXG4gICAgICogQHJldHVybnMgSW5zdGFuY2Ugb2YgVHlwZSwgTWFwLCBvciBPYmplY3RcbiAgICAgKi9cbiAgICB0b0pTT04oXywgY3R4LCBUeXBlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IFR5cGUgPyBuZXcgVHlwZSgpIDogY3R4Py5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgICAgICBpZiAoY3R4Py5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShtYXApO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcylcbiAgICAgICAgICAgIGFkZFBhaXJUb0pTTWFwKGN0eCwgbWFwLCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKCFpc1BhaXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXAgaXRlbXMgbXVzdCBhbGwgYmUgcGFpcnM7IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoaXRlbSl9IGluc3RlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN0eC5hbGxOdWxsVmFsdWVzICYmIHRoaXMuaGFzQWxsTnVsbFZhbHVlcyhmYWxzZSkpXG4gICAgICAgICAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgYWxsTnVsbFZhbHVlczogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUNvbGxlY3Rpb24odGhpcywgY3R4LCB7XG4gICAgICAgICAgICBibG9ja0l0ZW1QcmVmaXg6ICcnLFxuICAgICAgICAgICAgZmxvd0NoYXJzOiB7IHN0YXJ0OiAneycsIGVuZDogJ30nIH0sXG4gICAgICAgICAgICBpdGVtSW5kZW50OiBjdHguaW5kZW50IHx8ICcnLFxuICAgICAgICAgICAgb25DaG9tcEtlZXAsXG4gICAgICAgICAgICBvbkNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBZQU1MTWFwLCBmaW5kUGFpciB9O1xuIiwgImltcG9ydCB7IGlzTWFwIH0gZnJvbSAnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuXG5jb25zdCBtYXAgPSB7XG4gICAgY29sbGVjdGlvbjogJ21hcCcsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBub2RlQ2xhc3M6IFlBTUxNYXAsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJyxcbiAgICByZXNvbHZlKG1hcCwgb25FcnJvcikge1xuICAgICAgICBpZiAoIWlzTWFwKG1hcCkpXG4gICAgICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIG1hcHBpbmcgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBvYmosIGN0eCkgPT4gWUFNTE1hcC5mcm9tKHNjaGVtYSwgb2JqLCBjdHgpXG59O1xuXG5leHBvcnQgeyBtYXAgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi4vZG9jL2NyZWF0ZU5vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5Q29sbGVjdGlvbiB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgU0VRLCBpc1NjYWxhciB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXJWYWx1ZSB9IGZyb20gJy4vU2NhbGFyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jbGFzcyBZQU1MU2VxIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOnNlcSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihTRVEsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogYGtleWAgbXVzdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciBmb3IgdGhpcyB0byBzdWNjZWVkLlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXQgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIHJldHVybiAha2VlcFNjYWxhciAmJiBpc1NjYWxhcihpdCkgPyBpdC52YWx1ZSA6IGl0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICpcbiAgICAgKiBga2V5YCBtdXN0IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyIGZvciB0aGlzIHRvIHN1Y2NlZWQuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBpZHggPCB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICpcbiAgICAgKiBJZiBga2V5YCBkb2VzIG5vdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHZhbGlkIGluZGV4LCBub3QgJHtrZXl9LmApO1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgICBpZiAoaXNTY2FsYXIocHJldikgJiYgaXNTY2FsYXJWYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICBwcmV2LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgICAgICBpZiAoY3R4Py5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShzZXEpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgc2VxLnB1c2godG9KUyhpdGVtLCBTdHJpbmcoaSsrKSwgY3R4KSk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUNvbGxlY3Rpb24odGhpcywgY3R4LCB7XG4gICAgICAgICAgICBibG9ja0l0ZW1QcmVmaXg6ICctICcsXG4gICAgICAgICAgICBmbG93Q2hhcnM6IHsgc3RhcnQ6ICdbJywgZW5kOiAnXScgfSxcbiAgICAgICAgICAgIGl0ZW1JbmRlbnQ6IChjdHguaW5kZW50IHx8ICcnKSArICcgICcsXG4gICAgICAgICAgICBvbkNob21wS2VlcCxcbiAgICAgICAgICAgIG9uQ29tbWVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2NoZW1hLCBvYmosIGN0eCkge1xuICAgICAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNlcSA9IG5ldyB0aGlzKHNjaGVtYSk7XG4gICAgICAgIGlmIChvYmogJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChvYmopKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpdCBvZiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IG9iaiBpbnN0YW5jZW9mIFNldCA/IGl0IDogU3RyaW5nKGkrKyk7XG4gICAgICAgICAgICAgICAgICAgIGl0ID0gcmVwbGFjZXIuY2FsbChvYmosIGtleSwgaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaChjcmVhdGVOb2RlKGl0LCB1bmRlZmluZWQsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNJdGVtSW5kZXgoa2V5KSB7XG4gICAgbGV0IGlkeCA9IGlzU2NhbGFyKGtleSkgPyBrZXkudmFsdWUgOiBrZXk7XG4gICAgaWYgKGlkeCAmJiB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJylcbiAgICAgICAgaWR4ID0gTnVtYmVyKGlkeCk7XG4gICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoaWR4KSAmJiBpZHggPj0gMFxuICAgICAgICA/IGlkeFxuICAgICAgICA6IG51bGw7XG59XG5cbmV4cG9ydCB7IFlBTUxTZXEgfTtcbiIsICJpbXBvcnQgeyBpc1NlcSB9IGZyb20gJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcblxuY29uc3Qgc2VxID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgbm9kZUNsYXNzOiBZQU1MU2VxLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsXG4gICAgcmVzb2x2ZShzZXEsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc1NlcShzZXEpKVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBzZXF1ZW5jZSBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGU6IChzY2hlbWEsIG9iaiwgY3R4KSA9PiBZQU1MU2VxLmZyb20oc2NoZW1hLCBvYmosIGN0eClcbn07XG5cbmV4cG9ydCB7IHNlcSB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5jb25zdCBzdHJpbmcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgIHJlc29sdmU6IHN0ciA9PiBzdHIsXG4gICAgc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBjdHggPSBPYmplY3QuYXNzaWduKHsgYWN0dWFsU3RyaW5nOiB0cnVlIH0sIGN0eCk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBudWxsVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgICB0ZXN0OiAvXig/On58W05uXXVsbHxOVUxMKT8kLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyKG51bGwpLFxuICAgIHN0cmluZ2lmeTogKHsgc291cmNlIH0sIGN0eCkgPT4gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgbnVsbFRhZy50ZXN0LnRlc3Qoc291cmNlKVxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IGN0eC5vcHRpb25zLm51bGxTdHJcbn07XG5cbmV4cG9ydCB7IG51bGxUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBib29sVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86W1R0XXJ1ZXxUUlVFfFtGZl1hbHNlfEZBTFNFKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBuZXcgU2NhbGFyKHN0clswXSA9PT0gJ3QnIHx8IHN0clswXSA9PT0gJ1QnKSxcbiAgICBzdHJpbmdpZnkoeyBzb3VyY2UsIHZhbHVlIH0sIGN0eCkge1xuICAgICAgICBpZiAoc291cmNlICYmIGJvb2xUYWcudGVzdC50ZXN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ID0gc291cmNlWzBdID09PSAndCcgfHwgc291cmNlWzBdID09PSAnVCc7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHN2KVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gY3R4Lm9wdGlvbnMudHJ1ZVN0ciA6IGN0eC5vcHRpb25zLmZhbHNlU3RyO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGJvb2xUYWcgfTtcbiIsICJmdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIoeyBmb3JtYXQsIG1pbkZyYWN0aW9uRGlnaXRzLCB0YWcsIHZhbHVlIH0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gJy5uYW4nIDogbnVtIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gICAgbGV0IG4gPSBPYmplY3QuaXModmFsdWUsIC0wKSA/ICctMCcgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmb3JtYXQgJiZcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgJiZcbiAgICAgICAgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJlxuICAgICAgICAvXlxcZC8udGVzdChuKSkge1xuICAgICAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIG4gKz0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIHdoaWxlIChkLS0gPiAwKVxuICAgICAgICAgICAgbiArPSAnMCc7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eKD86Wy0rXT9cXC4oPzppbmZ8SW5mfElORil8XFwubmFufFxcLk5hTnxcXC5OQU4pJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgZmxvYXRFeHAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnRVhQJyxcbiAgICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldKyg/OlxcLlswLTldKik/KVtlRV1bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgc3RyaW5naWZ5KG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUobnVtKSA/IG51bS50b0V4cG9uZW50aWFsKCkgOiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3QgIT09IC0xICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBzdHIubGVuZ3RoIC0gZG90IC0gMTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcblxuZXhwb3J0IHsgZmxvYXQsIGZsb2F0RXhwLCBmbG9hdE5hTiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBpbnRJZGVudGlmeSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmNvbnN0IGludFJlc29sdmUgPSAoc3RyLCBvZmZzZXQsIHJhZGl4LCB7IGludEFzQmlnSW50IH0pID0+IChpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhvZmZzZXQpLCByYWRpeCkpO1xuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMClcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXjBvWzAtN10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDgsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCA4LCAnMG8nKVxufTtcbmNvbnN0IGludCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMCwgMTAsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eMHhbMC05YS1mQS1GXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydCB7IGludCwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRPY3QsIGludCwgaW50SGV4IH0gZnJvbSAnLi9pbnQuanMnO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLFxuICAgIHNlcSxcbiAgICBzdHJpbmcsXG4gICAgbnVsbFRhZyxcbiAgICBib29sVGFnLFxuICAgIGludE9jdCxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0XG5dO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcblxuZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmNvbnN0IHN0cmluZ2lmeUpTT04gPSAoeyB2YWx1ZSB9KSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5jb25zdCBqc29uU2NhbGFycyA9IFtcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgICAgICB0ZXN0OiAvXm51bGwkLyxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgICAgIHRlc3Q6IC9edHJ1ZSR8XmZhbHNlJC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBzdHIgPT09ICd0cnVlJyxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICAgICAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopJC8sXG4gICAgICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCB7IGludEFzQmlnSW50IH0pID0+IGludEFzQmlnSW50ID8gQmlnSW50KHN0cikgOiBwYXJzZUludChzdHIsIDEwKSxcbiAgICAgICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSg/OlxcLlswLTldKik/KD86W2VFXVstK10/WzAtOV0rKT8kLyxcbiAgICAgICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfVxuXTtcbmNvbnN0IGpzb25FcnJvciA9IHtcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJycsXG4gICAgdGVzdDogL14vLFxuICAgIHJlc29sdmUoc3RyLCBvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoYFVucmVzb2x2ZWQgcGxhaW4gc2NhbGFyICR7SlNPTi5zdHJpbmdpZnkoc3RyKX1gKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuY29uc3Qgc2NoZW1hID0gW21hcCwgc2VxXS5jb25jYXQoanNvblNjYWxhcnMsIGpzb25FcnJvcik7XG5cbmV4cG9ydCB7IHNjaGVtYSB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzJztcblxuY29uc3QgYmluYXJ5ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIC8vIEJ1ZmZlciBpbmhlcml0cyBmcm9tIFVpbnQ4QXJyYXlcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCdWZmZXIgaW4gbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiBicm93c2Vyc1xuICAgICAqXG4gICAgICogVG8gdXNlIHRoZSByZXN1bHRpbmcgYnVmZmVyIGFzIGFuIGltYWdlLCB5b3UnbGwgd2FudCB0byBkbyBzb21ldGhpbmcgbGlrZTpcbiAgICAgKlxuICAgICAqICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Bob3RvJykuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAqL1xuICAgIHJlc29sdmUoc3JjLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmluZ2lmeSh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCBidWYgPSB2YWx1ZTsgLy8gY2hlY2tlZCBlYXJsaWVyIGJ5IGJpbmFyeS5pZGVudGlmeSgpXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgICAgICAgICAgc3RyID0gYnRvYShzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHdyaXRpbmcgYmluYXJ5IHRhZ3M7IGVpdGhlciBCdWZmZXIgb3IgYnRvYSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPz8gKHR5cGUgPSBTY2FsYXIuQkxPQ0tfTElURVJBTCk7XG4gICAgICAgIGlmICh0eXBlICE9PSBTY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heChjdHgub3B0aW9ucy5saW5lV2lkdGggLSBjdHguaW5kZW50Lmxlbmd0aCwgY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoc3RyLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHN0ci5zdWJzdHIobywgbGluZVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGxpbmVzLmpvaW4odHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwgPyAnXFxuJyA6ICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlOiBzdHIgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBiaW5hcnkgfTtcbiIsICJpbXBvcnQgeyBpc1NlcSwgaXNQYWlyLCBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IGNyZWF0ZVBhaXIsIFBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWlycyhzZXEsIG9uRXJyb3IpIHtcbiAgICBpZiAoaXNTZXEoc2VxKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBzZXEuaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoaXNQYWlyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXAoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKCdFYWNoIHBhaXIgbXVzdCBoYXZlIGl0cyBvd24gc2VxdWVuY2UgaW5kaWNhdG9yJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFpciA9IGl0ZW0uaXRlbXNbMF0gfHwgbmV3IFBhaXIobmV3IFNjYWxhcihudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudEJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgcGFpci5rZXkuY29tbWVudEJlZm9yZSA9IHBhaXIua2V5LmNvbW1lbnRCZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7aXRlbS5jb21tZW50QmVmb3JlfVxcbiR7cGFpci5rZXkuY29tbWVudEJlZm9yZX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0uY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNuID0gcGFpci52YWx1ZSA/PyBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY24uY29tbWVudCA9IGNuLmNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7aXRlbS5jb21tZW50fVxcbiR7Y24uY29tbWVudH1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0uY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbSA9IHBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXEuaXRlbXNbaV0gPSBpc1BhaXIoaXRlbSkgPyBpdGVtIDogbmV3IFBhaXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIHNlcXVlbmNlIGZvciB0aGlzIHRhZycpO1xuICAgIHJldHVybiBzZXE7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgY29uc3QgcGFpcnMgPSBuZXcgWUFNTFNlcShzY2hlbWEpO1xuICAgIHBhaXJzLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGlmIChpdGVyYWJsZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXJhYmxlKSlcbiAgICAgICAgZm9yIChsZXQgaXQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgaXQgPSByZXBsYWNlci5jYWxsKGl0ZXJhYmxlLCBTdHJpbmcoaSsrKSwgaXQpO1xuICAgICAgICAgICAgbGV0IGtleSwgdmFsdWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGl0WzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0WzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFtrZXksIHZhbHVlXSB0dXBsZTogJHtpdH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ICYmIGl0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdHVwbGUgd2l0aCBvbmUga2V5LCBub3QgJHtrZXlzLmxlbmd0aH0ga2V5c2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IGl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFpcnMuaXRlbXMucHVzaChjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xufVxuY29uc3QgcGFpcnMgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLFxuICAgIHJlc29sdmU6IHJlc29sdmVQYWlycyxcbiAgICBjcmVhdGVOb2RlOiBjcmVhdGVQYWlyc1xufTtcblxuZXhwb3J0IHsgY3JlYXRlUGFpcnMsIHBhaXJzLCByZXNvbHZlUGFpcnMgfTtcbiIsICJpbXBvcnQgeyBpc1NjYWxhciwgaXNQYWlyIH0gZnJvbSAnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4uLy4uL25vZGVzL3RvSlMuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVBhaXJzLCBjcmVhdGVQYWlycyB9IGZyb20gJy4vcGFpcnMuanMnO1xuXG5jbGFzcyBZQU1MT01hcCBleHRlbmRzIFlBTUxTZXEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFkZCA9IFlBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IFlBTUxNYXAucHJvdG90eXBlLmRlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IFlBTUxNYXAucHJvdG90eXBlLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhcyA9IFlBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldCA9IFlBTUxNYXAucHJvdG90eXBlLnNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxPTWFwLnRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYGN0eGAgaXMgZ2l2ZW4sIHRoZSByZXR1cm4gdHlwZSBpcyBhY3R1YWxseSBgTWFwPHVua25vd24sIHVua25vd24+YCxcbiAgICAgKiBidXQgVHlwZVNjcmlwdCB3b24ndCBhbGxvdyB3aWRlbmluZyB0aGUgc2lnbmF0dXJlIG9mIGEgY2hpbGQgbWV0aG9kLlxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8pO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChjdHg/Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIocGFpcikpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0b0pTKHBhaXIua2V5LCAnJywgY3R4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUyhwYWlyLCAnJywgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXAuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cycpO1xuICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpO1xuICAgICAgICBjb25zdCBvbWFwID0gbmV3IHRoaXMoKTtcbiAgICAgICAgb21hcC5pdGVtcyA9IHBhaXJzLml0ZW1zO1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICB9XG59XG5ZQU1MT01hcC50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6b21hcCc7XG5jb25zdCBvbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCxcbiAgICBub2RlQ2xhc3M6IFlBTUxPTWFwLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gcmVzb2x2ZVBhaXJzKHNlcSwgb25FcnJvcik7XG4gICAgICAgIGNvbnN0IHNlZW5LZXlzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXkgfSBvZiBwYWlycy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbktleXMuaW5jbHVkZXMoa2V5LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGBPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5czogJHtrZXkudmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWVuS2V5cy5wdXNoKGtleS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MT01hcCgpLCBwYWlycyk7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSA9PiBZQU1MT01hcC5mcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eClcbn07XG5cbmV4cG9ydCB7IFlBTUxPTWFwLCBvbWFwIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gYm9vbFN0cmluZ2lmeSh7IHZhbHVlLCBzb3VyY2UgfSwgY3R4KSB7XG4gICAgY29uc3QgYm9vbE9iaiA9IHZhbHVlID8gdHJ1ZVRhZyA6IGZhbHNlVGFnO1xuICAgIGlmIChzb3VyY2UgJiYgYm9vbE9iai50ZXN0LnRlc3Qoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG59XG5jb25zdCB0cnVlVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86WXx5fFtZeV1lc3xZRVN8W1R0XXJ1ZXxUUlVFfFtPb11ufE9OKSQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIodHJ1ZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuY29uc3QgZmFsc2VUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gbmV3IFNjYWxhcihmYWxzZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuXG5leHBvcnQgeyBmYWxzZVRhZywgdHJ1ZVRhZyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5TnVtYmVyLmpzJztcblxuY29uc3QgZmxvYXROYU4gPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgdGVzdDogL14oPzpbLStdP1xcLig/OmluZnxJbmZ8SU5GKXxcXC5uYW58XFwuTmFOfFxcLk5BTikkLyxcbiAgICByZXNvbHZlOiAoc3RyKSA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/KD86XFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIH1cbn07XG5jb25zdCBmbG9hdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT9cXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpKTtcbiAgICAgICAgY29uc3QgZG90ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBzdHIuc3Vic3RyaW5nKGRvdCArIDEpLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICAgICAgaWYgKGZbZi5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnQgeyBmbG9hdCwgZmxvYXRFeHAsIGZsb2F0TmFOIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGludElkZW50aWZ5ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuZnVuY3Rpb24gaW50UmVzb2x2ZShzdHIsIG9mZnNldCwgcmFkaXgsIHsgaW50QXNCaWdJbnQgfSkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgaWYgKHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycpXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcob2Zmc2V0KS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICBpZiAoaW50QXNCaWdJbnQpIHtcbiAgICAgICAgc3dpdGNoIChyYWRpeCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN0ciA9IGAwYiR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBvJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgc3RyID0gYDB4JHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gQmlnSW50KHN0cik7XG4gICAgICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogbiA6IG47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBwYXJzZUludChzdHIsIHJhZGl4KTtcbiAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLTEgKiBuIDogbjtcbn1cbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRCaW4gPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdCSU4nLFxuICAgIHRlc3Q6IC9eWy0rXT8wYlswLTFfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpXG59O1xuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMSwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgaW50SGV4ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnSEVYJyxcbiAgICB0ZXN0OiAvXlstK10/MHhbMC05YS1mQS1GX10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDE2LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59O1xuXG5leHBvcnQgeyBpbnQsIGludEJpbiwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBpc01hcCwgaXNQYWlyLCBpc1NjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAsIGZpbmRQYWlyIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5cbmNsYXNzIFlBTUxTZXQgZXh0ZW5kcyBZQU1MTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoc2NoZW1hKTtcbiAgICAgICAgdGhpcy50YWcgPSBZQU1MU2V0LnRhZztcbiAgICB9XG4gICAgYWRkKGtleSkge1xuICAgICAgICBsZXQgcGFpcjtcbiAgICAgICAgaWYgKGlzUGFpcihrZXkpKVxuICAgICAgICAgICAgcGFpciA9IGtleTtcbiAgICAgICAgZWxzZSBpZiAoa2V5ICYmXG4gICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2tleScgaW4ga2V5ICYmXG4gICAgICAgICAgICAndmFsdWUnIGluIGtleSAmJlxuICAgICAgICAgICAga2V5LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyKGtleS5rZXksIG51bGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIoa2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBga2VlcFBhaXJgIGlzIGB0cnVlYCwgcmV0dXJucyB0aGUgUGFpciBtYXRjaGluZyBga2V5YC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoYXQgUGFpcidzIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5LCBrZWVwUGFpcikge1xuICAgICAgICBjb25zdCBwYWlyID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgcmV0dXJuICFrZWVwUGFpciAmJiBpc1BhaXIocGFpcilcbiAgICAgICAgICAgID8gaXNTY2FsYXIocGFpci5rZXkpXG4gICAgICAgICAgICAgICAgPyBwYWlyLmtleS52YWx1ZVxuICAgICAgICAgICAgICAgIDogcGFpci5rZXlcbiAgICAgICAgICAgIDogcGFpcjtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIHZhbHVlIGZvciBzZXQoa2V5LCB2YWx1ZSkgaW4gYSBZQU1MIHNldCwgbm90ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8sIGN0eCwgU2V0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKHRydWUpKVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pLCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzZXQgPSBuZXcgdGhpcyhzY2hlbWEpO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyYWJsZSkpXG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbChpdGVyYWJsZSwgdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZXQuaXRlbXMucHVzaChjcmVhdGVQYWlyKHZhbHVlLCBudWxsLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG59XG5ZQU1MU2V0LnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnO1xuY29uc3Qgc2V0ID0ge1xuICAgIGNvbGxlY3Rpb246ICdtYXAnLFxuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFNldCxcbiAgICBub2RlQ2xhc3M6IFlBTUxTZXQsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2V0JyxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSA9PiBZQU1MU2V0LmZyb20oc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSxcbiAgICByZXNvbHZlKG1hcCwgb25FcnJvcikge1xuICAgICAgICBpZiAoaXNNYXAobWFwKSkge1xuICAgICAgICAgICAgaWYgKG1hcC5oYXNBbGxOdWxsVmFsdWVzKHRydWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MU2V0KCksIG1hcCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb25FcnJvcignU2V0IGl0ZW1zIG11c3QgYWxsIGhhdmUgbnVsbCB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIG1hcHBpbmcgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgWUFNTFNldCwgc2V0IH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbi8qKiBJbnRlcm5hbCB0eXBlcyBoYW5kbGUgYmlnaW50IGFzIG51bWJlciwgYmVjYXVzZSBUUyBjYW4ndCBmaWd1cmUgaXQgb3V0LiAqL1xuZnVuY3Rpb24gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGFzQmlnSW50KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBjb25zdCBwYXJ0cyA9IHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycgPyBzdHIuc3Vic3RyaW5nKDEpIDogc3RyO1xuICAgIGNvbnN0IG51bSA9IChuKSA9PiBhc0JpZ0ludCA/IEJpZ0ludChuKSA6IE51bWJlcihuKTtcbiAgICBjb25zdCByZXMgPSBwYXJ0c1xuICAgICAgICAucmVwbGFjZSgvXy9nLCAnJylcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLnJlZHVjZSgocmVzLCBwKSA9PiByZXMgKiBudW0oNjApICsgbnVtKHApLCBudW0oMCkpO1xuICAgIHJldHVybiAoc2lnbiA9PT0gJy0nID8gbnVtKC0xKSAqIHJlcyA6IHJlcyk7XG59XG4vKipcbiAqIGhoaGg6bW06c3Muc3NzXG4gKlxuICogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U2V4YWdlc2ltYWwobm9kZSkge1xuICAgIGxldCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGxldCBudW0gPSAobikgPT4gbjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgbnVtID0gbiA9PiBCaWdJbnQobik7XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgbGV0IHNpZ24gPSAnJztcbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIHZhbHVlICo9IG51bSgtMSk7XG4gICAgfVxuICAgIGNvbnN0IF82MCA9IG51bSg2MCk7XG4gICAgY29uc3QgcGFydHMgPSBbdmFsdWUgJSBfNjBdOyAvLyBzZWNvbmRzLCBpbmNsdWRpbmcgbXNcbiAgICBpZiAodmFsdWUgPCA2MCkge1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KDApOyAvLyBhdCBsZWFzdCBvbmUgOiBpcyByZXF1aXJlZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUgJSBfNjApOyAvLyBtaW51dGVzXG4gICAgICAgIGlmICh2YWx1ZSA+PSA2MCkge1xuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlKTsgLy8gaG91cnNcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHNpZ24gK1xuICAgICAgICBwYXJ0c1xuICAgICAgICAgICAgLm1hcChuID0+IFN0cmluZyhuKS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgICAgICAgLmpvaW4oJzonKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzAwMDAwMFxcZCokLywgJycpIC8vICUgNjAgbWF5IGludHJvZHVjZSBlcnJvclxuICAgICk7XG59XG5jb25zdCBpbnRUaW1lID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgaW50QXNCaWdJbnQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCBmbG9hdFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnVElNRScsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCB0aW1lc3RhbXAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsXG4gICAgLy8gSWYgdGhlIHRpbWUgem9uZSBpcyBvbWl0dGVkLCB0aGUgdGltZXN0YW1wIGlzIGFzc3VtZWQgdG8gYmUgc3BlY2lmaWVkIGluIFVUQy4gVGhlIHRpbWUgcGFydFxuICAgIC8vIG1heSBiZSBvbWl0dGVkIGFsdG9nZXRoZXIsIHJlc3VsdGluZyBpbiBhIGRhdGUgZm9ybWF0LiBJbiBzdWNoIGEgY2FzZSwgdGhlIHRpbWUgcGFydCBpc1xuICAgIC8vIGFzc3VtZWQgdG8gYmUgMDA6MDA6MDBaIChzdGFydCBvZiBkYXksIFVUQykuXG4gICAgdGVzdDogUmVnRXhwKCdeKFswLTldezR9KS0oWzAtOV17MSwyfSktKFswLTldezEsMn0pJyArIC8vIFlZWVktTW0tRGRcbiAgICAgICAgJyg/OicgKyAvLyB0aW1lIGlzIG9wdGlvbmFsXG4gICAgICAgICcoPzp0fFR8WyBcXFxcdF0rKScgKyAvLyB0IHwgVCB8IHdoaXRlc3BhY2VcbiAgICAgICAgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0oXFxcXC5bMC05XSspPyknICsgLy8gSGg6TW06U3MoLnNzKT9cbiAgICAgICAgJyg/OlsgXFxcXHRdKihafFstK11bMDEyXT9bMC05XSg/OjpbMC05XXsyfSk/KSk/JyArIC8vIFogfCArNSB8IC0wMzozMFxuICAgICAgICAnKT8kJyksXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2godGltZXN0YW1wLnRlc3QpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchIXRpbWVzdGFtcCBleHBlY3RzIGEgZGF0ZSwgc3RhcnRpbmcgd2l0aCB5eXl5LW1tLWRkJyk7XG4gICAgICAgIGNvbnN0IFssIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IG1hdGNoLm1hcChOdW1iZXIpO1xuICAgICAgICBjb25zdCBtaWxsaXNlYyA9IG1hdGNoWzddID8gTnVtYmVyKChtYXRjaFs3XSArICcwMCcpLnN1YnN0cigxLCAzKSkgOiAwO1xuICAgICAgICBsZXQgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCwgbWlsbGlzZWMpO1xuICAgICAgICBjb25zdCB0eiA9IG1hdGNoWzhdO1xuICAgICAgICBpZiAodHogJiYgdHogIT09ICdaJykge1xuICAgICAgICAgICAgbGV0IGQgPSBwYXJzZVNleGFnZXNpbWFsKHR6LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZCkgPCAzMClcbiAgICAgICAgICAgICAgICBkICo9IDYwO1xuICAgICAgICAgICAgZGF0ZSAtPSA2MDAwMCAqIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZT8udG9JU09TdHJpbmcoKS5yZXBsYWNlKC8oVDAwOjAwOjAwKT9cXC4wMDBaJC8sICcnKSA/PyAnJ1xufTtcblxuZXhwb3J0IHsgZmxvYXRUaW1lLCBpbnRUaW1lLCB0aW1lc3RhbXAgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYmluYXJ5IH0gZnJvbSAnLi9iaW5hcnkuanMnO1xuaW1wb3J0IHsgdHJ1ZVRhZywgZmFsc2VUYWcgfSBmcm9tICcuL2Jvb2wuanMnO1xuaW1wb3J0IHsgZmxvYXROYU4sIGZsb2F0RXhwLCBmbG9hdCB9IGZyb20gJy4vZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50QmluLCBpbnRPY3QsIGludCwgaW50SGV4IH0gZnJvbSAnLi9pbnQuanMnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICcuL21lcmdlLmpzJztcbmltcG9ydCB7IG9tYXAgfSBmcm9tICcuL29tYXAuanMnO1xuaW1wb3J0IHsgcGFpcnMgfSBmcm9tICcuL3BhaXJzLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4vc2V0LmpzJztcbmltcG9ydCB7IGludFRpbWUsIGZsb2F0VGltZSwgdGltZXN0YW1wIH0gZnJvbSAnLi90aW1lc3RhbXAuanMnO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLFxuICAgIHNlcSxcbiAgICBzdHJpbmcsXG4gICAgbnVsbFRhZyxcbiAgICB0cnVlVGFnLFxuICAgIGZhbHNlVGFnLFxuICAgIGludEJpbixcbiAgICBpbnRPY3QsXG4gICAgaW50LFxuICAgIGludEhleCxcbiAgICBmbG9hdE5hTixcbiAgICBmbG9hdEV4cCxcbiAgICBmbG9hdCxcbiAgICBiaW5hcnksXG4gICAgbWVyZ2UsXG4gICAgb21hcCxcbiAgICBwYWlycyxcbiAgICBzZXQsXG4gICAgaW50VGltZSxcbiAgICBmbG9hdFRpbWUsXG4gICAgdGltZXN0YW1wXG5dO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgbnVsbFRhZyB9IGZyb20gJy4vY29tbW9uL251bGwuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBib29sVGFnIH0gZnJvbSAnLi9jb3JlL2Jvb2wuanMnO1xuaW1wb3J0IHsgZmxvYXROYU4sIGZsb2F0RXhwLCBmbG9hdCB9IGZyb20gJy4vY29yZS9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRPY3QsIGludEhleCwgaW50IH0gZnJvbSAnLi9jb3JlL2ludC5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgfSBmcm9tICcuL2NvcmUvc2NoZW1hLmpzJztcbmltcG9ydCB7IHNjaGVtYSBhcyBzY2hlbWEkMSB9IGZyb20gJy4vanNvbi9zY2hlbWEuanMnO1xuaW1wb3J0IHsgYmluYXJ5IH0gZnJvbSAnLi95YW1sLTEuMS9iaW5hcnkuanMnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICcuL3lhbWwtMS4xL21lcmdlLmpzJztcbmltcG9ydCB7IG9tYXAgfSBmcm9tICcuL3lhbWwtMS4xL29tYXAuanMnO1xuaW1wb3J0IHsgcGFpcnMgfSBmcm9tICcuL3lhbWwtMS4xL3BhaXJzLmpzJztcbmltcG9ydCB7IHNjaGVtYSBhcyBzY2hlbWEkMiB9IGZyb20gJy4veWFtbC0xLjEvc2NoZW1hLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4veWFtbC0xLjEvc2V0LmpzJztcbmltcG9ydCB7IHRpbWVzdGFtcCwgaW50VGltZSwgZmxvYXRUaW1lIH0gZnJvbSAnLi95YW1sLTEuMS90aW1lc3RhbXAuanMnO1xuXG5jb25zdCBzY2hlbWFzID0gbmV3IE1hcChbXG4gICAgWydjb3JlJywgc2NoZW1hXSxcbiAgICBbJ2ZhaWxzYWZlJywgW21hcCwgc2VxLCBzdHJpbmddXSxcbiAgICBbJ2pzb24nLCBzY2hlbWEkMV0sXG4gICAgWyd5YW1sMTEnLCBzY2hlbWEkMl0sXG4gICAgWyd5YW1sLTEuMScsIHNjaGVtYSQyXVxuXSk7XG5jb25zdCB0YWdzQnlOYW1lID0ge1xuICAgIGJpbmFyeSxcbiAgICBib29sOiBib29sVGFnLFxuICAgIGZsb2F0LFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0VGltZSxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGludE9jdCxcbiAgICBpbnRUaW1lLFxuICAgIG1hcCxcbiAgICBtZXJnZSxcbiAgICBudWxsOiBudWxsVGFnLFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2VxLFxuICAgIHNldCxcbiAgICB0aW1lc3RhbXBcbn07XG5jb25zdCBjb3JlS25vd25UYWdzID0ge1xuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknOiBiaW5hcnksXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJzogbWVyZ2UsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnOiBvbWFwLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc6IHBhaXJzLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnOiBzZXQsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCc6IHRpbWVzdGFtcFxufTtcbmZ1bmN0aW9uIGdldFRhZ3MoY3VzdG9tVGFncywgc2NoZW1hTmFtZSwgYWRkTWVyZ2VUYWcpIHtcbiAgICBjb25zdCBzY2hlbWFUYWdzID0gc2NoZW1hcy5nZXQoc2NoZW1hTmFtZSk7XG4gICAgaWYgKHNjaGVtYVRhZ3MgJiYgIWN1c3RvbVRhZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFkZE1lcmdlVGFnICYmICFzY2hlbWFUYWdzLmluY2x1ZGVzKG1lcmdlKVxuICAgICAgICAgICAgPyBzY2hlbWFUYWdzLmNvbmNhdChtZXJnZSlcbiAgICAgICAgICAgIDogc2NoZW1hVGFncy5zbGljZSgpO1xuICAgIH1cbiAgICBsZXQgdGFncyA9IHNjaGVtYVRhZ3M7XG4gICAgaWYgKCF0YWdzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHNjaGVtYXMua2V5cygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ3lhbWwxMScpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2hlbWEgXCIke3NjaGVtYU5hbWV9XCI7IHVzZSBvbmUgb2YgJHtrZXlzfSBvciBkZWZpbmUgY3VzdG9tVGFncyBhcnJheWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIGN1c3RvbVRhZ3MpXG4gICAgICAgICAgICB0YWdzID0gdGFncy5jb25jYXQodGFnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGN1c3RvbVRhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGFncyA9IGN1c3RvbVRhZ3ModGFncy5zbGljZSgpKTtcbiAgICB9XG4gICAgaWYgKGFkZE1lcmdlVGFnKVxuICAgICAgICB0YWdzID0gdGFncy5jb25jYXQobWVyZ2UpO1xuICAgIHJldHVybiB0YWdzLnJlZHVjZSgodGFncywgdGFnKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnID8gdGFnc0J5TmFtZVt0YWddIDogdGFnO1xuICAgICAgICBpZiAoIXRhZ09iaikge1xuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IEpTT04uc3RyaW5naWZ5KHRhZyk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGFnc0J5TmFtZSlcbiAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBKU09OLnN0cmluZ2lmeShrZXkpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGN1c3RvbSB0YWcgJHt0YWdOYW1lfTsgdXNlIG9uZSBvZiAke2tleXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YWdzLmluY2x1ZGVzKHRhZ09iaikpXG4gICAgICAgICAgICB0YWdzLnB1c2godGFnT2JqKTtcbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfSwgW10pO1xufVxuXG5leHBvcnQgeyBjb3JlS25vd25UYWdzLCBnZXRUYWdzIH07XG4iLCAiaW1wb3J0IHsgTUFQLCBTQ0FMQVIsIFNFUSB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGdldFRhZ3MsIGNvcmVLbm93blRhZ3MgfSBmcm9tICcuL3RhZ3MuanMnO1xuXG5jb25zdCBzb3J0TWFwRW50cmllc0J5S2V5ID0gKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IGEua2V5ID4gYi5rZXkgPyAxIDogMDtcbmNsYXNzIFNjaGVtYSB7XG4gICAgY29uc3RydWN0b3IoeyBjb21wYXQsIGN1c3RvbVRhZ3MsIG1lcmdlLCByZXNvbHZlS25vd25UYWdzLCBzY2hlbWEsIHNvcnRNYXBFbnRyaWVzLCB0b1N0cmluZ0RlZmF1bHRzIH0pIHtcbiAgICAgICAgdGhpcy5jb21wYXQgPSBBcnJheS5pc0FycmF5KGNvbXBhdClcbiAgICAgICAgICAgID8gZ2V0VGFncyhjb21wYXQsICdjb21wYXQnKVxuICAgICAgICAgICAgOiBjb21wYXRcbiAgICAgICAgICAgICAgICA/IGdldFRhZ3MobnVsbCwgY29tcGF0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lID0gKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnICYmIHNjaGVtYSkgfHwgJ2NvcmUnO1xuICAgICAgICB0aGlzLmtub3duVGFncyA9IHJlc29sdmVLbm93blRhZ3MgPyBjb3JlS25vd25UYWdzIDoge307XG4gICAgICAgIHRoaXMudGFncyA9IGdldFRhZ3MoY3VzdG9tVGFncywgdGhpcy5uYW1lLCBtZXJnZSk7XG4gICAgICAgIHRoaXMudG9TdHJpbmdPcHRpb25zID0gdG9TdHJpbmdEZWZhdWx0cyA/PyBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTUFQLCB7IHZhbHVlOiBtYXAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTQ0FMQVIsIHsgdmFsdWU6IHN0cmluZyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNFUSwgeyB2YWx1ZTogc2VxIH0pO1xuICAgICAgICAvLyBVc2VkIGJ5IGNyZWF0ZU1hcCgpXG4gICAgICAgIHRoaXMuc29ydE1hcEVudHJpZXMgPVxuICAgICAgICAgICAgdHlwZW9mIHNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBzb3J0TWFwRW50cmllc1xuICAgICAgICAgICAgICAgIDogc29ydE1hcEVudHJpZXMgPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgPyBzb3J0TWFwRW50cmllc0J5S2V5XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgY29weS50YWdzID0gdGhpcy50YWdzLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCwgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgaW5kZW50Q29tbWVudCwgbGluZUNvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlEb2N1bWVudChkb2MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGxldCBoYXNEaXJlY3RpdmVzID0gb3B0aW9ucy5kaXJlY3RpdmVzID09PSB0cnVlO1xuICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMgIT09IGZhbHNlICYmIGRvYy5kaXJlY3RpdmVzKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IGRvYy5kaXJlY3RpdmVzLnRvU3RyaW5nKGRvYyk7XG4gICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goZGlyKTtcbiAgICAgICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0KVxuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChoYXNEaXJlY3RpdmVzKVxuICAgICAgICBsaW5lcy5wdXNoKCctLS0nKTtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBjb21tZW50U3RyaW5nIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAoZG9jLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGxpbmVzLnVuc2hpZnQoJycpO1xuICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICBsaW5lcy51bnNoaWZ0KGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgfVxuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICBsZXQgY29udGVudENvbW1lbnQgPSBudWxsO1xuICAgIGlmIChkb2MuY29udGVudHMpIHtcbiAgICAgICAgaWYgKGlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLnNwYWNlQmVmb3JlICYmIGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBibG9jayBzY2FsYXJzIG5lZWQgdG8gYmUgaW5kZW50ZWQgaWYgZm9sbG93ZWQgYnkgYSBjb21tZW50XG4gICAgICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9ICEhZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICBjb250ZW50Q29tbWVudCA9IGRvYy5jb250ZW50cy5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uQ2hvbXBLZWVwID0gY29udGVudENvbW1lbnQgPyB1bmRlZmluZWQgOiAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSk7XG4gICAgICAgIGxldCBib2R5ID0gc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4LCAoKSA9PiAoY29udGVudENvbW1lbnQgPSBudWxsKSwgb25DaG9tcEtlZXApO1xuICAgICAgICBpZiAoY29udGVudENvbW1lbnQpXG4gICAgICAgICAgICBib2R5ICs9IGxpbmVDb21tZW50KGJvZHksICcnLCBjb21tZW50U3RyaW5nKGNvbnRlbnRDb21tZW50KSk7XG4gICAgICAgIGlmICgoYm9keVswXSA9PT0gJ3wnIHx8IGJvZHlbMF0gPT09ICc+JykgJiZcbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID09PSAnLS0tJykge1xuICAgICAgICAgICAgLy8gVG9wLWxldmVsIGJsb2NrIHNjYWxhcnMgd2l0aCBhIHByZWNlZGluZyBkb2MgbWFya2VyIG91Z2h0IHRvIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgbGluZSBmb3IgdGhlaXIgaGVhZGVyLlxuICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPSBgLS0tICR7Ym9keX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaW5lcy5wdXNoKHN0cmluZ2lmeShkb2MuY29udGVudHMsIGN0eCkpO1xuICAgIH1cbiAgICBpZiAoZG9jLmRpcmVjdGl2ZXM/LmRvY0VuZCkge1xuICAgICAgICBpZiAoZG9jLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyhkb2MuY29tbWVudCk7XG4gICAgICAgICAgICBpZiAoY3MuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChpbmRlbnRDb21tZW50KGNzLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChgLi4uICR7Y3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKCcuLi4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGRjID0gZG9jLmNvbW1lbnQ7XG4gICAgICAgIGlmIChkYyAmJiBjaG9tcEtlZXApXG4gICAgICAgICAgICBkYyA9IGRjLnJlcGxhY2UoL15cXG4rLywgJycpO1xuICAgICAgICBpZiAoZGMpIHtcbiAgICAgICAgICAgIGlmICgoIWNob21wS2VlcCB8fCBjb250ZW50Q29tbWVudCkgJiYgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gIT09ICcnKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgbGluZXMucHVzaChpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoZGMpLCAnJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlEb2N1bWVudCB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgaXNFbXB0eVBhdGgsIGNvbGxlY3Rpb25Gcm9tUGF0aCB9IGZyb20gJy4uL25vZGVzL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBET0MsIGlzTm9kZSwgaXNDb2xsZWN0aW9uLCBpc1NjYWxhciB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuLi9ub2Rlcy90b0pTLmpzJztcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gJy4uL3NjaGVtYS9TY2hlbWEuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5RG9jdW1lbnQgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5RG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgYW5jaG9yTmFtZXMsIGZpbmROZXdBbmNob3IsIGNyZWF0ZU5vZGVBbmNob3JzIH0gZnJvbSAnLi9hbmNob3JzLmpzJztcbmltcG9ydCB7IGFwcGx5UmV2aXZlciB9IGZyb20gJy4vYXBwbHlSZXZpdmVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuL2NyZWF0ZU5vZGUuanMnO1xuaW1wb3J0IHsgRGlyZWN0aXZlcyB9IGZyb20gJy4vZGlyZWN0aXZlcy5qcyc7XG5cbmNsYXNzIERvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcmVwbGFjZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqIEEgY29tbWVudCBiZWZvcmUgdGhpcyBEb2N1bWVudCAqL1xuICAgICAgICB0aGlzLmNvbW1lbnRCZWZvcmUgPSBudWxsO1xuICAgICAgICAvKiogQSBjb21tZW50IGltbWVkaWF0ZWx5IGFmdGVyIHRoaXMgRG9jdW1lbnQgKi9cbiAgICAgICAgdGhpcy5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgLyoqIEVycm9ycyBlbmNvdW50ZXJlZCBkdXJpbmcgcGFyc2luZy4gKi9cbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgLyoqIFdhcm5pbmdzIGVuY291bnRlcmVkIGR1cmluZyBwYXJzaW5nLiAqL1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBOT0RFX1RZUEUsIHsgdmFsdWU6IERPQyB9KTtcbiAgICAgICAgbGV0IF9yZXBsYWNlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBpbnRBc0JpZ0ludDogZmFsc2UsXG4gICAgICAgICAgICBrZWVwU291cmNlVG9rZW5zOiBmYWxzZSxcbiAgICAgICAgICAgIGxvZ0xldmVsOiAnd2FybicsXG4gICAgICAgICAgICBwcmV0dHlFcnJvcnM6IHRydWUsXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICBzdHJpbmdLZXlzOiBmYWxzZSxcbiAgICAgICAgICAgIHVuaXF1ZUtleXM6IHRydWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAnMS4yJ1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0O1xuICAgICAgICBsZXQgeyB2ZXJzaW9uIH0gPSBvcHQ7XG4gICAgICAgIGlmIChvcHRpb25zPy5fZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gb3B0aW9ucy5fZGlyZWN0aXZlcy5hdERvY3VtZW50KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzLnlhbWwuZXhwbGljaXQpXG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uIH0pO1xuICAgICAgICB0aGlzLnNldFNjaGVtYSh2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBjYW4ndCByZWFsbHkga25vdyB0aGF0IHRoaXMgbWF0Y2hlcyBDb250ZW50cy5cbiAgICAgICAgdGhpcy5jb250ZW50cyA9XG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgX3JlcGxhY2VyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoaXMgRG9jdW1lbnQgYW5kIGl0cyBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEN1c3RvbSBOb2RlIHZhbHVlcyB0aGF0IGluaGVyaXQgZnJvbSBgT2JqZWN0YCBzdGlsbCByZWZlciB0byB0aGVpciBvcmlnaW5hbCBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKERvY3VtZW50LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgW05PREVfVFlQRV06IHsgdmFsdWU6IERPQyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb3B5LmNvbW1lbnRCZWZvcmUgPSB0aGlzLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgIGNvcHkuY29tbWVudCA9IHRoaXMuY29tbWVudDtcbiAgICAgICAgY29weS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgICAgICBjb3B5Lndhcm5pbmdzID0gdGhpcy53YXJuaW5ncy5zbGljZSgpO1xuICAgICAgICBjb3B5Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgY29weS5kaXJlY3RpdmVzID0gdGhpcy5kaXJlY3RpdmVzLmNsb25lKCk7XG4gICAgICAgIGNvcHkuc2NoZW1hID0gdGhpcy5zY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBjYW4ndCByZWFsbHkga25vdyB0aGF0IHRoaXMgbWF0Y2hlcyBDb250ZW50cy5cbiAgICAgICAgY29weS5jb250ZW50cyA9IGlzTm9kZSh0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmNsb25lKGNvcHkuc2NoZW1hKVxuICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICBpZiAodGhpcy5yYW5nZSlcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB0aGlzLnJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGRvY3VtZW50LiAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGRJbihwYXRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgQWxpYXNgIG5vZGUsIGVuc3VyaW5nIHRoYXQgdGhlIHRhcmdldCBgbm9kZWAgaGFzIHRoZSByZXF1aXJlZCBhbmNob3IuXG4gICAgICpcbiAgICAgKiBJZiBgbm9kZWAgYWxyZWFkeSBoYXMgYW4gYW5jaG9yLCBgbmFtZWAgaXMgaWdub3JlZC5cbiAgICAgKiBPdGhlcndpc2UsIHRoZSBgbm9kZS5hbmNob3JgIHZhbHVlIHdpbGwgYmUgc2V0IHRvIGBuYW1lYCxcbiAgICAgKiBvciBpZiBhbiBhbmNob3Igd2l0aCB0aGF0IG5hbWUgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBkb2N1bWVudCxcbiAgICAgKiBgbmFtZWAgd2lsbCBiZSB1c2VkIGFzIGEgcHJlZml4IGZvciBhIG5ldyB1bmlxdWUgYW5jaG9yLlxuICAgICAqIElmIGBuYW1lYCBpcyB1bmRlZmluZWQsIHRoZSBnZW5lcmF0ZWQgYW5jaG9yIHdpbGwgdXNlICdhJyBhcyBhIHByZWZpeC5cbiAgICAgKi9cbiAgICBjcmVhdGVBbGlhcyhub2RlLCBuYW1lKSB7XG4gICAgICAgIGlmICghbm9kZS5hbmNob3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBhbmNob3JOYW1lcyh0aGlzKTtcbiAgICAgICAgICAgIG5vZGUuYW5jaG9yID1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgICAgICAgICAhbmFtZSB8fCBwcmV2LmhhcyhuYW1lKSA/IGZpbmROZXdBbmNob3IobmFtZSB8fCAnYScsIHByZXYpIDogbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFsaWFzKG5vZGUuYW5jaG9yKTtcbiAgICB9XG4gICAgY3JlYXRlTm9kZSh2YWx1ZSwgcmVwbGFjZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IF9yZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5VG9TdHIgPSAodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdiBpbnN0YW5jZW9mIE51bWJlcjtcbiAgICAgICAgICAgIGNvbnN0IGFzU3RyID0gcmVwbGFjZXIuZmlsdGVyKGtleVRvU3RyKS5tYXAoU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChhc1N0ci5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VyID0gcmVwbGFjZXIuY29uY2F0KGFzU3RyKTtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhbGlhc0R1cGxpY2F0ZU9iamVjdHMsIGFuY2hvclByZWZpeCwgZmxvdywga2VlcFVuZGVmaW5lZCwgb25UYWdPYmosIHRhZyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgY29uc3QgeyBvbkFuY2hvciwgc2V0QW5jaG9ycywgc291cmNlT2JqZWN0cyB9ID0gY3JlYXRlTm9kZUFuY2hvcnModGhpcywgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICBhbmNob3JQcmVmaXggfHwgJ2EnKTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgYWxpYXNEdXBsaWNhdGVPYmplY3RzOiBhbGlhc0R1cGxpY2F0ZU9iamVjdHMgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGtlZXBVbmRlZmluZWQ6IGtlZXBVbmRlZmluZWQgPz8gZmFsc2UsXG4gICAgICAgICAgICBvbkFuY2hvcixcbiAgICAgICAgICAgIG9uVGFnT2JqLFxuICAgICAgICAgICAgcmVwbGFjZXI6IF9yZXBsYWNlcixcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBzb3VyY2VPYmplY3RzXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjcmVhdGVOb2RlKHZhbHVlLCB0YWcsIGN0eCk7XG4gICAgICAgIGlmIChmbG93ICYmIGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIG5vZGUuZmxvdyA9IHRydWU7XG4gICAgICAgIHNldEFuY2hvcnMoKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBrZXkgYW5kIGEgdmFsdWUgaW50byBhIGBQYWlyYCB1c2luZyB0aGUgY3VycmVudCBzY2hlbWEsXG4gICAgICogcmVjdXJzaXZlbHkgd3JhcHBpbmcgYWxsIHZhbHVlcyBhcyBgU2NhbGFyYCBvciBgQ29sbGVjdGlvbmAgbm9kZXMuXG4gICAgICovXG4gICAgY3JlYXRlUGFpcihrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMuY3JlYXRlTm9kZShrZXksIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyKGssIHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBpdGVtIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpID8gdGhpcy5jb250ZW50cy5kZWxldGUoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBpdGVtIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBkZWxldGVJbihwYXRoKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFByZXN1bWVkIGltcG9zc2libGUgaWYgU3RyaWN0IGV4dGVuZHMgZmFsc2VcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5kZWxldGVJbihwYXRoKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBrZXlgLCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuIEJ5IGRlZmF1bHQgdW53cmFwc1xuICAgICAqIHNjYWxhciB2YWx1ZXMgZnJvbSB0aGVpciBzdXJyb3VuZGluZyBub2RlOyB0byBkaXNhYmxlIHNldCBga2VlcFNjYWxhcmAgdG9cbiAgICAgKiBgdHJ1ZWAgKGNvbGxlY3Rpb25zIGFyZSBhbHdheXMgcmV0dXJuZWQgaW50YWN0KS5cbiAgICAgKi9cbiAgICBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5nZXQoa2V5LCBrZWVwU2NhbGFyKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBgcGF0aGAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldEluKHBhdGgsIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLnZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZ2V0SW4ocGF0aCwga2VlcFNjYWxhcilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBkb2N1bWVudCBpbmNsdWRlcyBhIHZhbHVlIGF0IGBwYXRoYC5cbiAgICAgKi9cbiAgICBoYXNJbihwYXRoKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cykgPyB0aGlzLmNvbnRlbnRzLmhhc0luKHBhdGgpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGRvY3VtZW50LiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IHJlYWxseSBrbm93IHRoYXQgdGhpcyBtYXRjaGVzIENvbnRlbnRzLlxuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgW2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBkb2N1bWVudC4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IHJlYWxseSBrbm93IHRoYXQgdGhpcyBtYXRjaGVzIENvbnRlbnRzLlxuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBjYW4ndCByZWFsbHkga25vdyB0aGF0IHRoaXMgbWF0Y2hlcyBDb250ZW50cy5cbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIEFycmF5LmZyb20ocGF0aCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLnNldEluKHBhdGgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIFlBTUwgdmVyc2lvbiBhbmQgc2NoZW1hIHVzZWQgYnkgdGhlIGRvY3VtZW50LlxuICAgICAqIEEgYG51bGxgIHZlcnNpb24gZGlzYWJsZXMgc3VwcG9ydCBmb3IgZGlyZWN0aXZlcywgZXhwbGljaXQgdGFncywgYW5jaG9ycywgYW5kIGFsaWFzZXMuXG4gICAgICogSXQgYWxzbyByZXF1aXJlcyB0aGUgYHNjaGVtYWAgb3B0aW9uIHRvIGJlIGdpdmVuIGFzIGEgYFNjaGVtYWAgaW5zdGFuY2UgdmFsdWUuXG4gICAgICpcbiAgICAgKiBPdmVycmlkZXMgYWxsIHByZXZpb3VzbHkgc2V0IHNjaGVtYSBvcHRpb25zLlxuICAgICAqL1xuICAgIHNldFNjaGVtYSh2ZXJzaW9uLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG4gICAgICAgIGxldCBvcHQ7XG4gICAgICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICAgICAgY2FzZSAnMS4xJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMueWFtbC52ZXJzaW9uID0gJzEuMSc7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb246ICcxLjEnIH0pO1xuICAgICAgICAgICAgICAgIG9wdCA9IHsgcmVzb2x2ZUtub3duVGFnczogZmFsc2UsIHNjaGVtYTogJ3lhbWwtMS4xJyB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMS4yJzpcbiAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIG9wdCA9IHsgcmVzb2x2ZUtub3duVGFnczogdHJ1ZSwgc2NoZW1hOiAnY29yZScgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgICAgIG9wdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBKU09OLnN0cmluZ2lmeSh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICcxLjEnLCAnMS4yJyBvciBudWxsIGFzIGZpcnN0IGFyZ3VtZW50LCBidXQgZm91bmQ6ICR7c3Z9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGBpbnN0YW5jZW9mIFNjaGVtYWAgdG8gYWxsb3cgZm9yIGR1Y2sgdHlwaW5nXG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gICAgICAgIGVsc2UgaWYgKG9wdClcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gbmV3IFNjaGVtYShPYmplY3QuYXNzaWduKG9wdCwgb3B0aW9ucykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdpdGggYSBudWxsIFlBTUwgdmVyc2lvbiwgdGhlIHsgc2NoZW1hOiBTY2hlbWEgfSBvcHRpb24gaXMgcmVxdWlyZWRgKTtcbiAgICB9XG4gICAgLy8ganNvbiAmIGpzb25BcmcgYXJlIG9ubHkgdXNlZCBmcm9tIHRvSlNPTigpXG4gICAgdG9KUyh7IGpzb24sIGpzb25BcmcsIG1hcEFzTWFwLCBtYXhBbGlhc0NvdW50LCBvbkFuY2hvciwgcmV2aXZlciB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgYW5jaG9yczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgZG9jOiB0aGlzLFxuICAgICAgICAgICAga2VlcDogIWpzb24sXG4gICAgICAgICAgICBtYXBBc01hcDogbWFwQXNNYXAgPT09IHRydWUsXG4gICAgICAgICAgICBtYXBLZXlXYXJuZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWF4QWxpYXNDb3VudDogdHlwZW9mIG1heEFsaWFzQ291bnQgPT09ICdudW1iZXInID8gbWF4QWxpYXNDb3VudCA6IDEwMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSB0b0pTKHRoaXMuY29udGVudHMsIGpzb25BcmcgPz8gJycsIGN0eCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BbmNob3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgY291bnQsIHJlcyB9IG9mIGN0eC5hbmNob3JzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgIG9uQW5jaG9yKHJlcywgY291bnQpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHsgJyc6IHJlcyB9LCAnJywgcmVzKVxuICAgICAgICAgICAgOiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQgYGNvbnRlbnRzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqc29uQXJnIFVzZWQgYnkgYEpTT04uc3RyaW5naWZ5YCB0byBpbmRpY2F0ZSB0aGUgYXJyYXkgaW5kZXggb3JcbiAgICAgKiAgIHByb3BlcnR5IG5hbWUuXG4gICAgICovXG4gICAgdG9KU09OKGpzb25BcmcsIG9uQW5jaG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSlMoeyBqc29uOiB0cnVlLCBqc29uQXJnLCBtYXBBc01hcDogZmFsc2UsIG9uQW5jaG9yIH0pO1xuICAgIH1cbiAgICAvKiogQSBZQU1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkb2N1bWVudC4gKi9cbiAgICB0b1N0cmluZyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHdpdGggZXJyb3JzIGNhbm5vdCBiZSBzdHJpbmdpZmllZCcpO1xuICAgICAgICBpZiAoJ2luZGVudCcgaW4gb3B0aW9ucyAmJlxuICAgICAgICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMuaW5kZW50KSB8fCBOdW1iZXIob3B0aW9ucy5pbmRlbnQpIDw9IDApKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5pbmRlbnQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcImluZGVudFwiIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgbm90ICR7c31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5RG9jdW1lbnQodGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Q29sbGVjdGlvbihjb250ZW50cykge1xuICAgIGlmIChpc0NvbGxlY3Rpb24oY29udGVudHMpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgWUFNTCBjb2xsZWN0aW9uIGFzIGRvY3VtZW50IGNvbnRlbnRzJyk7XG59XG5cbmV4cG9ydCB7IERvY3VtZW50IH07XG4iLCAiY2xhc3MgWUFNTEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG59XG5jbGFzcyBZQU1MUGFyc2VFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCdZQU1MUGFyc2VFcnJvcicsIHBvcywgY29kZSwgbWVzc2FnZSk7XG4gICAgfVxufVxuY2xhc3MgWUFNTFdhcm5pbmcgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFdhcm5pbmcnLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNvbnN0IHByZXR0aWZ5RXJyb3IgPSAoc3JjLCBsYykgPT4gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yLnBvc1swXSA9PT0gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICBlcnJvci5saW5lUG9zID0gZXJyb3IucG9zLm1hcChwb3MgPT4gbGMubGluZVBvcyhwb3MpKTtcbiAgICBjb25zdCB7IGxpbmUsIGNvbCB9ID0gZXJyb3IubGluZVBvc1swXTtcbiAgICBlcnJvci5tZXNzYWdlICs9IGAgYXQgbGluZSAke2xpbmV9LCBjb2x1bW4gJHtjb2x9YDtcbiAgICBsZXQgY2kgPSBjb2wgLSAxO1xuICAgIGxldCBsaW5lU3RyID0gc3JjXG4gICAgICAgIC5zdWJzdHJpbmcobGMubGluZVN0YXJ0c1tsaW5lIC0gMV0sIGxjLmxpbmVTdGFydHNbbGluZV0pXG4gICAgICAgIC5yZXBsYWNlKC9bXFxuXFxyXSskLywgJycpO1xuICAgIC8vIFRyaW0gdG8gbWF4IDgwIGNoYXJzLCBrZWVwaW5nIGNvbCBwb3NpdGlvbiBuZWFyIHRoZSBtaWRkbGVcbiAgICBpZiAoY2kgPj0gNjAgJiYgbGluZVN0ci5sZW5ndGggPiA4MCkge1xuICAgICAgICBjb25zdCB0cmltU3RhcnQgPSBNYXRoLm1pbihjaSAtIDM5LCBsaW5lU3RyLmxlbmd0aCAtIDc5KTtcbiAgICAgICAgbGluZVN0ciA9ICdcdTIwMjYnICsgbGluZVN0ci5zdWJzdHJpbmcodHJpbVN0YXJ0KTtcbiAgICAgICAgY2kgLT0gdHJpbVN0YXJ0IC0gMTtcbiAgICB9XG4gICAgaWYgKGxpbmVTdHIubGVuZ3RoID4gODApXG4gICAgICAgIGxpbmVTdHIgPSBsaW5lU3RyLnN1YnN0cmluZygwLCA3OSkgKyAnXHUyMDI2JztcbiAgICAvLyBJbmNsdWRlIHByZXZpb3VzIGxpbmUgaW4gY29udGV4dCBpZiBwb2ludGluZyBhdCBsaW5lIHN0YXJ0XG4gICAgaWYgKGxpbmUgPiAxICYmIC9eICokLy50ZXN0KGxpbmVTdHIuc3Vic3RyaW5nKDAsIGNpKSkpIHtcbiAgICAgICAgLy8gUmVnZXhwIHdvbid0IG1hdGNoIGlmIHN0YXJ0IGlzIHRyaW1tZWRcbiAgICAgICAgbGV0IHByZXYgPSBzcmMuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDJdLCBsYy5saW5lU3RhcnRzW2xpbmUgLSAxXSk7XG4gICAgICAgIGlmIChwcmV2Lmxlbmd0aCA+IDgwKVxuICAgICAgICAgICAgcHJldiA9IHByZXYuc3Vic3RyaW5nKDAsIDc5KSArICdcdTIwMjZcXG4nO1xuICAgICAgICBsaW5lU3RyID0gcHJldiArIGxpbmVTdHI7XG4gICAgfVxuICAgIGlmICgvW14gXS8udGVzdChsaW5lU3RyKSkge1xuICAgICAgICBsZXQgY291bnQgPSAxO1xuICAgICAgICBjb25zdCBlbmQgPSBlcnJvci5saW5lUG9zWzFdO1xuICAgICAgICBpZiAoZW5kPy5saW5lID09PSBsaW5lICYmIGVuZC5jb2wgPiBjb2wpIHtcbiAgICAgICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oZW5kLmNvbCAtIGNvbCwgODAgLSBjaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSAnICcucmVwZWF0KGNpKSArICdeJy5yZXBlYXQoY291bnQpO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGA6XFxuXFxuJHtsaW5lU3RyfVxcbiR7cG9pbnRlcn1cXG5gO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxFcnJvciwgWUFNTFBhcnNlRXJyb3IsIFlBTUxXYXJuaW5nLCBwcmV0dGlmeUVycm9yIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZVByb3BzKHRva2VucywgeyBmbG93LCBpbmRpY2F0b3IsIG5leHQsIG9mZnNldCwgb25FcnJvciwgcGFyZW50SW5kZW50LCBzdGFydE9uTmV3bGluZSB9KSB7XG4gICAgbGV0IHNwYWNlQmVmb3JlID0gZmFsc2U7XG4gICAgbGV0IGF0TmV3bGluZSA9IHN0YXJ0T25OZXdsaW5lO1xuICAgIGxldCBoYXNTcGFjZSA9IHN0YXJ0T25OZXdsaW5lO1xuICAgIGxldCBjb21tZW50ID0gJyc7XG4gICAgbGV0IGNvbW1lbnRTZXAgPSAnJztcbiAgICBsZXQgaGFzTmV3bGluZSA9IGZhbHNlO1xuICAgIGxldCByZXFTcGFjZSA9IGZhbHNlO1xuICAgIGxldCB0YWIgPSBudWxsO1xuICAgIGxldCBhbmNob3IgPSBudWxsO1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGxldCBuZXdsaW5lQWZ0ZXJQcm9wID0gbnVsbDtcbiAgICBsZXQgY29tbWEgPSBudWxsO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICBpZiAocmVxU3BhY2UpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnc3BhY2UnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ2NvbW1hJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICAgICAgICAgIHJlcVNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhYikge1xuICAgICAgICAgICAgaWYgKGF0TmV3bGluZSAmJiB0b2tlbi50eXBlICE9PSAnY29tbWVudCcgJiYgdG9rZW4udHlwZSAhPT0gJ25ld2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0YWIsICdUQUJfQVNfSU5ERU5UJywgJ1RhYnMgYXJlIG5vdCBhbGxvd2VkIGFzIGluZGVudGF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBkb2MgbGV2ZWwsIHRhYnMgYXQgbGluZSBzdGFydCBtYXkgYmUgcGFyc2VkXG4gICAgICAgICAgICAgICAgLy8gYXMgbGVhZGluZyB3aGl0ZSBzcGFjZSByYXRoZXIgdGhhbiBpbmRlbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBJbiBhIGZsb3cgY29sbGVjdGlvbiwgb25seSB0aGUgcGFyc2VyIGhhbmRsZXMgaW5kZW50LlxuICAgICAgICAgICAgICAgIGlmICghZmxvdyAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5kaWNhdG9yICE9PSAnZG9jLXN0YXJ0JyB8fCBuZXh0Py50eXBlICE9PSAnZmxvdy1jb2xsZWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uc291cmNlLmluY2x1ZGVzKCdcXHQnKSkge1xuICAgICAgICAgICAgICAgICAgICB0YWIgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjb21tZW50U2VwICsgY2I7XG4gICAgICAgICAgICAgICAgY29tbWVudFNlcCA9ICcnO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKGF0TmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZm91bmQgfHwgaW5kaWNhdG9yICE9PSAnc2VxLWl0ZW0taW5kJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50U2VwICs9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhhc05ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgfHwgdGFnKVxuICAgICAgICAgICAgICAgICAgICBuZXdsaW5lQWZ0ZXJQcm9wID0gdG9rZW47XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTVVMVElQTEVfQU5DSE9SUycsICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgYW5jaG9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnNvdXJjZS5lbmRzV2l0aCgnOicpKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLm9mZnNldCArIHRva2VuLnNvdXJjZS5sZW5ndGggLSAxLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBlbmRpbmcgaW4gOiBpcyBhbWJpZ3VvdXMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBzdGFydCA/PyAoc3RhcnQgPSB0b2tlbi5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGFnJzoge1xuICAgICAgICAgICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9UQUdTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSB0YWcnKTtcbiAgICAgICAgICAgICAgICB0YWcgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBzdGFydCA/PyAoc3RhcnQgPSB0b2tlbi5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBpbmRpY2F0b3I6XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgaGVyZSBoYW5kbGUgcHJlY2VkaW5nIGNvbW1lbnRzIGRpZmZlcmVudGx5XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdCQURfUFJPUF9PUkRFUicsIGBBbmNob3JzIGFuZCB0YWdzIG11c3QgYmUgYWZ0ZXIgdGhlICR7dG9rZW4uc291cmNlfSBpbmRpY2F0b3JgKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi5zb3VyY2V9IGluICR7ZmxvdyA/PyAnY29sbGVjdGlvbid9YCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPVxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3IgPT09ICdzZXEtaXRlbS1pbmQnIHx8IGluZGljYXRvciA9PT0gJ2V4cGxpY2l0LWtleS1pbmQnO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgaWYgKGZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAsIGluICR7Zmxvd31gKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWEgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnR5cGV9IHRva2VuYCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBlbmQgPSBsYXN0ID8gbGFzdC5vZmZzZXQgKyBsYXN0LnNvdXJjZS5sZW5ndGggOiBvZmZzZXQ7XG4gICAgaWYgKHJlcVNwYWNlICYmXG4gICAgICAgIG5leHQgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnc3BhY2UnICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ25ld2xpbmUnICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ2NvbW1hJyAmJlxuICAgICAgICAobmV4dC50eXBlICE9PSAnc2NhbGFyJyB8fCBuZXh0LnNvdXJjZSAhPT0gJycpKSB7XG4gICAgICAgIG9uRXJyb3IobmV4dC5vZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnVGFncyBhbmQgYW5jaG9ycyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIHRoZSBuZXh0IHRva2VuIGJ5IHdoaXRlIHNwYWNlJyk7XG4gICAgfVxuICAgIGlmICh0YWIgJiZcbiAgICAgICAgKChhdE5ld2xpbmUgJiYgdGFiLmluZGVudCA8PSBwYXJlbnRJbmRlbnQpIHx8XG4gICAgICAgICAgICBuZXh0Py50eXBlID09PSAnYmxvY2stbWFwJyB8fFxuICAgICAgICAgICAgbmV4dD8udHlwZSA9PT0gJ2Jsb2NrLXNlcScpKVxuICAgICAgICBvbkVycm9yKHRhYiwgJ1RBQl9BU19JTkRFTlQnLCAnVGFicyBhcmUgbm90IGFsbG93ZWQgYXMgaW5kZW50YXRpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21tYSxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIHNwYWNlQmVmb3JlLFxuICAgICAgICBjb21tZW50LFxuICAgICAgICBoYXNOZXdsaW5lLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHRhZyxcbiAgICAgICAgbmV3bGluZUFmdGVyUHJvcCxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdGFydDogc3RhcnQgPz8gZW5kXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZVByb3BzIH07XG4iLCAiZnVuY3Rpb24gY29udGFpbnNOZXdsaW5lKGtleSkge1xuICAgIGlmICgha2V5KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBpZiAoa2V5LnNvdXJjZS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoa2V5LmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGtleS5lbmQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2Yga2V5Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNOZXdsaW5lKGl0LmtleSkgfHwgY29udGFpbnNOZXdsaW5lKGl0LnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9O1xuIiwgImltcG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9IGZyb20gJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJztcblxuZnVuY3Rpb24gZmxvd0luZGVudENoZWNrKGluZGVudCwgZmMsIG9uRXJyb3IpIHtcbiAgICBpZiAoZmM/LnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IGZjLmVuZFswXTtcbiAgICAgICAgaWYgKGVuZC5pbmRlbnQgPT09IGluZGVudCAmJlxuICAgICAgICAgICAgKGVuZC5zb3VyY2UgPT09ICddJyB8fCBlbmQuc291cmNlID09PSAnfScpICYmXG4gICAgICAgICAgICBjb250YWluc05ld2xpbmUoZmMpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnRmxvdyBlbmQgaW5kaWNhdG9yIHNob3VsZCBiZSBtb3JlIGluZGVudGVkIHRoYW4gcGFyZW50JztcbiAgICAgICAgICAgIG9uRXJyb3IoZW5kLCAnQkFEX0lOREVOVCcsIG1zZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGZsb3dJbmRlbnRDaGVjayB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuXG5mdW5jdGlvbiBtYXBJbmNsdWRlcyhjdHgsIGl0ZW1zLCBzZWFyY2gpIHtcbiAgICBjb25zdCB7IHVuaXF1ZUtleXMgfSA9IGN0eC5vcHRpb25zO1xuICAgIGlmICh1bmlxdWVLZXlzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGlzRXF1YWwgPSB0eXBlb2YgdW5pcXVlS2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHVuaXF1ZUtleXNcbiAgICAgICAgOiAoYSwgYikgPT4gYSA9PT0gYiB8fCAoaXNTY2FsYXIoYSkgJiYgaXNTY2FsYXIoYikgJiYgYS52YWx1ZSA9PT0gYi52YWx1ZSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUocGFpciA9PiBpc0VxdWFsKHBhaXIua2V5LCBzZWFyY2gpKTtcbn1cblxuZXhwb3J0IHsgbWFwSW5jbHVkZXMgfTtcbiIsICJpbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcbmltcG9ydCB7IG1hcEluY2x1ZGVzIH0gZnJvbSAnLi91dGlsLW1hcC1pbmNsdWRlcy5qcyc7XG5cbmNvbnN0IHN0YXJ0Q29sTXNnID0gJ0FsbCBtYXBwaW5nIGl0ZW1zIG11c3Qgc3RhcnQgYXQgdGhlIHNhbWUgY29sdW1uJztcbmZ1bmN0aW9uIHJlc29sdmVCbG9ja01hcCh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYm0sIG9uRXJyb3IsIHRhZykge1xuICAgIGNvbnN0IE5vZGVDbGFzcyA9IHRhZz8ubm9kZUNsYXNzID8/IFlBTUxNYXA7XG4gICAgY29uc3QgbWFwID0gbmV3IE5vZGVDbGFzcyhjdHguc2NoZW1hKTtcbiAgICBpZiAoY3R4LmF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBibS5vZmZzZXQ7XG4gICAgbGV0IGNvbW1lbnRFbmQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY29sbEl0ZW0gb2YgYm0uaXRlbXMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgLy8ga2V5IHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qga2V5UHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ2V4cGxpY2l0LWtleS1pbmQnLFxuICAgICAgICAgICAgbmV4dDoga2V5ID8/IHNlcD8uWzBdLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHBhcmVudEluZGVudDogYm0uaW5kZW50LFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGltcGxpY2l0S2V5ID0gIWtleVByb3BzLmZvdW5kO1xuICAgICAgICBpZiAoaW1wbGljaXRLZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnR5cGUgPT09ICdibG9jay1zZXEnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdBIGJsb2NrIHNlcXVlbmNlIG1heSBub3QgYmUgdXNlZCBhcyBhbiBpbXBsaWNpdCBtYXAga2V5Jyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ2luZGVudCcgaW4ga2V5ICYmIGtleS5pbmRlbnQgIT09IGJtLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgc3RhcnRDb2xNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXlQcm9wcy5hbmNob3IgJiYgIWtleVByb3BzLnRhZyAmJiAhc2VwKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudEVuZCA9IGtleVByb3BzLmVuZDtcbiAgICAgICAgICAgICAgICBpZiAoa2V5UHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuY29tbWVudCArPSAnXFxuJyArIGtleVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5jb21tZW50ID0ga2V5UHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5UHJvcHMubmV3bGluZUFmdGVyUHJvcCB8fCBjb250YWluc05ld2xpbmUoa2V5KSkge1xuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5ID8/IHN0YXJ0W3N0YXJ0Lmxlbmd0aCAtIDFdLCAnTVVMVElMSU5FX0lNUExJQ0lUX0tFWScsICdJbXBsaWNpdCBrZXlzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleVByb3BzLmZvdW5kPy5pbmRlbnQgIT09IGJtLmluZGVudCkge1xuICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgc3RhcnRDb2xNc2cpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICBjdHguYXRLZXkgPSB0cnVlO1xuICAgICAgICBjb25zdCBrZXlTdGFydCA9IGtleVByb3BzLmVuZDtcbiAgICAgICAgY29uc3Qga2V5Tm9kZSA9IGtleVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwga2V5UHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIGtleVByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwga2V5LCBvbkVycm9yKTtcbiAgICAgICAgY3R4LmF0S2V5ID0gZmFsc2U7XG4gICAgICAgIGlmIChtYXBJbmNsdWRlcyhjdHgsIG1hcC5pdGVtcywga2V5Tm9kZSkpXG4gICAgICAgICAgICBvbkVycm9yKGtleVN0YXJ0LCAnRFVQTElDQVRFX0tFWScsICdNYXAga2V5cyBtdXN0IGJlIHVuaXF1ZScpO1xuICAgICAgICAvLyB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMoc2VwID8/IFtdLCB7XG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdtYXAtdmFsdWUtaW5kJyxcbiAgICAgICAgICAgIG5leHQ6IHZhbHVlLFxuICAgICAgICAgICAgb2Zmc2V0OiBrZXlOb2RlLnJhbmdlWzJdLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHBhcmVudEluZGVudDogYm0uaW5kZW50LFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6ICFrZXkgfHwga2V5LnR5cGUgPT09ICdibG9jay1zY2FsYXInXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgPSB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZT8udHlwZSA9PT0gJ2Jsb2NrLW1hcCcgJiYgIXZhbHVlUHJvcHMuaGFzTmV3bGluZSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCTE9DS19BU19JTVBMSUNJVF9LRVknLCAnTmVzdGVkIG1hcHBpbmdzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wYWN0IG1hcHBpbmdzJyk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLnN0cmljdCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlQcm9wcy5zdGFydCA8IHZhbHVlUHJvcHMuZm91bmQub2Zmc2V0IC0gMTAyNClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnS0VZX09WRVJfMTAyNF9DSEFSUycsICdUaGUgOiBpbmRpY2F0b3IgbXVzdCBiZSBhdCBtb3N0IDEwMjQgY2hhcnMgYWZ0ZXIgdGhlIHN0YXJ0IG9mIGFuIGltcGxpY2l0IGJsb2NrIG1hcHBpbmcga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWx1ZSB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBzZXAsIG51bGwsIHZhbHVlUHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgICAgIGZsb3dJbmRlbnRDaGVjayhibS5pbmRlbnQsIHZhbHVlLCBvbkVycm9yKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZS5yYW5nZVsyXTtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBrZXkgd2l0aCBubyB2YWx1ZVxuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ01JU1NJTkdfQ0hBUicsICdJbXBsaWNpdCBtYXAga2V5cyBuZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IG1hcCB2YWx1ZXMnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIoa2V5Tm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tbWVudEVuZCAmJiBjb21tZW50RW5kIDwgb2Zmc2V0KVxuICAgICAgICBvbkVycm9yKGNvbW1lbnRFbmQsICdJTVBPU1NJQkxFJywgJ01hcCBjb21tZW50IHdpdGggdHJhaWxpbmcgY29udGVudCcpO1xuICAgIG1hcC5yYW5nZSA9IFtibS5vZmZzZXQsIG9mZnNldCwgY29tbWVudEVuZCA/PyBvZmZzZXRdO1xuICAgIHJldHVybiBtYXA7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVCbG9ja01hcCB9O1xuIiwgImltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5pbXBvcnQgeyBmbG93SW5kZW50Q2hlY2sgfSBmcm9tICcuL3V0aWwtZmxvdy1pbmRlbnQtY2hlY2suanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTZXEoeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGJzLCBvbkVycm9yLCB0YWcpIHtcbiAgICBjb25zdCBOb2RlQ2xhc3MgPSB0YWc/Lm5vZGVDbGFzcyA/PyBZQU1MU2VxO1xuICAgIGNvbnN0IHNlcSA9IG5ldyBOb2RlQ2xhc3MoY3R4LnNjaGVtYSk7XG4gICAgaWYgKGN0eC5hdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBpZiAoY3R4LmF0S2V5KVxuICAgICAgICBjdHguYXRLZXkgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gYnMub2Zmc2V0O1xuICAgIGxldCBjb21tZW50RW5kID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHsgc3RhcnQsIHZhbHVlIH0gb2YgYnMuaXRlbXMpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ3NlcS1pdGVtLWluZCcsXG4gICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGJzLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuYW5jaG9yIHx8IHByb3BzLnRhZyB8fCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZT8udHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuZW5kLCAnQkFEX0lOREVOVCcsICdBbGwgc2VxdWVuY2UgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1NlcXVlbmNlIGl0ZW0gd2l0aG91dCAtIGluZGljYXRvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbWVudEVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgc2VxLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJzLmluZGVudCwgdmFsdWUsIG9uRXJyb3IpO1xuICAgICAgICBvZmZzZXQgPSBub2RlLnJhbmdlWzJdO1xuICAgICAgICBzZXEuaXRlbXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgc2VxLnJhbmdlID0gW2JzLm9mZnNldCwgb2Zmc2V0LCBjb21tZW50RW5kID8/IG9mZnNldF07XG4gICAgcmV0dXJuIHNlcTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrU2VxIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIG9mZnNldCwgcmVxU3BhY2UsIG9uRXJyb3IpIHtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGlmIChlbmQpIHtcbiAgICAgICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBzZXAgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlLCB0eXBlIH0gPSB0b2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxU3BhY2UgJiYgIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjYjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBzZXAgKyBjYjtcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXAgKz0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0eXBlfSBhdCBub2RlIGVuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWVudCwgb2Zmc2V0IH07XG59XG5cbmV4cG9ydCB7IHJlc29sdmVFbmQgfTtcbiIsICJpbXBvcnQgeyBpc1BhaXIgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgbWFwSW5jbHVkZXMgfSBmcm9tICcuL3V0aWwtbWFwLWluY2x1ZGVzLmpzJztcblxuY29uc3QgYmxvY2tNc2cgPSAnQmxvY2sgY29sbGVjdGlvbnMgYXJlIG5vdCBhbGxvd2VkIHdpdGhpbiBmbG93IGNvbGxlY3Rpb25zJztcbmNvbnN0IGlzQmxvY2sgPSAodG9rZW4pID0+IHRva2VuICYmICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJyk7XG5mdW5jdGlvbiByZXNvbHZlRmxvd0NvbGxlY3Rpb24oeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGZjLCBvbkVycm9yLCB0YWcpIHtcbiAgICBjb25zdCBpc01hcCA9IGZjLnN0YXJ0LnNvdXJjZSA9PT0gJ3snO1xuICAgIGNvbnN0IGZjTmFtZSA9IGlzTWFwID8gJ2Zsb3cgbWFwJyA6ICdmbG93IHNlcXVlbmNlJztcbiAgICBjb25zdCBOb2RlQ2xhc3MgPSAodGFnPy5ub2RlQ2xhc3MgPz8gKGlzTWFwID8gWUFNTE1hcCA6IFlBTUxTZXEpKTtcbiAgICBjb25zdCBjb2xsID0gbmV3IE5vZGVDbGFzcyhjdHguc2NoZW1hKTtcbiAgICBjb2xsLmZsb3cgPSB0cnVlO1xuICAgIGNvbnN0IGF0Um9vdCA9IGN0eC5hdFJvb3Q7XG4gICAgaWYgKGF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGlmIChjdHguYXRLZXkpXG4gICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBmYy5vZmZzZXQgKyBmYy5zdGFydC5zb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29sbEl0ZW0gPSBmYy5pdGVtc1tpXTtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgIGluZGljYXRvcjogJ2V4cGxpY2l0LWtleS1pbmQnLFxuICAgICAgICAgICAgbmV4dDoga2V5ID8/IHNlcD8uWzBdLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHBhcmVudEluZGVudDogZmMuaW5kZW50LFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmFuY2hvciAmJiAhcHJvcHMudGFnICYmICFzZXAgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgZmMuaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCBlbXB0eSBpdGVtIGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgKz0gJ1xcbicgKyBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTWFwICYmIGN0eC5vcHRpb25zLnN0cmljdCAmJiBjb250YWluc05ld2xpbmUoa2V5KSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSwgLy8gY2hlY2tlZCBieSBjb250YWluc05ld2xpbmUoKVxuICAgICAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZJdGVtQ29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxvb3A6IGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2SXRlbUNvbW1lbnQgPSBzdC5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZJdGVtQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGNvbGwuaXRlbXNbY29sbC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFpcihwcmV2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnZhbHVlID8/IHByZXYua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ICs9ICdcXG4nICsgcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNvbW1lbnQgPSBwcmV2SXRlbUNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50LnN1YnN0cmluZyhwcmV2SXRlbUNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNYXAgJiYgIXNlcCAmJiAhcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSB2YWx1ZSBpbiBhIHNlcVxuICAgICAgICAgICAgLy8gXHUyMTkyIGtleSAmIHNlcCBhcmUgZW1wdHksIHN0YXJ0IGRvZXMgbm90IGluY2x1ZGUgPyBvciA6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzZXAsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSBrZXkrdmFsdWUgcGFpclxuICAgICAgICAgICAgLy8ga2V5IHZhbHVlXG4gICAgICAgICAgICBjdHguYXRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICBjb25zdCBrZXlOb2RlID0ga2V5XG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNCbG9jayhrZXkpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICBjdHguYXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMoc2VwID8/IFtdLCB7XG4gICAgICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgICAgIG5leHQ6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG9mZnNldDoga2V5Tm9kZS5yYW5nZVsyXSxcbiAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIHBhcmVudEluZGVudDogZmMuaW5kZW50LFxuICAgICAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVQcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNNYXAgJiYgIXByb3BzLmZvdW5kICYmIGN0eC5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBzZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QgPT09IHZhbHVlUHJvcHMuZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihzdCwgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBvZiBmbG93IHNlcXVlbmNlIHBhaXJzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5zdGFydCA8IHZhbHVlUHJvcHMuZm91bmQub2Zmc2V0IC0gMTAyNClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVQcm9wcy5mb3VuZCwgJ0tFWV9PVkVSXzEwMjRfQ0hBUlMnLCAnVGhlIDogaW5kaWNhdG9yIG11c3QgYmUgYXQgbW9zdCAxMDI0IGNoYXJzIGFmdGVyIHRoZSBzdGFydCBvZiBhbiBpbXBsaWNpdCBmbG93IHNlcXVlbmNlIGtleScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzb3VyY2UnIGluIHZhbHVlICYmIHZhbHVlLnNvdXJjZT8uWzBdID09PSAnOicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWUsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyBzcGFjZSBhZnRlciA6IGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZVByb3BzLnN0YXJ0LCAnTUlTU0lOR19DSEFSJywgYE1pc3NpbmcgLCBvciA6IGJldHdlZW4gJHtmY05hbWV9IGl0ZW1zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWx1ZSB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVByb3BzLmZvdW5kXG4gICAgICAgICAgICAgICAgICAgID8gY29tcG9zZUVtcHR5Tm9kZShjdHgsIHZhbHVlUHJvcHMuZW5kLCBzZXAsIG51bGwsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCbG9jayh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlUHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlOb2RlLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCArPSAnXFxuJyArIHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCA9IHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gY29sbDtcbiAgICAgICAgICAgICAgICBpZiAobWFwSW5jbHVkZXMoY3R4LCBtYXAuaXRlbXMsIGtleU5vZGUpKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleVN0YXJ0LCAnRFVQTElDQVRFX0tFWScsICdNYXAga2V5cyBtdXN0IGJlIHVuaXF1ZScpO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgbWFwLmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZFJhbmdlID0gKHZhbHVlTm9kZSA/PyBrZXlOb2RlKS5yYW5nZTtcbiAgICAgICAgICAgICAgICBtYXAucmFuZ2UgPSBba2V5Tm9kZS5yYW5nZVswXSwgZW5kUmFuZ2VbMV0sIGVuZFJhbmdlWzJdXTtcbiAgICAgICAgICAgICAgICBjb2xsLml0ZW1zLnB1c2gobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZSA/IHZhbHVlTm9kZS5yYW5nZVsyXSA6IHZhbHVlUHJvcHMuZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdGVkRW5kID0gaXNNYXAgPyAnfScgOiAnXSc7XG4gICAgY29uc3QgW2NlLCAuLi5lZV0gPSBmYy5lbmQ7XG4gICAgbGV0IGNlUG9zID0gb2Zmc2V0O1xuICAgIGlmIChjZT8uc291cmNlID09PSBleHBlY3RlZEVuZClcbiAgICAgICAgY2VQb3MgPSBjZS5vZmZzZXQgKyBjZS5zb3VyY2UubGVuZ3RoO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuYW1lID0gZmNOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBmY05hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBtc2cgPSBhdFJvb3RcbiAgICAgICAgICAgID8gYCR7bmFtZX0gbXVzdCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YFxuICAgICAgICAgICAgOiBgJHtuYW1lfSBpbiBibG9jayBjb2xsZWN0aW9uIG11c3QgYmUgc3VmZmljaWVudGx5IGluZGVudGVkIGFuZCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YDtcbiAgICAgICAgb25FcnJvcihvZmZzZXQsIGF0Um9vdCA/ICdNSVNTSU5HX0NIQVInIDogJ0JBRF9JTkRFTlQnLCBtc2cpO1xuICAgICAgICBpZiAoY2UgJiYgY2Uuc291cmNlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGVlLnVuc2hpZnQoY2UpO1xuICAgIH1cbiAgICBpZiAoZWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kKGVlLCBjZVBvcywgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGVuZC5jb21tZW50KSB7XG4gICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCArPSAnXFxuJyArIGVuZC5jb21tZW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCA9IGVuZC5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbGwucmFuZ2UgPSBbZmMub2Zmc2V0LCBjZVBvcywgZW5kLm9mZnNldF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb2xsLnJhbmdlID0gW2ZjLm9mZnNldCwgY2VQb3MsIGNlUG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGw7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVGbG93Q29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stbWFwLmpzJztcbmltcG9ydCB7IHJlc29sdmVCbG9ja1NlcSB9IGZyb20gJy4vcmVzb2x2ZS1ibG9jay1zZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUZsb3dDb2xsZWN0aW9uIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctY29sbGVjdGlvbi5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lLCB0YWcpIHtcbiAgICBjb25zdCBjb2xsID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLW1hcCdcbiAgICAgICAgPyByZXNvbHZlQmxvY2tNYXAoQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZylcbiAgICAgICAgOiB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJ1xuICAgICAgICAgICAgPyByZXNvbHZlQmxvY2tTZXEoQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZylcbiAgICAgICAgICAgIDogcmVzb2x2ZUZsb3dDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWcpO1xuICAgIGNvbnN0IENvbGwgPSBjb2xsLmNvbnN0cnVjdG9yO1xuICAgIC8vIElmIHdlIGdvdCBhIHRhZ05hbWUgbWF0Y2hpbmcgdGhlIGNsYXNzLCBvciB0aGUgdGFnIG5hbWUgaXMgJyEnLFxuICAgIC8vIHRoZW4gdXNlIHRoZSB0YWdOYW1lIGZyb20gdGhlIG5vZGUgY2xhc3MgdXNlZCB0byBjcmVhdGUgaXQuXG4gICAgaWYgKHRhZ05hbWUgPT09ICchJyB8fCB0YWdOYW1lID09PSBDb2xsLnRhZ05hbWUpIHtcbiAgICAgICAgY29sbC50YWcgPSBDb2xsLnRhZ05hbWU7XG4gICAgICAgIHJldHVybiBjb2xsO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgY29sbC50YWcgPSB0YWdOYW1lO1xuICAgIHJldHVybiBjb2xsO1xufVxuZnVuY3Rpb24gY29tcG9zZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgdGFnVG9rZW4gPSBwcm9wcy50YWc7XG4gICAgY29uc3QgdGFnTmFtZSA9ICF0YWdUb2tlblxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBjdHguZGlyZWN0aXZlcy50YWdOYW1lKHRhZ1Rva2VuLnNvdXJjZSwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpKTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcScpIHtcbiAgICAgICAgY29uc3QgeyBhbmNob3IsIG5ld2xpbmVBZnRlclByb3A6IG5sIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbGFzdFByb3AgPSBhbmNob3IgJiYgdGFnVG9rZW5cbiAgICAgICAgICAgID8gYW5jaG9yLm9mZnNldCA+IHRhZ1Rva2VuLm9mZnNldFxuICAgICAgICAgICAgICAgID8gYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB0YWdUb2tlblxuICAgICAgICAgICAgOiAoYW5jaG9yID8/IHRhZ1Rva2VuKTtcbiAgICAgICAgaWYgKGxhc3RQcm9wICYmICghbmwgfHwgbmwub2Zmc2V0IDwgbGFzdFByb3Aub2Zmc2V0KSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG5ld2xpbmUgYWZ0ZXIgYmxvY2sgc2VxdWVuY2UgcHJvcHMnO1xuICAgICAgICAgICAgb25FcnJvcihsYXN0UHJvcCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cFR5cGUgPSB0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJ1xuICAgICAgICA/ICdtYXAnXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcSdcbiAgICAgICAgICAgID8gJ3NlcSdcbiAgICAgICAgICAgIDogdG9rZW4uc3RhcnQuc291cmNlID09PSAneydcbiAgICAgICAgICAgICAgICA/ICdtYXAnXG4gICAgICAgICAgICAgICAgOiAnc2VxJztcbiAgICAvLyBzaG9ydGN1dDogY2hlY2sgaWYgaXQncyBhIGdlbmVyaWMgWUFNTE1hcCBvciBZQU1MU2VxXG4gICAgLy8gYmVmb3JlIGp1bXBpbmcgaW50byB0aGUgY3VzdG9tIHRhZyBsb2dpYy5cbiAgICBpZiAoIXRhZ1Rva2VuIHx8XG4gICAgICAgICF0YWdOYW1lIHx8XG4gICAgICAgIHRhZ05hbWUgPT09ICchJyB8fFxuICAgICAgICAodGFnTmFtZSA9PT0gWUFNTE1hcC50YWdOYW1lICYmIGV4cFR5cGUgPT09ICdtYXAnKSB8fFxuICAgICAgICAodGFnTmFtZSA9PT0gWUFNTFNlcS50YWdOYW1lICYmIGV4cFR5cGUgPT09ICdzZXEnKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZ05hbWUpO1xuICAgIH1cbiAgICBsZXQgdGFnID0gY3R4LnNjaGVtYS50YWdzLmZpbmQodCA9PiB0LnRhZyA9PT0gdGFnTmFtZSAmJiB0LmNvbGxlY3Rpb24gPT09IGV4cFR5cGUpO1xuICAgIGlmICghdGFnKSB7XG4gICAgICAgIGNvbnN0IGt0ID0gY3R4LnNjaGVtYS5rbm93blRhZ3NbdGFnTmFtZV07XG4gICAgICAgIGlmIChrdD8uY29sbGVjdGlvbiA9PT0gZXhwVHlwZSkge1xuICAgICAgICAgICAgY3R4LnNjaGVtYS50YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHsgZGVmYXVsdDogZmFsc2UgfSkpO1xuICAgICAgICAgICAgdGFnID0ga3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoa3QpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRhZ1Rva2VuLCAnQkFEX0NPTExFQ1RJT05fVFlQRScsIGAke2t0LnRhZ30gdXNlZCBmb3IgJHtleHBUeXBlfSBjb2xsZWN0aW9uLCBidXQgZXhwZWN0cyAke2t0LmNvbGxlY3Rpb24gPz8gJ3NjYWxhcid9YCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgYFVucmVzb2x2ZWQgdGFnOiAke3RhZ05hbWV9YCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbGwgPSByZXNvbHZlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnTmFtZSwgdGFnKTtcbiAgICBjb25zdCByZXMgPSB0YWcucmVzb2x2ZT8uKGNvbGwsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpID8/IGNvbGw7XG4gICAgY29uc3Qgbm9kZSA9IGlzTm9kZShyZXMpXG4gICAgICAgID8gcmVzXG4gICAgICAgIDogbmV3IFNjYWxhcihyZXMpO1xuICAgIG5vZGUucmFuZ2UgPSBjb2xsLnJhbmdlO1xuICAgIG5vZGUudGFnID0gdGFnTmFtZTtcbiAgICBpZiAodGFnPy5mb3JtYXQpXG4gICAgICAgIG5vZGUuZm9ybWF0ID0gdGFnLmZvcm1hdDtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY29tcG9zZUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTY2FsYXIoY3R4LCBzY2FsYXIsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzdGFydCA9IHNjYWxhci5vZmZzZXQ7XG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VCbG9ja1NjYWxhckhlYWRlcihzY2FsYXIsIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgaWYgKCFoZWFkZXIpXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiAnJywgdHlwZTogbnVsbCwgY29tbWVudDogJycsIHJhbmdlOiBbc3RhcnQsIHN0YXJ0LCBzdGFydF0gfTtcbiAgICBjb25zdCB0eXBlID0gaGVhZGVyLm1vZGUgPT09ICc+JyA/IFNjYWxhci5CTE9DS19GT0xERUQgOiBTY2FsYXIuQkxPQ0tfTElURVJBTDtcbiAgICBjb25zdCBsaW5lcyA9IHNjYWxhci5zb3VyY2UgPyBzcGxpdExpbmVzKHNjYWxhci5zb3VyY2UpIDogW107XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgY29udGVudCAmIHN0YXJ0IG9mIGNob21waW5nXG4gICAgbGV0IGNob21wU3RhcnQgPSBsaW5lcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBsaW5lc1tpXVsxXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKVxuICAgICAgICAgICAgY2hvbXBTdGFydCA9IGk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBzaG9ydGN1dCBmb3IgZW1wdHkgY29udGVudHNcbiAgICBpZiAoY2hvbXBTdGFydCA9PT0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5jaG9tcCA9PT0gJysnICYmIGxpbmVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gJ1xcbicucmVwZWF0KE1hdGgubWF4KDEsIGxpbmVzLmxlbmd0aCAtIDEpKVxuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjYWxhci5zb3VyY2UpXG4gICAgICAgICAgICBlbmQgKz0gc2NhbGFyLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7IHZhbHVlLCB0eXBlLCBjb21tZW50OiBoZWFkZXIuY29tbWVudCwgcmFuZ2U6IFtzdGFydCwgZW5kLCBlbmRdIH07XG4gICAgfVxuICAgIC8vIGZpbmQgdGhlIGluZGVudGF0aW9uIGxldmVsIHRvIHRyaW0gZnJvbSBzdGFydFxuICAgIGxldCB0cmltSW5kZW50ID0gc2NhbGFyLmluZGVudCArIGhlYWRlci5pbmRlbnQ7XG4gICAgbGV0IG9mZnNldCA9IHNjYWxhci5vZmZzZXQgKyBoZWFkZXIubGVuZ3RoO1xuICAgIGxldCBjb250ZW50U3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hvbXBTdGFydDsgKytpKSB7XG4gICAgICAgIGNvbnN0IFtpbmRlbnQsIGNvbnRlbnRdID0gbGluZXNbaV07XG4gICAgICAgIGlmIChjb250ZW50ID09PSAnJyB8fCBjb250ZW50ID09PSAnXFxyJykge1xuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDAgJiYgaW5kZW50Lmxlbmd0aCA+IHRyaW1JbmRlbnQpXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5kZW50Lmxlbmd0aCA8IHRyaW1JbmRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0Jsb2NrIHNjYWxhcnMgd2l0aCBtb3JlLWluZGVudGVkIGxlYWRpbmcgZW1wdHkgbGluZXMgbXVzdCB1c2UgYW4gZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJztcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCArIGluZGVudC5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXIuaW5kZW50ID09PSAwKVxuICAgICAgICAgICAgICAgIHRyaW1JbmRlbnQgPSBpbmRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgY29udGVudFN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGlmICh0cmltSW5kZW50ID09PSAwICYmICFjdHguYXRSb290KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdCbG9jayBzY2FsYXIgdmFsdWVzIGluIGNvbGxlY3Rpb25zIG11c3QgYmUgaW5kZW50ZWQnO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgdHJhaWxpbmcgbW9yZS1pbmRlbnRlZCBlbXB0eSBsaW5lcyBpbiBjb250ZW50XG4gICAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gY2hvbXBTdGFydDsgLS1pKSB7XG4gICAgICAgIGlmIChsaW5lc1tpXVswXS5sZW5ndGggPiB0cmltSW5kZW50KVxuICAgICAgICAgICAgY2hvbXBTdGFydCA9IGkgKyAxO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBsZXQgc2VwID0gJyc7XG4gICAgbGV0IHByZXZNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAvLyBsZWFkaW5nIHdoaXRlc3BhY2UgaXMga2VwdCBpbnRhY3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnRTdGFydDsgKytpKVxuICAgICAgICB2YWx1ZSArPSBsaW5lc1tpXVswXS5zbGljZSh0cmltSW5kZW50KSArICdcXG4nO1xuICAgIGZvciAobGV0IGkgPSBjb250ZW50U3RhcnQ7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgbGV0IFtpbmRlbnQsIGNvbnRlbnRdID0gbGluZXNbaV07XG4gICAgICAgIG9mZnNldCArPSBpbmRlbnQubGVuZ3RoICsgY29udGVudC5sZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBjcmxmID0gY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID09PSAnXFxyJztcbiAgICAgICAgaWYgKGNybGYpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgwLCAtMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBhbHJlYWR5IGNhdWdodCBpbiBsZXhlciAqL1xuICAgICAgICBpZiAoY29udGVudCAmJiBpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gaGVhZGVyLmluZGVudFxuICAgICAgICAgICAgICAgID8gJ2V4cGxpY2l0IGluZGVudGF0aW9uIGluZGljYXRvcidcbiAgICAgICAgICAgICAgICA6ICdmaXJzdCBsaW5lJztcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQmxvY2sgc2NhbGFyIGxpbmVzIG11c3Qgbm90IGJlIGxlc3MgaW5kZW50ZWQgdGhhbiB0aGVpciAke3NyY31gO1xuICAgICAgICAgICAgb25FcnJvcihvZmZzZXQgLSBjb250ZW50Lmxlbmd0aCAtIChjcmxmID8gMiA6IDEpLCAnQkFEX0lOREVOVCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgaW5kZW50ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZW50Lmxlbmd0aCA+IHRyaW1JbmRlbnQgfHwgY29udGVudFswXSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIG1vcmUtaW5kZW50ZWQgY29udGVudCB3aXRoaW4gYSBmb2xkZWQgYmxvY2tcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICcgJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmV2TW9yZUluZGVudGVkICYmIHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcblxcbic7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZVxuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoaGVhZGVyLmNob21wKSB7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNob21wU3RhcnQ7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJyArIGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgaGVhZGVyLmxlbmd0aCArIHNjYWxhci5zb3VyY2UubGVuZ3RoO1xuICAgIHJldHVybiB7IHZhbHVlLCB0eXBlLCBjb21tZW50OiBoZWFkZXIuY29tbWVudCwgcmFuZ2U6IFtzdGFydCwgZW5kLCBlbmRdIH07XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrU2NhbGFySGVhZGVyKHsgb2Zmc2V0LCBwcm9wcyB9LCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBpZiAocHJvcHNbMF0udHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKSB7XG4gICAgICAgIG9uRXJyb3IocHJvcHNbMF0sICdJTVBPU1NJQkxFJywgJ0Jsb2NrIHNjYWxhciBoZWFkZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gcHJvcHNbMF07XG4gICAgY29uc3QgbW9kZSA9IHNvdXJjZVswXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcbiAgICBsZXQgY2hvbXAgPSAnJztcbiAgICBsZXQgZXJyb3IgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKCFjaG9tcCAmJiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSlcbiAgICAgICAgICAgIGNob21wID0gY2g7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbiA9IE51bWJlcihjaCk7XG4gICAgICAgICAgICBpZiAoIWluZGVudCAmJiBuKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IG47XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gLTEpXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBvZmZzZXQgKyBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvciAhPT0gLTEpXG4gICAgICAgIG9uRXJyb3IoZXJyb3IsICdVTkVYUEVDVEVEX1RPS0VOJywgYEJsb2NrIHNjYWxhciBoZWFkZXIgaW5jbHVkZXMgZXh0cmEgY2hhcmFjdGVyczogJHtzb3VyY2V9YCk7XG4gICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcHJvcHNbaV07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIWhhc1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycyc7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRva2VuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCB0b2tlbi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIHRva2VuIGluIGJsb2NrIHNjYWxhciBoZWFkZXI6ICR7dG9rZW4udHlwZX1gO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHMgPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHRzICYmIHR5cGVvZiB0cyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kZSwgaW5kZW50LCBjaG9tcCwgY29tbWVudCwgbGVuZ3RoIH07XG59XG4vKiogQHJldHVybnMgQXJyYXkgb2YgbGluZXMgc3BsaXQgdXAgYXMgYFtpbmRlbnQsIGNvbnRlbnRdYCAqL1xuZnVuY3Rpb24gc3BsaXRMaW5lcyhzb3VyY2UpIHtcbiAgICBjb25zdCBzcGxpdCA9IHNvdXJjZS5zcGxpdCgvXFxuKCAqKS8pO1xuICAgIGNvbnN0IGZpcnN0ID0gc3BsaXRbMF07XG4gICAgY29uc3QgbSA9IGZpcnN0Lm1hdGNoKC9eKCAqKS8pO1xuICAgIGNvbnN0IGxpbmUwID0gbT8uWzFdXG4gICAgICAgID8gW21bMV0sIGZpcnN0LnNsaWNlKG1bMV0ubGVuZ3RoKV1cbiAgICAgICAgOiBbJycsIGZpcnN0XTtcbiAgICBjb25zdCBsaW5lcyA9IFtsaW5lMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGxpdC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgbGluZXMucHVzaChbc3BsaXRbaV0sIHNwbGl0W2kgKyAxXV0pO1xuICAgIHJldHVybiBsaW5lcztcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrU2NhbGFyIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dTY2FsYXIoc2NhbGFyLCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgdHlwZSwgc291cmNlLCBlbmQgfSA9IHNjYWxhcjtcbiAgICBsZXQgX3R5cGU7XG4gICAgbGV0IHZhbHVlO1xuICAgIGNvbnN0IF9vbkVycm9yID0gKHJlbCwgY29kZSwgbXNnKSA9PiBvbkVycm9yKG9mZnNldCArIHJlbCwgY29kZSwgbXNnKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIF90eXBlID0gU2NhbGFyLlBMQUlOO1xuICAgICAgICAgICAgdmFsdWUgPSBwbGFpblZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIF90eXBlID0gU2NhbGFyLlFVT1RFX1NJTkdMRTtcbiAgICAgICAgICAgIHZhbHVlID0gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUVVPVEVfRE9VQkxFO1xuICAgICAgICAgICAgdmFsdWUgPSBkb3VibGVRdW90ZWRWYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb25FcnJvcihzY2FsYXIsICdVTkVYUEVDVEVEX1RPS0VOJywgYEV4cGVjdGVkIGEgZmxvdyBzY2FsYXIgdmFsdWUsIGJ1dCBmb3VuZDogJHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb21tZW50OiAnJyxcbiAgICAgICAgICAgICAgICByYW5nZTogW29mZnNldCwgb2Zmc2V0ICsgc291cmNlLmxlbmd0aCwgb2Zmc2V0ICsgc291cmNlLmxlbmd0aF1cbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlRW5kID0gb2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCB2YWx1ZUVuZCwgc3RyaWN0LCBvbkVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogX3R5cGUsXG4gICAgICAgIGNvbW1lbnQ6IHJlLmNvbW1lbnQsXG4gICAgICAgIHJhbmdlOiBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XVxuICAgIH07XG59XG5mdW5jdGlvbiBwbGFpblZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCBiYWRDaGFyID0gJyc7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnYSB0YWIgY2hhcmFjdGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVyICwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdkaXJlY3RpdmUgaW5kaWNhdG9yIGNoYXJhY3RlciAlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgYmxvY2sgc2NhbGFyIGluZGljYXRvciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgIGNhc2UgJ2AnOiB7XG4gICAgICAgICAgICBiYWRDaGFyID0gYHJlc2VydmVkIGNoYXJhY3RlciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJhZENoYXIpXG4gICAgICAgIG9uRXJyb3IoMCwgJ0JBRF9TQ0FMQVJfU1RBUlQnLCBgUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggJHtiYWRDaGFyfWApO1xuICAgIHJldHVybiBmb2xkTGluZXMoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSBcIidcIiB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCBcIk1pc3NpbmcgY2xvc2luZyAncXVvdGVcIik7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2Uuc2xpY2UoMSwgLTEpKS5yZXBsYWNlKC8nJy9nLCBcIidcIik7XG59XG5mdW5jdGlvbiBmb2xkTGluZXMoc291cmNlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaGVyZSBhbmQgaW4gdGhlIGByZWAgUmVnRXhwIGlzIHRvXG4gICAgICogcHJldmVudCBjYXVzaW5nIGEgcG9seW5vbWlhbCBzZWFyY2ggdGltZSBpbiBjZXJ0YWluIGNhc2VzLlxuICAgICAqXG4gICAgICogVGhlIHRyeS1jYXRjaCBpcyBmb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhpcyB5ZXQ6XG4gICAgICogaHR0cHM6Ly9jYW5pdXNlLmNvbS9qcy1yZWdleHAtbG9va2JlaGluZFxuICAgICAqL1xuICAgIGxldCBmaXJzdCwgbGluZTtcbiAgICB0cnkge1xuICAgICAgICBmaXJzdCA9IG5ldyBSZWdFeHAoJyguKj8pKD88IVsgXFx0XSlbIFxcdF0qXFxyP1xcbicsICdzeScpO1xuICAgICAgICBsaW5lID0gbmV3IFJlZ0V4cCgnWyBcXHRdKiguKj8pKD86KD88IVsgXFx0XSlbIFxcdF0qKT9cXHI/XFxuJywgJ3N5Jyk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgZmlyc3QgPSAvKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICAgICAgbGluZSA9IC9bIFxcdF0qKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZmlyc3QuZXhlYyhzb3VyY2UpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IHJlcyA9IG1hdGNoWzFdO1xuICAgIGxldCBzZXAgPSAnICc7XG4gICAgbGV0IHBvcyA9IGZpcnN0Lmxhc3RJbmRleDtcbiAgICBsaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZS5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzZXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gc2VwICsgbWF0Y2hbMV07XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbGluZS5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSAvWyBcXHRdKiguKikvc3k7XG4gICAgbGFzdC5sYXN0SW5kZXggPSBwb3M7XG4gICAgbWF0Y2ggPSBsYXN0LmV4ZWMoc291cmNlKTtcbiAgICByZXR1cm4gcmVzICsgc2VwICsgKG1hdGNoPy5bMV0gPz8gJycpO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvbGQsIG9mZnNldCB9ID0gZm9sZE5ld2xpbmUoc291cmNlLCBpKTtcbiAgICAgICAgICAgIHJlcyArPSBmb2xkO1xuICAgICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgY2MgPSBlc2NhcGVDb2Rlc1tuZXh0XTtcbiAgICAgICAgICAgIGlmIChjYylcbiAgICAgICAgICAgICAgICByZXMgKz0gY2M7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdcXHInICYmIHNvdXJjZVtpICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIENSTEYgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICd4JyB8fCBuZXh0ID09PSAndScgfHwgbmV4dCA9PT0gJ1UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0geyB4OiAyLCB1OiA0LCBVOiA4IH1bbmV4dF07XG4gICAgICAgICAgICAgICAgcmVzICs9IHBhcnNlQ2hhckNvZGUoc291cmNlLCBpICsgMSwgbGVuZ3RoLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoaSAtIDEsICdCQURfRFFfRVNDQVBFJywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7cmF3fWApO1xuICAgICAgICAgICAgICAgIHJlcyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3Qgd3NTdGFydCA9IGk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicgJiYgIShuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDJdID09PSAnXFxuJykpXG4gICAgICAgICAgICAgICAgcmVzICs9IGkgPiB3c1N0YXJ0ID8gc291cmNlLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnXCInIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGNsb3NpbmcgXCJxdW90ZScpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEZvbGQgYSBzaW5nbGUgbmV3bGluZSBpbnRvIGEgc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzLlxuICogUHJlc3VtZXMgYHNvdXJjZVtvZmZzZXRdID09PSAnXFxuJ2BcbiAqL1xuZnVuY3Rpb24gZm9sZE5ld2xpbmUoc291cmNlLCBvZmZzZXQpIHtcbiAgICBsZXQgZm9sZCA9ICcnO1xuICAgIGxldCBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFxyJykge1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtvZmZzZXQgKyAyXSAhPT0gJ1xcbicpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgaWYgKCFmb2xkKVxuICAgICAgICBmb2xkID0gJyAnO1xuICAgIHJldHVybiB7IGZvbGQsIG9mZnNldCB9O1xufVxuY29uc3QgZXNjYXBlQ29kZXMgPSB7XG4gICAgJzAnOiAnXFwwJywgLy8gbnVsbCBjaGFyYWN0ZXJcbiAgICBhOiAnXFx4MDcnLCAvLyBiZWxsIGNoYXJhY3RlclxuICAgIGI6ICdcXGInLCAvLyBiYWNrc3BhY2VcbiAgICBlOiAnXFx4MWInLCAvLyBlc2NhcGUgY2hhcmFjdGVyXG4gICAgZjogJ1xcZicsIC8vIGZvcm0gZmVlZFxuICAgIG46ICdcXG4nLCAvLyBsaW5lIGZlZWRcbiAgICByOiAnXFxyJywgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgdDogJ1xcdCcsIC8vIGhvcml6b250YWwgdGFiXG4gICAgdjogJ1xcdicsIC8vIHZlcnRpY2FsIHRhYlxuICAgIE46ICdcXHUwMDg1JywgLy8gVW5pY29kZSBuZXh0IGxpbmVcbiAgICBfOiAnXFx1MDBhMCcsIC8vIFVuaWNvZGUgbm9uLWJyZWFraW5nIHNwYWNlXG4gICAgTDogJ1xcdTIwMjgnLCAvLyBVbmljb2RlIGxpbmUgc2VwYXJhdG9yXG4gICAgUDogJ1xcdTIwMjknLCAvLyBVbmljb2RlIHBhcmFncmFwaCBzZXBhcmF0b3JcbiAgICAnICc6ICcgJyxcbiAgICAnXCInOiAnXCInLFxuICAgICcvJzogJy8nLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHQnOiAnXFx0J1xufTtcbmZ1bmN0aW9uIHBhcnNlQ2hhckNvZGUoc291cmNlLCBvZmZzZXQsIGxlbmd0aCwgb25FcnJvcikge1xuICAgIGNvbnN0IGNjID0gc291cmNlLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgY29uc3Qgb2sgPSBjYy5sZW5ndGggPT09IGxlbmd0aCAmJiAvXlswLTlhLWZBLUZdKyQvLnRlc3QoY2MpO1xuICAgIGNvbnN0IGNvZGUgPSBvayA/IHBhcnNlSW50KGNjLCAxNikgOiBOYU47XG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIob2Zmc2V0IC0gMiwgbGVuZ3RoICsgMik7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0IC0gMiwgJ0JBRF9EUV9FU0NBUEUnLCBgSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgJHtyYXd9YCk7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUZsb3dTY2FsYXIgfTtcbiIsICJpbXBvcnQgeyBpc1NjYWxhciwgU0NBTEFSIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVCbG9ja1NjYWxhciB9IGZyb20gJy4vcmVzb2x2ZS1ibG9jay1zY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUZsb3dTY2FsYXIgfSBmcm9tICcuL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMnO1xuXG5mdW5jdGlvbiBjb21wb3NlU2NhbGFyKGN0eCwgdG9rZW4sIHRhZ1Rva2VuLCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgdHlwZSwgY29tbWVudCwgcmFuZ2UgfSA9IHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInXG4gICAgICAgID8gcmVzb2x2ZUJsb2NrU2NhbGFyKGN0eCwgdG9rZW4sIG9uRXJyb3IpXG4gICAgICAgIDogcmVzb2x2ZUZsb3dTY2FsYXIodG9rZW4sIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgY29uc3QgdGFnTmFtZSA9IHRhZ1Rva2VuXG4gICAgICAgID8gY3R4LmRpcmVjdGl2ZXMudGFnTmFtZSh0YWdUb2tlbi5zb3VyY2UsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGxldCB0YWc7XG4gICAgaWYgKGN0eC5vcHRpb25zLnN0cmluZ0tleXMgJiYgY3R4LmF0S2V5KSB7XG4gICAgICAgIHRhZyA9IGN0eC5zY2hlbWFbU0NBTEFSXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFnTmFtZSlcbiAgICAgICAgdGFnID0gZmluZFNjYWxhclRhZ0J5TmFtZShjdHguc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpO1xuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInKVxuICAgICAgICB0YWcgPSBmaW5kU2NhbGFyVGFnQnlUZXN0KGN0eCwgdmFsdWUsIHRva2VuLCBvbkVycm9yKTtcbiAgICBlbHNlXG4gICAgICAgIHRhZyA9IGN0eC5zY2hlbWFbU0NBTEFSXTtcbiAgICBsZXQgc2NhbGFyO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKHZhbHVlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiA/PyB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKTtcbiAgICAgICAgc2NhbGFyID0gaXNTY2FsYXIocmVzKSA/IHJlcyA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgb25FcnJvcih0YWdUb2tlbiA/PyB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyk7XG4gICAgICAgIHNjYWxhciA9IG5ldyBTY2FsYXIodmFsdWUpO1xuICAgIH1cbiAgICBzY2FsYXIucmFuZ2UgPSByYW5nZTtcbiAgICBzY2FsYXIuc291cmNlID0gdmFsdWU7XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHNjYWxhci50eXBlID0gdHlwZTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgc2NhbGFyLnRhZyA9IHRhZ05hbWU7XG4gICAgaWYgKHRhZy5mb3JtYXQpXG4gICAgICAgIHNjYWxhci5mb3JtYXQgPSB0YWcuZm9ybWF0O1xuICAgIGlmIChjb21tZW50KVxuICAgICAgICBzY2FsYXIuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIHNjYWxhcjtcbn1cbmZ1bmN0aW9uIGZpbmRTY2FsYXJUYWdCeU5hbWUoc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnKVxuICAgICAgICByZXR1cm4gc2NoZW1hW1NDQUxBUl07IC8vIG5vbi1zcGVjaWZpYyB0YWdcbiAgICBjb25zdCBtYXRjaFdpdGhUZXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2Ygc2NoZW1hLnRhZ3MpIHtcbiAgICAgICAgaWYgKCF0YWcuY29sbGVjdGlvbiAmJiB0YWcudGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAodGFnLmRlZmF1bHQgJiYgdGFnLnRlc3QpXG4gICAgICAgICAgICAgICAgbWF0Y2hXaXRoVGVzdC5wdXNoKHRhZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBtYXRjaFdpdGhUZXN0KVxuICAgICAgICBpZiAodGFnLnRlc3Q/LnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICBjb25zdCBrdCA9IHNjaGVtYS5rbm93blRhZ3NbdGFnTmFtZV07XG4gICAgaWYgKGt0ICYmICFrdC5jb2xsZWN0aW9uKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBrbm93biB0YWcgaXMgYXZhaWxhYmxlIGZvciBzdHJpbmdpZnlpbmcsXG4gICAgICAgIC8vIGJ1dCBkb2VzIG5vdCBnZXQgdXNlZCBieSBkZWZhdWx0LlxuICAgICAgICBzY2hlbWEudGFncy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGt0LCB7IGRlZmF1bHQ6IGZhbHNlLCB0ZXN0OiB1bmRlZmluZWQgfSkpO1xuICAgICAgICByZXR1cm4ga3Q7XG4gICAgfVxuICAgIG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBgVW5yZXNvbHZlZCB0YWc6ICR7dGFnTmFtZX1gLCB0YWdOYW1lICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyk7XG4gICAgcmV0dXJuIHNjaGVtYVtTQ0FMQVJdO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5VGVzdCh7IGF0S2V5LCBkaXJlY3RpdmVzLCBzY2hlbWEgfSwgdmFsdWUsIHRva2VuLCBvbkVycm9yKSB7XG4gICAgY29uc3QgdGFnID0gc2NoZW1hLnRhZ3MuZmluZCh0YWcgPT4gKHRhZy5kZWZhdWx0ID09PSB0cnVlIHx8IChhdEtleSAmJiB0YWcuZGVmYXVsdCA9PT0gJ2tleScpKSAmJlxuICAgICAgICB0YWcudGVzdD8udGVzdCh2YWx1ZSkpIHx8IHNjaGVtYVtTQ0FMQVJdO1xuICAgIGlmIChzY2hlbWEuY29tcGF0KSB7XG4gICAgICAgIGNvbnN0IGNvbXBhdCA9IHNjaGVtYS5jb21wYXQuZmluZCh0YWcgPT4gdGFnLmRlZmF1bHQgJiYgdGFnLnRlc3Q/LnRlc3QodmFsdWUpKSA/P1xuICAgICAgICAgICAgc2NoZW1hW1NDQUxBUl07XG4gICAgICAgIGlmICh0YWcudGFnICE9PSBjb21wYXQudGFnKSB7XG4gICAgICAgICAgICBjb25zdCB0cyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKHRhZy50YWcpO1xuICAgICAgICAgICAgY29uc3QgY3MgPSBkaXJlY3RpdmVzLnRhZ1N0cmluZyhjb21wYXQudGFnKTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBWYWx1ZSBtYXkgYmUgcGFyc2VkIGFzIGVpdGhlciAke3RzfSBvciAke2NzfWA7XG4gICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xufVxuXG5leHBvcnQgeyBjb21wb3NlU2NhbGFyIH07XG4iLCAiZnVuY3Rpb24gZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSB7XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBwb3MgPz8gKHBvcyA9IGJlZm9yZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBzdCA9IGJlZm9yZVtpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHksIGFuIGVtcHR5IHNjYWxhciBpcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBub24tZW1wdHlcbiAgICAgICAgICAgIC8vIG5vZGUsIGJ1dCBpdCdzIG1vcmUgdXNlZnVsIHRvIHBsYWNlIGl0IGFmdGVyIGFueSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIHdoaWxlIChzdD8udHlwZSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0ID0gYmVmb3JlWysraV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5leHBvcnQgeyBlbXB0eVNjYWxhclBvc2l0aW9uIH07XG4iLCAiaW1wb3J0IHsgQWxpYXMgfSBmcm9tICcuLi9ub2Rlcy9BbGlhcy5qcyc7XG5pbXBvcnQgeyBpc1NjYWxhciB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IGNvbXBvc2VDb2xsZWN0aW9uIH0gZnJvbSAnLi9jb21wb3NlLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgY29tcG9zZVNjYWxhciB9IGZyb20gJy4vY29tcG9zZS1zY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuaW1wb3J0IHsgZW1wdHlTY2FsYXJQb3NpdGlvbiB9IGZyb20gJy4vdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMnO1xuXG5jb25zdCBDTiA9IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfTtcbmZ1bmN0aW9uIGNvbXBvc2VOb2RlKGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgYXRLZXkgPSBjdHguYXRLZXk7XG4gICAgY29uc3QgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcgfSA9IHByb3BzO1xuICAgIGxldCBub2RlO1xuICAgIGxldCBpc1NyY1Rva2VuID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VBbGlhcyhjdHgsIHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IgfHwgdGFnKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdBTElBU19QUk9QUycsICdBbiBhbGlhcyBub2RlIG11c3Qgbm90IHNwZWNpZnkgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgIG5vZGUgPSBjb21wb3NlU2NhbGFyKGN0eCwgdG9rZW4sIHRhZywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKVxuICAgICAgICAgICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzpcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIG5vZGUgPSBjb21wb3NlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0b2tlbi50eXBlID09PSAnZXJyb3InXG4gICAgICAgICAgICAgICAgPyB0b2tlbi5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBgVW5zdXBwb3J0ZWQgdG9rZW4gKHR5cGU6ICR7dG9rZW4udHlwZX0pYDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUVtcHR5Tm9kZShjdHgsIHRva2VuLm9mZnNldCwgdW5kZWZpbmVkLCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpc1NyY1Rva2VuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuY2hvciAmJiBub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKGF0S2V5ICYmXG4gICAgICAgIGN0eC5vcHRpb25zLnN0cmluZ0tleXMgJiZcbiAgICAgICAgKCFpc1NjYWxhcihub2RlKSB8fFxuICAgICAgICAgICAgdHlwZW9mIG5vZGUudmFsdWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAobm9kZS50YWcgJiYgbm9kZS50YWcgIT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInKSkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ1dpdGggc3RyaW5nS2V5cywgYWxsIGtleXMgbXVzdCBiZSBzdHJpbmdzJztcbiAgICAgICAgb25FcnJvcih0YWcgPz8gdG9rZW4sICdOT05fU1RSSU5HX0tFWScsIG1zZyk7XG4gICAgfVxuICAgIGlmIChzcGFjZUJlZm9yZSlcbiAgICAgICAgbm9kZS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInICYmIHRva2VuLnNvdXJjZSA9PT0gJycpXG4gICAgICAgICAgICBub2RlLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBub2RlLmNvbW1lbnRCZWZvcmUgPSBjb21tZW50O1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFR5cGUgY2hlY2tpbmcgbWlzc2VzIG1lYW5pbmcgb2YgaXNTcmNUb2tlblxuICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zICYmIGlzU3JjVG9rZW4pXG4gICAgICAgIG5vZGUuc3JjVG9rZW4gPSB0b2tlbjtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBvZmZzZXQsIGJlZm9yZSwgcG9zLCB7IHNwYWNlQmVmb3JlLCBjb21tZW50LCBhbmNob3IsIHRhZywgZW5kIH0sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ3NjYWxhcicsXG4gICAgICAgIG9mZnNldDogZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSxcbiAgICAgICAgaW5kZW50OiAtMSxcbiAgICAgICAgc291cmNlOiAnJ1xuICAgIH07XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIG5vZGUucmFuZ2VbMl0gPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUFsaWFzKHsgb3B0aW9ucyB9LCB7IG9mZnNldCwgc291cmNlLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IGFsaWFzID0gbmV3IEFsaWFzKHNvdXJjZS5zdWJzdHJpbmcoMSkpO1xuICAgIGlmIChhbGlhcy5zb3VyY2UgPT09ICcnKVxuICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9BTElBUycsICdBbGlhcyBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZS5lbmRzV2l0aCgnOicpKVxuICAgICAgICBvbkVycm9yKG9mZnNldCArIHNvdXJjZS5sZW5ndGggLSAxLCAnQkFEX0FMSUFTJywgJ0FsaWFzIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgIGNvbnN0IHZhbHVlRW5kID0gb2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCB2YWx1ZUVuZCwgb3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgIGFsaWFzLnJhbmdlID0gW29mZnNldCwgdmFsdWVFbmQsIHJlLm9mZnNldF07XG4gICAgaWYgKHJlLmNvbW1lbnQpXG4gICAgICAgIGFsaWFzLmNvbW1lbnQgPSByZS5jb21tZW50O1xuICAgIHJldHVybiBhbGlhcztcbn1cblxuZXhwb3J0IHsgY29tcG9zZUVtcHR5Tm9kZSwgY29tcG9zZU5vZGUgfTtcbiIsICJpbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4uL2RvYy9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9IGZyb20gJy4vY29tcG9zZS1ub2RlLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VEb2Mob3B0aW9ucywgZGlyZWN0aXZlcywgeyBvZmZzZXQsIHN0YXJ0LCB2YWx1ZSwgZW5kIH0sIG9uRXJyb3IpIHtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IF9kaXJlY3RpdmVzOiBkaXJlY3RpdmVzIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgYXRLZXk6IGZhbHNlLFxuICAgICAgICBhdFJvb3Q6IHRydWUsXG4gICAgICAgIGRpcmVjdGl2ZXM6IGRvYy5kaXJlY3RpdmVzLFxuICAgICAgICBvcHRpb25zOiBkb2Mub3B0aW9ucyxcbiAgICAgICAgc2NoZW1hOiBkb2Muc2NoZW1hXG4gICAgfTtcbiAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICBpbmRpY2F0b3I6ICdkb2Mtc3RhcnQnLFxuICAgICAgICBuZXh0OiB2YWx1ZSA/PyBlbmQ/LlswXSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBwYXJlbnRJbmRlbnQ6IDAsXG4gICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHByb3BzLmZvdW5kKSB7XG4gICAgICAgIGRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICAodmFsdWUudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHwgdmFsdWUudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAhcHJvcHMuaGFzTmV3bGluZSlcbiAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuZW5kLCAnTUlTU0lOR19DSEFSJywgJ0Jsb2NrIGNvbGxlY3Rpb24gY2Fubm90IHN0YXJ0IG9uIHNhbWUgbGluZSB3aXRoIGRpcmVjdGl2ZXMtZW5kIG1hcmtlcicpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIElmIENvbnRlbnRzIGlzIHNldCwgbGV0J3MgdHJ1c3QgdGhlIHVzZXJcbiAgICBkb2MuY29udGVudHMgPSB2YWx1ZVxuICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBwcm9wcy5lbmQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgY29uc3QgY29udGVudEVuZCA9IGRvYy5jb250ZW50cy5yYW5nZVsyXTtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCBjb250ZW50RW5kLCBmYWxzZSwgb25FcnJvcik7XG4gICAgaWYgKHJlLmNvbW1lbnQpXG4gICAgICAgIGRvYy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICBkb2MucmFuZ2UgPSBbb2Zmc2V0LCBjb250ZW50RW5kLCByZS5vZmZzZXRdO1xuICAgIHJldHVybiBkb2M7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VEb2MgfTtcbiIsICJpbXBvcnQgeyBEaXJlY3RpdmVzIH0gZnJvbSAnLi4vZG9jL2RpcmVjdGl2ZXMuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgWUFNTFdhcm5pbmcsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzQ29sbGVjdGlvbiwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgY29tcG9zZURvYyB9IGZyb20gJy4vY29tcG9zZS1kb2MuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiBnZXRFcnJvclBvcyhzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBbc3JjLCBzcmMgKyAxXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICByZXR1cm4gc3JjLmxlbmd0aCA9PT0gMiA/IHNyYyA6IFtzcmNbMF0sIHNyY1sxXV07XG4gICAgY29uc3QgeyBvZmZzZXQsIHNvdXJjZSB9ID0gc3JjO1xuICAgIHJldHVybiBbb2Zmc2V0LCBvZmZzZXQgKyAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubGVuZ3RoIDogMSldO1xufVxuZnVuY3Rpb24gcGFyc2VQcmVsdWRlKHByZWx1ZGUpIHtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICBsZXQgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWx1ZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gcHJlbHVkZVtpXTtcbiAgICAgICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIGNvbW1lbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgKGNvbW1lbnQgPT09ICcnID8gJycgOiBhZnRlckVtcHR5TGluZSA/ICdcXG5cXG4nIDogJ1xcbicpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJyk7XG4gICAgICAgICAgICAgICAgYXRDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZnRlckVtcHR5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgaWYgKHByZWx1ZGVbaSArIDFdPy5bMF0gIT09ICcjJylcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSB3cm9uZyBhZnRlciBkb2MtZW5kLCBidXQgaW4gdGhhdCBjYXNlIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgaWYgKCFhdENvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9O1xufVxuLyoqXG4gKiBDb21wb3NlIGEgc3RyZWFtIG9mIENTVCBub2RlcyBpbnRvIGEgc3RyZWFtIG9mIFlBTUwgRG9jdW1lbnRzLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb3NlciwgUGFyc2VyIH0gZnJvbSAneWFtbCdcbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgdG9rZW5zID0gbmV3IFBhcnNlcigpLnBhcnNlKHNyYylcbiAqIGNvbnN0IGRvY3MgPSBuZXcgQ29tcG9zZXIoKS5jb21wb3NlKHRva2VucylcbiAqIGBgYFxuICovXG5jbGFzcyBDb21wb3NlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gKHNvdXJjZSwgY29kZSwgbWVzc2FnZSwgd2FybmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3Moc291cmNlKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChuZXcgWUFNTFdhcm5pbmcocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb246IG9wdGlvbnMudmVyc2lvbiB8fCAnMS4yJyB9KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZGVjb3JhdGUoZG9jLCBhZnRlckRvYykge1xuICAgICAgICBjb25zdCB7IGNvbW1lbnQsIGFmdGVyRW1wdHlMaW5lIH0gPSBwYXJzZVByZWx1ZGUodGhpcy5wcmVsdWRlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh7IGRjOiBkb2MuY29tbWVudCwgcHJlbHVkZSwgY29tbWVudCB9KVxuICAgICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZGMgPSBkb2MuY29udGVudHM7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJEb2MpIHtcbiAgICAgICAgICAgICAgICBkb2MuY29tbWVudCA9IGRvYy5jb21tZW50ID8gYCR7ZG9jLmNvbW1lbnR9XFxuJHtjb21tZW50fWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXJFbXB0eUxpbmUgfHwgZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQgfHwgIWRjKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnRCZWZvcmUgPSBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGRjKSAmJiAhZGMuZmxvdyAmJiBkYy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gZGMuaXRlbXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFpcihpdCkpXG4gICAgICAgICAgICAgICAgICAgIGl0ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gaXQuY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBpdC5jb21tZW50QmVmb3JlID0gY2IgPyBgJHtjb21tZW50fVxcbiR7Y2J9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGRjLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgZGMuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLmVycm9ycywgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLndhcm5pbmdzLCB0aGlzLndhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgIGRvYy53YXJuaW5ncyA9IHRoaXMud2FybmluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdHJlYW0gc3RhdHVzIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogTW9zdGx5IHVzZWZ1bCBhdCB0aGUgZW5kIG9mIGlucHV0IGZvciBhbiBlbXB0eSBzdHJlYW0uXG4gICAgICovXG4gICAgc3RyZWFtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1lbnQ6IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpLmNvbW1lbnQsXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzLFxuICAgICAgICAgICAgd2FybmluZ3M6IHRoaXMud2FybmluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZSB0b2tlbnMgaW50byBkb2N1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICpjb21wb3NlKHRva2VucywgZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5uZXh0KHRva2VuKTtcbiAgICAgICAgeWllbGQqIHRoaXMuZW5kKGZvcmNlRG9jLCBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQWR2YW5jZSB0aGUgY29tcG9zZXIgYnkgb25lIENTVCB0b2tlbi4gKi9cbiAgICAqbmV4dCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmFkZCh0b2tlbi5zb3VyY2UsIChvZmZzZXQsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3ModG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IocG9zLCAnQkFEX0RJUkVDVElWRScsIG1lc3NhZ2UsIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gY29tcG9zZURvYyh0aGlzLm9wdGlvbnMsIHRoaXMuZGlyZWN0aXZlcywgdG9rZW4sIHRoaXMub25FcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzICYmICFkb2MuZGlyZWN0aXZlcy5kb2NTdGFydClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ01pc3NpbmcgZGlyZWN0aXZlcy1lbmQvZG9jLXN0YXJ0IGluZGljYXRvciBsaW5lJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZShkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2MpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLnByZWx1ZGUucHVzaCh0b2tlbi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gdG9rZW4uc291cmNlXG4gICAgICAgICAgICAgICAgICAgID8gYCR7dG9rZW4ubWVzc2FnZX06ICR7SlNPTi5zdHJpbmdpZnkodG9rZW4uc291cmNlKX1gXG4gICAgICAgICAgICAgICAgICAgIDogdG9rZW4ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgfHwgIXRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5leHBlY3RlZCBkb2MtZW5kIHdpdGhvdXQgcHJlY2VkaW5nIGRvY3VtZW50JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1zZykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MuZGlyZWN0aXZlcy5kb2NFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJlc29sdmVFbmQodG9rZW4uZW5kLCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5zb3VyY2UubGVuZ3RoLCB0aGlzLmRvYy5vcHRpb25zLnN0cmljdCwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGMgPSB0aGlzLmRvYy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5jb21tZW50ID0gZGMgPyBgJHtkY31cXG4ke2VuZC5jb21tZW50fWAgOiBlbmQuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MucmFuZ2VbMl0gPSBlbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuc3VwcG9ydGVkIHRva2VuICR7dG9rZW4udHlwZX1gKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8geWllbGQgYW55IHJlbWFpbmluZyBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZURvYyAtIElmIHRoZSBzdHJlYW0gY29udGFpbnMgbm8gZG9jdW1lbnQsIHN0aWxsIGVtaXQgYSBmaW5hbCBkb2N1bWVudCBpbmNsdWRpbmcgYW55IGNvbW1lbnRzIGFuZCBkaXJlY3RpdmVzIHRoYXQgd291bGQgYmUgYXBwbGllZCB0byBhIHN1YnNlcXVlbnQgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIGVuZE9mZnNldCAtIFNob3VsZCBiZSBzZXQgaWYgYGZvcmNlRG9jYCBpcyBhbHNvIHNldCwgdG8gc2V0IHRoZSBkb2N1bWVudCByYW5nZSBlbmQgYW5kIHRvIGluZGljYXRlIGVycm9ycyBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgKmVuZChmb3JjZURvYyA9IGZhbHNlLCBlbmRPZmZzZXQgPSAtMSkge1xuICAgICAgICBpZiAodGhpcy5kb2MpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUodGhpcy5kb2MsIHRydWUpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5kb2M7XG4gICAgICAgICAgICB0aGlzLmRvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2VEb2MpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgX2RpcmVjdGl2ZXM6IHRoaXMuZGlyZWN0aXZlcyB9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IERvY3VtZW50KHVuZGVmaW5lZCwgb3B0cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVuZE9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGRpcmVjdGl2ZXMtZW5kIGluZGljYXRvciBsaW5lJyk7XG4gICAgICAgICAgICBkb2MucmFuZ2UgPSBbMCwgZW5kT2Zmc2V0LCBlbmRPZmZzZXRdO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZShkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgIHlpZWxkIGRvYztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgQ29tcG9zZXIgfTtcbiIsICJjb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIGl0ZW0nKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGEgQ1NUIGRvY3VtZW50IG9yIGl0ZW0uXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50cyB3aGVuIGVudGVyaW5nIGVhY2ggaXRlbTpcbiAqICAgLSBgaXRlbWA6IFRoZSBjdXJyZW50IGl0ZW0sIHdoaWNoIGluY2x1ZGVkIHRoZSBmb2xsb3dpbmcgbWVtYmVyczpcbiAqICAgICAtIGBzdGFydDogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmVmb3JlIHRoZSBrZXkgb3IgdmFsdWUsXG4gKiAgICAgICBwb3NzaWJseSBpbmNsdWRpbmcgaXRzIGFuY2hvciBvciB0YWcuXG4gKiAgICAgLSBga2V5PzogVG9rZW4gfCBudWxsYCBcdTIwMTMgU2V0IGZvciBwYWlyIHZhbHVlcy4gTWF5IHRoZW4gYmUgYG51bGxgLCBpZlxuICogICAgICAgdGhlIGtleSBiZWZvcmUgdGhlIGA6YCBzZXBhcmF0b3IgaXMgZW1wdHkuXG4gKiAgICAgLSBgc2VwPzogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmV0d2VlbiB0aGUga2V5IGFuZCB0aGUgdmFsdWUsXG4gKiAgICAgICB3aGljaCBzaG91bGQgaW5jbHVkZSB0aGUgYDpgIG1hcCB2YWx1ZSBpbmRpY2F0b3IgaWYgYHZhbHVlYCBpcyBzZXQuXG4gKiAgICAgLSBgdmFsdWU/OiBUb2tlbmAgXHUyMDEzIFRoZSB2YWx1ZSBvZiBhIHNlcXVlbmNlIGl0ZW0sIG9yIG9mIGEgbWFwIHBhaXIuXG4gKiAgIC0gYHBhdGhgOiBUaGUgc3RlcHMgZnJvbSB0aGUgcm9vdCB0byB0aGUgY3VycmVudCBub2RlLCBhcyBhbiBhcnJheSBvZlxuICogICAgIGBbJ2tleScgfCAndmFsdWUnLCBudW1iZXJdYCB0dXBsZXMuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIHRva2VuLCBjb250aW51ZSB3aXRoXG4gKiAgICAgIG5leHQgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBudW1iZXJgOiBTZXQgdGhlIGluZGV4IG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWZcbiAqICAgICB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdG9rZW4gaGFzIGNoYW5nZWQuXG4gKiAgIC0gYGZ1bmN0aW9uYDogRGVmaW5lIHRoZSBuZXh0IHZpc2l0b3IgZm9yIHRoaXMgaXRlbS4gQWZ0ZXIgdGhlIG9yaWdpbmFsXG4gKiAgICAgdmlzaXRvciBpcyBjYWxsZWQgb24gaXRlbSBlbnRyeSwgbmV4dCB2aXNpdG9ycyBhcmUgY2FsbGVkIGFmdGVyIGhhbmRsaW5nXG4gKiAgICAgYSBub24tZW1wdHkgYGtleWAgYW5kIHdoZW4gZXhpdGluZyB0aGUgaXRlbS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQoY3N0LCB2aXNpdG9yKSB7XG4gICAgaWYgKCd0eXBlJyBpbiBjc3QgJiYgY3N0LnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgICAgIGNzdCA9IHsgc3RhcnQ6IGNzdC5zdGFydCwgdmFsdWU6IGNzdC52YWx1ZSB9O1xuICAgIF92aXNpdChPYmplY3QuZnJlZXplKFtdKSwgY3N0LCB2aXNpdG9yKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXQuQlJFQUsgPSBCUkVBSztcbi8qKiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IGl0ZW0gKi9cbnZpc2l0LlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBpdGVtICovXG52aXNpdC5SRU1PVkUgPSBSRU1PVkU7XG4vKiogRmluZCB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdCAqL1xudmlzaXQuaXRlbUF0UGF0aCA9IChjc3QsIHBhdGgpID0+IHtcbiAgICBsZXQgaXRlbSA9IGNzdDtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZCwgaW5kZXhdIG9mIHBhdGgpIHtcbiAgICAgICAgY29uc3QgdG9rID0gaXRlbT8uW2ZpZWxkXTtcbiAgICAgICAgaWYgKHRvayAmJiAnaXRlbXMnIGluIHRvaykge1xuICAgICAgICAgICAgaXRlbSA9IHRvay5pdGVtc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59O1xuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgY29sbGVjdGlvbiBvZiB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvbGxlY3Rpb24gaXMgbm90IGZvdW5kLCB3aGljaCBzaG91bGQgbmV2ZXIgaGFwcGVuIGlmIHRoZSBpdGVtIGl0c2VsZiBleGlzdHMuXG4gKi9cbnZpc2l0LnBhcmVudENvbGxlY3Rpb24gPSAoY3N0LCBwYXRoKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gdmlzaXQuaXRlbUF0UGF0aChjc3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBjb25zdCBmaWVsZCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVswXTtcbiAgICBjb25zdCBjb2xsID0gcGFyZW50Py5bZmllbGRdO1xuICAgIGlmIChjb2xsICYmICdpdGVtcycgaW4gY29sbClcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgY29sbGVjdGlvbiBub3QgZm91bmQnKTtcbn07XG5mdW5jdGlvbiBfdmlzaXQocGF0aCwgaXRlbSwgdmlzaXRvcikge1xuICAgIGxldCBjdHJsID0gdmlzaXRvcihpdGVtLCBwYXRoKTtcbiAgICBpZiAodHlwZW9mIGN0cmwgPT09ICdzeW1ib2wnKVxuICAgICAgICByZXR1cm4gY3RybDtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIFsna2V5JywgJ3ZhbHVlJ10pIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgaWYgKHRva2VuICYmICdpdGVtcycgaW4gdG9rZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW4uaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IF92aXNpdChPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KFtbZmllbGQsIGldXSkpLCB0b2tlbi5pdGVtc1tpXSwgdmlzaXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjaSAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN0cmwgPT09ICdmdW5jdGlvbicgJiYgZmllbGQgPT09ICdrZXknKVxuICAgICAgICAgICAgICAgIGN0cmwgPSBjdHJsKGl0ZW0sIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyA/IGN0cmwoaXRlbSwgcGF0aCkgOiBjdHJsO1xufVxuXG5leHBvcnQgeyB2aXNpdCB9O1xuIiwgImV4cG9ydCB7IGNyZWF0ZVNjYWxhclRva2VuLCByZXNvbHZlQXNTY2FsYXIsIHNldFNjYWxhclZhbHVlIH0gZnJvbSAnLi9jc3Qtc2NhbGFyLmpzJztcbmV4cG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vY3N0LXN0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyB2aXNpdCB9IGZyb20gJy4vY3N0LXZpc2l0LmpzJztcblxuLyoqIFRoZSBieXRlIG9yZGVyIG1hcmsgKi9cbmNvbnN0IEJPTSA9ICdcXHV7RkVGRn0nO1xuLyoqIFN0YXJ0IG9mIGRvYy1tb2RlICovXG5jb25zdCBET0NVTUVOVCA9ICdcXHgwMic7IC8vIEMwOiBTdGFydCBvZiBUZXh0XG4vKiogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlICovXG5jb25zdCBGTE9XX0VORCA9ICdcXHgxOCc7IC8vIEMwOiBDYW5jZWxcbi8qKiBOZXh0IHRva2VuIGlzIGEgc2NhbGFyIHZhbHVlICovXG5jb25zdCBTQ0FMQVIgPSAnXFx4MWYnOyAvLyBDMDogVW5pdCBTZXBhcmF0b3Jcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgY29sbGVjdGlvbiAqL1xuY29uc3QgaXNDb2xsZWN0aW9uID0gKHRva2VuKSA9PiAhIXRva2VuICYmICdpdGVtcycgaW4gdG9rZW47XG4vKiogQHJldHVybnMgYHRydWVgIGlmIGB0b2tlbmAgaXMgYSBmbG93IG9yIGJsb2NrIHNjYWxhcjsgbm90IGFuIGFsaWFzICovXG5jb25zdCBpc1NjYWxhciA9ICh0b2tlbikgPT4gISF0b2tlbiAmJlxuICAgICh0b2tlbi50eXBlID09PSAnc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdkb3VibGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcicpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKiBHZXQgYSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBsZXhlciB0b2tlbiAqL1xuZnVuY3Rpb24gcHJldHR5VG9rZW4odG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgQk9NOlxuICAgICAgICAgICAgcmV0dXJuICc8Qk9NPic7XG4gICAgICAgIGNhc2UgRE9DVU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJzxET0M+JztcbiAgICAgICAgY2FzZSBGTE9XX0VORDpcbiAgICAgICAgICAgIHJldHVybiAnPEZMT1dfRU5EPic7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICc8U0NBTEFSPic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodG9rZW4pO1xuICAgIH1cbn1cbi8qKiBJZGVudGlmeSB0aGUgdHlwZSBvZiBhIGxleGVyIHRva2VuLiBNYXkgcmV0dXJuIGBudWxsYCBmb3IgdW5rbm93biB0b2tlbnMuICovXG5mdW5jdGlvbiB0b2tlblR5cGUoc291cmNlKSB7XG4gICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJ2J5dGUtb3JkZXItbWFyayc7XG4gICAgICAgIGNhc2UgRE9DVU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ2RvYy1tb2RlJztcbiAgICAgICAgY2FzZSBGTE9XX0VORDpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1lcnJvci1lbmQnO1xuICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIHJldHVybiAnc2NhbGFyJztcbiAgICAgICAgY2FzZSAnLS0tJzpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnLi4uJzpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLWVuZCc7XG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xcclxcbic6XG4gICAgICAgICAgICByZXR1cm4gJ25ld2xpbmUnO1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIHJldHVybiAnc2VxLWl0ZW0taW5kJztcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICByZXR1cm4gJ2V4cGxpY2l0LWtleS1pbmQnO1xuICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIHJldHVybiAnbWFwLXZhbHVlLWluZCc7XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LW1hcC1zdGFydCc7XG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LW1hcC1lbmQnO1xuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1zZXEtc3RhcnQnO1xuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1zZXEtZW5kJztcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbW1hJztcbiAgICB9XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgY2FzZSAnICc6XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NwYWNlJztcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHJldHVybiAnZGlyZWN0aXZlLWxpbmUnO1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIHJldHVybiAnYWxpYXMnO1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnYW5jaG9yJztcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICByZXR1cm4gJ3RhZyc7XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICByZXR1cm4gJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgcmV0dXJuICdkb3VibGUtcXVvdGVkLXNjYWxhcic7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2stc2NhbGFyLWhlYWRlcic7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBCT00sIERPQ1VNRU5ULCBGTE9XX0VORCwgU0NBTEFSLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyLCBwcmV0dHlUb2tlbiwgdG9rZW5UeXBlIH07XG4iLCAiaW1wb3J0IHsgQk9NLCBET0NVTUVOVCwgRkxPV19FTkQsIFNDQUxBUiB9IGZyb20gJy4vY3N0LmpzJztcblxuLypcblNUQVJUIC0+IHN0cmVhbVxuXG5zdHJlYW1cbiAgZGlyZWN0aXZlIC0+IGxpbmUtZW5kIC0+IHN0cmVhbVxuICBpbmRlbnQgKyBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGxpbmUtc3RhcnRcblxubGluZS1lbmRcbiAgY29tbWVudCAtPiBsaW5lLWVuZFxuICBuZXdsaW5lIC0+IC5cbiAgaW5wdXQtZW5kIC0+IEVORFxuXG5saW5lLXN0YXJ0XG4gIGRvYy1zdGFydCAtPiBkb2NcbiAgZG9jLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGluZGVudCAtPiBibG9jay1zdGFydFxuXG5ibG9jay1zdGFydFxuICBzZXEtaXRlbS1zdGFydCAtPiBibG9jay1zdGFydFxuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIFtlbHNlXSAtPiBkb2NcblxuZG9jXG4gIGxpbmUtZW5kIC0+IGxpbmUtc3RhcnRcbiAgc3BhY2VzIC0+IGRvY1xuICBhbmNob3IgLT4gZG9jXG4gIHRhZyAtPiBkb2NcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGRvY1xuICBmbG93LWVuZCAtPiBlcnJvciAtPiBkb2NcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBlcnJvciAtPiBkb2NcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGRvY1xuICBhbGlhcyAtPiBkb2NcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBkb2NcbiAgYmxvY2stc2NhbGFyLWhlYWRlciAtPiBsaW5lLWVuZCAtPiBibG9jay1zY2FsYXIobWluKSAtPiBsaW5lLXN0YXJ0XG4gIFtlbHNlXSAtPiBwbGFpbi1zY2FsYXIoZmFsc2UsIG1pbikgLT4gZG9jXG5cbmZsb3dcbiAgbGluZS1lbmQgLT4gZmxvd1xuICBzcGFjZXMgLT4gZmxvd1xuICBhbmNob3IgLT4gZmxvd1xuICB0YWcgLT4gZmxvd1xuICBmbG93LXN0YXJ0IC0+IGZsb3cgLT4gZmxvd1xuICBmbG93LWVuZCAtPiAuXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGZsb3dcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGZsb3dcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGZsb3dcbiAgYWxpYXMgLT4gZmxvd1xuICBxdW90ZS1zdGFydCAtPiBxdW90ZWQtc2NhbGFyIC0+IGZsb3dcbiAgY29tbWEgLT4gZmxvd1xuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKHRydWUsIDApIC0+IGZsb3dcblxucXVvdGVkLXNjYWxhclxuICBxdW90ZS1lbmQgLT4gLlxuICBbZWxzZV0gLT4gcXVvdGVkLXNjYWxhclxuXG5ibG9jay1zY2FsYXIobWluKVxuICBuZXdsaW5lICsgcGVlayhpbmRlbnQgPCBtaW4pIC0+IC5cbiAgW2Vsc2VdIC0+IGJsb2NrLXNjYWxhcihtaW4pXG5cbnBsYWluLXNjYWxhcihpcy1mbG93LCBtaW4pXG4gIHNjYWxhci1lbmQoaXMtZmxvdykgLT4gLlxuICBwZWVrKG5ld2xpbmUgKyAoaW5kZW50IDwgbWluKSkgLT4gLlxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKG1pbilcbiovXG5mdW5jdGlvbiBpc0VtcHR5KGNoKSB7XG4gICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnICc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBoZXhEaWdpdHMgPSBuZXcgU2V0KCcwMTIzNDU2Nzg5QUJDREVGYWJjZGVmJyk7XG5jb25zdCB0YWdDaGFycyA9IG5ldyBTZXQoXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei0jOy8/OkAmPSskXy4hfionKClcIik7XG5jb25zdCBmbG93SW5kaWNhdG9yQ2hhcnMgPSBuZXcgU2V0KCcsW117fScpO1xuY29uc3QgaW52YWxpZEFuY2hvckNoYXJzID0gbmV3IFNldCgnICxbXXt9XFxuXFxyXFx0Jyk7XG5jb25zdCBpc05vdEFuY2hvckNoYXIgPSAoY2gpID0+ICFjaCB8fCBpbnZhbGlkQW5jaG9yQ2hhcnMuaGFzKGNoKTtcbi8qKlxuICogU3BsaXRzIGFuIGlucHV0IHN0cmluZyBpbnRvIGxleGljYWwgdG9rZW5zLCBpLmUuIHNtYWxsZXIgc3RyaW5ncyB0aGF0IGFyZVxuICogZWFzaWx5IGlkZW50aWZpYWJsZSBieSBgdG9rZW5zLnRva2VuVHlwZSgpYC5cbiAqXG4gKiBMZXhpbmcgc3RhcnRzIGFsd2F5cyBpbiBhIFwic3RyZWFtXCIgY29udGV4dC4gSW5jb21wbGV0ZSBpbnB1dCBtYXkgYmUgYnVmZmVyZWRcbiAqIHVudGlsIGEgY29tcGxldGUgdG9rZW4gY2FuIGJlIGVtaXR0ZWQuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gc2xpY2VzIG9mIHRoZSBvcmlnaW5hbCBpbnB1dCwgdGhlIGZvbGxvd2luZyBjb250cm9sIGNoYXJhY3RlcnNcbiAqIG1heSBhbHNvIGJlIGVtaXR0ZWQ6XG4gKlxuICogLSBgXFx4MDJgIChTdGFydCBvZiBUZXh0KTogQSBkb2N1bWVudCBzdGFydHMgd2l0aCB0aGUgbmV4dCB0b2tlblxuICogLSBgXFx4MThgIChDYW5jZWwpOiBVbmV4cGVjdGVkIGVuZCBvZiBmbG93LW1vZGUgKGluZGljYXRlcyBhbiBlcnJvcilcbiAqIC0gYFxceDFmYCAoVW5pdCBTZXBhcmF0b3IpOiBOZXh0IHRva2VuIGlzIGEgc2NhbGFyIHZhbHVlXG4gKiAtIGBcXHV7RkVGRn1gIChCeXRlIG9yZGVyIG1hcmspOiBFbWl0dGVkIHNlcGFyYXRlbHkgb3V0c2lkZSBkb2N1bWVudHNcbiAqL1xuY2xhc3MgTGV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgbWFya3MgdGhlIGVuZCBvZlxuICAgICAgICAgKiBhbGwgaW5wdXRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXRFbmQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGxpY2l0IGluZGVudCBzZXQgaW4gYmxvY2sgc2NhbGFyIGhlYWRlciwgYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnRcbiAgICAgICAgICogbWluaW11bSBpbmRlbnQsIHNvIGUuZy4gc2V0IHRvIDEgZnJvbSBhIGhlYWRlciBgfDIrYC4gU2V0IHRvIC0xIGlmIG5vdFxuICAgICAgICAgKiBleHBsaWNpdGx5IHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJsb2NrIHNjYWxhcnMgdGhhdCBpbmNsdWRlIGEgKyAoa2VlcCkgY2hvbXBpbmcgaW5kaWNhdG9yIGluIHRoZWlyIGhlYWRlclxuICAgICAgICAgKiBpbmNsdWRlIHRyYWlsaW5nIGVtcHR5IGxpbmVzLCB3aGljaCBhcmUgb3RoZXJ3aXNlIGV4Y2x1ZGVkIGZyb20gdGhlXG4gICAgICAgICAqIHNjYWxhcidzIGNvbnRlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSBmYWxzZTtcbiAgICAgICAgLyoqIEN1cnJlbnQgaW5wdXQgKi9cbiAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgbm90aW5nIHdoZXRoZXIgdGhlIG1hcCB2YWx1ZSBpbmRpY2F0b3IgOiBjYW4gaW1tZWRpYXRlbHkgZm9sbG93IHRoaXNcbiAgICAgICAgICogbm9kZSB3aXRoaW4gYSBmbG93IGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgLyoqIENvdW50IG9mIHN1cnJvdW5kaW5nIGZsb3cgY29sbGVjdGlvbiBsZXZlbHMuICovXG4gICAgICAgIHRoaXMuZmxvd0xldmVsID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1pbmltdW0gbGV2ZWwgb2YgaW5kZW50YXRpb24gcmVxdWlyZWQgZm9yIG5leHQgbGluZXMgdG8gYmUgcGFyc2VkIGFzIGFcbiAgICAgICAgICogcGFydCBvZiB0aGUgY3VycmVudCBzY2FsYXIgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGVudE5leHQgPSAwO1xuICAgICAgICAvKiogSW5kZW50YXRpb24gbGV2ZWwgb2YgdGhlIGN1cnJlbnQgbGluZS4gKi9cbiAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IDA7XG4gICAgICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgbmV4dCBcXG4gY2hhcmFjdGVyLiAqL1xuICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICAvKiogU3RvcmVzIHRoZSBzdGF0ZSBvZiB0aGUgbGV4ZXIgaWYgcmVhY2hpbmcgdGhlIGVuZCBvZiBpbmNwb21wbGV0ZSBpbnB1dCAqL1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICAvKiogQSBwb2ludGVyIHRvIGBidWZmZXJgOyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbGV4ZXIuICovXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgWUFNTCB0b2tlbnMgZnJvbSB0aGUgYHNvdXJjZWAgc3RyaW5nLiBJZiBgaW5jb21wbGV0ZWAsXG4gICAgICogYSBwYXJ0IG9mIHRoZSBsYXN0IGxpbmUgbWF5IGJlIGxlZnQgYXMgYSBidWZmZXIgZm9yIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGdlbmVyYXRvciBvZiBsZXhpY2FsIHRva2Vuc1xuICAgICAqL1xuICAgICpsZXgoc291cmNlLCBpbmNvbXBsZXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignc291cmNlIGlzIG5vdCBhIHN0cmluZycpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyICsgc291cmNlIDogc291cmNlO1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0RW5kID0gIWluY29tcGxldGU7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0ID8/ICdzdHJlYW0nO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAoaW5jb21wbGV0ZSB8fCB0aGlzLmhhc0NoYXJzKDEpKSlcbiAgICAgICAgICAgIG5leHQgPSB5aWVsZCogdGhpcy5wYXJzZU5leHQobmV4dCk7XG4gICAgfVxuICAgIGF0TGluZUVuZCgpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJyMnIHx8IGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW2kgKyAxXSA9PT0gJ1xcbic7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2hhckF0KG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMucG9zICsgbl07XG4gICAgfVxuICAgIGNvbnRpbnVlU2NhbGFyKG9mZnNldCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltvZmZzZXRdO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnROZXh0ID4gMCkge1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY2ggPT09ICcgJylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraW5kZW50ICsgb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5idWZmZXJbaW5kZW50ICsgb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nIHx8ICghbmV4dCAmJiAhdGhpcy5hdEVuZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyBpbmRlbnQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoID09PSAnXFxuJyB8fCBpbmRlbnQgPj0gdGhpcy5pbmRlbnROZXh0IHx8ICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgPyBvZmZzZXQgKyBpbmRlbnRcbiAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy5idWZmZXIuc3Vic3RyKG9mZnNldCwgMyk7XG4gICAgICAgICAgICBpZiAoKGR0ID09PSAnLS0tJyB8fCBkdCA9PT0gJy4uLicpICYmIGlzRW1wdHkodGhpcy5idWZmZXJbb2Zmc2V0ICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBnZXRMaW5lKCkge1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5saW5lRW5kUG9zO1xuICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgKGVuZCAhPT0gLTEgJiYgZW5kIDwgdGhpcy5wb3MpKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKCdcXG4nLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdEVuZCA/IHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvcykgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJbZW5kIC0gMV0gPT09ICdcXHInKVxuICAgICAgICAgICAgZW5kIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MsIGVuZCk7XG4gICAgfVxuICAgIGhhc0NoYXJzKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zICsgbiA8PSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHNldE5leHQoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVlayhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5wb3MsIG4pO1xuICAgIH1cbiAgICAqcGFyc2VOZXh0KG5leHQpIHtcbiAgICAgICAgc3dpdGNoIChuZXh0KSB7XG4gICAgICAgICAgICBjYXNlICdzdHJlYW0nOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVN0cmVhbSgpO1xuICAgICAgICAgICAgY2FzZSAnbGluZS1zdGFydCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zdGFydCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAnZG9jJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VEb2N1bWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnZmxvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlRmxvd0NvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIGNhc2UgJ3F1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1NjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAncGxhaW4tc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VQbGFpblNjYWxhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpwYXJzZVN0cmVhbSgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdzdHJlYW0nKTtcbiAgICAgICAgaWYgKGxpbmVbMF0gPT09IEJPTSkge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lWzBdID09PSAnJScpIHtcbiAgICAgICAgICAgIGxldCBkaXJFbmQgPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjcyA9IGxpbmUuaW5kZXhPZignIycpO1xuICAgICAgICAgICAgd2hpbGUgKGNzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gbGluZVtjcyAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgICAgICBkaXJFbmQgPSBjcyAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3MgPSBsaW5lLmluZGV4T2YoJyMnLCBjcyArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSBsaW5lW2RpckVuZCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgZGlyRW5kIC09IDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG4gPSAoeWllbGQqIHRoaXMucHVzaENvdW50KGRpckVuZCkpICsgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7IC8vIHBvc3NpYmxlIGNvbW1lbnRcbiAgICAgICAgICAgIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdExpbmVFbmQoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3AgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gc3ApO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBET0NVTUVOVDtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUxpbmVTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kICYmICF0aGlzLmhhc0NoYXJzKDQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnBlZWsoMyk7XG4gICAgICAgICAgICBpZiAoKHMgPT09ICctLS0nIHx8IHMgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBzID09PSAnLS0tJyA/ICdkb2MnIDogJ3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXMoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnROZXh0ID4gdGhpcy5pbmRlbnRWYWx1ZSAmJiAhaXNFbXB0eSh0aGlzLmNoYXJBdCgxKSkpXG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IFtjaDAsIGNoMV0gPSB0aGlzLnBlZWsoMik7XG4gICAgICAgIGlmICghY2gxICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc3RhcnQnKTtcbiAgICAgICAgaWYgKChjaDAgPT09ICctJyB8fCBjaDAgPT09ICc/JyB8fCBjaDAgPT09ICc6JykgJiYgaXNFbXB0eShjaDEpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuICAgICpwYXJzZURvY3VtZW50KCkge1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnZG9jJyk7XG4gICAgICAgIGxldCBuID0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFySGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VGbG93Q29sbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IG5sLCBzcDtcbiAgICAgICAgbGV0IGluZGVudCA9IC0xO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBubCA9IHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICBpZiAobmwgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3AgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gaW5kZW50ID0gc3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcCArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICB9IHdoaWxlIChubCArIHNwID4gMCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdmbG93Jyk7XG4gICAgICAgIGlmICgoaW5kZW50ICE9PSAtMSAmJiBpbmRlbnQgPCB0aGlzLmluZGVudE5leHQgJiYgbGluZVswXSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgKGluZGVudCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShsaW5lWzNdKSkpIHtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIGZvciB0aGUgdGVybWluYWwgXSBvciB9IGF0IHRoZSBzYW1lIChyYXRoZXIgdGhhbiBncmVhdGVyKVxuICAgICAgICAgICAgLy8gaW5kZW50IGxldmVsIGFzIHRoZSBpbml0aWFsIFsgb3IgeyBpcyB0ZWNobmljYWxseSBpbnZhbGlkLCBidXRcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgaGVyZSB3b3VsZCBiZSBzdXJwcmlzaW5nIHRvIHVzZXJzLlxuICAgICAgICAgICAgY29uc3QgYXRGbG93RW5kTWFya2VyID0gaW5kZW50ID09PSB0aGlzLmluZGVudE5leHQgLSAxICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAobGluZVswXSA9PT0gJ10nIHx8IGxpbmVbMF0gPT09ICd9Jyk7XG4gICAgICAgICAgICBpZiAoIWF0Rmxvd0VuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgeWllbGQgRkxPV19FTkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICB3aGlsZSAobGluZVtuXSA9PT0gJywnKSB7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93S2V5IHx8IGlzRW1wdHkobmV4dCkgfHwgbmV4dCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VRdW90ZWRTY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlID0gdGhpcy5jaGFyQXQoMCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKHF1b3RlLCB0aGlzLnBvcyArIDEpO1xuICAgICAgICBpZiAocXVvdGUgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSAmJiB0aGlzLmJ1ZmZlcltlbmQgKyAxXSA9PT0gXCInXCIpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihcIidcIiwgZW5kICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVcbiAgICAgICAgICAgIHdoaWxlIChlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlcltlbmQgLSAxIC0gbl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXCInLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGxvb2tpbmcgZm9yIG5ld2xpbmVzIHdpdGhpbiB0aGUgcXVvdGVzXG4gICAgICAgIGNvbnN0IHFiID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgICAgIGxldCBubCA9IHFiLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gcWIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3IgY2F1c2VkIGJ5IGFuIHVuZXhwZWN0ZWQgdW5pbmRlbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBubCAtIChxYltubCAtIDFdID09PSAnXFxyJyA/IDIgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3F1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dMZXZlbCA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcGFyc2VCbG9ja1NjYWxhckhlYWRlcigpIHtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycpXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPiAnMCcgJiYgY2ggPD0gJzknKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSBOdW1iZXIoY2gpIC0gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoICE9PSAnLScpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChjaCA9PiBpc0VtcHR5KGNoKSB8fCBjaCA9PT0gJyMnKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXIoKSB7XG4gICAgICAgIGxldCBubCA9IHRoaXMucG9zIC0gMTsgLy8gbWF5IGJlIC0xIGlmIHRoaXMucG9zID09PSAwXG4gICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGxvb3A6IGZvciAobGV0IGkgPSB0aGlzLnBvczsgKGNoID0gdGhpcy5idWZmZXJbaV0pOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgICAgIG5sID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICBpZiAoaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IGluZGVudDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgKyAodGhpcy5pbmRlbnROZXh0ID09PSAwID8gMSA6IHRoaXMuaW5kZW50TmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKG5sICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKCdcXG4nLCBjcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChubCAhPT0gLTEpO1xuICAgICAgICAgICAgaWYgKG5sID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc2NhbGFyJyk7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhaWxpbmcgaW5zdWZmaWNpZW50bHkgaW5kZW50ZWQgdGFicyBhcmUgaW52YWxpZC5cbiAgICAgICAgLy8gVG8gY2F0Y2ggdGhhdCBkdXJpbmcgcGFyc2luZywgd2UgaW5jbHVkZSB0aGVtIGluIHRoZSBibG9jayBzY2FsYXIgdmFsdWUuXG4gICAgICAgIGxldCBpID0gbmwgKyAxO1xuICAgICAgICBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoY2ggPT09ICcgJylcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFx0Jykge1xuICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnXFx0JyB8fCBjaCA9PT0gJyAnIHx8IGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgbmwgPSBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5ibG9ja1NjYWxhcktlZXApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IG5sIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWy0taV07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXIgPSBpOyAvLyBEcm9wIHRoZSBsaW5lIGlmIGxhc3QgY2hhciBub3QgbW9yZSBpbmRlbnRlZFxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWy0taV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJyAmJiBpID49IHRoaXMucG9zICYmIGkgKyAxICsgaW5kZW50ID4gbGFzdENoYXIpXG4gICAgICAgICAgICAgICAgICAgIG5sID0gaTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgU0NBTEFSO1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChubCArIDEsIHRydWUpO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlUGxhaW5TY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IGluRmxvdyA9IHRoaXMuZmxvd0xldmVsID4gMDtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgd2hpbGUgKChjaCA9IHRoaXMuYnVmZmVyWysraV0pKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkobmV4dCkgfHwgKGluRmxvdyAmJiBmbG93SW5kaWNhdG9yQ2hhcnMuaGFzKG5leHQpKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRW1wdHkoY2gpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnIycgfHwgKGluRmxvdyAmJiBmbG93SW5kaWNhdG9yQ2hhcnMuaGFzKG5leHQpKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBNYXRoLm1heChpLCBjcyAtIDIpOyAvLyB0byBhZHZhbmNlLCBidXQgc3RpbGwgYWNjb3VudCBmb3IgJyAjJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbkZsb3cgJiYgZmxvd0luZGljYXRvckNoYXJzLmhhcyhjaCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3BsYWluLXNjYWxhcicpO1xuICAgICAgICB5aWVsZCBTQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGVuZCArIDEsIHRydWUpO1xuICAgICAgICByZXR1cm4gaW5GbG93ID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgfVxuICAgICpwdXNoQ291bnQobikge1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVG9JbmRleChpLCBhbGxvd0VtcHR5KSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLnBvcywgaSk7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB5aWVsZCBzO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gcy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dFbXB0eSlcbiAgICAgICAgICAgIHlpZWxkICcnO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hJbmRpY2F0b3JzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVGFnKCkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICctJzogLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgY2FzZSAnPyc6IC8vIHRoaXMgaXMgYW4gZXJyb3Igb3V0c2lkZSBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluRmxvdyA9IHRoaXMuZmxvd0xldmVsID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaDEgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShjaDEpIHx8IChpbkZsb3cgJiYgZmxvd0luZGljYXRvckNoYXJzLmhhcyhjaDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluRmxvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsb3dLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFyQXQoMSkgPT09ICc8Jykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDI7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlICghaXNFbXB0eShjaCkgJiYgY2ggIT09ICc+JylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoY2ggPT09ICc+JyA/IGkgKyAxIDogaSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdDaGFycy5oYXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICclJyAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaGFzKHRoaXMuYnVmZmVyW2kgKyAxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaGV4RGlnaXRzLmhhcyh0aGlzLmJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKGkgKz0gMyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcHVzaE5ld2xpbmUoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuY2hhckF0KDEpID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFNwYWNlcyhhbGxvd1RhYnMpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICB9IHdoaWxlIChjaCA9PT0gJyAnIHx8IChhbGxvd1RhYnMgJiYgY2ggPT09ICdcXHQnKSk7XG4gICAgICAgIGNvbnN0IG4gPSBpIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgKnB1c2hVbnRpbCh0ZXN0KSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoIXRlc3QoY2gpKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoaSwgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTGV4ZXIgfTtcbiIsICIvKipcbiAqIFRyYWNrcyBuZXdsaW5lcyBkdXJpbmcgcGFyc2luZyBpbiBvcmRlciB0byBwcm92aWRlIGFuIGVmZmljaWVudCBBUEkgZm9yXG4gKiBkZXRlcm1pbmluZyB0aGUgb25lLWluZGV4ZWQgYHsgbGluZSwgY29sIH1gIHBvc2l0aW9uIGZvciBhbnkgb2Zmc2V0XG4gKiB3aXRoaW4gdGhlIGlucHV0LlxuICovXG5jbGFzcyBMaW5lQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGNhbGxlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgY2FsbFxuICAgICAgICAgKiBgbGluZUNvdW50ZXIubGluZVN0YXJ0cy5zb3J0KClgIGJlZm9yZSBjYWxsaW5nIGBsaW5lUG9zKClgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGROZXdMaW5lID0gKG9mZnNldCkgPT4gdGhpcy5saW5lU3RhcnRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBhbmQgcmV0dXJucyB0aGUgMS1pbmRleGVkIHsgbGluZSwgY29sIH1cbiAgICAgICAgICogcG9zaXRpb24gb2YgYG9mZnNldGAuIElmIGBsaW5lID09PSAwYCwgYGFkZE5ld0xpbmVgIGhhcyBuZXZlciBiZWVuXG4gICAgICAgICAqIGNhbGxlZCBvciBgb2Zmc2V0YCBpcyBiZWZvcmUgdGhlIGZpcnN0IGtub3duIG5ld2xpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVQb3MgPSAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgICAgIGxldCBoaWdoID0gdGhpcy5saW5lU3RhcnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7IC8vIE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMilcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lU3RhcnRzW21pZF0gPCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0c1tsb3ddID09PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbG93ICsgMSwgY29sOiAxIH07XG4gICAgICAgICAgICBpZiAobG93ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNvbDogb2Zmc2V0IH07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMubGluZVN0YXJ0c1tsb3cgLSAxXTtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxvdywgY29sOiBvZmZzZXQgLSBzdGFydCArIDEgfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExpbmVDb3VudGVyIH07XG4iLCAiaW1wb3J0IHsgdG9rZW5UeXBlIH0gZnJvbSAnLi9jc3QuanMnO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tICcuL2xleGVyLmpzJztcblxuZnVuY3Rpb24gaW5jbHVkZXNUb2tlbihsaXN0LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZE5vbkVtcHR5SW5kZXgobGlzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBzd2l0Y2ggKGxpc3RbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gaXNGbG93VG9rZW4odG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuPy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQcmV2UHJvcHMocGFyZW50KSB7XG4gICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnN0YXJ0O1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICBjb25zdCBpdCA9IHBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gaXQuc2VwID8/IGl0LnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zdGFydDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4vKiogTm90ZTogTWF5IG1vZGlmeSBpbnB1dCBhcnJheSAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpIHtcbiAgICBpZiAocHJldi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgaSA9IHByZXYubGVuZ3RoO1xuICAgIGxvb3A6IHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICBzd2l0Y2ggKHByZXZbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAocHJldlsrK2ldPy50eXBlID09PSAnc3BhY2UnKSB7XG4gICAgICAgIC8qIGxvb3AgKi9cbiAgICB9XG4gICAgcmV0dXJuIHByZXYuc3BsaWNlKGksIHByZXYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpeEZsb3dTZXFJdGVtcyhmYykge1xuICAgIGlmIChmYy5zdGFydC50eXBlID09PSAnZmxvdy1zZXEtc3RhcnQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgZmMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAhaXQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmxvd1Rva2VuKGl0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQudmFsdWUuZW5kLCBpdC5zZXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZS5lbmQgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQuc3RhcnQsIGl0LnNlcCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBZQU1MIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIHBhcnNlclxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogZm9yIChjb25zdCB0b2tlbiBvZiBuZXcgUGFyc2VyKCkucGFyc2Uoc3JjKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIHVzZSB0aGUgcGFyc2VyIHdpdGggYSB1c2VyLXByb3ZpZGVkIGxleGVyOlxuICpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiogcGFyc2Uoc291cmNlOiBzdHJpbmcsIGxleGVyOiBMZXhlcikge1xuICogICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKClcbiAqICAgZm9yIChjb25zdCBsZXhlbWUgb2YgbGV4ZXIubGV4KHNvdXJjZSkpXG4gKiAgICAgeWllbGQqIHBhcnNlci5uZXh0KGxleGVtZSlcbiAqICAgeWllbGQqIHBhcnNlci5lbmQoKVxuICogfVxuICpcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBjb25zdCBsZXhlciA9IG5ldyBMZXhlcigpXG4gKiBmb3IgKGNvbnN0IHRva2VuIG9mIHBhcnNlKHNyYywgbGV4ZXIpKSB7XG4gKiAgIC8vIHRva2VuOiBUb2tlblxuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTmV3TGluZSAtIElmIGRlZmluZWQsIGNhbGxlZCBzZXBhcmF0ZWx5IHdpdGggdGhlIHN0YXJ0IHBvc2l0aW9uIG9mXG4gICAgICogICBlYWNoIG5ldyBsaW5lIChpbiBgcGFyc2UoKWAsIGluY2x1ZGluZyB0aGUgc3RhcnQgb2YgaW5wdXQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9uTmV3TGluZSkge1xuICAgICAgICAvKiogSWYgdHJ1ZSwgc3BhY2UgYW5kIHNlcXVlbmNlIGluZGljYXRvcnMgY291bnQgYXMgaW5kZW50YXRpb24gKi9cbiAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAvKiogSWYgdHJ1ZSwgbmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGluZGVudGF0aW9uIGxldmVsICovXG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgLyoqIEN1cnJlbnQgb2Zmc2V0IHNpbmNlIHRoZSBzdGFydCBvZiBwYXJzaW5nICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqIE9uIHRoZSBzYW1lIGxpbmUgd2l0aCBhIGJsb2NrIG1hcCBrZXkgKi9cbiAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvcCBpbmRpY2F0ZXMgdGhlIG5vZGUgdGhhdCdzIGN1cnJlbnRseSBiZWluZyBidWlsdCAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKiBUaGUgc291cmNlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgdG9rZW4sIHNldCBpbiBwYXJzZSgpICovXG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICAvLyBNdXN0IGJlIGRlZmluZWQgYWZ0ZXIgYG5leHQoKWBcbiAgICAgICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcigpO1xuICAgICAgICB0aGlzLm9uTmV3TGluZSA9IG9uTmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYHNvdXJjZWAgYXMgYSBZQU1MIHN0cmVhbS5cbiAgICAgKiBJZiBgaW5jb21wbGV0ZWAsIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogRXJyb3JzIGFyZSBub3QgdGhyb3duLCBidXQgeWllbGRlZCBhcyBgeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlIH1gIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIHRva2VucyByZXByZXNlbnRpbmcgZWFjaCBkaXJlY3RpdmUsIGRvY3VtZW50LCBhbmQgb3RoZXIgc3RydWN0dXJlLlxuICAgICAqL1xuICAgICpwYXJzZShzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUgJiYgdGhpcy5vZmZzZXQgPT09IDApXG4gICAgICAgICAgICB0aGlzLm9uTmV3TGluZSgwKTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlbWUgb2YgdGhpcy5sZXhlci5sZXgoc291cmNlLCBpbmNvbXBsZXRlKSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLm5leHQobGV4ZW1lKTtcbiAgICAgICAgaWYgKCFpbmNvbXBsZXRlKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdGhlIHBhcnNlciBieSB0aGUgYHNvdXJjZWAgb2Ygb25lIGxleGljYWwgdG9rZW4uXG4gICAgICovXG4gICAgKm5leHQoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAodGhpcy5hdFNjYWxhcikge1xuICAgICAgICAgICAgdGhpcy5hdFNjYWxhciA9IGZhbHNlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gdG9rZW5UeXBlKHNvdXJjZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBOb3QgYSBZQU1MIHRva2VuOiAke3NvdXJjZX1gO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgbWVzc2FnZSwgc291cmNlIH0pO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2NhbGFyJykge1xuICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3NjYWxhcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSAmJiBzb3VyY2VbMF0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWVycm9yLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8gcHVzaCBvdXQgYW55IHJlbWFpbmluZyBjb25zdHJ1Y3Rpb25zICovXG4gICAgKmVuZCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgIH1cbiAgICBnZXQgc291cmNlVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHN0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdDtcbiAgICB9XG4gICAgKnN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1lbmQnICYmIHRvcD8udHlwZSAhPT0gJ2RvYy1lbmQnKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG9jLWVuZCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcClcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5zdHJlYW0oKTtcbiAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5kb2N1bWVudCh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc2NhbGFyKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tNYXAodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrU2VxdWVuY2UodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZsb3dDb2xsZWN0aW9uKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnRFbmQodG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgcGVlayhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbl07XG4gICAgfVxuICAgICpwb3AoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBlcnJvciA/PyB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdUcmllZCB0byBwb3AgYW4gZW1wdHkgc3RhY2snO1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZXJyb3InLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6ICcnLCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgc2NhbGFycyB1c2UgdGhlaXIgcGFyZW50IHJhdGhlciB0aGFuIGhlYWRlciBpbmRlbnRcbiAgICAgICAgICAgICAgICB0b2tlbi5pbmRlbnQgPSAnaW5kZW50JyBpbiB0b3AgPyB0b3AuaW5kZW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nICYmIHRvcC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBpbmRlbnQgZm9yIHRvcC1sZXZlbCBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJylcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXModG9rZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgdG9wLnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wcm9wcy5wdXNoKHRva2VuKTsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSAhaXQuZXhwbGljaXRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwgdmFsdWU6IHRva2VuIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRvcC50eXBlID09PSAnZG9jdW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1zZXEnKSAmJlxuICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdG9rZW4uaXRlbXNbdG9rZW4uaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3Quc2VwICYmXG4gICAgICAgICAgICAgICAgICAgICFsYXN0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmaW5kTm9uRW1wdHlJbmRleChsYXN0LnN0YXJ0KSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLmluZGVudCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5ldmVyeShzdCA9PiBzdC50eXBlICE9PSAnY29tbWVudCcgfHwgc3QuaW5kZW50IDwgdG9rZW4uaW5kZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcC50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmVuZCA9IGxhc3Quc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IGxhc3Quc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICpzdHJlYW0oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RpdmUtbGluZSc6XG4gICAgICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZGlyZWN0aXZlJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2J5dGUtb3JkZXItbWFyayc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc291cmNlVG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZG9jLW1vZGUnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RvY3VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZG9jLXN0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGRvYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgc3RyZWFtYCxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgKmRvY3VtZW50KGRvYykge1xuICAgICAgICBpZiAoZG9jLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmxpbmVFbmQoZG9jKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZE5vbkVtcHR5SW5kZXgoZG9jLnN0YXJ0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoZG9jKTtcbiAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIGRvY3VtZW50YCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgICpzY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJykge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyh0aGlzLnBlZWsoMikpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICBsZXQgc2VwO1xuICAgICAgICAgICAgaWYgKHNjYWxhci5lbmQpIHtcbiAgICAgICAgICAgICAgICBzZXAgPSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHNjYWxhci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBzY2FsYXIuaW5kZW50LFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBzY2FsYXIsIHNlcCB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5saW5lRW5kKHNjYWxhcik7XG4gICAgfVxuICAgICpibG9ja1NjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgc2NhbGFyLnByb3BzLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIuc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICAgICAgLy8gYmxvY2stc2NhbGFyIHNvdXJjZSBpbmNsdWRlcyB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpibG9ja01hcChtYXApIHtcbiAgICAgICAgY29uc3QgaXQgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBpdC5zZXAgaXMgdHJ1ZS1pc2ggaWYgcGFpciBhbHJlYWR5IGhhcyBrZXkgb3IgOiBzZXBhcmF0b3JcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9ICdlbmQnIGluIGl0LnZhbHVlID8gaXQudmFsdWUuZW5kIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kW2VuZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3Q/LnR5cGUgPT09ICdjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZD8ucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgbWFwLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldj8udmFsdWU/LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPj0gbWFwLmluZGVudCkge1xuICAgICAgICAgICAgY29uc3QgYXRNYXBJbmRlbnQgPSAhdGhpcy5vbktleUxpbmUgJiYgdGhpcy5pbmRlbnQgPT09IG1hcC5pbmRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdE5leHRJdGVtID0gYXRNYXBJbmRlbnQgJiZcbiAgICAgICAgICAgICAgICAoaXQuc2VwIHx8IGl0LmV4cGxpY2l0S2V5KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSAhPT0gJ3NlcS1pdGVtLWluZCc7XG4gICAgICAgICAgICAvLyBGb3IgZW1wdHkgbm9kZXMsIGFzc2lnbiBuZXdsaW5lLXNlcGFyYXRlZCBub3QgaW5kZW50ZWQgZW1wdHkgdG9rZW5zIHRvIGZvbGxvd2luZyBub2RlXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBbXTtcbiAgICAgICAgICAgIGlmIChhdE5leHRJdGVtICYmIGl0LnNlcCAmJiAhaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBubCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXQuc2VwLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gaXQuc2VwW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5sLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QuaW5kZW50ID4gbWFwLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmwubGVuZ3RoID49IDIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaXQuc2VwLnNwbGljZShubFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXAgJiYgIWl0LmV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0LCBleHBsaWNpdEtleTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dLCBleHBsaWNpdEtleTogdHJ1ZSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5leHBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ25ld2xpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmxvd1Rva2VuKGl0LmtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICduZXdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcCA9IGl0LnNlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGUgZ3VhcmQgaXMgd3JvbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlIGd1YXJkIGlzIHdyb25nIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleSwgc2VwIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFjdHVhbGx5IGF0IG5leHQgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcCA9IGl0LnNlcC5jb25jYXQoc3RhcnQsIHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlIHx8IGF0TmV4dEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcyA9IHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCwga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUobWFwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnYudHlwZSA9PT0gJ2Jsb2NrLXNlcScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LmV4cGxpY2l0S2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICduZXdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VuZXhwZWN0ZWQgYmxvY2stc2VxLWluZCBvbiBzYW1lIGxpbmUgd2l0aCBrZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0TWFwSW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICB9XG4gICAgKmJsb2NrU2VxdWVuY2Uoc2VxKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gc2VxLml0ZW1zW3NlcS5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiBpdC52YWx1ZSA/IGl0LnZhbHVlLmVuZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5LmlzQXJyYXkoZW5kKSA/IGVuZFtlbmQubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Py50eXBlID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ/LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgc2VxLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldj8udmFsdWU/LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCB0aGlzLmluZGVudCA8PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZW50ICE9PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUgfHwgaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ3NlcS1pdGVtLWluZCcpKVxuICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPiBzZXEuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKHNlcSk7XG4gICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqZmxvd0NvbGxlY3Rpb24oZmMpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmYy5pdGVtc1tmYy5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2Zsb3ctZXJyb3ItZW5kJykge1xuICAgICAgICAgICAgbGV0IHRvcDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b3A/LnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmYy5lbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmMuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZzID0gdGhpcy5mbG93U2NhbGFyKHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnMpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtZW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LXNlcS1lbmQnOlxuICAgICAgICAgICAgICAgICAgICBmYy5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShmYyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBlZWsoMik7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdibG9jay1tYXAnICYmXG4gICAgICAgICAgICAgICAgKCh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJyAmJiBwYXJlbnQuaW5kZW50ID09PSBmYy5pbmRlbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV0uc2VwKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJyAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC50eXBlICE9PSAnZmxvdy1jb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXMoZmMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcCA9IGZjLmVuZC5zcGxpY2UoMSwgZmMuZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBmYy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogZmMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogZmMsIHNlcCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoZmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZsb3dTY2FsYXIodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgIGxldCBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJywgbmwpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydEJsb2NrVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhci1oZWFkZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zY2FsYXInLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogW3RoaXMuc291cmNlVG9rZW5dLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmxvdy1jb2xsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zZXEnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzoge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBleHBsaWNpdEtleTogdHJ1ZSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzoge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGF0SW5kZW50ZWRDb21tZW50KHN0YXJ0LCBpbmRlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPD0gaW5kZW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RhcnQuZXZlcnkoc3QgPT4gc3QudHlwZSA9PT0gJ25ld2xpbmUnIHx8IHN0LnR5cGUgPT09ICdzcGFjZScpO1xuICAgIH1cbiAgICAqZG9jdW1lbnRFbmQoZG9jRW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdkb2MtbW9kZScpIHtcbiAgICAgICAgICAgIGlmIChkb2NFbmQuZW5kKVxuICAgICAgICAgICAgICAgIGRvY0VuZC5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpsaW5lRW5kKHRva2VuKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdmbG93LXNlcS1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciB2YWx1ZXMgYXJlIGVycm9yc1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZW5kID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFBhcnNlciB9O1xuIiwgImltcG9ydCB7IENvbXBvc2VyIH0gZnJvbSAnLi9jb21wb3NlL2NvbXBvc2VyLmpzJztcbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgcHJldHRpZnlFcnJvciwgWUFNTFBhcnNlRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi9sb2cuanMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgTGluZUNvdW50ZXIgfSBmcm9tICcuL3BhcnNlL2xpbmUtY291bnRlci5qcyc7XG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tICcuL3BhcnNlL3BhcnNlci5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgcHJldHR5RXJyb3JzID0gb3B0aW9ucy5wcmV0dHlFcnJvcnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IGxpbmVDb3VudGVyID0gb3B0aW9ucy5saW5lQ291bnRlciB8fCAocHJldHR5RXJyb3JzICYmIG5ldyBMaW5lQ291bnRlcigpKSB8fCBudWxsO1xuICAgIHJldHVybiB7IGxpbmVDb3VudGVyLCBwcmV0dHlFcnJvcnMgfTtcbn1cbi8qKlxuICogUGFyc2UgdGhlIGlucHV0IGFzIGEgc3RyZWFtIG9mIFlBTUwgZG9jdW1lbnRzLlxuICpcbiAqIERvY3VtZW50cyBzaG91bGQgYmUgc2VwYXJhdGVkIGZyb20gZWFjaCBvdGhlciBieSBgLi4uYCBvciBgLS0tYCBtYXJrZXIgbGluZXMuXG4gKlxuICogQHJldHVybnMgSWYgYW4gZW1wdHkgYGRvY3NgIGFycmF5IGlzIHJldHVybmVkLCBpdCB3aWxsIGJlIG9mIHR5cGVcbiAqICAgRW1wdHlTdHJlYW0gYW5kIGNvbnRhaW4gYWRkaXRpb25hbCBzdHJlYW0gaW5mb3JtYXRpb24uIEluXG4gKiAgIFR5cGVTY3JpcHQsIHlvdSBzaG91bGQgdXNlIGAnZW1wdHknIGluIGRvY3NgIGFzIGEgdHlwZSBndWFyZCBmb3IgaXQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQWxsRG9jdW1lbnRzKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH0gPSBwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihsaW5lQ291bnRlcj8uYWRkTmV3TGluZSk7XG4gICAgY29uc3QgY29tcG9zZXIgPSBuZXcgQ29tcG9zZXIob3B0aW9ucyk7XG4gICAgY29uc3QgZG9jcyA9IEFycmF5LmZyb20oY29tcG9zZXIuY29tcG9zZShwYXJzZXIucGFyc2Uoc291cmNlKSkpO1xuICAgIGlmIChwcmV0dHlFcnJvcnMgJiYgbGluZUNvdW50ZXIpXG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgICAgICB9XG4gICAgaWYgKGRvY3MubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIGRvY3M7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oW10sIHsgZW1wdHk6IHRydWUgfSwgY29tcG9zZXIuc3RyZWFtSW5mbygpKTtcbn1cbi8qKiBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgaW50byBhIHNpbmdsZSBZQU1MLkRvY3VtZW50ICovXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH0gPSBwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihsaW5lQ291bnRlcj8uYWRkTmV3TGluZSk7XG4gICAgY29uc3QgY29tcG9zZXIgPSBuZXcgQ29tcG9zZXIob3B0aW9ucyk7XG4gICAgLy8gYGRvY2AgaXMgYWx3YXlzIHNldCBieSBjb21wb3NlLmVuZCh0cnVlKSBhdCB0aGUgdmVyeSBsYXRlc3RcbiAgICBsZXQgZG9jID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IF9kb2Mgb2YgY29tcG9zZXIuY29tcG9zZShwYXJzZXIucGFyc2Uoc291cmNlKSwgdHJ1ZSwgc291cmNlLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKCFkb2MpXG4gICAgICAgICAgICBkb2MgPSBfZG9jO1xuICAgICAgICBlbHNlIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IoX2RvYy5yYW5nZS5zbGljZSgwLCAyKSwgJ01VTFRJUExFX0RPQ1MnLCAnU291cmNlIGNvbnRhaW5zIG11bHRpcGxlIGRvY3VtZW50czsgcGxlYXNlIHVzZSBZQU1MLnBhcnNlQWxsRG9jdW1lbnRzKCknKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldHR5RXJyb3JzICYmIGxpbmVDb3VudGVyKSB7XG4gICAgICAgIGRvYy5lcnJvcnMuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgZG9jLndhcm5pbmdzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBkb2M7XG59XG5mdW5jdGlvbiBwYXJzZShzcmMsIHJldml2ZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgX3Jldml2ZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9yZXZpdmVyID0gcmV2aXZlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJldml2ZXIgJiYgdHlwZW9mIHJldml2ZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXZpdmVyO1xuICAgIH1cbiAgICBjb25zdCBkb2MgPSBwYXJzZURvY3VtZW50KHNyYywgb3B0aW9ucyk7XG4gICAgaWYgKCFkb2MpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHdhcm5pbmcgPT4gd2Fybihkb2Mub3B0aW9ucy5sb2dMZXZlbCwgd2FybmluZykpO1xuICAgIGlmIChkb2MuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGRvYy5vcHRpb25zLmxvZ0xldmVsICE9PSAnc2lsZW50JylcbiAgICAgICAgICAgIHRocm93IGRvYy5lcnJvcnNbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRvYy5lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYy50b0pTKE9iamVjdC5hc3NpZ24oeyByZXZpdmVyOiBfcmV2aXZlciB9LCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgbGV0IF9yZXBsYWNlciA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJylcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gTWF0aC5yb3VuZChvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucyA9IGluZGVudCA8IDEgPyB1bmRlZmluZWQgOiBpbmRlbnQgPiA4ID8geyBpbmRlbnQ6IDggfSA6IHsgaW5kZW50IH07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsga2VlcFVuZGVmaW5lZCB9ID0gb3B0aW9ucyA/PyByZXBsYWNlciA/PyB7fTtcbiAgICAgICAgaWYgKCFrZWVwVW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnQodmFsdWUpICYmICFfcmVwbGFjZXIpXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IERvY3VtZW50KHZhbHVlLCBfcmVwbGFjZXIsIG9wdGlvbnMpLnRvU3RyaW5nKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgeyBwYXJzZSwgcGFyc2VBbGxEb2N1bWVudHMsIHBhcnNlRG9jdW1lbnQsIHN0cmluZ2lmeSB9O1xuIiwgImltcG9ydCB7IFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuXG5leHBvcnQgY2xhc3MgRWRpdGluZ1Rvb2xiYXJTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0VkaXRpbmcgVG9vbGJhcicgfSk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnRG8geW91IHdhbnQgdG8gdXNlIHRoZSBFZGl0aW5nIFRvb2xiYXI/J1xuXHRcdH0pO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0dGV4dDogJ1RoaXMgZW5hYmxlcyBhIHZpc3VhbCBlZGl0aW5nIHRvb2xiYXIgZm9yIGZvcm1hdHRpbmcgdGV4dC4gVGhlIHRvb2xiYXIgY2FuIGJlIHRvZ2dsZWQgb24vb2ZmIHZpYSBjb21tYW5kLidcblx0XHR9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0VuYWJsZSBFZGl0aW5nIFRvb2xiYXInKVxuXHRcdFx0LnNldERlc2MoJ1Nob3cgdGhlIGVkaXRpbmcgdG9vbGJhciBjb21tYW5kIGluIHRoZSBwYWdlIGhlYWRlcicpXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXIpXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVFZGl0aW5nVG9vbGJhciA9IHZhbHVlO1xuXHRcdFx0XHR9KSk7XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdFZGl0aW5nIFRvb2xiYXIgcHJlZmVyZW5jZSc7XG5cdH1cblxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnQ29uZmlndXJlIGVkaXRpbmcgdG9vbGJhciBwcmVmZXJlbmNlJztcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcblxuZXhwb3J0IGNsYXNzIEJhc2VzQ01TQ29uZmlnU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdCYXNlcyBDTVMgY29uZmlndXJhdGlvbicgfSk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnQmFzZXMgQ01TIHZpZXdzIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGZvciBlYWNoIGVuYWJsZWQgY29udGVudCB0eXBlIHVzaW5nIHlvdXIgbWFwcGVkIGZyb250bWF0dGVyIHByb3BlcnRpZXMuJyBcblx0XHR9KTtcblxuXHRcdGNvbnN0IGVuYWJsZWRUeXBlcyA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzLmZpbHRlcihjdCA9PiBjdC5lbmFibGVkKTtcblx0XHRcblx0XHRpZiAoZW5hYmxlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxuXHRcdFx0XHR0ZXh0OiAnTm8gY29udGVudCB0eXBlcyBlbmFibGVkLiBQbGVhc2UgZ28gYmFjayBhbmQgZW5hYmxlIGF0IGxlYXN0IG9uZSBjb250ZW50IHR5cGUuJyBcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1ZpZXdzIHRvIGJlIGNyZWF0ZWQ6JyB9KTtcblx0XHRjb25zdCBsaXN0ID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3VsJyk7XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBlbmFibGVkVHlwZXMpIHtcblx0XHRcdGNvbnN0IHByb3BzID0gdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdO1xuXHRcdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRcdGNvbnN0IHByb3BlcnRpZXM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdGlmIChwcm9wcy50aXRsZVByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2goYHRpdGxlOiAke3Byb3BzLnRpdGxlUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy5kYXRlUHJvcGVydHkpIHByb3BlcnRpZXMucHVzaChgZGF0ZTogJHtwcm9wcy5kYXRlUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2goYGRlc2NyaXB0aW9uOiAke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy50YWdzUHJvcGVydHkpIHByb3BlcnRpZXMucHVzaChgdGFnczogJHtwcm9wcy50YWdzUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy5pbWFnZVByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2goYGltYWdlOiAke3Byb3BzLmltYWdlUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy5kcmFmdFByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2goYGRyYWZ0OiAke3Byb3BzLmRyYWZ0UHJvcGVydHl9YCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBwcm9wZXJ0aWVzVGV4dCA9IHByb3BlcnRpZXMubGVuZ3RoID4gMCA/IHByb3BlcnRpZXMuam9pbignLCAnKSA6ICdkZWZhdWx0IHByb3BlcnRpZXMnO1xuXHRcdFx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgXG5cdFx0XHRcdFx0dGV4dDogYCR7Y29udGVudFR5cGUubmFtZX06ICR7cHJvcGVydGllc1RleHR9YCBcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnWW91IGNhbiBjdXN0b21pemUgdGhlc2Ugdmlld3MgbGF0ZXIgaW4gdGhlIEJhc2VzIENNUyBzZXR0aW5ncy4nIFxuXHRcdH0pO1xuXHR9XG5cblx0dmFsaWRhdGUoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUuY29udGVudFR5cGVzLnNvbWUoY3QgPT4gY3QuZW5hYmxlZCk7XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnQmFzZXMgQ01TIGNvbmZpZ3VyYXRpb24nO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ0NvbmZpZ3VyZSBCYXNlcyBDTVMgdmlld3MnO1xuXHR9XG59XG5cbiIsICJpbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuXG5leHBvcnQgY2xhc3MgQXN0cm9Db21wb3NlclN0ZXAgZXh0ZW5kcyBCYXNlV2l6YXJkU3RlcCB7XG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnQXN0cm8gQ29tcG9zZXIgY29uZmlndXJhdGlvbicgfSk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnQXN0cm8gQ29tcG9zZXIgd2lsbCBiZSBjb25maWd1cmVkIHdpdGggeW91ciBjb250ZW50IHR5cGVzIGFuZCBmcm9udG1hdHRlciBwcm9wZXJ0aWVzLicgXG5cdFx0fSk7XG5cblx0XHRjb25zdCBlbmFibGVkVHlwZXMgPSB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZCk7XG5cdFx0XG5cdFx0aWYgKGVuYWJsZWRUeXBlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdFx0dGV4dDogJ05vIGNvbnRlbnQgdHlwZXMgZW5hYmxlZC4nIFxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnQ29udGVudCB0eXBlcyB0byBjb25maWd1cmU6JyB9KTtcblx0XHRjb25zdCBsaXN0ID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3VsJyk7XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBlbmFibGVkVHlwZXMpIHtcblx0XHRcdGNvbnN0IHByb3BzID0gdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdO1xuXHRcdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRcdGNvbnN0IG1vZGVMYWJlbCA9IGNvbnRlbnRUeXBlLmZpbGVPcmdhbml6YXRpb24gPT09ICdmb2xkZXInID8gJ2ZvbGRlci1iYXNlZCcgOiAnZmlsZS1iYXNlZCc7XG5cdFx0XHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyBcblx0XHRcdFx0XHR0ZXh0OiBgJHtjb250ZW50VHlwZS5uYW1lfSAoJHtjb250ZW50VHlwZS5mb2xkZXJ9KTogJHttb2RlTGFiZWx9YCBcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbikge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCkge1xuXHRcdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXG5cdFx0XHRcdFx0dGV4dDogYFByb2plY3Qgcm9vdDogJHt0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3R9YCBcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoKSB7XG5cdFx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdFx0XHR0ZXh0OiBgQ29uZmlnIGZpbGU6ICR7dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRofWAgXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ0FzdHJvIENvbXBvc2VyIGNvbmZpZ3VyYXRpb24nO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ0NvbmZpZ3VyZSBBc3RybyBDb21wb3Nlcic7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBmb3Igc2V0Q3NzUHJvcHMgKG1heSBub3QgYmUgaW4gdHlwZXMgeWV0KVxuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuXHRcdGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcblx0fVxufVxuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcbmltcG9ydCB7IFBhdGhSZXNvbHZlciB9IGZyb20gJy4uLy4uL3V0aWxzL1BhdGhSZXNvbHZlcic7XG5cbmV4cG9ydCBjbGFzcyBTRU9Db25maWdTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1NFTyBwbHVnaW4gY29uZmlndXJhdGlvbicgfSk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnU0VPIHBsdWdpbiB3aWxsIGJlIGNvbmZpZ3VyZWQgdXNpbmcgeW91ciBtYXBwZWQgZnJvbnRtYXR0ZXIgcHJvcGVydGllcy4nIFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgZW5hYmxlZFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xuXHRcdGNvbnN0IGZpcnN0VHlwZSA9IGVuYWJsZWRUeXBlc1swXTtcblx0XHRjb25zdCBmaXJzdFByb3BzID0gZmlyc3RUeXBlID8gdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbZmlyc3RUeXBlLmlkXSA6IHVuZGVmaW5lZDtcblxuXHRcdC8vIENoZWNrIGlmIGRpZmZlcmVudCBjb250ZW50IHR5cGVzIHVzZSBkaWZmZXJlbnQgcHJvcGVydGllc1xuXHRcdGNvbnN0IHRpdGxlUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGNvbnN0IGRlc2NyaXB0aW9uUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgY29udGVudFR5cGUgb2YgZW5hYmxlZFR5cGVzKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXTtcblx0XHRcdGlmIChwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHRpdGxlUHJvcGVydGllcy5hZGQocHJvcHMudGl0bGVQcm9wZXJ0eSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdFx0XHRkZXNjcmlwdGlvblByb3BlcnRpZXMuYWRkKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2hvdyB3YXJuaW5nIGlmIHByb3BlcnRpZXMgZGlmZmVyIGFjcm9zcyBjb250ZW50IHR5cGVzXG5cdFx0aWYgKHRpdGxlUHJvcGVydGllcy5zaXplID4gMSB8fCBkZXNjcmlwdGlvblByb3BlcnRpZXMuc2l6ZSA+IDEpIHtcblx0XHRcdGNvbnN0IHdhcm5pbmdEaXYgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICd2YXVsdC1jbXMtd2FybmluZycgfSk7XG5cdFx0XHRzZXRDc3NQcm9wcyh3YXJuaW5nRGl2LCB7XG5cdFx0XHRcdHBhZGRpbmc6ICcxMHB4Jyxcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiAndmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJyxcblx0XHRcdFx0Ym9yZGVyTGVmdDogJzNweCBzb2xpZCB2YXIoLS10ZXh0LXdhcm5pbmcpJyxcblx0XHRcdFx0bWFyZ2luQm90dG9tOiAnMTVweCdcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR3YXJuaW5nRGl2LmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0XHR0ZXh0OiAnXHUyNkEwXHVGRTBGIFdhcm5pbmc6IERpZmZlcmVudCBjb250ZW50IHR5cGVzIHVzZSBkaWZmZXJlbnQgcHJvcGVydGllcyBmb3IgdGl0bGUgb3IgZGVzY3JpcHRpb24uJyxcblx0XHRcdFx0YXR0cjogeyBzdHlsZTogJ21hcmdpbjogMCAwIDVweCAwOyBmb250LXdlaWdodDogYm9sZDsnIH1cblx0XHRcdH0pO1xuXHRcdFx0d2FybmluZ0Rpdi5jcmVhdGVFbCgncCcsIHtcblx0XHRcdFx0dGV4dDogJ1RoZSBTRU8gcGx1Z2luIHdpbGwgdXNlIHRoZSBmaXJzdCBjb250ZW50IHR5cGVcXCdzIHByb3BlcnRpZXMuIFlvdSBtYXkgbmVlZCB0byBtYW51YWxseSBjb25maWd1cmUgU0VPIHNldHRpbmdzIGZvciBvdGhlciBjb250ZW50IHR5cGVzLicsXG5cdFx0XHRcdGF0dHI6IHsgc3R5bGU6ICdtYXJnaW46IDA7JyB9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoZmlyc3RQcm9wcykge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnQ29uZmlndXJhdGlvbjonIH0pO1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxuXHRcdFx0XHR0ZXh0OiBgVGl0bGUgcHJvcGVydHk6ICR7Zmlyc3RQcm9wcy50aXRsZVByb3BlcnR5IHx8ICcodXNpbmcgZmlsZW5hbWUpJ31gIFxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoZmlyc3RQcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdFx0XHR0ZXh0OiBgRGVzY3JpcHRpb24gcHJvcGVydHk6ICR7Zmlyc3RQcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5fWAgXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzY2FuRGlycyA9IGVuYWJsZWRUeXBlc1xuXHRcdFx0XHQubWFwKGN0ID0+IGN0LmZvbGRlcilcblx0XHRcdFx0LmpvaW4oJywgJyk7XG5cblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdFx0dGV4dDogYFNjYW4gZGlyZWN0b3JpZXM6ICR7c2NhbkRpcnN9YCBcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBzYXZlZCBzY2FuRGlyZWN0b3JpZXMgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgZGVmYXVsdCB0byBlbmFibGVkIGNvbnRlbnQgdHlwZSBmb2xkZXJzXG5cdFx0Ly8gVXNlIFBhdGhSZXNvbHZlciB0byBnZXQgdGhlIGNvcnJlY3QgZm9sZGVyIHBhdGhzIChlLmcuLCBcImNvbnRlbnQvZG9jc1wiIGluc3RlYWQgb2YgXCJkb2NzXCIpXG5cdFx0Y29uc3QgcGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcih0aGlzLmFwcCk7XG5cdFx0Y29uc3QgZGVmYXVsdFNjYW5EaXJzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXNcblx0XHRcdC5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZClcblx0XHRcdC5tYXAoY3QgPT4gcGF0aFJlc29sdmVyLmdldEZvbGRlclBhdGhGcm9tVmF1bHRSb290KGN0LmZvbGRlciwgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKSlcblx0XHRcdC5qb2luKCcsJyk7XG5cdFx0Y29uc3Qgc2F2ZWRTY2FuRGlycyA9IHRoaXMuc3RhdGUuc2VvQ29uZmlnPy5zY2FuRGlyZWN0b3JpZXM7XG5cdFx0Y29uc3QgaW5pdGlhbFNjYW5EaXJzID0gc2F2ZWRTY2FuRGlycyAmJiBzYXZlZFNjYW5EaXJzLnRyaW0oKSA/IHNhdmVkU2NhbkRpcnMgOiBkZWZhdWx0U2NhbkRpcnM7XG5cdFx0XG5cdFx0Ly8gSW5pdGlhbGl6ZSBzY2FuRGlyZWN0b3JpZXMgaWYgbm90IHNldFxuXHRcdGlmICghdGhpcy5zdGF0ZS5zZW9Db25maWcuc2NhbkRpcmVjdG9yaWVzIHx8ICF0aGlzLnN0YXRlLnNlb0NvbmZpZy5zY2FuRGlyZWN0b3JpZXMudHJpbSgpKSB7XG5cdFx0XHR0aGlzLnN0YXRlLnNlb0NvbmZpZy5zY2FuRGlyZWN0b3JpZXMgPSBpbml0aWFsU2NhbkRpcnM7XG5cdFx0fVxuXHRcdFxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1NjYW4gZGlyZWN0b3JpZXMnKVxuXHRcdFx0LnNldERlc2MoJ0NvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGRpcmVjdG9yaWVzIHRvIHNjYW4gKHlvdSBjYW4gY3VzdG9taXplIHRoaXMpJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0VmFsdWUoaW5pdGlhbFNjYW5EaXJzKVxuXHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdC8vIFN0b3JlIGN1c3RvbSBzY2FuIGRpcmVjdG9yaWVzIGlmIHVzZXIgY2hhbmdlcyB0aGVtXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3RhdGUuc2VvQ29uZmlnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLnNlb0NvbmZpZy5zY2FuRGlyZWN0b3JpZXMgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblx0fVxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ1NFTyBjb25maWd1cmF0aW9uJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb25maWd1cmUgU0VPIHBsdWdpbic7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZywgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wcyAobWF5IG5vdCBiZSBpbiB0eXBlcyB5ZXQpXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuXHR9XG59XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBQbHVnaW5NYW5hZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvUGx1Z2luTWFuYWdlcic7XG5cbmludGVyZmFjZSBQbHVnaW5JbmZvIHtcblx0aWQ6IHN0cmluZztcblx0bmFtZTogc3RyaW5nO1xuXHRjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfCAnbmljZS10by1oYXZlJztcbn1cblxuZXhwb3J0IGNsYXNzIE9wdGlvbmFsUGx1Z2luc1N0ZXAgZXh0ZW5kcyBCYXNlV2l6YXJkU3RlcCB7XG5cdHByaXZhdGUgcGx1Z2luTWFuYWdlcjogUGx1Z2luTWFuYWdlcjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xuXHRcdHN1cGVyKGFwcCwgY29udGFpbmVyRWwsIHN0YXRlLCBvbk5leHQsIG9uQmFjaywgb25DYW5jZWwpO1xuXHRcdHRoaXMucGx1Z2luTWFuYWdlciA9IG5ldyBQbHVnaW5NYW5hZ2VyKGFwcCk7XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1BsdWdpbiBjb25maWd1cmF0aW9uJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcblx0XHRcdHRleHQ6ICdSZXZpZXcgYW5kIGNvbmZpZ3VyZSB5b3VyIGluc3RhbGxlZCBwbHVnaW5zLiBFc3NlbnRpYWwgcGx1Z2lucyBhcmUgcmVjb21tZW5kZWQgZm9yIHRoZSBjb3JlIFZhdWx0IENNUyBleHBlcmllbmNlLidcblx0XHR9KTtcblxuXHRcdC8vIERlZmluZSBhbGwgcGx1Z2lucyB3aXRoIHRoZWlyIGNhdGVnb3JpZXNcblx0XHRjb25zdCBhbGxQbHVnaW5zOiBQbHVnaW5JbmZvW10gPSBbXG5cdFx0XHQvLyBFc3NlbnRpYWwgcGx1Z2lucyAoYWxwaGFiZXRpY2FsbHkgb3JkZXJlZClcblx0XHRcdHsgaWQ6ICdhc3Ryby1jb21wb3NlcicsIG5hbWU6ICdBc3RybyBDb21wb3NlcicsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ2Jhc2VzLWNtcycsIG5hbWU6ICdCYXNlcyBDTVMnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICduZXctdGFiLWRlZmF1bHQtcGFnZScsIG5hbWU6ICdEZWZhdWx0IE5ldyBUYWIgUGFnZScsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ2VkaXRpbmctdG9vbGJhcicsIG5hbWU6ICdFZGl0aW5nIFRvb2xiYXInLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdob21lLWJhc2UnLCBuYW1lOiAnSG9tZSBCYXNlJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnaG9tZXBhZ2UnLCBuYW1lOiAnSG9tZXBhZ2UnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdpbWFnZS1tYW5hZ2VyJywgbmFtZTogJ0ltYWdlIE1hbmFnZXInLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdvYnNpZGlhbi1wYXN0ZS1pbWFnZS1yZW5hbWUnLCBuYW1lOiAnUGFzdGUgSW1hZ2UgUmVuYW1lJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAncHJvcGVydHktb3Zlci1maWxlLW5hbWUnLCBuYW1lOiAnUHJvcGVydHkgT3ZlciBGaWxlIE5hbWUnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdzZW8nLCBuYW1lOiAnU0VPJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAndWktdHdlYWtlcicsIG5hbWU6ICdVSSBUd2Vha2VyJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnc2ltcGxlLWZvY3VzJywgbmFtZTogJ1NpbXBsZSBGb2N1cycsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ3N0YXR1c2Jhci1vcmdhbml6ZXInLCBuYW1lOiAnU3RhdHVzIEJhciBPcmdhbml6ZXInLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdC8vIE5pY2UgdG8gaGF2ZSBwbHVnaW5zIChhbHBoYWJldGljYWxseSBvcmRlcmVkKVxuXHRcdFx0eyBpZDogJ2FsaWFzLWZpbGUtbmFtZS1oaXN0b3J5JywgbmFtZTogJ0FsaWFzIEZpbGUgTmFtZSBIaXN0b3J5JywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAnZGF0YS1maWxlcy1lZGl0b3InLCBuYW1lOiAnRGF0YSBGaWxlcyBFZGl0b3InLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICdpY29uaWMnLCBuYW1lOiAnSWNvbmljJywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAncGFzdGUtaW1hZ2UtaW50by1wcm9wZXJ0eScsIG5hbWU6ICdQYXN0ZSBJbWFnZSBJbnRvIFByb3BlcnR5JywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAnc2V0dGluZ3Mtc2VhcmNoJywgbmFtZTogJ1NldHRpbmdzIFNlYXJjaCcsIGNhdGVnb3J5OiAnbmljZS10by1oYXZlJyB9LFxuXHRcdFx0eyBpZDogJ3RhZy13cmFuZ2xlcicsIG5hbWU6ICdUYWcgV3JhbmdsZXInLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICd6ZW5tb2RlJywgbmFtZTogJ1plbiBNb2RlJywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAnZXhwbG9yZXItZm9jdXMnLCBuYW1lOiAnRXhwbG9yZXIgRm9jdXMnLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfVxuXHRcdF07XG5cblx0XHQvLyBHZXQgaW5zdGFsbGVkIHBsdWdpbnNcblx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+OyBlbmFibGVkUGx1Z2lucz86IFNldDxzdHJpbmc+IH0gfSkucGx1Z2lucztcblx0XHRjb25zdCBpbnN0YWxsZWRQbHVnaW5JZHMgPSBwbHVnaW5zPy5wbHVnaW5zID8gT2JqZWN0LmtleXMocGx1Z2lucy5wbHVnaW5zKSA6IFtdO1xuXG5cdFx0Ly8gRmlsdGVyIHRvIG9ubHkgc2hvdyBpbnN0YWxsZWQgcGx1Z2lucyAoZXhjbHVkaW5nIGlnbm9yZWQgb25lcylcblx0XHRjb25zdCBpZ25vcmVkUGx1Z2lucyA9IFtcblx0XHRcdCdvYnNpZGlhbjQyLWJyYXQnLFxuXHRcdFx0J2FzdHJvLW1vZHVsYXItc2V0dGluZ3MnLFxuXHRcdFx0J2ZvbGRlci1ub3RlcycsXG5cdFx0XHQnZGlzYWJsZS10YWJzJyxcblx0XHRcdCd2YXVsdC1jbXMnIC8vIERvbid0IHNob3cgVmF1bHQgQ01TIHBsdWdpbiBpdHNlbGZcblx0XHRdO1xuXG5cdFx0Y29uc3QgZXNzZW50aWFsUGx1Z2lucyA9IGFsbFBsdWdpbnMuZmlsdGVyKHAgPT5cblx0XHRcdHAuY2F0ZWdvcnkgPT09ICdlc3NlbnRpYWwnICYmXG5cdFx0XHRpbnN0YWxsZWRQbHVnaW5JZHMuaW5jbHVkZXMocC5pZCkgJiZcblx0XHRcdCFpZ25vcmVkUGx1Z2lucy5pbmNsdWRlcyhwLmlkKVxuXHRcdCk7XG5cdFx0Ly8gRmlsdGVyIG5pY2UtdG8taGF2ZSBwbHVnaW5zIGFuZCBzb3J0IGFscGhhYmV0aWNhbGx5IGJ5IG5hbWVcblx0XHRjb25zdCBuaWNlVG9IYXZlUGx1Z2lucyA9IGFsbFBsdWdpbnNcblx0XHRcdC5maWx0ZXIocCA9PlxuXHRcdFx0XHRwLmNhdGVnb3J5ID09PSAnbmljZS10by1oYXZlJyAmJlxuXHRcdFx0XHRpbnN0YWxsZWRQbHVnaW5JZHMuaW5jbHVkZXMocC5pZCkgJiZcblx0XHRcdFx0IWlnbm9yZWRQbHVnaW5zLmluY2x1ZGVzKHAuaWQpXG5cdFx0XHQpXG5cdFx0XHQuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XG5cblx0XHQvLyBFc3NlbnRpYWwgcGx1Z2lucyBzZWN0aW9uXG5cdFx0aWYgKGVzc2VudGlhbFBsdWdpbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnRXNzZW50aWFsIHBsdWdpbnMnLCBjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1oZWFkZXInIH0pO1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHRcdHRleHQ6ICdUaGVzZSBwbHVnaW5zIGFyZSByZWNvbW1lbmRlZCBmb3IgdGhlIGNvcmUgVmF1bHQgQ01TIGV4cGVyaWVuY2UuJyxcblx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLXNlY3Rpb24tZGVzYydcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKGNvbnN0IHBsdWdpbiBvZiBlc3NlbnRpYWxQbHVnaW5zKSB7XG5cdFx0XHRcdGNvbnN0IHBsdWdpbkluc3RhbmNlID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbi5pZF07XG5cdFx0XHRcdGNvbnN0IGlzSW5zdGFsbGVkID0gISFwbHVnaW5JbnN0YW5jZTtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgcGx1Z2luIGlzIGVuYWJsZWQgLSB1c2UgZW5hYmxlZFBsdWdpbnMgU2V0IChtb3JlIHJlbGlhYmxlKVxuXHRcdFx0XHRjb25zdCBwbHVnaW5JbnN0YW5jZVR5cGVkID0gcGx1Z2luSW5zdGFuY2UgYXMgeyBlbmFibGVkPzogYm9vbGVhbiB9IHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRjb25zdCBpc0N1cnJlbnRseUVuYWJsZWQgPSBwbHVnaW5zPy5lbmFibGVkUGx1Z2lucz8uaGFzPy4ocGx1Z2luLmlkKSA/PyBwbHVnaW5JbnN0YW5jZVR5cGVkPy5lbmFibGVkID8/IGZhbHNlO1xuXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYFBsdWdpbiAke3BsdWdpbi5pZH06IGluc3RhbGxlZD0ke2lzSW5zdGFsbGVkfSwgZW5hYmxlZD0ke2lzQ3VycmVudGx5RW5hYmxlZH1gKTtcblxuXHRcdFx0XHQvLyBTeW5jIHN0YXRlIHdpdGggYWN0dWFsIHBsdWdpbiBzdGF0ZVxuXHRcdFx0XHRpZiAoaXNJbnN0YWxsZWQgJiYgaXNDdXJyZW50bHlFbmFibGVkKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5pZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMucHVzaChwbHVnaW4uaWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucyA9IHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zLmZpbHRlcihwID0+IHAgIT09IHBsdWdpbi5pZCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNJbnN0YWxsZWQgJiYgIWlzQ3VycmVudGx5RW5hYmxlZCkge1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMgPSB0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLmZpbHRlcihwID0+IHAgIT09IHBsdWdpbi5pZCk7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uaWQpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucy5wdXNoKHBsdWdpbi5pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHRcdC5zZXROYW1lKHBsdWdpbi5uYW1lKVxuXHRcdFx0XHRcdC5zZXREZXNjKGlzSW5zdGFsbGVkID9cblx0XHRcdFx0XHRcdChpc0N1cnJlbnRseUVuYWJsZWQgPyAnSW5zdGFsbGVkIGFuZCBlbmFibGVkJyA6ICdJbnN0YWxsZWQgYnV0IGRpc2FibGVkJykgOlxuXHRcdFx0XHRcdFx0J05vdCBpbnN0YWxsZWQnKTtcblxuXHRcdFx0XHQvLyBBZGQgaWNvbiBpbnN0ZWFkIG9mIHRvZ2dsZVxuXHRcdFx0XHRjb25zdCBpY29uQ29udGFpbmVyID0gc2V0dGluZy5jb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAndmF1bHQtY21zLXBsdWdpbi1zdGF0dXMnIH0pO1xuXHRcdFx0XHRpZiAoaXNJbnN0YWxsZWQgJiYgaXNDdXJyZW50bHlFbmFibGVkKSB7XG5cdFx0XHRcdFx0c2V0SWNvbihpY29uQ29udGFpbmVyLCAnbHVjaWRlLWNoZWNrLWNpcmNsZS0yJyk7XG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoaWNvbkNvbnRhaW5lciwgeyBjb2xvcjogJ3ZhcigtLXRleHQtc3VjY2VzcyknIH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldEljb24oaWNvbkNvbnRhaW5lciwgJ2x1Y2lkZS14LWNpcmNsZScpO1xuXHRcdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgY29sb3I6ICd2YXIoLS10ZXh0LWVycm9yKScgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBOaWNlIHRvIGhhdmUgcGx1Z2lucyBzZWN0aW9uXG5cdFx0aWYgKG5pY2VUb0hhdmVQbHVnaW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ05pY2UgdG8gaGF2ZSBwbHVnaW5zJywgY2xzOiAndmF1bHQtY21zLXNlY3Rpb24taGVhZGVyJyB9KTtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0XHR0ZXh0OiAnVGhlc2UgcGx1Z2lucyBjYW4gYmUgaGVscGZ1bCBkZXBlbmRpbmcgb24geW91ciB0aGVtZVxcJ3MgY2FwYWJpbGl0aWVzIGFuZCB3b3JrZmxvdyBuZWVkcy4nLFxuXHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1kZXNjJ1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoY29uc3QgcGx1Z2luIG9mIG5pY2VUb0hhdmVQbHVnaW5zKSB7XG5cdFx0XHRcdGNvbnN0IHBsdWdpbkluc3RhbmNlID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbi5pZF07XG5cdFx0XHRcdGNvbnN0IGlzSW5zdGFsbGVkID0gISFwbHVnaW5JbnN0YW5jZTtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgcGx1Z2luIGlzIGVuYWJsZWQgLSB1c2UgZW5hYmxlZFBsdWdpbnMgU2V0IChtb3JlIHJlbGlhYmxlKVxuXHRcdFx0XHRjb25zdCBwbHVnaW5JbnN0YW5jZVR5cGVkID0gcGx1Z2luSW5zdGFuY2UgYXMgeyBlbmFibGVkPzogYm9vbGVhbiB9IHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRjb25zdCBpc0N1cnJlbnRseUVuYWJsZWQgPSBwbHVnaW5zPy5lbmFibGVkUGx1Z2lucz8uaGFzPy4ocGx1Z2luLmlkKSA/PyBwbHVnaW5JbnN0YW5jZVR5cGVkPy5lbmFibGVkID8/IGZhbHNlO1xuXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYFBsdWdpbiAke3BsdWdpbi5pZH06IGluc3RhbGxlZD0ke2lzSW5zdGFsbGVkfSwgZW5hYmxlZD0ke2lzQ3VycmVudGx5RW5hYmxlZH1gKTtcblxuXHRcdFx0XHQvLyBTeW5jIHN0YXRlIHdpdGggYWN0dWFsIHBsdWdpbiBzdGF0ZVxuXHRcdFx0XHRpZiAoaXNJbnN0YWxsZWQgJiYgaXNDdXJyZW50bHlFbmFibGVkKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5pZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMucHVzaChwbHVnaW4uaWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucyA9IHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zLmZpbHRlcihwID0+IHAgIT09IHBsdWdpbi5pZCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNJbnN0YWxsZWQgJiYgIWlzQ3VycmVudGx5RW5hYmxlZCkge1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMgPSB0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLmZpbHRlcihwID0+IHAgIT09IHBsdWdpbi5pZCk7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uaWQpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucy5wdXNoKHBsdWdpbi5pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHRcdC5zZXROYW1lKHBsdWdpbi5uYW1lKVxuXHRcdFx0XHRcdC5zZXREZXNjKGlzSW5zdGFsbGVkID9cblx0XHRcdFx0XHRcdChpc0N1cnJlbnRseUVuYWJsZWQgPyAnSW5zdGFsbGVkIGFuZCBlbmFibGVkJyA6ICdJbnN0YWxsZWQgYnV0IGRpc2FibGVkJykgOlxuXHRcdFx0XHRcdFx0J05vdCBpbnN0YWxsZWQnKTtcblxuXHRcdFx0XHQvLyBBZGQgaWNvbiBpbnN0ZWFkIG9mIHRvZ2dsZVxuXHRcdFx0XHRjb25zdCBpY29uQ29udGFpbmVyID0gc2V0dGluZy5jb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAndmF1bHQtY21zLXBsdWdpbi1zdGF0dXMnIH0pO1xuXHRcdFx0XHRpZiAoaXNJbnN0YWxsZWQgJiYgaXNDdXJyZW50bHlFbmFibGVkKSB7XG5cdFx0XHRcdFx0c2V0SWNvbihpY29uQ29udGFpbmVyLCAnbHVjaWRlLWNoZWNrLWNpcmNsZS0yJyk7XG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoaWNvbkNvbnRhaW5lciwgeyBjb2xvcjogJ3ZhcigtLXRleHQtc3VjY2VzcyknIH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldEljb24oaWNvbkNvbnRhaW5lciwgJ2x1Y2lkZS14LWNpcmNsZScpO1xuXHRcdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgY29sb3I6ICd2YXIoLS10ZXh0LWVycm9yKScgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiBubyBwbHVnaW5zIGZvdW5kXG5cdFx0aWYgKGVzc2VudGlhbFBsdWdpbnMubGVuZ3RoID09PSAwICYmIG5pY2VUb0hhdmVQbHVnaW5zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHRcdHRleHQ6ICdObyBWYXVsdCBDTVMgcGx1Z2lucyBkZXRlY3RlZC4gTWFrZSBzdXJlIHlvdSBoYXZlIGluc3RhbGxlZCB0aGUgcmVjb21tZW5kZWQgcGx1Z2lucy4nXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdPcHRpb25hbCBQbHVnaW5zJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb25maWd1cmUgb3B0aW9uYWwgcGx1Z2lucyc7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbmV4cG9ydCBjbGFzcyBQbHVnaW5NYW5hZ2VyIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRhc3luYyBlbmFibGVQbHVnaW4ocGx1Z2luSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiB7IHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCB7IGVuYWJsZWQ/OiBib29sZWFuIH0+OyBlbmFibGVQbHVnaW4/OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB9IH0pLnBsdWdpbnM7XHJcblx0XHRpZiAoIXBsdWdpbnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnMucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdGlmIChwbHVnaW4gJiYgIXBsdWdpbi5lbmFibGVkKSB7XHJcblx0XHRcdGF3YWl0IHBsdWdpbnMuZW5hYmxlUGx1Z2luPy4ocGx1Z2luSWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgZGlzYWJsZVBsdWdpbihwbHVnaW5JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHsgZW5hYmxlZD86IGJvb2xlYW4gfT47IGRpc2FibGVQbHVnaW4/OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB9IH0pLnBsdWdpbnM7XHJcblx0XHRpZiAoIXBsdWdpbnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnMucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdGlmIChwbHVnaW4gJiYgcGx1Z2luLmVuYWJsZWQpIHtcclxuXHRcdFx0YXdhaXQgcGx1Z2lucy5kaXNhYmxlUGx1Z2luPy4ocGx1Z2luSWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgc2V0UGx1Z2luU3RhdGVzKGVuYWJsZWQ6IHN0cmluZ1tdLCBkaXNhYmxlZDogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdC8vIEZpbHRlciBvdXQgY29yZSBwbHVnaW5zIGZyb20gZGlzYWJsZWQgbGlzdCBqdXN0IGluIGNhc2VcclxuXHRcdGNvbnN0IGNvcmVQbHVnaW5zID0gWydiYXNlcy1jbXMnLCAnYXN0cm8tY29tcG9zZXInLCAndmF1bHQtY21zJ107XHJcblx0XHRjb25zdCBzYWZlRGlzYWJsZWQgPSBkaXNhYmxlZC5maWx0ZXIocCA9PiAhY29yZVBsdWdpbnMuaW5jbHVkZXMocCkpO1xyXG5cclxuXHRcdC8vIERpc2FibGUgcGx1Z2lucyBmaXJzdFxyXG5cdFx0Zm9yIChjb25zdCBwbHVnaW5JZCBvZiBzYWZlRGlzYWJsZWQpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5kaXNhYmxlUGx1Z2luKHBsdWdpbklkKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUaGVuIGVuYWJsZSBwbHVnaW5zXHJcblx0XHRmb3IgKGNvbnN0IHBsdWdpbklkIG9mIGVuYWJsZWQpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5lbmFibGVQbHVnaW4ocGx1Z2luSWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0UHJlc2V0UGx1Z2lucyhwcmVzZXQ6ICd2YW5pbGxhJyB8ICdvcGluaW9uYXRlZCcgfCAnY3VzdG9tJyk6IHsgZW5hYmxlZDogc3RyaW5nW107IGRpc2FibGVkOiBzdHJpbmdbXSB9IHtcclxuXHRcdC8vIENvcmUgcGx1Z2lucyB0aGF0IHNob3VsZCBhbHdheXMgYmUgZW5hYmxlZCAobm90IG9wdGlvbmFsKVxyXG5cdFx0Y29uc3QgY29yZVBsdWdpbnMgPSBbXHJcblx0XHRcdCdhc3Ryby1jb21wb3NlcicsXHJcblx0XHRcdCdiYXNlcy1jbXMnLFxyXG5cdFx0XHQnaG9tZXBhZ2UnLFxyXG5cdFx0XHQnbmV3LXRhYi1kZWZhdWx0LXBhZ2UnLFxyXG5cdFx0XHQncHJvcGVydHktb3Zlci1maWxlLW5hbWUnLFxyXG5cdFx0XHQnc2V0dGluZ3Mtc2VhcmNoJyxcclxuXHRcdFx0J3N0YXR1c2Jhci1vcmdhbml6ZXInLFxyXG5cdFx0XHQnc2VvJyxcclxuXHRcdFx0J3VpLXR3ZWFrZXInLFxyXG5cdFx0XHQnemVubW9kZScsXHJcblx0XHRcdCdjbWRyJyxcclxuXHRcdFx0J3NpbXBsZS1mb2N1cycsXHJcblx0XHRcdCd0YWctd3JhbmdsZXInXHJcblx0XHRdO1xyXG5cclxuXHRcdC8vIE9wdGlvbmFsIHBsdWdpbnMgdGhhdCBjYW4gYmUgZW5hYmxlZC9kaXNhYmxlZFxyXG5cdFx0Y29uc3Qgb3B0aW9uYWxQbHVnaW5zID0gW1xyXG5cdFx0XHQnZWRpdGluZy10b29sYmFyJyxcclxuXHRcdFx0J2luc2VydC11bnNwbGFzaC1pbWFnZScsXHJcblx0XHRcdCdjdXN0b20tc2F2ZScsXHJcblx0XHRcdCd0aXRsZS1vbmx5LXRhYicsXHJcblx0XHRcdCdvYnNpZGlhbi1wYXN0ZS1pbWFnZS1yZW5hbWUnLFxyXG5cdFx0XHQnb2JzaWRpYW40Mi1icmF0JyxcclxuXHRcdFx0J29ic2lkaWFuLWhpZGVyJyxcclxuXHRcdFx0J2Rpc2FibGUtdGFicycsXHJcblx0XHRcdCdvYnNpZGlhbi1zdHlsZS1zZXR0aW5ncycsXHJcblx0XHRcdCdtZHgtYXMtbWQtb2JzaWRpYW4nLFxyXG5cdFx0XHQnZXhwbG9yZXItZm9jdXMnXHJcblx0XHRdO1xyXG5cclxuXHRcdC8vIE9waW5pb25hdGVkLXNwZWNpZmljIHBsdWdpbnNcclxuXHRcdGNvbnN0IG9waW5pb25hdGVkUGx1Z2lucyA9IFtcclxuXHRcdFx0J29ic2lkaWFuLW94eWdlbicsXHJcblx0XHRcdCdvYnNpZGlhbi1zdHlsZS1zZXR0aW5ncydcclxuXHRcdF07XHJcblxyXG5cdFx0aWYgKHByZXNldCA9PT0gJ3ZhbmlsbGEnKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZW5hYmxlZDogWy4uLmNvcmVQbHVnaW5zLCAuLi5vcHRpb25hbFBsdWdpbnMuZmlsdGVyKHAgPT4gIW9waW5pb25hdGVkUGx1Z2lucy5pbmNsdWRlcyhwKSldLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBvcGluaW9uYXRlZFBsdWdpbnNcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiAocHJlc2V0ID09PSAnb3BpbmlvbmF0ZWQnKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZW5hYmxlZDogWy4uLmNvcmVQbHVnaW5zLCAuLi5vcHRpb25hbFBsdWdpbnNdLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBbXVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gQ3VzdG9tIC0gcmV0dXJuIGFsbCBhcyBhdmFpbGFibGVcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRlbmFibGVkOiBbXSxcclxuXHRcdFx0XHRkaXNhYmxlZDogW11cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFByb2plY3RPcHRpbWl6ZXIgfSBmcm9tICcuLi8uLi91dGlscy9Qcm9qZWN0T3B0aW1pemVyJztcblxuZXhwb3J0IGNsYXNzIElnbm9yZVN0ZXAgZXh0ZW5kcyBCYXNlV2l6YXJkU3RlcCB7XG5cdHByaXZhdGUgb3B0aW1pemVyOiBQcm9qZWN0T3B0aW1pemVyO1xuXHRwcml2YXRlIGdpdFNldHRpbmc6IFNldHRpbmc7XG5cdHByaXZhdGUgdml0ZVNldHRpbmc6IFNldHRpbmc7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHAsIGNvbnRhaW5lckVsLCBzdGF0ZSwgb25OZXh0LCBvbkJhY2ssIG9uQ2FuY2VsKTtcblx0XHR0aGlzLm9wdGltaXplciA9IG5ldyBQcm9qZWN0T3B0aW1pemVyKGFwcCwgc3RhdGUpO1xuXHR9XG5cblx0YXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLm9wdGltaXplci5nZXRTdGF0dXMoKTtcblx0XHR0aGlzLnN0YXRlLmlnbm9yZUNvbmZpZy5naXRJZ25vcmVDb25maWd1cmVkID0gc3RhdHVzLmdpdElnbm9yZVN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnO1xuXHRcdHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnLnZpdGVJZ25vcmVDb25maWd1cmVkID0gc3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMgPT09ICdjb25maWd1cmVkJztcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3Qgb3B0aW1pemF0aW9uIChvcHRpb25hbCknIH0pO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0dGV4dDogJ09wdGltaXplIHlvdXIgcHJvamVjdCBieSBpZ25vcmluZyBPYnNpZGlhbi1zcGVjaWZpYyBmaWxlcyBpbiBHaXQgYW5kIFZpdGUuJ1xuXHRcdH0pO1xuXG5cdFx0Ly8gR2l0IElnbm9yZSBTZXR0aW5nXG5cdFx0dGhpcy5naXRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpO1xuXHRcdHRoaXMudXBkYXRlR2l0U2V0dGluZyhzdGF0dXMuZ2l0SWdub3JlU3RhdHVzKTtcblxuXHRcdC8vIFZpdGUgSWdub3JlIFNldHRpbmdcblx0XHR0aGlzLnZpdGVTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpO1xuXHRcdHRoaXMudXBkYXRlVml0ZVNldHRpbmcoc3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVHaXRTZXR0aW5nKHN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJykge1xuXHRcdHRoaXMuZ2l0U2V0dGluZy5zZXROYW1lKCdJZ25vcmUgd29ya3NwYWNlIGZpbGVzIGluIEdpdCcpXG5cdFx0XHQuc2V0RGVzYygnQWRkIE9ic2lkaWFuIHdvcmtzcGFjZSBmaWxlcyB0byAuZ2l0aWdub3JlIHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlaW5nIHRyYWNrZWQuJylcblx0XHRcdC5jbGVhcigpOyAvLyBDbGVhciBleGlzdGluZyBidXR0b25zIGFuZCBzdGF0dXNcblxuXHRcdHRoaXMuZ2l0U2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLm9wdGltaXplci5jb25maWd1cmVHaXRJZ25vcmUoKTtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnLmdpdElnbm9yZUNvbmZpZ3VyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnLmdpdGlnbm9yZSB1cGRhdGVkJyk7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXdTdGF0dXMgPSBhd2FpdCB0aGlzLm9wdGltaXplci5nZXRTdGF0dXMoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlR2l0U2V0dGluZyhuZXdTdGF0dXMuZ2l0SWdub3JlU3RhdHVzKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHVwZGF0ZSAuZ2l0aWdub3JlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5vcHRpbWl6ZXIucmVuZGVyU3RhdHVzKHRoaXMuZ2l0U2V0dGluZy5jb250cm9sRWwsIHN0YXR1cyk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVZpdGVTZXR0aW5nKHN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJykge1xuXHRcdHRoaXMudml0ZVNldHRpbmcuc2V0TmFtZSgnSWdub3JlIHdvcmtzcGFjZSBhbmQgYmFzZXMgZm9sZGVycyBpbiBWaXRlJylcblx0XHRcdC5zZXREZXNjKCdDb25maWd1cmUgVml0ZSB0byBpZ25vcmUgT2JzaWRpYW4gYW5kIGJhc2VzIGZvbGRlcnMuJylcblx0XHRcdC5jbGVhcigpOyAvLyBDbGVhciBleGlzdGluZyBidXR0b25zIGFuZCBzdGF0dXNcblxuXHRcdHRoaXMudml0ZVNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG5cdFx0XHRidXR0b24uc2V0QnV0dG9uVGV4dChzdGF0dXMgPT09ICdjb25maWd1cmVkJyA/ICdSZS1jb25maWd1cmUnIDogJ0NvbmZpZ3VyZScpXG5cdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5vcHRpbWl6ZXIuY29uZmlndXJlVml0ZUlnbm9yZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5pZ25vcmVDb25maWcudml0ZUlnbm9yZUNvbmZpZ3VyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnVml0ZSBvcHRpbWl6YXRpb24gYXBwbGllZCcpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3U3RhdHVzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuZ2V0U3RhdHVzKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZVZpdGVTZXR0aW5nKG5ld1N0YXR1cy52aXRlSWdub3JlU3RhdHVzKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHVwZGF0ZSBWaXRlIGNvbmZpZzogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMub3B0aW1pemVyLnJlbmRlclN0YXR1cyh0aGlzLnZpdGVTZXR0aW5nLmNvbnRyb2xFbCwgc3RhdHVzKTtcblx0fVxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ1Byb2plY3Qgb3B0aW1pemF0aW9uIChvcHRpb25hbCknO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ0NvbmZpZ3VyZSBwcm9qZWN0LWxldmVsIGlnbm9yZXMnO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBzZXRJY29uIH0gZnJvbSAnb2JzaWRpYW4nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlcyAtLSBOb2RlLmpzIG1vZHVsZSBuZWVkZWQgZm9yIHBhdGggb3BlcmF0aW9uc1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBmaWxlIG9wZXJhdGlvbnNcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGltaXphdGlvblN0YXR1cyB7XG5cdGdpdElnbm9yZVN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJztcblx0dml0ZUlnbm9yZVN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzXG4gKi9cbmZ1bmN0aW9uIHNldENzc1Byb3BzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFByb2plY3RPcHRpbWl6ZXIge1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXHRwcml2YXRlIHN0YXRlOiBXaXphcmRTdGF0ZTtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgc3RhdGU6IFdpemFyZFN0YXRlKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xuXHR9XG5cblx0cHVibGljIGFzeW5jIGdldFN0YXR1cygpOiBQcm9taXNlPE9wdGltaXphdGlvblN0YXR1cz4ge1xuXHRcdGNvbnN0IHN0YXR1czogT3B0aW1pemF0aW9uU3RhdHVzID0ge1xuXHRcdFx0Z2l0SWdub3JlU3RhdHVzOiAnbm90LWNvbmZpZ3VyZWQnLFxuXHRcdFx0dml0ZUlnbm9yZVN0YXR1czogJ25vdC1jb25maWd1cmVkJ1xuXHRcdH07XG5cblx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3Q7XG5cdFx0aWYgKCFwcm9qZWN0Um9vdCkge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogTm8gcHJvamVjdFJvb3QgaW4gc3RhdGUnKTtcblx0XHRcdHJldHVybiBzdGF0dXM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IENoZWNraW5nIHN0YXR1cyBmb3Igcm9vdDonLCBwcm9qZWN0Um9vdCwgJ2NvbmZpZ0RpcjonLCBjb25maWdEaXIpO1xuXG5cdFx0Ly8gQ2hlY2sgLmdpdGlnbm9yZVxuXHRcdGNvbnN0IGdpdElnbm9yZVBhdGggPSBwYXRoLmpvaW4ocHJvamVjdFJvb3QsICcuZ2l0aWdub3JlJyk7XG5cdFx0aWYgKGZzLmV4aXN0c1N5bmMoZ2l0SWdub3JlUGF0aCkpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZ2l0SWdub3JlUGF0aCwgJ3V0ZjgnKTtcblx0XHRcdGNvbnN0IGlzQ29uZmlndXJlZCA9IGNvbnRlbnQuaW5jbHVkZXMoYCR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvbmApIHx8IGNvbnRlbnQuaW5jbHVkZXMoYCoqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvbmApO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogLmdpdGlnbm9yZSBleGlzdHMsIGNvbmZpZ3VyZWQ6JywgaXNDb25maWd1cmVkKTtcblx0XHRcdGlmIChpc0NvbmZpZ3VyZWQpIHtcblx0XHRcdFx0c3RhdHVzLmdpdElnbm9yZVN0YXR1cyA9ICdjb25maWd1cmVkJztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogLmdpdGlnbm9yZSBOT1QgZm91bmQgYXQ6JywgZ2l0SWdub3JlUGF0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgVml0ZSBjb25maWdcblx0XHRjb25zdCBhc3Ryb0NvbmZpZ05hbWVzID0gWydhc3Ryby5jb25maWcudHMnLCAnYXN0cm8uY29uZmlnLm1qcycsICdhc3Ryby5jb25maWcuanMnLCAnYXN0cm8uY29uZmlnLm10cycsICdhc3Ryby5jb25maWcuY2pzJ107XG5cdFx0bGV0IHJlc29sdmVkVml0ZUNvbmZpZ1BhdGggPSAnJztcblxuXHRcdGZvciAoY29uc3QgbmFtZSBvZiBhc3Ryb0NvbmZpZ05hbWVzKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aC5qb2luKHByb2plY3RSb290LCBuYW1lKTtcblx0XHRcdGlmIChmcy5leGlzdHNTeW5jKHApKSB7XG5cdFx0XHRcdHJlc29sdmVkVml0ZUNvbmZpZ1BhdGggPSBwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlc29sdmVkVml0ZUNvbmZpZ1BhdGggJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0cmVzb2x2ZWRWaXRlQ29uZmlnUGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aDtcblx0XHR9XG5cblx0XHRpZiAocmVzb2x2ZWRWaXRlQ29uZmlnUGF0aCAmJiBmcy5leGlzdHNTeW5jKHJlc29sdmVkVml0ZUNvbmZpZ1BhdGgpKSB7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdbVmF1bHQgQ01TXSBQcm9qZWN0T3B0aW1pemVyOiBDaGVja2luZyBWaXRlIGNvbmZpZyBhdDonLCByZXNvbHZlZFZpdGVDb25maWdQYXRoKTtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMocmVzb2x2ZWRWaXRlQ29uZmlnUGF0aCwgJ3V0ZjgnKTtcblx0XHRcdGNvbnN0IGhhc1dhdGNoSWdub3JlZCA9IGNvbnRlbnQuaW5jbHVkZXMoJ3NlcnZlci53YXRjaC5pZ25vcmVkJykgfHwgY29udGVudC5pbmNsdWRlcygnaWdub3JlZDonKTtcblx0XHRcdGNvbnN0IGhhc0NvbmZpZ0RpciA9IGNvbnRlbnQuaW5jbHVkZXMoY29uZmlnRGlyKTtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IFZpdGUgY29uZmlnIGhhcyBwYXR0ZXJuczonLCB7IGhhc1dhdGNoSWdub3JlZCwgaGFzQ29uZmlnRGlyIH0pO1xuXHRcdFx0aWYgKGhhc1dhdGNoSWdub3JlZCAmJiBoYXNDb25maWdEaXIpIHtcblx0XHRcdFx0c3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMgPSAnY29uZmlndXJlZCc7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IE5vIHZhbGlkIEFzdHJvIGNvbmZpZyBmb3VuZCB0byBjaGVjaycpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdGF0dXM7XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgY29uZmlndXJlR2l0SWdub3JlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGNvbnN0IHByb2plY3RSb290ID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdDtcblx0XHRpZiAoIXByb2plY3RSb290KSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdbVmF1bHQgQ01TXSBQcm9qZWN0T3B0aW1pemVyOiBObyBwcm9qZWN0Um9vdCBmb3IgR2l0IGNvbmZpZ3VyYXRpb24nKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XG5cdFx0Y29uc3QgZ2l0SWdub3JlUGF0aCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgJy5naXRpZ25vcmUnKTtcblx0XHRjb25zdCBydWxlcyA9IGBcXG4jIE9ic2lkaWFuIHdvcmtzcGFjZSBmaWxlc1xcbioqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvblxcbioqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UtbW9iaWxlLmpzb25cXG5gO1xuXG5cdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogQ29uZmlndXJpbmcgR2l0IGlnbm9yZSBhdDonLCBnaXRJZ25vcmVQYXRoKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoZnMuZXhpc3RzU3luYyhnaXRJZ25vcmVQYXRoKSkge1xuXHRcdFx0XHRsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhnaXRJZ25vcmVQYXRoLCAndXRmOCcpO1xuXHRcdFx0XHRjb25zdCBoYXNOZXdQYXR0ZXJuID0gY29udGVudC5pbmNsdWRlcyhgKiovJHtjb25maWdEaXJ9L3dvcmtzcGFjZS5qc29uYCk7XG5cdFx0XHRcdGNvbnN0IGhhc09sZFBhdHRlcm4gPSBjb250ZW50LmluY2x1ZGVzKGAqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvbmApIHx8IGNvbnRlbnQuaW5jbHVkZXMoYCR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvbmApO1xuXG5cdFx0XHRcdGlmIChoYXNPbGRQYXR0ZXJuICYmICFoYXNOZXdQYXR0ZXJuKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogVXBkYXRpbmcgb2xkIEdpdCBwYXR0ZXJucycpO1xuXHRcdFx0XHRcdC8vIFJlcGxhY2Ugb2xkIHBhdHRlcm5zIGlmIHRoZXkgZXhpc3Rcblx0XHRcdFx0XHRjb250ZW50ID0gY29udGVudC5yZXBsYWNlKG5ldyBSZWdFeHAoYFxcXFwqPy8/JHtjb25maWdEaXJ9L3dvcmtzcGFjZVxcXFwuanNvbmAsICdnJyksIGAqKi8ke2NvbmZpZ0Rpcn0vd29ya3NwYWNlLmpzb25gKTtcblx0XHRcdFx0XHRjb250ZW50ID0gY29udGVudC5yZXBsYWNlKG5ldyBSZWdFeHAoYFxcXFwqPy8/JHtjb25maWdEaXJ9L3dvcmtzcGFjZS1tb2JpbGVcXFxcLmpzb25gLCAnZycpLCBgKiovJHtjb25maWdEaXJ9L3dvcmtzcGFjZS1tb2JpbGUuanNvbmApO1xuXHRcdFx0XHRcdGZzLndyaXRlRmlsZVN5bmMoZ2l0SWdub3JlUGF0aCwgY29udGVudCwgJ3V0ZjgnKTtcblx0XHRcdFx0fSBlbHNlIGlmICghaGFzTmV3UGF0dGVybikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IEFkZGluZyBuZXcgR2l0IHBhdHRlcm5zJyk7XG5cdFx0XHRcdFx0Ly8gQWRkIG5ldyBydWxlcyBpZiBuZWl0aGVyIHBhdHRlcm4gZXhpc3RzXG5cdFx0XHRcdFx0Y29udGVudCArPSBydWxlcztcblx0XHRcdFx0XHRmcy53cml0ZUZpbGVTeW5jKGdpdElnbm9yZVBhdGgsIGNvbnRlbnQsICd1dGY4Jyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogR2l0IHBhdHRlcm5zIGFscmVhZHkgcHJlc2VudCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdbVmF1bHQgQ01TXSBQcm9qZWN0T3B0aW1pemVyOiBDcmVhdGluZyBuZXcgLmdpdGlnbm9yZScpO1xuXHRcdFx0XHRmcy53cml0ZUZpbGVTeW5jKGdpdElnbm9yZVBhdGgsIHJ1bGVzLCAndXRmOCcpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1tWYXVsdCBDTVNdIEZhaWxlZCB0byB1cGRhdGUgLmdpdGlnbm9yZTonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgY29uZmlndXJlVml0ZUlnbm9yZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3Q7XG5cdFx0aWYgKCFwcm9qZWN0Um9vdCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXG5cdFx0Y29uc3QgYXN0cm9Db25maWdOYW1lcyA9IFsnYXN0cm8uY29uZmlnLnRzJywgJ2FzdHJvLmNvbmZpZy5tanMnLCAnYXN0cm8uY29uZmlnLmpzJywgJ2FzdHJvLmNvbmZpZy5tdHMnLCAnYXN0cm8uY29uZmlnLmNqcyddO1xuXHRcdGxldCByZXNvbHZlZENvbmZpZ1BhdGggPSAnJztcblx0XHRsZXQgY29uZmlnRmlsZU5hbWUgPSAnJztcblxuXHRcdGZvciAoY29uc3QgbmFtZSBvZiBhc3Ryb0NvbmZpZ05hbWVzKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aC5qb2luKHByb2plY3RSb290LCBuYW1lKTtcblx0XHRcdGlmIChmcy5leGlzdHNTeW5jKHApKSB7XG5cdFx0XHRcdHJlc29sdmVkQ29uZmlnUGF0aCA9IHA7XG5cdFx0XHRcdGNvbmZpZ0ZpbGVOYW1lID0gbmFtZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFyZXNvbHZlZENvbmZpZ1BhdGggJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0cmVzb2x2ZWRDb25maWdQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoO1xuXHRcdFx0Y29uZmlnRmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHJlc29sdmVkQ29uZmlnUGF0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFyZXNvbHZlZENvbmZpZ1BhdGggfHwgIWZzLmV4aXN0c1N5bmMocmVzb2x2ZWRDb25maWdQYXRoKSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogVml0ZSBjb25maWcgTk9UIGZvdW5kIGluOicsIHByb2plY3RSb290KTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgQXN0cm8gY29uZmlnIGZpbGUgbm90IGZvdW5kIGluOiAke3Byb2plY3RSb290fWApO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IENvbmZpZ3VyaW5nIFZpdGUgaWdub3JlIGF0OicsIHJlc29sdmVkQ29uZmlnUGF0aCk7XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhyZXNvbHZlZENvbmZpZ1BhdGgsICd1dGY4Jyk7XG5cblx0XHRcdGlmIChjb250ZW50LmluY2x1ZGVzKCdzZXJ2ZXIud2F0Y2guaWdub3JlZCcpICYmIGNvbnRlbnQuaW5jbHVkZXMoY29uZmlnRGlyKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXhwb3J0SWR4ID0gY29udGVudC5sYXN0SW5kZXhPZignZXhwb3J0IGRlZmF1bHQnKTtcblx0XHRcdGxldCBzdGFydEluZGV4ID0gLTE7XG5cdFx0XHRsZXQgZW5kSW5kZXggPSAtMTtcblx0XHRcdGxldCBjb25maWdCb2R5ID0gJyc7XG5cdFx0XHRsZXQgaXNXaG9sZUZpbGUgPSBmYWxzZTtcblxuXHRcdFx0aWYgKGV4cG9ydElkeCAhPT0gLTEpIHtcblx0XHRcdFx0c3RhcnRJbmRleCA9IGNvbnRlbnQuaW5kZXhPZigneycsIGV4cG9ydElkeCk7XG5cdFx0XHRcdGlmIChzdGFydEluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdGxldCBicmFjZUNvdW50ID0gMDtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChjb250ZW50W2ldID09PSAneycpIGJyYWNlQ291bnQrKztcblx0XHRcdFx0XHRcdGVsc2UgaWYgKGNvbnRlbnRbaV0gPT09ICd9JykgYnJhY2VDb3VudC0tO1xuXG5cdFx0XHRcdFx0XHRpZiAoYnJhY2VDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRlbmRJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlbmRJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdGNvbmZpZ0JvZHkgPSBjb250ZW50LnN1YnN0cmluZyhzdGFydEluZGV4ICsgMSwgZW5kSW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWNvbmZpZ0JvZHkgJiYgKGNvbnRlbnQuaW5jbHVkZXMoJ3ZpdGU6JykgfHwgY29udGVudC5pbmNsdWRlcygnc2VydmVyOicpKSkge1xuXHRcdFx0XHRjb25maWdCb2R5ID0gY29udGVudDtcblx0XHRcdFx0aXNXaG9sZUZpbGUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY29uZmlnQm9keSkge1xuXHRcdFx0XHRpZiAoY29uZmlnQm9keS5pbmNsdWRlcygndml0ZTonKSkge1xuXHRcdFx0XHRcdGlmIChjb25maWdCb2R5LmluY2x1ZGVzKCdzZXJ2ZXI6JykpIHtcblx0XHRcdFx0XHRcdGlmIChjb25maWdCb2R5LmluY2x1ZGVzKCd3YXRjaDonKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY29uZmlnQm9keS5pbmNsdWRlcygnaWdub3JlZDonKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICghY29uZmlnQm9keS5pbmNsdWRlcyhjb25maWdEaXIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gY29uZmlnQm9keS5yZXBsYWNlKC9pZ25vcmVkOlxccypcXFsoW15cXF1dKilcXF0vLCAoX20sIHAxOiBzdHJpbmcpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmcgPSBwMS50cmltKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNlcGFyYXRvciA9IGV4aXN0aW5nID8gJywgJyA6ICcnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYGlnbm9yZWQ6IFske2V4aXN0aW5nfSR7c2VwYXJhdG9yfScqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11gO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbmZpZ0JvZHkgPSBjb25maWdCb2R5LnJlcGxhY2UoL3dhdGNoOlxccypcXHsvLCBgd2F0Y2g6IHtcXG4gICAgICBpZ25vcmVkOiBbJyoqLyR7Y29uZmlnRGlyfS8qKicsICcqKi9fYmFzZXMvKionLCAnKiovYmFzZXMvKionXSxgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uZmlnQm9keSA9IGNvbmZpZ0JvZHkucmVwbGFjZSgvc2VydmVyOlxccypcXHsvLCBgc2VydmVyOiB7XFxuICAgIHdhdGNoOiB7XFxuICAgICAgaWdub3JlZDogWycqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11cXG4gICAgfSxgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uZmlnQm9keSA9IGNvbmZpZ0JvZHkucmVwbGFjZSgvdml0ZTpcXHMqXFx7LywgYHZpdGU6IHtcXG4gICAgc2VydmVyOiB7XFxuICAgICAgd2F0Y2g6IHtcXG4gICAgICAgIGlnbm9yZWQ6IFsnKiovJHtjb25maWdEaXJ9LyoqJywgJyoqL19iYXNlcy8qKicsICcqKi9iYXNlcy8qKiddXFxuICAgICAgfVxcbiAgICB9LGApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaXNXaG9sZUZpbGUpIHtcblx0XHRcdFx0XHRcdGlmIChjb250ZW50LmluY2x1ZGVzKCdkZWZpbmVDb25maWcnKSkge1xuXHRcdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gY29uZmlnQm9keS5yZXBsYWNlKC9kZWZpbmVDb25maWdcXHMqXFwoXFxzKlxcey8sIGBkZWZpbmVDb25maWcoe1xcbiAgdml0ZToge1xcbiAgICBzZXJ2ZXI6IHtcXG4gICAgICB3YXRjaDoge1xcbiAgICAgICAgaWdub3JlZDogWycqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sYCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgY2xlYXIgcGxhY2UgdG8gaW5zZXJ0IFZpdGUgY29uZmlnIGluICR7Y29uZmlnRmlsZU5hbWV9LmApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gYFxcbiAgdml0ZToge1xcbiAgICBzZXJ2ZXI6IHtcXG4gICAgICB3YXRjaDoge1xcbiAgICAgICAgaWdub3JlZDogWycqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sYCArIGNvbmZpZ0JvZHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlZENvbnRlbnQgPSBpc1dob2xlRmlsZSA/IGNvbmZpZ0JvZHkgOiAoY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpICsgY29uZmlnQm9keSArIGNvbnRlbnQuc3Vic3RyaW5nKGVuZEluZGV4KSk7XG5cdFx0XHRcdGZzLndyaXRlRmlsZVN5bmMocmVzb2x2ZWRDb25maWdQYXRoLCB1cGRhdGVkQ29udGVudCwgJ3V0ZjgnKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBjb25maWd1cmF0aW9uIGluICR7Y29uZmlnRmlsZU5hbWV9LmApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBQcm9qZWN0T3B0aW1pemVyOiBFcnJvciB1cGRhdGluZyAke2NvbmZpZ0ZpbGVOYW1lfTpgLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgcmVuZGVyU3RhdHVzKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJykge1xuXHRcdGNvbnN0IHN0YXR1c0VsID0gY29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy1wbHVnaW4tc3RhdHVzJyB9KTtcblx0XHRpZiAoc3RhdHVzID09PSAnY29uZmlndXJlZCcpIHtcblx0XHRcdHNldEljb24oc3RhdHVzRWwsICdsdWNpZGUtY2hlY2stY2lyY2xlLTInKTtcblx0XHRcdHNldENzc1Byb3BzKHN0YXR1c0VsLCB7IGNvbG9yOiAndmFyKC0tdGV4dC1zdWNjZXNzKScgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldEljb24oc3RhdHVzRWwsICdsdWNpZGUtYWxlcnQtY2lyY2xlJyk7XG5cdFx0XHRzZXRDc3NQcm9wcyhzdGF0dXNFbCwgeyBjb2xvcjogJ3ZhcigtLXRleHQtd2FybmluZyknIH0pO1xuXHRcdH1cblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZywgTm90aWNlLCBCdXR0b25Db21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCAqIGFzIG9ic2lkaWFuIGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcbmltcG9ydCB7IEdpdE1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9HaXRNYW5hZ2VyJztcclxuaW1wb3J0IHsgQ29uZmlnRmx1c2hTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29uZmlnRmx1c2hTZXJ2aWNlJztcclxuaW1wb3J0IHsgU2FmZUNvbmZpZ1dyaXRlciB9IGZyb20gJy4uLy4uL3V0aWxzL1NhZmVDb25maWdXcml0ZXInO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdpdFNldHVwU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcclxuICAgIHByaXZhdGUgZ2l0TWFuYWdlcjogdHlwZW9mIEdpdE1hbmFnZXI7XHJcbiAgICBwcml2YXRlIGNvbmZpZ0ZsdXNoU2VydmljZTogQ29uZmlnRmx1c2hTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBzYWZlQ29uZmlnV3JpdGVyOiBTYWZlQ29uZmlnV3JpdGVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHN0YXRlOiBXaXphcmRTdGF0ZSwgb25OZXh0OiAoKSA9PiB2b2lkLCBvbkJhY2s6ICgpID0+IHZvaWQsIG9uQ2FuY2VsOiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCBjb250YWluZXJFbCwgc3RhdGUsIG9uTmV4dCwgb25CYWNrLCBvbkNhbmNlbCk7XHJcbiAgICAgICAgdGhpcy5naXRNYW5hZ2VyID0gR2l0TWFuYWdlcjtcclxuICAgICAgICB0aGlzLmNvbmZpZ0ZsdXNoU2VydmljZSA9IG5ldyBDb25maWdGbHVzaFNlcnZpY2UoYXBwKTtcclxuICAgICAgICB0aGlzLnNhZmVDb25maWdXcml0ZXIgPSBuZXcgU2FmZUNvbmZpZ1dyaXRlcihhcHApO1xyXG4gICAgICAgIHRoaXMuc2hvd05leHRCdXR0b24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEFic29sdXRlUHJvamVjdFJvb3QoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVJvb3QgPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290IHx8ICcuJztcclxuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHJlbGF0aXZlUm9vdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlUm9vdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIGFueTtcclxuICAgICAgICBjb25zdCB2YXVsdFJvb3QgPSBhZGFwdGVyLmdldEJhc2VQYXRoID8gYWRhcHRlci5nZXRCYXNlUGF0aCgpIDogJyc7XHJcbiAgICAgICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh2YXVsdFJvb3QsIHJlbGF0aXZlUm9vdCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0dpdCBJbnRlZ3JhdGlvbicgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2plY3RSb290ID0gdGhpcy5nZXRBYnNvbHV0ZVByb2plY3RSb290KCk7XHJcbiAgICAgICAgbGV0IGlzUmVwbyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCByZW1vdGVVcmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAocHJvamVjdFJvb3QpIHtcclxuICAgICAgICAgICAgaXNSZXBvID0gYXdhaXQgdGhpcy5naXRNYW5hZ2VyLmlzUmVwbyhwcm9qZWN0Um9vdCk7XHJcbiAgICAgICAgICAgIGlmIChpc1JlcG8pIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVVybCA9IGF3YWl0IHRoaXMuZ2l0TWFuYWdlci5nZXRSZW1vdGVVcmwocHJvamVjdFJvb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RJbmZvID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnZ2l0LXJvb3QtaW5mbycsIGF0dHI6IHsgc3R5bGU6ICdtYXJnaW4tYm90dG9tOiAxcmVtOycgfSB9KTtcclxuICAgICAgICAgICAgICAgIHJvb3RJbmZvLmNyZWF0ZUVsKCdiJywgeyB0ZXh0OiAnUHJvamVjdCBSb290OiAnIH0pO1xyXG4gICAgICAgICAgICAgICAgcm9vdEluZm8uY3JlYXRlU3Bhbih7IHRleHQ6IHRoaXMudG9SZWxhdGl2ZVBhdGgocHJvamVjdFJvb3QpIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0VsID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6ICdnaXQtc3RhdHVzLW1lc3NhZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHI6IHsgc3R5bGU6ICdtYXJnaW4tYm90dG9tOiAycmVtOyBwYWRkaW5nOiAxcmVtOyBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcik7IGJvcmRlci1yYWRpdXM6IDRweDsnIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzRWwuY3JlYXRlRWwoJ2InLCB7IHRleHQ6ICdTdGF0dXM6ICcgfSk7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXNFbC5jcmVhdGVTcGFuKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnR2l0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyOiB7IHN0eWxlOiAnY29sb3I6IHZhcigtLXRleHQtc3VjY2Vzcyk7IGZvbnQtd2VpZ2h0OiBib2xkOycgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZVVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUVsID0gc3RhdHVzRWwuY3JlYXRlRGl2KHsgYXR0cjogeyBzdHlsZTogJ21hcmdpbi10b3A6IDAuNXJlbTsnIH0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRWwuY3JlYXRlRWwoJ2InLCB7IHRleHQ6ICdSZW1vdGU6ICcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRWwuY3JlYXRlU3Bhbih7IHRleHQ6IHJlbW90ZVVybCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBDb250YWluZXJcclxuICAgICAgICBjb25zdCBjb25maWdDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdnaXQtY29uZmlnLWNvbnRhaW5lcicgfSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBjb25maWdDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnZ2l0LWluc3RydWN0aW9ucycgfSk7XHJcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLmNyZWF0ZUVsKCdwJywge1xyXG4gICAgICAgICAgICB0ZXh0OiAnQ29ubmVjdCB5b3VyIHByb2plY3QgdG8gR2l0SHViIHRvIHB1Ymxpc2ggeW91ciBzaXRlLiBDbGljayBcIlNraXBcIiB0byBza2lwIEdpdCBzZXR1cCBub3cgYW5kIHNldCBpdCB1cCBsYXRlci4nXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRva2VuTGluayA9IGluc3RydWN0aW9ucy5jcmVhdGVFbCgncCcpO1xyXG4gICAgICAgIHRva2VuTGluay5jcmVhdGVFbCgnYScsIHtcclxuICAgICAgICAgICAgdGV4dDogJ0dlbmVyYXRlIGEgbmV3IEdpdEh1YiBQZXJzb25hbCBhY2Nlc3MgdG9rZW4nLFxyXG4gICAgICAgICAgICBocmVmOiBgaHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucy9uZXc/c2NvcGVzPXJlcG8mZGVzY3JpcHRpb249JHtlbmNvZGVVUklDb21wb25lbnQoKHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnJlcG9OYW1lIHx8ICdQcm9qZWN0JykgKyAnIChWYXVsdCBDTVMpJyl9YFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB0b2tlbkhlbHAgPSBpbnN0cnVjdGlvbnMuY3JlYXRlRWwoJ3VsJyk7XHJcbiAgICAgICAgdG9rZW5IZWxwLmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogYFNldCBhIE5vdGUgKGUuZy4sIFwiJHt0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvTmFtZSB8fCAnUHJvamVjdCd9IChWYXVsdCBDTVMpXCIpYCB9KTtcclxuICAgICAgICB0b2tlbkhlbHAuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnU2V0IEV4cGlyYXRpb24gdG8gXCJObyBleHBpcmF0aW9uXCInIH0pO1xyXG4gICAgICAgIHRva2VuSGVscC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdDaGVjayB0aGUgXCJyZXBvXCIgYm94IChzbyBhbGwgdG9wIG9wdGlvbnMgYXJlIHNlbGVjdGVkKScgfSk7XHJcbiAgICAgICAgdG9rZW5IZWxwLmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ0NsaWNrIFwiR2VuZXJhdGUgdG9rZW5cIiBhdCB0aGUgYm90dG9tLCBjb3B5IGl0LCBhbmQgcGFzdGUgaXQgYmVsb3cuJyB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZW1vdGVVcmwpIHtcclxuICAgICAgICAgICAgY29uZmlnQ29udGFpbmVyLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogaXNSZXBvID8gJ0Nvbm5lY3QgdG8gR2l0SHViJyA6ICdDcmVhdGUgTmV3IFJlcG9zaXRvcnknIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0NvbnRhaW5lci5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdVcGRhdGUgR2l0SHViIENvbm5lY3Rpb24nIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2l0SHViIFBBVCBTZXR0aW5nXHJcbiAgICAgICAgY29uc3QgcGF0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbmZpZ0NvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0dpdEh1YiBQZXJzb25hbCBBY2Nlc3MgVG9rZW4nKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnU3RvcmVkIHNlY3VyZWx5IGluIE9ic2lkaWFuIFNlY3JldHMuJylcclxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XHJcbiAgICAgICAgICAgICAgICBidG4uc2V0SWNvbignbGluaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0dlbmVyYXRlIGEgbmV3IFBlcnNvbmFsIGFjY2VzcyB0b2tlbiBvbiBHaXRIdWInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBlbmNvZGVVUklDb21wb25lbnQoKHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnJlcG9OYW1lIHx8ICdQcm9qZWN0JykgKyAnIChWYXVsdCBDTVMpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGBodHRwczovL2dpdGh1Yi5jb20vc2V0dGluZ3MvdG9rZW5zL25ldz9zY29wZXM9cmVwbyZkZXNjcmlwdGlvbj0ke2Rlc2NyaXB0aW9ufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2VjcmV0SWQgPSAndmF1bHQtY21zLWdpdGh1Yi1wYXQnO1xyXG4gICAgICAgIGxldCBzZWNyZXRWYWx1ZSA9ICh0aGlzLmFwcCBhcyBhbnkpLnNlY3JldFN0b3JhZ2U/LmdldFNlY3JldChzZWNyZXRJZCk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBzdGF0ZSBpcyBzeW5jZWQgd2l0aCBzZWNyZXQgc3RvcmFnZSBvbiBtb3VudFxyXG4gICAgICAgIGlmIChzZWNyZXRWYWx1ZSAmJiAhdGhpcy5zdGF0ZS5naXRDb25maWcucGF0KSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gXCJnaG9zdFwiIGRhdmlkdmtpbWJhbGwgaWYgaXQncyBzdGFsZVxyXG4gICAgICAgICAgICAvLyBCdXQgaWYgaXQncyB0aGVyZSwgd2Uga2VlcCBpdCBmb3IgdGhlIFN5bmMgYnV0dG9uLlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGF0U2V0dGluZy5hZGRUZXh0KHRleHQgPT4ge1xyXG4gICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdnaHBfeHh4eHh4eHh4eHh4JylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZWNyZXRWYWx1ZSA/ICcqKioqKioqKicgOiAnJykgLy8gU2hvdyBkb3RzIGlmIHdlIGhhdmUgYSBzYXZlZCBzZWNyZXRcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcucGF0ID0gdmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRleHQuaW5wdXRFbC50eXBlID0gJ3Bhc3N3b3JkJztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcGF0U3RhdHVzID0gY29uZmlnQ29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ3BhdC1zdGF0dXMtaW5mbycsIGF0dHI6IHsgc3R5bGU6ICdtYXJnaW4tYm90dG9tOiAxcmVtOyBmb250LXNpemU6IDAuOWVtOyBjb2xvcjogdmFyKC0tdGV4dC1tdXRlZCk7JyB9IH0pO1xyXG4gICAgICAgIGlmIChzZWNyZXRWYWx1ZSkge1xyXG4gICAgICAgICAgICBwYXRTdGF0dXMuY3JlYXRlU3Bhbih7IHRleHQ6ICdcdTI3MTMgTGlua2VkIHRvIE9ic2lkaWFuIFNlY3JldDogJywgYXR0cjogeyBzdHlsZTogJ2NvbG9yOiB2YXIoLS10ZXh0LXN1Y2Nlc3MpOyBmb250LXdlaWdodDogYm9sZDsnIH0gfSk7XHJcbiAgICAgICAgICAgIHBhdFN0YXR1cy5jcmVhdGVTcGFuKHsgdGV4dDogc2VjcmV0SWQgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXRTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4ge1xyXG4gICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnVmVyaWZ5IFRva2VuJylcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBSZXNvbHZlIFRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdGhpcy5zdGF0ZS5naXRDb25maWcucGF0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmllbGQgaXMgYmxhbmssIGNvbnRhaW5zIGRvdHMsIG9yIHRoZSBJRCBzdHJpbmcsIHB1bGwgZnJvbSBzdG9yYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbiA9PT0gJyoqKioqKioqJyB8fCB0b2tlbiA9PT0gJ3ZhdWx0LWNtcy1naXRodWItcGF0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9ICh0aGlzLmFwcCBhcyBhbnkpLnNlY3JldFN0b3JhZ2U/LmdldFNlY3JldCgndmF1bHQtY21zLWdpdGh1Yi1wYXQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIGVudGVyIG9yIHBhc3RlIHlvdXIgR2l0SHViIFBlcnNvbmFsIEFjY2VzcyBUb2tlbi4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1ZlcmlmeWluZy4uLicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXRTdGF0dXMuZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IGF3YWl0IHRoaXMuZ2l0TWFuYWdlci52ZXJpZnlUb2tlbih0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VybmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgVG9rZW4gdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5IGFzICR7dXNlcm5hbWV9IWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0U3RhdHVzLmNyZWF0ZVNwYW4oeyB0ZXh0OiBgXHUyNzEzIFZlcmlmaWVkIGFzIGAsIGF0dHI6IHsgc3R5bGU6ICdjb2xvcjogdmFyKC0tdGV4dC1zdWNjZXNzKTsnIH0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRTdGF0dXMuY3JlYXRlRWwoJ2InLCB7IHRleHQ6IHVzZXJuYW1lIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5hcHAgYXMgYW55KS5zZWNyZXRTdG9yYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgKHRoaXMuYXBwIGFzIGFueSkuc2VjcmV0U3RvcmFnZS5zZXRTZWNyZXQoJ3ZhdWx0LWNtcy1naXRodWItcGF0JywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHN0YW5kYXJkIGxvY2FsU3RvcmFnZSBkaXJlY3RseSBpZiB0aGlzLmFwcC5zYXZlTG9jYWxTdG9yYWdlIGlzIG1pc3NpbmcvYnJva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmFwcCBhcyBhbnkpLnNhdmVMb2NhbFN0b3JhZ2UoJ29ic2lkaWFuLWdpdDp1c2VybmFtZScsIHVzZXJuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnb2JzaWRpYW4tZ2l0OnVzZXJuYW1lJywgdXNlcm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnVmVyaWZpZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25FbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndmFyKC0taW50ZXJhY3RpdmUtYWNjZW50KSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uRWwuc3R5bGUuY29sb3IgPSAndmFyKC0tdGV4dC1vbi1hY2NlbnQpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0ludmFsaWQgdG9rZW4gb3IgR2l0SHViIEFQSSBlcnJvci4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdFN0YXR1cy5jcmVhdGVTcGFuKHsgdGV4dDogJ1x1MjcxNyBJbnZhbGlkIHRva2VuIG9yIEdpdEh1YiBBUEkgZXJyb3IuJywgYXR0cjogeyBzdHlsZTogJ2NvbG9yOiB2YXIoLS10ZXh0LWVycm9yKTsnIH0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnVmVyaWZ5IFRva2VuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdWZXJpZmljYXRpb24gZmFpbGVkLiBDaGVjayB5b3VyIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdFN0YXR1cy5jcmVhdGVTcGFuKHsgdGV4dDogJ1x1MjcxNyBWZXJpZmljYXRpb24gZmFpbGVkLiBDaGVjayB5b3VyIGNvbm5lY3Rpb24uJywgYXR0cjogeyBzdHlsZTogJ2NvbG9yOiB2YXIoLS10ZXh0LWVycm9yKTsnIH0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdWZXJpZnkgVG9rZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUmVwbyBjcmVhdGlvbiBzZXR0aW5nc1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbmZpZ0NvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldE5hbWUocmVtb3RlVXJsID8gJ05ldyBSZXBvc2l0b3J5IE5hbWUnIDogJ1JlcG9zaXRvcnkgTmFtZScpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgbmFtZSBvZiB5b3VyIEdpdEh1YiByZXBvc2l0b3J5LicpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdE5hbWUgPSBwcm9qZWN0Um9vdCA/IHByb2plY3RSb290LnNwbGl0KC9bXFxcXC9dLykucG9wKCkgOiAnJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnJlcG9OYW1lIHx8IGRlZmF1bHROYW1lIHx8ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb2FjdGl2ZWx5IHNldCB0aGUgc3RhdGUgc28gaXQncyBub3QgZW1wdHkgaWYgdGhlIHVzZXIgZG9lc24ndCBjaGFuZ2UgaXRcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5naXRDb25maWcucmVwb05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvTmFtZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdteS1ibG9nJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoaW5pdGlhbFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnJlcG9OYW1lID0gdmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29uZmlnQ29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGVzY3JpcHRpb24nKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQSBzaG9ydCBkZXNjcmlwdGlvbiBmb3IgeW91ciByZXBvc2l0b3J5LicpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignTXkgcGVyc29uYWwgYmxvZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnJlcG9EZXNjcmlwdGlvbiB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvRGVzY3JpcHRpb24gPSB2YWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb25maWdDb250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcml2YXRlIFJlcG9zaXRvcnknKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnS2VlcCB0aGlzIHJlcG9zaXRvcnkgcHJpdmF0ZSBhbmQgaGlkZGVuIGZyb20gdGhlIHB1YmxpYy4nKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5zdGF0ZS5naXRDb25maWcuaXNQcml2YXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmlzUHJpdmF0ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQnJhbmNoIE5hbWVcclxuICAgICAgICBuZXcgU2V0dGluZyhjb25maWdDb250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZWZhdWx0IEJyYW5jaCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgbmFtZSBvZiB0aGUgaW5pdGlhbCBicmFuY2ggKGUuZy4sIFwibWFpblwiIG9yIFwibWFzdGVyXCIpLicpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbEJyYW5jaCA9IHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmJyYW5jaE5hbWUgfHwgJ21haW4nO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmdpdENvbmZpZy5icmFuY2hOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcuYnJhbmNoTmFtZSA9IGluaXRpYWxCcmFuY2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdtYWluJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoaW5pdGlhbEJyYW5jaClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdpdENvbmZpZy5icmFuY2hOYW1lID0gdmFsdWUudHJpbSgpIHx8ICdtYWluJztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEF1dG8tY29uZmlndXJlIG9ic2lkaWFuLWdpdFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbmZpZ0NvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dG8tY29uZmlndXJlIEdpdCBwbHVnaW4nKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQXV0b21hdGljYWxseSBzZXQgdXAgdGhlIFwiR2l0XCIgcGx1Z2luIHRvIHdvcmsgd2l0aCB0aGlzIHByb2plY3QuJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmF1dG9Db25maWd1cmVPYnNpZGlhbkdpdClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdpdENvbmZpZy5hdXRvQ29uZmlndXJlT2JzaWRpYW5HaXQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEFjdGlvbiBCdXR0b25cclxuICAgICAgICBjb25zdCBhY3Rpb25Db250YWluZXIgPSBjb25maWdDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnZ2l0LWFjdGlvbi1jb250YWluZXInLCBhdHRyOiB7IHN0eWxlOiAnbWFyZ2luLXRvcDogMnJlbTsnIH0gfSk7XHJcbiAgICAgICAgbGV0IGJ1dHRvblRleHQgPSBpc1JlcG8gPyAocmVtb3RlVXJsID8gJ1VwZGF0ZSBSZW1vdGUgJiBQdXNoJyA6ICdDb25uZWN0IHRvIEdpdEh1YicpIDogJ0luaXRpYWxpemUgJiBQdXNoIHRvIEdpdEh1Yic7XHJcblxyXG4gICAgICAgIGNvbnN0IGNyZWF0ZUJ0biA9IG5ldyBCdXR0b25Db21wb25lbnQoYWN0aW9uQ29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChidXR0b25UZXh0KVxyXG4gICAgICAgICAgICAuc2V0Q3RhKClcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVHaXRTZXR1cChjcmVhdGVCdG4sIGlzUmVwbywgISFyZW1vdGVVcmwpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uZmlnQ29udGFpbmVyLmNyZWF0ZUVsKCdwJywge1xyXG4gICAgICAgICAgICBjbHM6ICdnaXQtc2tpcC1pbmZvJyxcclxuICAgICAgICAgICAgYXR0cjogeyBzdHlsZTogJ2ZvbnQtc2l6ZTogMC44ZW07IGNvbG9yOiB2YXIoLS10ZXh0LW11dGVkKTsgbWFyZ2luLXRvcDogMXJlbTsgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKTsgcGFkZGluZy10b3A6IDFyZW07JyB9LFxyXG4gICAgICAgICAgICB0ZXh0OiAnQ2xpY2sgXCJTa2lwXCIgdG8gc2tpcCBHaXQgc2V0dXAuJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGhhc0FkdmFuY2VkID0gZmFsc2U7XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVHaXRTZXR1cChidXR0b246IEJ1dHRvbkNvbXBvbmVudCwgYWxyZWFkeVJlcG86IGJvb2xlYW4sIGFscmVhZHlIYXNSZW1vdGU6IGJvb2xlYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNBZHZhbmNlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgeyBwYXQgfSA9IHRoaXMuc3RhdGUuZ2l0Q29uZmlnO1xyXG4gICAgICAgIGNvbnN0IHsgcmVwb05hbWUsIHJlcG9EZXNjcmlwdGlvbiwgaXNQcml2YXRlLCBicmFuY2hOYW1lIH0gPSB0aGlzLnN0YXRlLmdpdENvbmZpZztcclxuICAgICAgICBjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMuZ2V0QWJzb2x1dGVQcm9qZWN0Um9vdCgpO1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IGJyYW5jaE5hbWUgfHwgJ21haW4nO1xyXG5cclxuICAgICAgICAvLyAxLiBSZXNvbHZlIFRva2VuOiBTdGF0ZSAoZnJlc2ggZW50cnkpIC0+IFNlY3JldCBTdG9yYWdlIChtYXNrL0lEIGNoZWNrKSAtPiBOdWxsXHJcbiAgICAgICAgaWYgKCFwYXQgfHwgcGF0ID09PSAnKioqKioqKionIHx8IHBhdCA9PT0gJ3ZhdWx0LWNtcy1naXRodWItcGF0Jykge1xyXG4gICAgICAgICAgICBwYXQgPSAodGhpcy5hcHAgYXMgYW55KS5zZWNyZXRTdG9yYWdlPy5nZXRTZWNyZXQoJ3ZhdWx0LWNtcy1naXRodWItcGF0JykgfHwgcGF0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYXQ7XHJcblxyXG4gICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4gPT09ICcqKioqKioqKicgfHwgdG9rZW4gPT09ICd2YXVsdC1jbXMtZ2l0aHViLXBhdCcgfHwgIXByb2plY3RSb290KSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBwcm92aWRlIGEgdmFsaWQgVG9rZW4gYW5kIGVuc3VyZSBwcm9qZWN0IHJvb3QgaXMgZGV0ZWN0ZWQuJyk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghYWxyZWFkeUhhc1JlbW90ZSAmJiAhcmVwb05hbWUpIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIHByb3ZpZGUgYSBSZXBvc2l0b3J5IE5hbWUuJyk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZCh0cnVlKTtcclxuICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChhbHJlYWR5SGFzUmVtb3RlID8gJ1VwZGF0aW5nLi4uJyA6ICdJbml0aWFsaXppbmcuLi4nKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gMS4gR2l0IEluaXQgKG9ubHkgaWYgbm90IGFscmVhZHkgYSByZXBvKVxyXG4gICAgICAgICAgICBpZiAoIWFscmVhZHlSZXBvKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdpdE1hbmFnZXIuaW5pdFJlcG8ocHJvamVjdFJvb3QpO1xyXG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnTG9jYWwgR2l0IHJlcG9zaXRvcnkgaW5pdGlhbGl6ZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBHaXRIdWIgUmVwbyAmIFNldCBSZW1vdGVcclxuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSBoYXMgcmVtb3RlLCB3ZSBjcmVhdGUgYSBORVcgcmVwbyBhbmQgVVBEQVRFIHRoZSByZW1vdGVcclxuICAgICAgICAgICAgbmV3IE5vdGljZShhbHJlYWR5SGFzUmVtb3RlID8gJ0NyZWF0aW5nIG5ldyBHaXRIdWIgcmVwb3NpdG9yeS4uLicgOiAnQ3JlYXRpbmcgR2l0SHViIHJlcG9zaXRvcnkuLi4nKTtcclxuICAgICAgICAgICAgY29uc3QgcmVwb0luZm8gPSBhd2FpdCB0aGlzLmdpdE1hbmFnZXIuY3JlYXRlR2l0SHViUmVwbyh0b2tlbiwgcmVwb05hbWUhLCByZXBvRGVzY3JpcHRpb24gfHwgJycsIGlzUHJpdmF0ZSk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdpdE1hbmFnZXIuc2V0UmVtb3RlKHByb2plY3RSb290LCByZXBvSW5mby5jbG9uZV91cmwpO1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBTdWNjZXNzZnVsbHkgJHthbHJlYWR5SGFzUmVtb3RlID8gJ3VwZGF0ZWQnIDogJ2Nvbm5lY3RlZCd9IHRvICR7cmVwb0luZm8uaHRtbF91cmx9YCk7XHJcblxyXG4gICAgICAgICAgICAvLyAzLiBFYXJseSBGbHVzaDogU2F2ZSBjb25maWd1cmF0aW9ucyB0byBkaXNrIEJFRk9SRSBjb21taXR0aW5nXHJcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgaW5pdGlhbCBjb21taXQgY29udGFpbnMgdGhlIHVzZXIncyB3aXphcmQgc2V0dGluZ3NcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29uZmlnRmx1c2hTZXJ2aWNlLmZsdXNoKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnR2l0U2V0dXBTdGVwOiBFYXJseSBjb25maWd1cmF0aW9uIGZsdXNoIHN1Y2Nlc3NmdWwnKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZmx1c2hFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdHaXRTZXR1cFN0ZXA6IEVhcmx5IGNvbmZpZ3VyYXRpb24gZmx1c2ggZmFpbGVkLCBidXQgY29udGludWluZyB3aXRoIHN5bmM6JywgZmx1c2hFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdpdE1hbmFnZXIuaW5pdGlhbENvbW1pdEFuZFB1c2gocHJvamVjdFJvb3QsIGJyYW5jaCwgJ29yaWdpbicsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1N1Y2Nlc3NmdWxseSBzeW5jZWQgd2l0aCBHaXRIdWIhJyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKHB1c2hFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignU3luYyBmYWlsZWQ6JywgcHVzaEVycm9yKTtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0luaXRpYWwgc3luYyBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgeW91IGhhdmUgR2l0IGNvbmZpZ3VyZWQgbG9jYWxseSBhbmQgeW91ciBjcmVkZW50aWFscyBhcmUgc2V0IHVwIChlLmcuIEdpdCBDcmVkZW50aWFsIE1hbmFnZXIpLicpO1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdGhyb3csIGxldCB0aGVtIGZpbmlzaCBzZXR1cCBhbmQgc3luYyBtYW51YWxseSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gNC4gQ29uZmlndXJlIE9ic2lkaWFuIEdpdFxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5naXRDb25maWcuYXV0b0NvbmZpZ3VyZU9ic2lkaWFuR2l0KSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbmZpZ3VyZU9ic2lkaWFuR2l0KHRva2VuLCBwcm9qZWN0Um9vdCwgYnJhbmNoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gNS4gU2VjdXJlbHkgc2F2ZSB0b2tlbiBpZiBpdCB3YXMganVzdCBlbnRlcmVkXHJcbiAgICAgICAgICAgIGlmIChwYXQgJiYgKHRoaXMuYXBwIGFzIGFueSkuc2VjcmV0U3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgKHRoaXMuYXBwIGFzIGFueSkuc2VjcmV0U3RvcmFnZS5zZXRTZWNyZXQoJ3ZhdWx0LWNtcy1naXRodWItcGF0JywgcGF0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYXIgcGxhaW4tdGV4dCBQQVQgZnJvbSBzdGF0ZSBiZWZvcmUgZmluaXNoaW5nXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnBhdCA9ICcnO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdTdWNjZXNzIScpO1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdHaXQgc2V0dXAgY29tcGxldGUhJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBBdXRvLWFkdmFuY2UgYWZ0ZXIgc21hbGwgZGVsYXlcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0FkdmFuY2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0FkdmFuY2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vbk5leHQoKSwgMTUwMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignR2l0IGludGVncmF0aW9uIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgU2V0dXAgZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoYWxyZWFkeUhhc1JlbW90ZSA/ICdVcGRhdGUgU2V0dGluZ3MgJiBTeW5jJyA6ICdJbml0aWFsaXplICYgUHVzaCB0byBHaXRIdWInKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBjb25maWd1cmVPYnNpZGlhbkdpdChwYXQ6IHN0cmluZywgcHJvamVjdFJvb3Q6IHN0cmluZywgYnJhbmNoOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmRlYnVnKCdHaXRTZXR1cFN0ZXA6IENvbmZpZ3VyaW5nIE9ic2lkaWFuIEdpdCBwbHVnaW4uLi4nKTtcclxuXHJcbiAgICAgICAgLy8gMS4gU2V0IGNyZWRlbnRpYWxzIGluIGxvY2FsU3RvcmFnZSAoc3RhbmRhcmQgZmFsbGJhY2sgZm9yIE9ic2lkaWFuIEdpdClcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAodGhpcy5hcHAgYXMgYW55KS5zYXZlTG9jYWxTdG9yYWdlKCdvYnNpZGlhbi1naXQ6cGFzc3dvcmQnLCBwYXQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ29ic2lkaWFuLWdpdDpwYXNzd29yZCcsIHBhdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyBhbnk7XHJcbiAgICAgICAgY29uc3QgdmF1bHRSb290ID0gYWRhcHRlci5nZXRCYXNlUGF0aCA/IGFkYXB0ZXIuZ2V0QmFzZVBhdGgoKSA6ICcnO1xyXG5cclxuICAgICAgICBpZiAodmF1bHRSb290ICYmIHByb2plY3RSb290KSB7XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSBwcm9qZWN0Um9vdCBpcyBhYnNvbHV0ZSBmb3IgY29tcGFyaXNvblxyXG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVByb2plY3RSb290ID0gcGF0aC5pc0Fic29sdXRlKHByb2plY3RSb290KSA/IHByb2plY3RSb290IDogcGF0aC5yZXNvbHZlKHZhdWx0Um9vdCwgcHJvamVjdFJvb3QpO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHZhdWx0Um9vdCwgYWJzb2x1dGVQcm9qZWN0Um9vdCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29uZmlnVXBkYXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuICAgICAgICAgICAgICAgIGJhc2VQYXRoOiByZWxhdGl2ZVBhdGggfHwgJycsXHJcbiAgICAgICAgICAgICAgICBnaXRSZW1vdGU6ICdvcmlnaW4nLFxyXG4gICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogJ29yaWdpbicsIC8vIFNvbWUgdmVyc2lvbnMgdXNlIHRoaXNcclxuICAgICAgICAgICAgICAgIG1haW5CcmFuY2g6IGJyYW5jaCxcclxuICAgICAgICAgICAgICAgIGJyYW5jaDogYnJhbmNoLCAgICAgICAvLyBTb21lIHZlcnNpb25zIHVzZSB0aGlzXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVtb3RlOiAnb3JpZ2luJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gMi4gVXBkYXRlIHNldHRpbmdzIGluLW1lbW9yeSBpZiB0aGUgcGx1Z2luIGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgcmVsaWFibGUgd2F5IHRvIHByZXZlbnQgcHJvbXB0cyBmcm9tIGEgcnVubmluZyBwbHVnaW5cclxuICAgICAgICAgICAgY29uc3QgZ2l0UGx1Z2luID0gKHRoaXMuYXBwIGFzIGFueSkucGx1Z2lucz8uZ2V0UGx1Z2luKCdvYnNpZGlhbi1naXQnKTtcclxuICAgICAgICAgICAgaWYgKGdpdFBsdWdpbikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnR2l0U2V0dXBTdGVwOiBGb3VuZCBydW5uaW5nIE9ic2lkaWFuIEdpdCBwbHVnaW4sIHVwZGF0aW5nIGluLW1lbW9yeSBzZXR0aW5ncycpO1xyXG4gICAgICAgICAgICAgICAgZ2l0UGx1Z2luLnNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdpdFBsdWdpbi5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWdVcGRhdGVzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnaXRQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZ2l0UGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAzLiBBbHdheXMgbWVyZ2Uvd3JpdGUgdG8gZGF0YS5qc29uIGFzIGEgcGVyc2lzdGVudCBmYWxsYmFja1xyXG4gICAgICAgICAgICAvLyBXZSB1c2UgbWVyZ2VDb25maWcgd2hpY2ggaGFuZGxlcyBpdCBldmVuIGlmIGRhdGEuanNvbiBkb2Vzbid0IGV4aXN0IHlldFxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhZmVDb25maWdXcml0ZXIubWVyZ2VDb25maWcoJ29ic2lkaWFuLWdpdCcsIGNvbmZpZ1VwZGF0ZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmV3IE5vdGljZSgnT2JzaWRpYW4gR2l0IHBsdWdpbiBjb25maWd1cmVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBPcHRpb25hbCBzdGVwXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGl0bGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gJ0dpdCBJbnRlZ3JhdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gJ0Nvbm5lY3QgdG8gR2l0SHViJztcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IENvbnRlbnRUeXBlQ29uZmlnLCBGcm9udG1hdHRlclByb3BlcnRpZXMsIFByb2plY3REZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB5YW1sIGZyb20gJ3lhbWwnO1xuaW1wb3J0IHsgUGF0aFJlc29sdmVyIH0gZnJvbSAnLi9QYXRoUmVzb2x2ZXInO1xuXG5leHBvcnQgY2xhc3MgQmFzZXNDTVNDb25maWd1cmF0b3Ige1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXHRwcml2YXRlIHBhdGhSZXNvbHZlcjogUGF0aFJlc29sdmVyO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdFx0dGhpcy5wYXRoUmVzb2x2ZXIgPSBuZXcgUGF0aFJlc29sdmVyKGFwcCk7XG5cdH1cblxuXHRhc3luYyByZXNvbHZlQmFzZUZpbGVQYXRoKCk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3QgcHJlZmVycmVkUGF0aCA9ICdfYmFzZXMvSG9tZS5iYXNlJztcblx0XHRjb25zdCBsZWdhY3lQYXRoID0gJ2Jhc2VzL0hvbWUuYmFzZSc7XG5cblx0XHRpZiAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMocHJlZmVycmVkUGF0aCkpIHtcblx0XHRcdHJldHVybiBwcmVmZXJyZWRQYXRoO1xuXHRcdH1cblx0XHRpZiAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobGVnYWN5UGF0aCkpIHtcblx0XHRcdHJldHVybiBsZWdhY3lQYXRoO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIGZvbGRlcnMgZXhpc3QgZXZlbiBpZiBmaWxlIGRvZXNuJ3Rcblx0XHRpZiAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMoJ19iYXNlcycpKSB7XG5cdFx0XHRyZXR1cm4gcHJlZmVycmVkUGF0aDtcblx0XHR9XG5cdFx0aWYgKGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKCdiYXNlcycpKSB7XG5cdFx0XHRyZXR1cm4gbGVnYWN5UGF0aDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJlZmVycmVkUGF0aDtcblx0fVxuXG5cdGFzeW5jIGNyZWF0ZU9yVXBkYXRlQmFzZUZpbGUoXG5cdFx0Y29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdLFxuXHRcdGZyb250bWF0dGVyUHJvcGVydGllczogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIH0sXG5cdFx0ZGVmYXVsdENvbnRlbnRUeXBlSWQ/OiBzdHJpbmcsXG5cdFx0cHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQsXG5cdFx0ZW5hYmxlTWR4U3VwcG9ydD86IGJvb2xlYW5cblx0KTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYmFzZUZpbGVQYXRoID0gYXdhaXQgdGhpcy5yZXNvbHZlQmFzZUZpbGVQYXRoKCk7XG5cdFx0Y29uc3QgZm9sZGVyUGF0aCA9IGJhc2VGaWxlUGF0aC5zcGxpdCgnLycpWzBdO1xuXG5cdFx0Ly8gRW5zdXJlIGJhc2VzIGRpcmVjdG9yeSBleGlzdHNcblx0XHRjb25zdCBiYXNlc0ZvbGRlciA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmb2xkZXJQYXRoKTtcblx0XHRpZiAoIWJhc2VzRm9sZGVyKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIoZm9sZGVyUGF0aCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0XHQvLyBGb2xkZXIgbWlnaHQgYWxyZWFkeSBleGlzdCwgaWdub3JlIGVycm9yXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcblx0XHRcdFx0aWYgKCFlcnJvck1lc3NhZ2UgfHwgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihgQmFzZXNDTVNDb25maWc6IENvdWxkIG5vdCBjcmVhdGUgJHtmb2xkZXJQYXRofSBmb2xkZXI6YCwgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgZmlsZSBleGlzdHMgKHJlLWNoZWNrIGFmdGVyIGZvbGRlciBjcmVhdGlvbilcblx0XHRjb25zdCBiYXNlRmlsZUFic3RyYWN0ID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGJhc2VGaWxlUGF0aCk7XG5cdFx0bGV0IGJhc2VGaWxlOiBURmlsZSB8IG51bGwgPSBiYXNlRmlsZUFic3RyYWN0IGluc3RhbmNlb2YgVEZpbGUgPyBiYXNlRmlsZUFic3RyYWN0IDogbnVsbDtcblxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgYmFzZSBmaWxlIGlmIGl0IGV4aXN0c1xuXHRcdGxldCBleGlzdGluZ0Jhc2U6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCA9IG51bGw7XG5cdFx0aWYgKGJhc2VGaWxlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChiYXNlRmlsZSk7XG5cdFx0XHRcdGV4aXN0aW5nQmFzZSA9IHlhbWwucGFyc2UoY29udGVudCkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdCYXNlc0NNU0NvbmZpZzogRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIGJhc2UgZmlsZTonLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgZW5hYmxlZFR5cGVzID0gY29udGVudFR5cGVzLmZpbHRlcihjdCA9PiBjdC5lbmFibGVkKTtcblx0XHRjb25zb2xlLmRlYnVnKCdCYXNlc0NNU0NvbmZpZzogR2VuZXJhdGluZyBiYXNlIGNvbnRlbnQgZm9yJywgY29udGVudFR5cGVzLmxlbmd0aCwgJ2NvbnRlbnQgdHlwZXMnKTtcblx0XHRjb25zb2xlLmRlYnVnKCdCYXNlc0NNU0NvbmZpZzogRW5hYmxlZCBjb250ZW50IHR5cGVzOicsIGVuYWJsZWRUeXBlcy5tYXAoY3QgPT4gY3QubmFtZSkpO1xuXG5cdFx0Y29uc3QgYmFzZUNvbnRlbnQgPSB0aGlzLmdlbmVyYXRlQmFzZUNvbnRlbnQoY29udGVudFR5cGVzLCBmcm9udG1hdHRlclByb3BlcnRpZXMsIGRlZmF1bHRDb250ZW50VHlwZUlkLCBleGlzdGluZ0Jhc2UsIHByb2plY3REZXRlY3Rpb24sIGVuYWJsZU1keFN1cHBvcnQpO1xuXG5cdFx0Ly8gQ291bnQgdmlld3MgaW4gZ2VuZXJhdGVkIGNvbnRlbnQgdG8gdmVyaWZ5IHRoZXkncmUgYmVpbmcgY3JlYXRlZFxuXHRcdGNvbnN0IHZpZXdNYXRjaGVzID0gYmFzZUNvbnRlbnQubWF0Y2goL15cXHMqLVxccyt0eXBlOlxccytiYXNlcy1jbXMvZ20pO1xuXHRcdGNvbnN0IHZpZXdDb3VudCA9IHZpZXdNYXRjaGVzID8gdmlld01hdGNoZXMubGVuZ3RoIDogMDtcblx0XHRjb25zb2xlLmRlYnVnKCdCYXNlc0NNU0NvbmZpZzogR2VuZXJhdGVkJywgdmlld0NvdW50LCAndmlld3MgaW4gYmFzZSBjb250ZW50Jyk7XG5cblx0XHQvLyBBbHdheXMgdHJ5IHRvIG1vZGlmeSBmaXJzdCAtIGlmIGZpbGUgZG9lc24ndCBleGlzdCwgbW9kaWZ5IHdpbGwgdGhyb3csIHRoZW4gd2UgY3JlYXRlXG5cdFx0Ly8gVGhpcyBhdm9pZHMgcmFjZSBjb25kaXRpb25zIHdpdGggZ2V0QWJzdHJhY3RGaWxlQnlQYXRoXG5cdFx0Y29uc3QgYmFzZUZpbGVBYnN0cmFjdDIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYmFzZUZpbGVQYXRoKTtcblx0XHRiYXNlRmlsZSA9IGJhc2VGaWxlQWJzdHJhY3QyIGluc3RhbmNlb2YgVEZpbGUgPyBiYXNlRmlsZUFic3RyYWN0MiA6IG51bGw7XG5cblx0XHRpZiAoYmFzZUZpbGUpIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoYEJhc2VzQ01TQ29uZmlnOiBNb2RpZnlpbmcgZXhpc3RpbmcgJHtiYXNlRmlsZVBhdGh9IGZpbGVgKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShiYXNlRmlsZSwgYmFzZUNvbnRlbnQpO1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKGBCYXNlc0NNU0NvbmZpZzogU3VjY2Vzc2Z1bGx5IG1vZGlmaWVkICR7YmFzZUZpbGVQYXRofSBmaWxlYCk7XG5cdFx0XHRcdHJldHVybjsgLy8gU3VjY2VzcywgZXhpdCBlYXJseVxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignQmFzZXNDTVNDb25maWc6IEZhaWxlZCB0byBtb2RpZnkgZmlsZTonLCBlcnJvcik7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpbGUgZG9lc24ndCBleGlzdCAob3IgY2FuJ3QgYmUgZm91bmQpLCB0cnkgdG8gY3JlYXRlIGl0XG5cdFx0Y29uc29sZS5kZWJ1ZyhgQmFzZXNDTVNDb25maWc6IENyZWF0aW5nIG5ldyAke2Jhc2VGaWxlUGF0aH0gZmlsZWApO1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYmFzZUZpbGVQYXRoLCBiYXNlQ29udGVudCk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKGBCYXNlc0NNU0NvbmZpZzogU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgJHtiYXNlRmlsZVBhdGh9IGZpbGVgKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Ly8gSWYgY3JlYXRlIGZhaWxzIGJlY2F1c2UgZmlsZSBleGlzdHMsIHRoZSBmaWxlIHdhcyBjcmVhdGVkIGJldHdlZW4gY2hlY2sgYW5kIGNyZWF0ZVxuXHRcdFx0Ly8gVHJ5IHRvIG1vZGlmeSBpdCBkaXJlY3RseSB1c2luZyB0aGUgcGF0aCBzdHJpbmdcblx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcblx0XHRcdGlmIChlcnJvck1lc3NhZ2UgJiYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSkpIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQmFzZXNDTVNDb25maWc6IEZpbGUgZXhpc3RlZCwgYXR0ZW1wdGluZyBkaXJlY3QgbW9kaWZ5IHZpYSBwYXRoJyk7XG5cdFx0XHRcdC8vIFVzZSBhZGFwdGVyIHRvIHdyaXRlIGRpcmVjdGx5IC0gdGhpcyBieXBhc3NlcyB0aGUgaW5kZXhpbmcgaXNzdWVcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRcdFx0XHRpZiAoYWRhcHRlciAmJiB0eXBlb2YgYWRhcHRlci53cml0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0YXdhaXQgYWRhcHRlci53cml0ZShiYXNlRmlsZVBhdGgsIGJhc2VDb250ZW50KTtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBTdWNjZXNzZnVsbHkgd3JvdGUgSG9tZS5iYXNlIGZpbGUgdmlhIGFkYXB0ZXInKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2s6IHJldHJ5IGdldEFic3RyYWN0RmlsZUJ5UGF0aCB3aXRoIGxvbmdlciBkZWxheXNcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBBZGFwdGVyIHdyaXRlIG5vdCBhdmFpbGFibGUsIHJldHJ5aW5nIGdldEFic3RyYWN0RmlsZUJ5UGF0aCcpO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmV0cnlGaWxlQWJzdHJhY3QgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYmFzZUZpbGVQYXRoKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmV0cnlGaWxlID0gcmV0cnlGaWxlQWJzdHJhY3QgaW5zdGFuY2VvZiBURmlsZSA/IHJldHJ5RmlsZUFic3RyYWN0IDogbnVsbDtcblx0XHRcdFx0XHRcdFx0aWYgKHJldHJ5RmlsZSkge1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShyZXRyeUZpbGUsIGJhc2VDb250ZW50KTtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBCYXNlc0NNU0NvbmZpZzogU3VjY2Vzc2Z1bGx5IG1vZGlmaWVkIEhvbWUuYmFzZSBmaWxlIG9uIHJldHJ5ICR7aSArIDF9YCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdCYXNlc0NNU0NvbmZpZzogRmlsZSBleGlzdHMgYnV0IGNhbm5vdCBiZSBmb3VuZCBhZnRlciBhbGwgcmV0cmllcycpO1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGaWxlIGV4aXN0cyBidXQgY2Fubm90IGJlIGFjY2Vzc2VkLiBQbGVhc2UgdHJ5IGFnYWluIG9yIG1hbnVhbGx5IGVkaXQgJHtiYXNlRmlsZVBhdGh9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoICh3cml0ZUVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignQmFzZXNDTVNDb25maWc6IEZhaWxlZCB0byB3cml0ZSBmaWxlIHZpYSBhZGFwdGVyOicsIHdyaXRlRXJyb3IpO1xuXHRcdFx0XHRcdHRocm93IHdyaXRlRXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Jhc2VzQ01TQ29uZmlnOiBGYWlsZWQgdG8gY3JlYXRlIGJhc2UgZmlsZTonLCBlcnJvcik7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVCYXNlQ29udGVudChcblx0XHRjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10sXG5cdFx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiB7IFtjb250ZW50VHlwZUlkOiBzdHJpbmddOiBGcm9udG1hdHRlclByb3BlcnRpZXMgfSxcblx0XHRkZWZhdWx0Q29udGVudFR5cGVJZDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuXHRcdGV4aXN0aW5nQmFzZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsLFxuXHRcdHByb2plY3REZXRlY3Rpb24/OiBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0LFxuXHRcdGVuYWJsZU1keFN1cHBvcnQ/OiBib29sZWFuXG5cdCk6IHN0cmluZyB7XG5cdFx0Ly8gQmFzZXMgdXNlcyBhIHNwZWNpZmljIHN5bnRheCAtIHdlIG5lZWQgdG8gZ2VuZXJhdGUgaXQgbWFudWFsbHkgdG8gbWF0Y2ggdGhlIGZvcm1hdFxuXHRcdGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdFx0Ly8gRmluZCBkZWZhdWx0IGNvbnRlbnQgdHlwZVxuXHRcdGNvbnN0IGRlZmF1bHRDb250ZW50VHlwZSA9IGRlZmF1bHRDb250ZW50VHlwZUlkID9cblx0XHRcdGNvbnRlbnRUeXBlcy5maW5kKGN0ID0+IGN0LmlkID09PSBkZWZhdWx0Q29udGVudFR5cGVJZCAmJiBjdC5lbmFibGVkKSA6IG51bGw7XG5cblx0XHQvLyBBZGQgZGVmYXVsdFZpZXcgcHJvcGVydHkgYXQgdGhlIHRvcCBsZXZlbCBpZiBhIGRlZmF1bHQgY29udGVudCB0eXBlIGlzIHNlbGVjdGVkXG5cdFx0aWYgKGRlZmF1bHRDb250ZW50VHlwZSkge1xuXHRcdFx0bGluZXMucHVzaChgZGVmYXVsdFZpZXc6IFwiJHtkZWZhdWx0Q29udGVudFR5cGUubmFtZX1cImApO1xuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIGZvcm11bGFzIGlmIHRoZXkgZXhpc3Rcblx0XHRpZiAoZXhpc3RpbmdCYXNlPy5mb3JtdWxhcykge1xuXHRcdFx0bGluZXMucHVzaCgnZm9ybXVsYXM6Jyk7XG5cdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhleGlzdGluZ0Jhc2UuZm9ybXVsYXMpKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAke2tleX06IHwtYCk7XG5cdFx0XHRcdFx0Y29uc3QgZm9ybXVsYUxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpO1xuXHRcdFx0XHRcdGZvciAoY29uc3QgZm9ybXVsYUxpbmUgb2YgZm9ybXVsYUxpbmVzKSB7XG5cdFx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgJHtmb3JtdWxhTGluZX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpbmVzLnB1c2goJycpO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnMgc2VjdGlvblxuXHRcdGxpbmVzLnB1c2goJ2ZpbHRlcnM6Jyk7XG5cdFx0aWYgKGVuYWJsZU1keFN1cHBvcnQpIHtcblx0XHRcdGxpbmVzLnB1c2goJyAgb3I6Jyk7XG5cdFx0XHRsaW5lcy5wdXNoKCcgICAgLSBmaWxlLmV4dCA9PSBcIm1kXCInKTtcblx0XHRcdGxpbmVzLnB1c2goJyAgICAtIGZpbGUuZXh0ID09IFwibWR4XCInKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGluZXMucHVzaCgnICBhbmQ6Jyk7XG5cdFx0XHRsaW5lcy5wdXNoKCcgICAgLSBmaWxlLmV4dCA9PSBcIm1kXCInKTtcblx0XHR9XG5cdFx0bGluZXMucHVzaCgnJyk7XG5cblx0XHQvLyBQcm9wZXJ0aWVzIHNlY3Rpb24gLSBjb2xsZWN0IGFsbCBwcm9wZXJ0aWVzIGZyb20gY29udGVudCB0eXBlc1xuXHRcdGNvbnN0IGFsbFByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblx0XHRmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIGNvbnRlbnRUeXBlcykge1xuXHRcdFx0Y29uc3QgcHJvcHMgPSBmcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdO1xuXHRcdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wcy50aXRsZVByb3BlcnR5KSBhbGxQcm9wZXJ0aWVzLmFkZChgbm90ZS4ke3Byb3BzLnRpdGxlUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy5kYXRlUHJvcGVydHkpIGFsbFByb3BlcnRpZXMuYWRkKGBub3RlLiR7cHJvcHMuZGF0ZVByb3BlcnR5fWApO1xuXHRcdFx0XHRpZiAocHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSkgYWxsUHJvcGVydGllcy5hZGQoYG5vdGUuJHtwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5fWApO1xuXHRcdFx0XHRpZiAocHJvcHMudGFnc1Byb3BlcnR5KSBhbGxQcm9wZXJ0aWVzLmFkZChgbm90ZS4ke3Byb3BzLnRhZ3NQcm9wZXJ0eX1gKTtcblx0XHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIGFsbFByb3BlcnRpZXMuYWRkKGBub3RlLiR7cHJvcHMuZHJhZnRQcm9wZXJ0eX1gKTtcblx0XHRcdFx0aWYgKHByb3BzLmltYWdlUHJvcGVydHkpIGFsbFByb3BlcnRpZXMuYWRkKGBub3RlLiR7cHJvcHMuaW1hZ2VQcm9wZXJ0eX1gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgY29tbW9uIHByb3BlcnRpZXNcblx0XHRhbGxQcm9wZXJ0aWVzLmFkZCgnbm90ZS50aXRsZScpO1xuXHRcdGFsbFByb3BlcnRpZXMuYWRkKCdub3RlLmRhdGUnKTtcblx0XHRhbGxQcm9wZXJ0aWVzLmFkZCgnbm90ZS5wdWJEYXRlJyk7XG5cdFx0YWxsUHJvcGVydGllcy5hZGQoJ25vdGUuZHJhZnQnKTtcblx0XHRhbGxQcm9wZXJ0aWVzLmFkZCgnZmlsZS5mdWxsbmFtZScpOyAvLyBBbHdheXMgaW5jbHVkZSBmdWxsIGZpbGUgbmFtZVxuXHRcdGFsbFByb3BlcnRpZXMuYWRkKCdmaWxlLm5hbWUnKTsgLy8gQWxzbyBpbmNsdWRlIGZpbGUgbmFtZSBmb3IgY29tcGF0aWJpbGl0eVxuXG5cdFx0Ly8gUHJlc2VydmUgZm9ybXVsYSBwcm9wZXJ0aWVzIGlmIHRoZXkgZXhpc3Rcblx0XHRpZiAoZXhpc3RpbmdCYXNlPy5wcm9wZXJ0aWVzKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoZXhpc3RpbmdCYXNlLnByb3BlcnRpZXMpKSB7XG5cdFx0XHRcdGlmIChwcm9wLnN0YXJ0c1dpdGgoJ2Zvcm11bGEuJykpIHtcblx0XHRcdFx0XHRhbGxQcm9wZXJ0aWVzLmFkZChwcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChhbGxQcm9wZXJ0aWVzLnNpemUgPiAwKSB7XG5cdFx0XHRsaW5lcy5wdXNoKCdwcm9wZXJ0aWVzOicpO1xuXHRcdFx0Ly8gUHJlc2VydmUgZXhpc3RpbmcgcHJvcGVydHkgZGlzcGxheU5hbWVzLCBlc3BlY2lhbGx5IGZvciBmaWxlLm5hbWUvZnVsbG5hbWVcblx0XHRcdGNvbnN0IGV4aXN0aW5nUHJvcHMgPSAoZXhpc3RpbmdCYXNlPy5wcm9wZXJ0aWVzIGFzIFJlY29yZDxzdHJpbmcsIHsgZGlzcGxheU5hbWU/OiBzdHJpbmcgfSB8IHVuZGVmaW5lZD4pIHx8IHt9O1xuXHRcdFx0Zm9yIChjb25zdCBwcm9wIG9mIEFycmF5LmZyb20oYWxsUHJvcGVydGllcykuc29ydCgpKSB7XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgJHtwcm9wfTpgKTtcblx0XHRcdFx0Ly8gUHJlc2VydmUgZXhpc3RpbmcgZGlzcGxheU5hbWUgaWYgaXQgZXhpc3RzLCBlc3BlY2lhbGx5IGZvciBmaWxlLm5hbWUvZnVsbG5hbWVcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdQcm9wID0gZXhpc3RpbmdQcm9wc1twcm9wXTtcblx0XHRcdFx0aWYgKGV4aXN0aW5nUHJvcD8uZGlzcGxheU5hbWUpIHtcblx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgZGlzcGxheU5hbWU6ICR7ZXhpc3RpbmdQcm9wLmRpc3BsYXlOYW1lfWApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByb3AgPT09ICdmaWxlLmZ1bGxuYW1lJykge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkaXNwbGF5TmFtZTogRnVsbCBGaWxlIE5hbWVgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBwcm9wTmFtZSA9IHByb3AucmVwbGFjZSgnbm90ZS4nLCAnJykucmVwbGFjZSgnZmlsZS4nLCAnJyk7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAgIGRpc3BsYXlOYW1lOiAke3RoaXMuY2FwaXRhbGl6ZUZpcnN0KHByb3BOYW1lKX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGluZXMucHVzaCgnJyk7XG5cdFx0fVxuXG5cdFx0Ly8gVmlld3Mgc2VjdGlvbiAtIHByZXNlcnZlIGV4aXN0aW5nIHZpZXdzIGFuZCBhZGQvdXBkYXRlIGNvbnRlbnQgdHlwZSB2aWV3c1xuXHRcdGxpbmVzLnB1c2goJ3ZpZXdzOicpO1xuXG5cdFx0Y29uc3QgZXhpc3RpbmdWaWV3cyA9IChleGlzdGluZ0Jhc2U/LnZpZXdzIGFzIEFycmF5PGFueT4pIHx8IFtdO1xuXHRcdGNvbnN0IHZpZXdzQnlOYW1lID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblx0XHRmb3IgKGNvbnN0IHZpZXcgb2YgZXhpc3RpbmdWaWV3cykge1xuXHRcdFx0aWYgKHZpZXcubmFtZSkgdmlld3NCeU5hbWUuc2V0KHZpZXcubmFtZSwgdmlldyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmluYWxWaWV3czogYW55W10gPSBbXTtcblx0XHRjb25zdCBwcm9jZXNzZWRWaWV3TmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuXHRcdC8vIDEuIFByb2Nlc3MgQ29udGVudCBUeXBlcyAoRGVmYXVsdCBGaXJzdClcblx0XHRjb25zdCBlbmFibGVkVHlwZXMgPSBjb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xuXHRcdGNvbnN0IGRlZmF1bHRUeXBlID0gZGVmYXVsdENvbnRlbnRUeXBlSWQgPyBlbmFibGVkVHlwZXMuZmluZChjdCA9PiBjdC5pZCA9PT0gZGVmYXVsdENvbnRlbnRUeXBlSWQpIDogbnVsbDtcblx0XHRjb25zdCBvdGhlclR5cGVzID0gZW5hYmxlZFR5cGVzLmZpbHRlcihjdCA9PiBjdCAhPT0gZGVmYXVsdFR5cGUpO1xuXG5cdFx0Y29uc3QgcHJvY2Vzc1R5cGUgPSAoY3Q6IENvbnRlbnRUeXBlQ29uZmlnKSA9PiB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGZyb250bWF0dGVyUHJvcGVydGllc1tjdC5pZF07XG5cdFx0XHRpZiAoIXByb3BzKSByZXR1cm47XG5cblx0XHRcdGNvbnN0IGV4aXN0aW5nVmlldyA9IHZpZXdzQnlOYW1lLmdldChjdC5uYW1lKTtcblx0XHRcdGNvbnN0IGdlbmVyYXRlZFZpZXcgPSB0aGlzLmdlbmVyYXRlVmlld0ZvckNvbnRlbnRUeXBlKGN0LCBwcm9wcywgcHJvamVjdERldGVjdGlvbik7XG5cblx0XHRcdGlmIChleGlzdGluZ1ZpZXcpIHtcblx0XHRcdFx0Ly8gT05MWSB1cGRhdGUgY29yZSBcInBsdW1iaW5nXCIgcHJvcGVydGllcyBmcm9tIHRoZSB3aXphcmRcblx0XHRcdFx0Ly8gUHJlc2VydmUgYWxsIG90aGVyIHVzZXIgY3VzdG9taXphdGlvbnMgKHNvcnQsIGxheW91dCwgZm9ybXVsYXMsIGV0Yy4pXG5cdFx0XHRcdGNvbnN0IGNvcmVVcGRhdGVzID0ge1xuXHRcdFx0XHRcdGZpbHRlcnM6IGdlbmVyYXRlZFZpZXcuZmlsdGVycyxcblx0XHRcdFx0XHRuZXdOb3RlTG9jYXRpb246IGdlbmVyYXRlZFZpZXcubmV3Tm90ZUxvY2F0aW9uLFxuXHRcdFx0XHRcdHRpdGxlUHJvcGVydHk6IGdlbmVyYXRlZFZpZXcudGl0bGVQcm9wZXJ0eSxcblx0XHRcdFx0XHRkYXRlUHJvcGVydHk6IGdlbmVyYXRlZFZpZXcuZGF0ZVByb3BlcnR5LFxuXHRcdFx0XHRcdGRyYWZ0U3RhdHVzUHJvcGVydHk6IGdlbmVyYXRlZFZpZXcuZHJhZnRTdGF0dXNQcm9wZXJ0eSxcblx0XHRcdFx0XHR0YWdzUHJvcGVydHk6IGdlbmVyYXRlZFZpZXcudGFnc1Byb3BlcnR5LFxuXHRcdFx0XHRcdHNob3dUYWdzOiBnZW5lcmF0ZWRWaWV3LnNob3dUYWdzLFxuXHRcdFx0XHRcdHNob3dEcmFmdFN0YXR1czogZ2VuZXJhdGVkVmlldy5zaG93RHJhZnRTdGF0dXMsXG5cdFx0XHRcdFx0ZHJhZnRTdGF0dXNSZXZlcnNlOiBnZW5lcmF0ZWRWaWV3LmRyYWZ0U3RhdHVzUmV2ZXJzZSxcblx0XHRcdFx0XHRkcmFmdFN0YXR1c1VzZUZpbGVuYW1lUHJlZml4OiBnZW5lcmF0ZWRWaWV3LmRyYWZ0U3RhdHVzVXNlRmlsZW5hbWVQcmVmaXhcblx0XHRcdFx0fTtcblx0XHRcdFx0ZmluYWxWaWV3cy5wdXNoKHsgLi4uZXhpc3RpbmdWaWV3LCAuLi5jb3JlVXBkYXRlcyB9KTtcblx0XHRcdFx0cHJvY2Vzc2VkVmlld05hbWVzLmFkZChjdC5uYW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpbmFsVmlld3MucHVzaChnZW5lcmF0ZWRWaWV3KTtcblx0XHRcdFx0cHJvY2Vzc2VkVmlld05hbWVzLmFkZChjdC5uYW1lKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKGRlZmF1bHRUeXBlKSBwcm9jZXNzVHlwZShkZWZhdWx0VHlwZSk7XG5cdFx0Zm9yIChjb25zdCBjdCBvZiBvdGhlclR5cGVzKSBwcm9jZXNzVHlwZShjdCk7XG5cblx0XHQvLyAyLiBBZGQgb3RoZXIgdW5pcXVlIHZpZXdzIChwcmVzZXJ2aW5nIG9yaWdpbmFsIG9yZGVyIGFzIG11Y2ggYXMgcG9zc2libGUpXG5cdFx0Zm9yIChjb25zdCB2aWV3IG9mIGV4aXN0aW5nVmlld3MpIHtcblx0XHRcdGlmICh2aWV3Lm5hbWUgPT09ICdWYXVsdCBDTVMgR3VpZGUnIHx8IHZpZXcubmFtZSA9PT0gJ0d1aWRlJyB8fCBwcm9jZXNzZWRWaWV3TmFtZXMuaGFzKHZpZXcubmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0ZmluYWxWaWV3cy5wdXNoKHZpZXcpO1xuXHRcdH1cblxuXHRcdC8vIDMuIEFkZCBWYXVsdCBDTVMgR3VpZGUgbGFzdFxuXHRcdGxldCBndWlkZVZpZXcgPSB2aWV3c0J5TmFtZS5nZXQoJ1ZhdWx0IENNUyBHdWlkZScpIHx8IHZpZXdzQnlOYW1lLmdldCgnR3VpZGUnKTtcblx0XHRpZiAoZ3VpZGVWaWV3KSB7XG5cdFx0XHRndWlkZVZpZXcgPSB7IC4uLmd1aWRlVmlldywgbmFtZTogJ1ZhdWx0IENNUyBHdWlkZScgfTtcblx0XHRcdGZpbmFsVmlld3MucHVzaChndWlkZVZpZXcpO1xuXHRcdH1cblxuXHRcdC8vIFNlcmlhbGl6ZSBhbGwgZmluYWwgdmlld3Ncblx0XHRmb3IgKGNvbnN0IHZpZXcgb2YgZmluYWxWaWV3cykge1xuXHRcdFx0bGluZXMucHVzaCguLi50aGlzLnNlcmlhbGl6ZVZpZXcodmlldykpO1xuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVWaWV3Rm9yQ29udGVudFR5cGUoXG5cdFx0Y29udGVudFR5cGU6IENvbnRlbnRUeXBlQ29uZmlnLFxuXHRcdHByb3BzOiBGcm9udG1hdHRlclByb3BlcnRpZXMsXG5cdFx0cHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHRcblx0KTogYW55IHtcblx0XHRjb25zdCBmb2xkZXJQYXRoID0gdGhpcy5wYXRoUmVzb2x2ZXIuZ2V0QmFzZXNDTVNGb2xkZXJQYXRoKGNvbnRlbnRUeXBlLmZvbGRlciwgcHJvamVjdERldGVjdGlvbik7XG5cblx0XHRjb25zdCB2aWV3OiBhbnkgPSB7XG5cdFx0XHR0eXBlOiAnYmFzZXMtY21zJyxcblx0XHRcdG5hbWU6IGNvbnRlbnRUeXBlLm5hbWUsXG5cdFx0XHRmaWx0ZXJzOiB7XG5cdFx0XHRcdGFuZDogW1xuXHRcdFx0XHRcdGZvbGRlclBhdGggPT09ICcnIHx8IGZvbGRlclBhdGggPT09ICcuJyA/ICdmaWxlLmZvbGRlciA9PSBcIi9cIicgOiBgZmlsZS5mb2xkZXIuc3RhcnRzV2l0aChcIiR7Zm9sZGVyUGF0aH1cIilgXG5cdFx0XHRcdF1cblx0XHRcdH0sXG5cdFx0XHRpbWFnZUZvcm1hdDogJ2NvdmVyJyxcblx0XHRcdHNob3dEYXRlOiB0cnVlLFxuXHRcdFx0Y3VzdG9taXplTmV3QnV0dG9uOiB0cnVlLFxuXHRcdFx0bmV3Tm90ZUxvY2F0aW9uOiBmb2xkZXJQYXRoLFxuXHRcdFx0ZmFsbGJhY2tUb0VtYmVkczogJ2lmLWVtcHR5Jyxcblx0XHRcdHByb3BlcnR5RGlzcGxheTE6ICdmaWxlLmZ1bGxuYW1lJyxcblx0XHRcdHNob3dUZXh0UHJldmlldzogdHJ1ZSxcblx0XHRcdHByb3BlcnR5TGFiZWxzOiAnYWJvdmUnLFxuXHRcdFx0c29ydDogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cHJvcGVydHk6IHByb3BzLmRhdGVQcm9wZXJ0eSA/IGBub3RlLiR7cHJvcHMuZGF0ZVByb3BlcnR5fWAgOiAnZmlsZS5jdGltZScsXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiAnREVTQydcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH07XG5cblx0XHQvLyBIYW5kbGUgYmxhbmsgdGl0bGUvZGF0ZSBwcm9wZXJ0aWVzXG5cdFx0aWYgKHByb3BzLnRpdGxlUHJvcGVydHkpIHtcblx0XHRcdHZpZXcudGl0bGVQcm9wZXJ0eSA9IGBub3RlLiR7cHJvcHMudGl0bGVQcm9wZXJ0eX1gO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWV3LnRpdGxlUHJvcGVydHkgPSBgZmlsZS5mdWxsbmFtZWA7XG5cdFx0fVxuXG5cdFx0aWYgKHByb3BzLmRhdGVQcm9wZXJ0eSkge1xuXHRcdFx0dmlldy5kYXRlUHJvcGVydHkgPSBgbm90ZS4ke3Byb3BzLmRhdGVQcm9wZXJ0eX1gO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWV3LmRhdGVQcm9wZXJ0eSA9IGBmaWxlLmN0aW1lYDtcblx0XHR9XG5cblx0XHRpZiAocHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSkge1xuXHRcdFx0dmlldy5kZXNjcmlwdGlvblByb3BlcnR5ID0gYG5vdGUuJHtwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5fWA7XG5cdFx0fVxuXG5cdFx0aWYgKHByb3BzLmltYWdlUHJvcGVydHkpIHtcblx0XHRcdHZpZXcuaW1hZ2VQcm9wZXJ0eSA9IGBub3RlLiR7cHJvcHMuaW1hZ2VQcm9wZXJ0eX1gO1xuXHRcdH1cblxuXHRcdHZpZXcuc2hvd1RhZ3MgPSAhIXByb3BzLnRhZ3NQcm9wZXJ0eTtcblx0XHRpZiAocHJvcHMudGFnc1Byb3BlcnR5KSB7XG5cdFx0XHR2aWV3LnRhZ3NQcm9wZXJ0eSA9IGBub3RlLiR7cHJvcHMudGFnc1Byb3BlcnR5fWA7XG5cdFx0fVxuXG5cdFx0dmlldy5zaG93RHJhZnRTdGF0dXMgPSAhIXByb3BzLmhhc0RyYWZ0U3RhdHVzO1xuXHRcdGlmIChwcm9wcy5oYXNEcmFmdFN0YXR1cykge1xuXHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdFx0dmlldy5kcmFmdFN0YXR1c1Byb3BlcnR5ID0gYG5vdGUuJHtwcm9wcy5kcmFmdFByb3BlcnR5fWA7XG5cdFx0XHRcdHZpZXcuZHJhZnRTdGF0dXNSZXZlcnNlID0gcHJvcHMuZHJhZnRMb2dpYyA9PT0gJ2ZhbHNlLWRyYWZ0Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZpZXcuZHJhZnRTdGF0dXNVc2VGaWxlbmFtZVByZWZpeCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXc7XG5cdH1cblxuXG5cdHByaXZhdGUgY2FwaXRhbGl6ZUZpcnN0KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZSBhIHZpZXcgb2JqZWN0IHRvIFlBTUwgbGluZXMgKHdpdGggcHJvcGVyIGluZGVudGF0aW9uKVxuXHQgKi9cblx0cHJpdmF0ZSBzZXJpYWxpemVWaWV3KHZpZXc6IHsgbmFtZT86IHN0cmluZzsgZmlsdGVycz86IHsgYW5kPzogQXJyYXk8c3RyaW5nIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+IH07IGdyb3VwQnk/OiB7IHByb3BlcnR5Pzogc3RyaW5nOyBkaXJlY3Rpb24/OiBzdHJpbmcgfSB8IHN0cmluZzsgb3JkZXI/OiBzdHJpbmdbXTsgc29ydD86IEFycmF5PHsgcHJvcGVydHk/OiBzdHJpbmc7IGRpcmVjdGlvbj86IHN0cmluZyB9Pjtba2V5OiBzdHJpbmddOiB1bmtub3duIH0pOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3Qgdmlld0xpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdHZpZXdMaW5lcy5wdXNoKCcgIC0gdHlwZTogYmFzZXMtY21zJyk7XG5cdFx0dmlld0xpbmVzLnB1c2goYCAgICBuYW1lOiBcIiR7dmlldy5uYW1lfVwiYCk7XG5cblx0XHRpZiAodmlldy5maWx0ZXJzKSB7XG5cdFx0XHR2aWV3TGluZXMucHVzaCgnICAgIGZpbHRlcnM6Jyk7XG5cdFx0XHRpZiAodmlldy5maWx0ZXJzLmFuZCkge1xuXHRcdFx0XHRpZiAodmlldy5maWx0ZXJzLmFuZC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaCgnICAgICAgYW5kOiBbXScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgICBhbmQ6Jyk7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBmaWx0ZXIgb2Ygdmlldy5maWx0ZXJzLmFuZCkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgICAgIC0gJHtmaWx0ZXJ9YCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBvYmplY3QgZmlsdGVycyBsaWtlIHsgXCJmaWxlLmZvbGRlci5zdGFydHNXaXRoXCI6IFwicG9zdHNcIiB9XG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpbHRlcikpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCB2YWx1ZVN0ciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBgXCIke3ZhbHVlfVwiYCA6IFN0cmluZyh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAgICAgLSAke2tleX06ICR7dmFsdWVTdHJ9YCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodmlldy5ncm91cEJ5KSB7XG5cdFx0XHR2aWV3TGluZXMucHVzaCgnICAgIGdyb3VwQnk6Jyk7XG5cdFx0XHRpZiAodHlwZW9mIHZpZXcuZ3JvdXBCeSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKHZpZXcuZ3JvdXBCeS5wcm9wZXJ0eSkgdmlld0xpbmVzLnB1c2goYCAgICAgIHByb3BlcnR5OiAke3ZpZXcuZ3JvdXBCeS5wcm9wZXJ0eX1gKTtcblx0XHRcdFx0aWYgKHZpZXcuZ3JvdXBCeS5kaXJlY3Rpb24pIHZpZXdMaW5lcy5wdXNoKGAgICAgICBkaXJlY3Rpb246ICR7dmlldy5ncm91cEJ5LmRpcmVjdGlvbn1gKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZpZXcuZ3JvdXBCeSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAgICR7dmlldy5ncm91cEJ5fWApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh2aWV3Lm9yZGVyKSB7XG5cdFx0XHRpZiAodmlldy5vcmRlci5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICBvcmRlcjogW10nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgb3JkZXI6Jyk7XG5cdFx0XHRcdGZvciAoY29uc3Qgb3JkZXJJdGVtIG9mIHZpZXcub3JkZXIpIHtcblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICAgLSAke29yZGVySXRlbX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh2aWV3LnNvcnQpIHtcblx0XHRcdGlmICh2aWV3LnNvcnQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgc29ydDogW10nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgc29ydDonKTtcblx0XHRcdFx0Zm9yIChjb25zdCBzb3J0SXRlbSBvZiB2aWV3LnNvcnQpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHNvcnRJdGVtID09PSAnb2JqZWN0JyAmJiBzb3J0SXRlbS5wcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAgIC0gcHJvcGVydHk6ICR7c29ydEl0ZW0ucHJvcGVydHl9YCk7XG5cdFx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICAgICBkaXJlY3Rpb246ICR7c29ydEl0ZW0uZGlyZWN0aW9uIHx8ICdBU0MnfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCBhbGwgb3RoZXIgcHJvcGVydGllcyAtIHByZXNlcnZlIEFMTCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9yaWdpbmFsIHZpZXdcblx0XHQvLyBUaGlzIGVuc3VyZXMgd2UgZG9uJ3QgbG9zZSBhbnkgc2V0dGluZ3MgbGlrZSBoaWRlUXVpY2tFZGl0SWNvblxuXHRcdC8vIFNraXAgcHJvcGVydGllcyB0aGF0IGFyZSBhbHJlYWR5IGhhbmRsZWQgYWJvdmUgKHR5cGUsIG5hbWUsIGZpbHRlcnMsIGdyb3VwQnksIG9yZGVyLCBzb3J0KVxuXHRcdGNvbnN0IHNraXBQcm9wcyA9IFsndHlwZScsICduYW1lJywgJ2ZpbHRlcnMnLCAnZ3JvdXBCeScsICdvcmRlcicsICdzb3J0J107XG5cblx0XHQvLyBTZXJpYWxpemUgYWxsIHJlbWFpbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhlIHZpZXdcblx0XHRmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXModmlldykpIHtcblx0XHRcdGlmIChza2lwUHJvcHMuaW5jbHVkZXMocHJvcCkgfHwgdmlld1twcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHZpZXdbcHJvcF07XG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAke3Byb3B9OiBudWxsYCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgJHtwcm9wfTogJHt2YWx1ZX1gKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06ICR7dmFsdWV9YCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSAnJykge1xuXHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgJHtwcm9wfTogXCJcImApO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEZvciBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdGUvZmlsZSByZWZlcmVuY2VzLCBkb24ndCBxdW90ZSB0aGVtXG5cdFx0XHRcdC8vIENoZWNrIGZvciBwcm9wZXJ0eURpc3BsYXlOIGFzIHdlbGwgYXMgYW55dGhpbmcgZW5kaW5nIGluIFByb3BlcnR5XG5cdFx0XHRcdGNvbnN0IGlzUHJvcGVydHlSZWYgPSAocHJvcC5pbmNsdWRlcygnUHJvcGVydHknKSB8fCBwcm9wLnN0YXJ0c1dpdGgoJ3Byb3BlcnR5RGlzcGxheScpKSAmJlxuXHRcdFx0XHRcdCh2YWx1ZS5zdGFydHNXaXRoKCdub3RlLicpIHx8IHZhbHVlLnN0YXJ0c1dpdGgoJ2ZpbGUuJykpO1xuXG5cdFx0XHRcdGlmIChpc1Byb3BlcnR5UmVmKSB7XG5cdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAke3Byb3B9OiAke3ZhbHVlfWApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByb3AgPT09ICduZXdOb3RlTG9jYXRpb24nKSB7XG5cdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAke3Byb3B9OiBcIiR7dmFsdWV9XCJgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBRdW90ZSBvdGhlciBzdHJpbmdzXG5cdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAke3Byb3B9OiBcIiR7dmFsdWV9XCJgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3TGluZXM7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgU0VPQ29uZmlnLCBDb250ZW50VHlwZUNvbmZpZywgRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLCBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBQYXRoUmVzb2x2ZXIgfSBmcm9tICcuL1BhdGhSZXNvbHZlcic7XHJcbmltcG9ydCB7IFNhZmVDb25maWdXcml0ZXIgfSBmcm9tICcuL1NhZmVDb25maWdXcml0ZXInO1xyXG5cclxudHlwZSBTRU9QbHVnaW4gPSB7XHJcblx0c2V0dGluZ3M/OiB7XHJcblx0XHRzY2FuRGlyZWN0b3JpZXM/OiBzdHJpbmc7XHJcblx0XHR0aXRsZVByb3BlcnR5Pzogc3RyaW5nO1xyXG5cdFx0ZGVzY3JpcHRpb25Qcm9wZXJ0eT86IHN0cmluZztcclxuXHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XHJcblx0fTtcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59O1xyXG5cclxudHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBTRU9QbHVnaW4+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFNFT0NvbmZpZ3VyYXRvciB7XHJcblx0cHJpdmF0ZSBhcHA6IEFwcDtcclxuXHRwcml2YXRlIHBhdGhSZXNvbHZlcjogUGF0aFJlc29sdmVyO1xyXG5cdHByaXZhdGUgc2FmZVdyaXRlcjogU2FmZUNvbmZpZ1dyaXRlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdFx0dGhpcy5wYXRoUmVzb2x2ZXIgPSBuZXcgUGF0aFJlc29sdmVyKGFwcCk7XHJcblx0XHR0aGlzLnNhZmVXcml0ZXIgPSBuZXcgU2FmZUNvbmZpZ1dyaXRlcihhcHApO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVTRU9Db25maWcoXHJcblx0XHRjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10sXHJcblx0XHRmcm9udG1hdHRlclByb3BlcnRpZXM6IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEZyb250bWF0dGVyUHJvcGVydGllcyB9LFxyXG5cdFx0cHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQsXHJcblx0XHRlbmFibGVNZHhTdXBwb3J0PzogYm9vbGVhblxyXG5cdCk6IFNFT0NvbmZpZyB7XHJcblx0XHQvLyBVc2UgdGhlIGZpcnN0IGNvbnRlbnQgdHlwZSdzIHByb3BlcnRpZXMgYXMgZGVmYXVsdHNcclxuXHRcdGNvbnN0IGZpcnN0VHlwZSA9IGNvbnRlbnRUeXBlcy5maW5kKGN0ID0+IGN0LmVuYWJsZWQpO1xyXG5cdFx0Y29uc3QgZmlyc3RQcm9wcyA9IGZpcnN0VHlwZSA/IGZyb250bWF0dGVyUHJvcGVydGllc1tmaXJzdFR5cGUuaWRdIDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdC8vIEJ1aWxkIHNjYW4gZGlyZWN0b3JpZXMgZnJvbSBhbGwgZW5hYmxlZCBjb250ZW50IHR5cGVzXHJcblx0XHRjb25zdCBzY2FuRGlyZWN0b3JpZXMgPSBjb250ZW50VHlwZXNcclxuXHRcdFx0LmZpbHRlcihjdCA9PiBjdC5lbmFibGVkKVxyXG5cdFx0XHQubWFwKGN0ID0+IHRoaXMucGF0aFJlc29sdmVyLmdldEZvbGRlclBhdGhGcm9tVmF1bHRSb290KGN0LmZvbGRlciwgcHJvamVjdERldGVjdGlvbikpXHJcblx0XHRcdC5qb2luKCcsJyk7XHJcblxyXG5cdFx0Y29uc3QgY29uZmlnOiBTRU9Db25maWcgPSB7XHJcblx0XHRcdC8vIE9ubHkgc2V0IHRpdGxlUHJvcGVydHkgaWYgaXQgZXhpc3RzIChub3QgYmxhbmspIC0gdGhpcyBjb21lcyBmcm9tIHRoZSB3aXphcmRcclxuXHRcdFx0dGl0bGVQcm9wZXJ0eTogZmlyc3RQcm9wcz8udGl0bGVQcm9wZXJ0eSAmJiBmaXJzdFByb3BzLnRpdGxlUHJvcGVydHkudHJpbSgpICE9PSAnJyBcclxuXHRcdFx0XHQ/IGZpcnN0UHJvcHMudGl0bGVQcm9wZXJ0eSBcclxuXHRcdFx0XHQ6ICd0aXRsZScsIC8vIERlZmF1bHQgZmFsbGJhY2tcclxuXHRcdFx0Ly8gT25seSBzZXQgZGVzY3JpcHRpb25Qcm9wZXJ0eSBpZiBpdCBleGlzdHMgKG5vdCBibGFuaykgLSB0aGlzIGNvbWVzIGZyb20gdGhlIHdpemFyZFxyXG5cdFx0XHRkZXNjcmlwdGlvblByb3BlcnR5OiBmaXJzdFByb3BzPy5kZXNjcmlwdGlvblByb3BlcnR5ICYmIGZpcnN0UHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eS50cmltKCkgIT09ICcnXHJcblx0XHRcdFx0PyBmaXJzdFByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHlcclxuXHRcdFx0XHQ6IHVuZGVmaW5lZCxcclxuXHRcdFx0c2NhbkRpcmVjdG9yaWVzOiBzY2FuRGlyZWN0b3JpZXMsXHJcblx0XHRcdC8vIERvbid0IHNldCB0aGVzZSAtIHdlIGRvbid0IGNvbGxlY3QgdGhlbSBpbiB0aGUgd2l6YXJkXHJcblx0XHRcdGtleXdvcmRQcm9wZXJ0eTogdW5kZWZpbmVkLFxyXG5cdFx0XHR1c2VGaWxlbmFtZUFzVGl0bGU6IGZhbHNlLFxyXG5cdFx0XHR1c2VGaWxlbmFtZUFzU2x1ZzogdHJ1ZSxcclxuXHRcdFx0ZW5hYmxlTURYU3VwcG9ydDogZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZUNvbmZpZyhjb25maWc6IFNFT0NvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyKVxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc3Qgc2VvUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uWydzZW8nXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChzZW9QbHVnaW4gJiYgc2VvUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Y29uc3QgcGx1Z2luU2V0dGluZ3MgPSBzZW9QbHVnaW4uc2V0dGluZ3M7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gVXBkYXRlIHNldHRpbmdzIGZyb20gY29uZmlnIC0gb25seSB1cGRhdGUgd2hhdCB3ZSBjb2xsZWN0IGluIHRoZSB3aXphcmRcclxuXHRcdFx0XHQvLyAxLiBzY2FuRGlyZWN0b3JpZXMgLSBhbHdheXMgdXBkYXRlIChnZW5lcmF0ZWQgZnJvbSBjb250ZW50IHR5cGVzKVxyXG5cdFx0XHRcdGlmIChjb25maWcuc2NhbkRpcmVjdG9yaWVzKSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5zY2FuRGlyZWN0b3JpZXMgPSBjb25maWcuc2NhbkRpcmVjdG9yaWVzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyAyLiB0aXRsZVByb3BlcnR5IC0gdXBkYXRlIGlmIHByb3ZpZGVkIChjb2xsZWN0ZWQgaW4gd2l6YXJkKVxyXG5cdFx0XHRcdGlmIChjb25maWcudGl0bGVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy50aXRsZVByb3BlcnR5ID0gY29uZmlnLnRpdGxlUHJvcGVydHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIDMuIGRlc2NyaXB0aW9uUHJvcGVydHkgLSB1cGRhdGUgaWYgcHJvdmlkZWQgKGNvbGxlY3RlZCBpbiB3aXphcmQpXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5kZXNjcmlwdGlvblByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLmRlc2NyaXB0aW9uUHJvcGVydHkgPSBjb25maWcuZGVzY3JpcHRpb25Qcm9wZXJ0eTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gNC4gZW5hYmxlTURYU3VwcG9ydCAtIHVwZGF0ZSBpZiBwcm92aWRlZCAoY29sbGVjdGVkIGluIHdpemFyZClcclxuXHRcdFx0XHRpZiAoY29uZmlnLmVuYWJsZU1EWFN1cHBvcnQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZW5hYmxlTURYU3VwcG9ydCA9IGNvbmZpZy5lbmFibGVNRFhTdXBwb3J0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBEb24ndCB1cGRhdGUga2V5d29yZFByb3BlcnR5LCB1c2VGaWxlbmFtZUFzVGl0bGUsIG9yIHVzZUZpbGVuYW1lQXNTbHVnXHJcblx0XHRcdFx0Ly8gLSB3ZSBkb24ndCBjb2xsZWN0IHRoZXNlIGluIHRoZSB3aXphcmQsIGxldCB1c2VyIGNvbmZpZ3VyZSBpbiBTRU8gcGx1Z2luIHNldHRpbmdzXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2F2ZSB0aGUgc2V0dGluZ3MgdXNpbmcgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZFxyXG5cdFx0XHRcdGlmICh0eXBlb2Ygc2VvUGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0YXdhaXQgc2VvUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnU0VPQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFNFTyBjb25maWcgdmlhIHBsdWdpbiBtZXRob2Q6JywgZXJyb3IpO1xyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZFxyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnOiBTRU9Db25maWcpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ3Nlbyc7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIHNhZmVseVxyXG5cdFx0XHRsZXQgZXhpc3RpbmdEYXRhID0gYXdhaXQgdGhpcy5zYWZlV3JpdGVyLnJlYWRDb25maWcocGx1Z2luSWQpO1xyXG5cdFx0XHRpZiAoIWV4aXN0aW5nRGF0YSkge1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IHt9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNZXJnZSBjb25maWcgaW50byBleGlzdGluZyBkYXRhIChwcmVzZXJ2ZSBhbGwgZXhpc3Rpbmcgc2V0dGluZ3MpXHJcblx0XHRcdC8vIE9ubHkgdXBkYXRlIHRoZSBwcm9wZXJ0aWVzIHdlIGNvbGxlY3QgaW4gdGhlIHdpemFyZDpcclxuXHRcdFx0Ly8gMS4gc2NhbkRpcmVjdG9yaWVzIChnZW5lcmF0ZWQgZnJvbSBjb250ZW50IHR5cGVzKVxyXG5cdFx0XHQvLyAyLiB0aXRsZVByb3BlcnR5IChjb2xsZWN0ZWQgaW4gd2l6YXJkKVxyXG5cdFx0XHQvLyAzLiBkZXNjcmlwdGlvblByb3BlcnR5IChjb2xsZWN0ZWQgaW4gd2l6YXJkKVxyXG5cdFx0XHQvLyBEb24ndCB0b3VjaCBrZXl3b3JkUHJvcGVydHksIHVzZUZpbGVuYW1lQXNUaXRsZSwgdXNlRmlsZW5hbWVBc1NsdWcsIGV0Yy5cclxuXHRcdFx0Y29uc3QgbWVyZ2VkRGF0YSA9IHtcclxuXHRcdFx0XHQuLi5leGlzdGluZ0RhdGEsXHJcblx0XHRcdFx0Ly8gQWx3YXlzIHVwZGF0ZSBzY2FuRGlyZWN0b3JpZXNcclxuXHRcdFx0XHRzY2FuRGlyZWN0b3JpZXM6IGNvbmZpZy5zY2FuRGlyZWN0b3JpZXMsXHJcblx0XHRcdFx0Ly8gVXBkYXRlIHRpdGxlUHJvcGVydHkgaWYgcHJvdmlkZWQgKGZyb20gd2l6YXJkKVxyXG5cdFx0XHRcdC4uLihjb25maWcudGl0bGVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICYmIHsgdGl0bGVQcm9wZXJ0eTogY29uZmlnLnRpdGxlUHJvcGVydHkgfSksXHJcblx0XHRcdFx0Ly8gVXBkYXRlIGRlc2NyaXB0aW9uUHJvcGVydHkgaWYgcHJvdmlkZWQgKGZyb20gd2l6YXJkKVxyXG5cdFx0XHRcdC4uLihjb25maWcuZGVzY3JpcHRpb25Qcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICYmIHsgZGVzY3JpcHRpb25Qcm9wZXJ0eTogY29uZmlnLmRlc2NyaXB0aW9uUHJvcGVydHkgfSksXHJcblx0XHRcdFx0Ly8gVXBkYXRlIGVuYWJsZU1EWFN1cHBvcnQgaWYgcHJvdmlkZWQgKGZyb20gd2l6YXJkKVxyXG5cdFx0XHRcdC4uLihjb25maWcuZW5hYmxlTURYU3VwcG9ydCAhPT0gdW5kZWZpbmVkICYmIHsgZW5hYmxlTURYU3VwcG9ydDogY29uZmlnLmVuYWJsZU1EWFN1cHBvcnQgfSlcclxuXHRcdFx0XHQvLyBBbGwgb3RoZXIgcHJvcGVydGllcyAoa2V5d29yZFByb3BlcnR5LCB1c2VGaWxlbmFtZUFzVGl0bGUsIHVzZUZpbGVuYW1lQXNTbHVnLCBldGMuKVxyXG5cdFx0XHRcdC8vIGFyZSBwcmVzZXJ2ZWQgZnJvbSBleGlzdGluZ0RhdGEgLSB3ZSBkb24ndCBjb2xsZWN0IHRoZW0gaW4gdGhlIHdpemFyZFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Ly8gV3JpdGUgY29uZmlnIHNhZmVseSB3aXRoIGJhY2t1cCBhbmQgdmFsaWRhdGlvblxyXG5cdFx0XHRjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zYWZlV3JpdGVyLndyaXRlQ29uZmlnKHBsdWdpbklkLCBtZXJnZWREYXRhLCB7XHJcblx0XHRcdFx0c2hvd05vdGljZTogdHJ1ZSxcclxuXHRcdFx0XHRjcmVhdGVCYWNrdXA6IHRydWVcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAoIXN1Y2Nlc3MpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFNFTyBjb25maWd1cmF0aW9uJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1NFT0NvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIFNFTyBwbHVnaW4gY29uZmlndXJhdGlvbicpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgU0VPIGNvbmZpZyAoZmFsbGJhY2spOicsIGVycm9yKTtcclxuXHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoY29uZmlnOiBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyIGFuZCBTRU8pXHJcblx0XHRcdHR5cGUgUGx1Z2luc0FQSSA9IHtcclxuXHRcdFx0XHRwbHVnaW5zPzogUmVjb3JkPHN0cmluZywge1xyXG5cdFx0XHRcdFx0c2V0dGluZ3M/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0XHRcdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcblx0XHRcdFx0fT47XHJcblx0XHRcdH07XHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LlsncHJvcGVydHktb3Zlci1maWxlLW5hbWUnXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbiAmJiBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdGNvbnN0IHBsdWdpblNldHRpbmdzID0gcHJvcGVydHlPdmVyRmlsZU5hbWVQbHVnaW4uc2V0dGluZ3M7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IFVzaW5nIHBsdWdpbi5zYXZlU2V0dGluZ3MoKSBtZXRob2QnKTtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogSW5wdXQgY29uZmlnLmVuYWJsZU1keFN1cHBvcnQgPScsIGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBVcGRhdGUgcHJvcGVydHlLZXkgaWYgcHJvdmlkZWRcclxuXHRcdFx0XHRpZiAoY29uZmlnLnByb3BlcnR5S2V5KSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5wcm9wZXJ0eUtleSA9IGNvbmZpZy5wcm9wZXJ0eUtleTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQUxXQVlTIHVwZGF0ZSBlbmFibGVNZHhTdXBwb3J0IGlmIHByb3ZpZGVkIChldmVuIGlmIGZhbHNlKVxyXG5cdFx0XHRcdGlmIChjb25maWcuZW5hYmxlTWR4U3VwcG9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVNZHhTdXBwb3J0ID0gY29uZmlnLmVuYWJsZU1keFN1cHBvcnQ7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogU2V0IHBsdWdpblNldHRpbmdzLmVuYWJsZU1keFN1cHBvcnQgdG8nLCBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0IGlzIHVuZGVmaW5lZCEnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2F2ZSB0aGUgc2V0dGluZ3MgdXNpbmcgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZFxyXG5cdFx0XHRcdGlmICh0eXBlb2YgcHJvcGVydHlPdmVyRmlsZU5hbWVQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBQbHVnaW4gc2F2ZVNldHRpbmdzIG5vdCBhdmFpbGFibGUsIHVzaW5nIGZhbGxiYWNrJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IFBsdWdpbiBub3QgZm91bmQgb3Igc2V0dGluZ3Mgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2snKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lIGNvbmZpZyB2aWEgcGx1Z2luIG1ldGhvZDonLCBlcnJvcik7XHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHNhdmVDb25maWdGYWxsYmFjayhjb25maWc6IFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdwcm9wZXJ0eS1vdmVyLWZpbGUtbmFtZSc7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHRsZXQgZXhpc3RpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xyXG5cdFx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKSkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBVc2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogSW5wdXQgY29uZmlnID0nLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IElucHV0IGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0ID0nLCBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBFeGlzdGluZyBkYXRhID0nLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEpKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIE1lcmdlIGNvbmZpZywgcHJlc2VydmluZyBleGlzdGluZyBzZXR0aW5nc1xyXG5cdFx0XHQvLyBGaXJzdCBzcHJlYWQgZXhpc3RpbmcgZGF0YSwgdGhlbiBzcHJlYWQgY29uZmlnICh3aGljaCBtYXkgaW5jbHVkZSBlbmFibGVNZHhTdXBwb3J0KVxyXG5cdFx0XHRjb25zdCBtZXJnZWREYXRhID0geyBcclxuXHRcdFx0XHQuLi5leGlzdGluZ0RhdGEsIFxyXG5cdFx0XHRcdC4uLmNvbmZpZ1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQUxXQVlTIGV4cGxpY2l0bHkgc2V0IGVuYWJsZU1keFN1cHBvcnQgaWYgaXQncyBwcm92aWRlZCBpbiBjb25maWcgKGV2ZW4gaWYgZmFsc2UpXHJcblx0XHRcdC8vIFRoaXMgZW5zdXJlcyBpdCBvdmVycmlkZXMgYW55IGV4aXN0aW5nIHZhbHVlXHJcblx0XHRcdGlmIChjb25maWcuZW5hYmxlTWR4U3VwcG9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0bWVyZ2VkRGF0YS5lbmFibGVNZHhTdXBwb3J0ID0gY29uZmlnLmVuYWJsZU1keFN1cHBvcnQ7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IEV4cGxpY2l0bHkgc2V0IGVuYWJsZU1keFN1cHBvcnQgdG8nLCBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogY29uZmlnLmVuYWJsZU1keFN1cHBvcnQgaXMgdW5kZWZpbmVkIScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogRmluYWwgbWVyZ2VkRGF0YS5lbmFibGVNZHhTdXBwb3J0ID0nLCBtZXJnZWREYXRhLmVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogRmluYWwgbWVyZ2VkRGF0YSA9JywgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSkpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0XHRjb25zdCBwbHVnaW5EaXIgPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH1gO1xyXG5cdFx0XHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdFx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRcdFx0Ly8gRm9sZGVyIG1pZ2h0IGFscmVhZHkgZXhpc3QgKHJhY2UgY29uZGl0aW9uKSwgaWdub3JlIGVycm9yXHJcblx0XHRcdFx0XHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaWxlXHJcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lIGNvbmZpZyAoZmFsbGJhY2spOicsIGVycm9yKTtcclxuXHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVUlUd2Vha2VyQ29tbWFuZCB7XHJcblx0aWQ6IHN0cmluZztcclxuXHRpY29uOiBzdHJpbmc7XHJcblx0bmFtZTogc3RyaW5nO1xyXG5cdGRpc3BsYXlOYW1lOiBzdHJpbmc7XHJcblx0bW9kZTogc3RyaW5nO1xyXG5cdHRvZ2dsZUljb24/OiBzdHJpbmc7XHJcblx0c2hvd09uRmlsZVR5cGVzPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVJVHdlYWtlckNvbmZpZyB7XHJcblx0dGFiQmFyQ29tbWFuZHM/OiBVSVR3ZWFrZXJDb21tYW5kW107XHJcbn1cclxuXHJcbnR5cGUgUGx1Z2luV2l0aFNldHRpbmdzID0ge1xyXG5cdHNldHRpbmdzPzogVUlUd2Vha2VyQ29uZmlnO1xyXG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIFBsdWdpbldpdGhTZXR0aW5ncz47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgVUlUd2Vha2VyQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlQ29uZmlnKGVuYWJsZU1keFN1cHBvcnQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ3VpLXR3ZWFrZXInO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIGxpdmUgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCB1aVR3ZWFrZXJQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHVpVHdlYWtlclBsdWdpbiAmJiB1aVR3ZWFrZXJQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdVSVR3ZWFrZXJDb25maWc6IFVzaW5nIHBsdWdpbi5zZXR0aW5ncyBBUEknKTtcclxuXHRcdFx0XHRjb25zdCBzZXR0aW5ncyA9IHVpVHdlYWtlclBsdWdpbi5zZXR0aW5ncztcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBGb3JjZSB0aGUgTURYIHVwZGF0ZVxyXG5cdFx0XHRcdHRoaXMuZm9yY2VNZHhVcGRhdGUoc2V0dGluZ3MsIGVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFNhdmUgc2V0dGluZ3MgdmlhIHBsdWdpbiBBUElcclxuXHRcdFx0XHRpZiAodHlwZW9mIHVpVHdlYWtlclBsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGF3YWl0IHVpVHdlYWtlclBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1VJVHdlYWtlckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kIGlmIHBsdWdpbiBub3QgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1VJVHdlYWtlckNvbmZpZzogUGx1Z2luIEFQSSBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhlbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFVJIFR3ZWFrZXIgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gVHJ5IGZhbGxiYWNrIGFueXdheVxyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhlbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZm9yY2VNZHhVcGRhdGUoc2V0dGluZ3M6IFVJVHdlYWtlckNvbmZpZywgZW5hYmxlTWR4U3VwcG9ydDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgbWR4RmlsZVR5cGVzID0gZW5hYmxlTWR4U3VwcG9ydCA/ICdtZCxtZHgnIDogJ21kJztcclxuXHRcdFxyXG5cdFx0aWYgKCFzZXR0aW5ncy50YWJCYXJDb21tYW5kcyB8fCAhQXJyYXkuaXNBcnJheShzZXR0aW5ncy50YWJCYXJDb21tYW5kcykpIHtcclxuXHRcdFx0c2V0dGluZ3MudGFiQmFyQ29tbWFuZHMgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YWJCYXJDb21tYW5kcyA9IHNldHRpbmdzLnRhYkJhckNvbW1hbmRzIGFzIHVua25vd24gYXMgQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+O1xyXG5cdFx0Y29uc3QgdG9vbGJhckNvbW1hbmRJbmRleCA9IHRhYkJhckNvbW1hbmRzLmZpbmRJbmRleChjbWQgPT4gY21kLmlkID09PSAnZWRpdGluZy10b29sYmFyOmhpZGUtc2hvdy1tZW51Jyk7XHJcblxyXG5cdFx0aWYgKHRvb2xiYXJDb21tYW5kSW5kZXggIT09IC0xKSB7XHJcblx0XHRcdC8vIE9OTFkgdXBkYXRlIHNob3dPbkZpbGVUeXBlcywgbGVhdmUgZXZlcnl0aGluZyBlbHNlIGFsb25lIVxyXG5cdFx0XHR0YWJCYXJDb21tYW5kc1t0b29sYmFyQ29tbWFuZEluZGV4XSA9IHtcclxuXHRcdFx0XHQuLi50YWJCYXJDb21tYW5kc1t0b29sYmFyQ29tbWFuZEluZGV4XSxcclxuXHRcdFx0XHRcInNob3dPbkZpbGVUeXBlc1wiOiBtZHhGaWxlVHlwZXNcclxuXHRcdFx0fTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhgVUlUd2Vha2VyQ29uZmlnOiBVcGRhdGVkIGV4aXN0aW5nIHRvb2xiYXIgY29tbWFuZCBzaG93T25GaWxlVHlwZXMgdG8gJHttZHhGaWxlVHlwZXN9YCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBPbmx5IGFkZCBpZiBtaXNzaW5nLCB1c2luZyB0aGUgdXNlcidzIHByZWZlcnJlZCBkZWZhdWx0c1xyXG5cdFx0XHR0YWJCYXJDb21tYW5kcy5wdXNoKHtcclxuXHRcdFx0XHRcImlkXCI6IFwiZWRpdGluZy10b29sYmFyOmhpZGUtc2hvdy1tZW51XCIsXHJcblx0XHRcdFx0XCJpY29uXCI6IFwibHVjaWRlLXBhbmVsLXRvcC1vcGVuXCIsXHJcblx0XHRcdFx0XCJuYW1lXCI6IFwiVG9nZ2xlIGVkaXRpbmcgdG9vbGJhclwiLFxyXG5cdFx0XHRcdFwiZGlzcGxheU5hbWVcIjogXCJFZGl0aW5nIFRvb2xiYXI6IEhpZGUvU2hvdyBcIixcclxuXHRcdFx0XHRcIm1vZGVcIjogXCJkZXNrdG9wXCIsXHJcblx0XHRcdFx0XCJ0b2dnbGVJY29uXCI6IFwibHVjaWRlLXBhbmVsLXRvcC1jbG9zZVwiLFxyXG5cdFx0XHRcdFwic2hvd09uRmlsZVR5cGVzXCI6IG1keEZpbGVUeXBlc1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhgVUlUd2Vha2VyQ29uZmlnOiBBZGRlZCBtaXNzaW5nIHRvb2xiYXIgY29tbWFuZCB3aXRoIHNob3dPbkZpbGVUeXBlcz0ke21keEZpbGVUeXBlc31gKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGVuYWJsZU1keFN1cHBvcnQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ3VpLXR3ZWFrZXInO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyB1aS10d2Vha2VyIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBGb3JjZSB0aGUgTURYIHVwZGF0ZSBvbiB0aGUgbWVyZ2VkIGRhdGFcclxuXHRcdHRoaXMuZm9yY2VNZHhVcGRhdGUoZXhpc3RpbmdEYXRhIGFzIHVua25vd24gYXMgVUlUd2Vha2VyQ29uZmlnLCBlbmFibGVNZHhTdXBwb3J0KTtcclxuXHJcblx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRjb25zdCBwbHVnaW5EaXJGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcblx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGb2xkZXIgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2F2ZSB0byBmaWxlXHJcblx0XHRjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKTtcclxuXHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgY29udGVudCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0Y29uc29sZS5kZWJ1ZygnVUlUd2Vha2VyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdWktdHdlYWtlciBjb25maWcgdmlhIGZhbGxiYWNrJyk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEYXRhRmlsZXNFZGl0b3JTZXR0aW5ncyB7XHJcbiAgICBkb0xvYWRUeHQ6IGJvb2xlYW47XHJcbiAgICBkb0NyZWF0ZVR4dDogYm9vbGVhbjtcclxuICAgIGRvTG9hZFhtbDogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlWG1sOiBib29sZWFuO1xyXG4gICAgZG9Mb2FkSnNvbjogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlSnNvbjogYm9vbGVhbjtcclxuICAgIGRvTG9hZFlhbWw6IGJvb2xlYW47XHJcbiAgICBkb0NyZWF0ZVlhbWw6IGJvb2xlYW47XHJcbiAgICBkb0xvYWRBc3RybzogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlQXN0cm86IGJvb2xlYW47XHJcbiAgICBkb0xvYWRUczogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlVHM6IGJvb2xlYW47XHJcbiAgICBkb0xvYWRDc3M6IGJvb2xlYW47XHJcbiAgICBkb0NyZWF0ZUNzczogYm9vbGVhbjtcclxuICAgIGRvTG9hZEh0bWw6IGJvb2xlYW47XHJcbiAgICBkb0NyZWF0ZUh0bWw6IGJvb2xlYW47XHJcbiAgICBkb0xvYWRKczogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlSnM6IGJvb2xlYW47XHJcbiAgICBkb0xvYWRNanM6IGJvb2xlYW47XHJcbiAgICBkb0NyZWF0ZU1qczogYm9vbGVhbjtcclxuICAgIGRvQXV0b3NhdmVGaWxlczogYm9vbGVhbjtcclxuICAgIGxpbmVXcmFwcGluZzogYm9vbGVhbjtcclxuICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XHJcbn1cclxuXHJcbnR5cGUgUGx1Z2luV2l0aFNldHRpbmdzID0ge1xyXG4gICAgc2V0dGluZ3M/OiBEYXRhRmlsZXNFZGl0b3JTZXR0aW5ncztcclxuICAgIHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcbiAgICBwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgUGx1Z2luV2l0aFNldHRpbmdzPjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXRhRmlsZXNFZGl0b3JDb25maWd1cmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBhcHA6IEFwcDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNhdmVDb25maWcoZW5hYmxlZDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHBsdWdpbklkID0gJ2RhdGEtZmlsZXMtZWRpdG9yJztcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBsaXZlIHNldHRpbmdzIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICBjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuICAgICAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwbHVnaW4gJiYgcGx1Z2luLnNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEYXRhRmlsZXNFZGl0b3JDb25maWc6IFVzaW5nIHBsdWdpbi5zZXR0aW5ncyBBUEknKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gcGx1Z2luLnNldHRpbmdzO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlTZXR0aW5ncyhzZXR0aW5ncywgZW5hYmxlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBzZXR0aW5ncyB2aWEgcGx1Z2luIEFQSVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RhdGFGaWxlc0VkaXRvckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kIGlmIHBsdWdpbiBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RhdGFGaWxlc0VkaXRvckNvbmZpZzogUGx1Z2luIEFQSSBub3QgYXZhaWxhYmxlIG9yIHNldHRpbmdzIG5vdCBsb2FkZWQsIHVzaW5nIGZhbGxiYWNrIGZpbGUgbWV0aG9kJyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGVuYWJsZWQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIERhdGEgRmlsZXMgRWRpdG9yIGNvbmZpZzonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIC8vIFRyeSBmYWxsYmFjayBhbnl3YXlcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soZW5hYmxlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXBwbHlTZXR0aW5ncyhzZXR0aW5nczogRGF0YUZpbGVzRWRpdG9yU2V0dGluZ3MgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgZW5hYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIC8vIFNldCBKU09OIGFuZCBBc3RybyBiYXNlZCBvbiB0aGUgdG9nZ2xlXHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkSnNvbiA9IGVuYWJsZWQ7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVKc29uID0gZW5hYmxlZDtcclxuICAgICAgICBzZXR0aW5ncy5kb0xvYWRBc3RybyA9IGVuYWJsZWQ7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVBc3RybyA9IGVuYWJsZWQ7XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgYWxsIG90aGVyIFwibG9hZC9jcmVhdGVcIiBzZXR0aW5ncyB0byBmYWxzZSBhcyByZXF1ZXN0ZWRcclxuICAgICAgICBzZXR0aW5ncy5kb0xvYWRUeHQgPSBmYWxzZTtcclxuICAgICAgICBzZXR0aW5ncy5kb0NyZWF0ZVR4dCA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvTG9hZFhtbCA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvQ3JlYXRlWG1sID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkWWFtbCA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvQ3JlYXRlWWFtbCA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvTG9hZFRzID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVUcyA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvTG9hZENzcyA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvQ3JlYXRlQ3NzID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkSHRtbCA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvQ3JlYXRlSHRtbCA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvTG9hZEpzID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVKcyA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvTG9hZE1qcyA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvQ3JlYXRlTWpzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB0aGVzZSBhcmUgdHJ1ZSBhcyByZXF1ZXN0ZWRcclxuICAgICAgICBzZXR0aW5ncy5kb0F1dG9zYXZlRmlsZXMgPSB0cnVlO1xyXG4gICAgICAgIHNldHRpbmdzLmxpbmVXcmFwcGluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soZW5hYmxlZDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHBsdWdpbklkID0gJ2RhdGEtZmlsZXMtZWRpdG9yJztcclxuICAgICAgICBjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcbiAgICAgICAgY29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHJcbiAgICAgICAgbGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuICAgICAgICBjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblxyXG4gICAgICAgIGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIGRhdGEtZmlsZXMtZWRpdG9yIGRhdGEuanNvbjonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHRoZSBzZXR0aW5ncyB1cGRhdGVcclxuICAgICAgICB0aGlzLmFwcGx5U2V0dGluZ3MoZXhpc3RpbmdEYXRhLCBlbmFibGVkKTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHBsdWdpbiBkaXJlY3RvcnkgZXhpc3RzXHJcbiAgICAgICAgY29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuICAgICAgICBjb25zdCBwbHVnaW5EaXJGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcbiAgICAgICAgaWYgKCFwbHVnaW5EaXJGaWxlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRm9sZGVyIGFscmVhZHkgZXhpc3RzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2F2ZSB0byBmaWxlXHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nRGF0YSwgbnVsbCwgMik7XHJcbiAgICAgICAgaWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBjb250ZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmRlYnVnKCdEYXRhRmlsZXNFZGl0b3JDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCBkYXRhLWZpbGVzLWVkaXRvciBjb25maWcgdmlhIGZhbGxiYWNrJyk7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IEJhc2VzQ01TQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9CYXNlc0NNU0NvbmZpZyc7XHJcbmltcG9ydCB7IEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IgfSBmcm9tICcuL0FzdHJvQ29tcG9zZXJDb25maWcnO1xyXG5pbXBvcnQgeyBTRU9Db25maWd1cmF0b3IgfSBmcm9tICcuL1NFT0NvbmZpZyc7XHJcbmltcG9ydCB7IFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9Qcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZyc7XHJcbmltcG9ydCB7IFVJVHdlYWtlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4vVUlUd2Vha2VyQ29uZmlnJztcclxuaW1wb3J0IHsgSW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9JbWFnZU1hbmFnZXJDb25maWcnO1xyXG5pbXBvcnQgeyBIb21lQmFzZUNvbmZpZ3VyYXRvciB9IGZyb20gJy4vSG9tZUJhc2VDb25maWcnO1xyXG5pbXBvcnQgeyBFeHBsb3JlckZvY3VzQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9FeHBsb3JlckZvY3VzQ29uZmlnJztcclxuaW1wb3J0IHsgRGF0YUZpbGVzRWRpdG9yQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9EYXRhRmlsZXNFZGl0b3JDb25maWcnO1xyXG5pbXBvcnQgeyBFZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvciB9IGZyb20gJy4vRWRpdGluZ1Rvb2xiYXJDb25maWcnO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbmZpZ0ZsdXNoU2VydmljZSB7XHJcbiAgICBwcml2YXRlIGJhc2VzQ01TQ29uZmlndXJhdG9yOiBCYXNlc0NNU0NvbmZpZ3VyYXRvcjtcclxuICAgIHByaXZhdGUgYXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvcjogQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvcjtcclxuICAgIHByaXZhdGUgc2VvQ29uZmlndXJhdG9yOiBTRU9Db25maWd1cmF0b3I7XHJcbiAgICBwcml2YXRlIHByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlndXJhdG9yOiBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZ3VyYXRvcjtcclxuICAgIHByaXZhdGUgdWlUd2Vha2VyQ29uZmlndXJhdG9yOiBVSVR3ZWFrZXJDb25maWd1cmF0b3I7XHJcbiAgICBwcml2YXRlIGltYWdlTWFuYWdlckNvbmZpZ3VyYXRvcjogSW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yO1xyXG4gICAgcHJpdmF0ZSBob21lQmFzZUNvbmZpZ3VyYXRvcjogSG9tZUJhc2VDb25maWd1cmF0b3I7XHJcbiAgICBwcml2YXRlIGV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3I6IEV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3I7XHJcbiAgICBwcml2YXRlIGRhdGFGaWxlc0VkaXRvckNvbmZpZ3VyYXRvcjogRGF0YUZpbGVzRWRpdG9yQ29uZmlndXJhdG9yO1xyXG4gICAgcHJpdmF0ZSBlZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvcjogRWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3I7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcHA6IEFwcCkge1xyXG4gICAgICAgIHRoaXMuYmFzZXNDTVNDb25maWd1cmF0b3IgPSBuZXcgQmFzZXNDTVNDb25maWd1cmF0b3IoYXBwKTtcclxuICAgICAgICB0aGlzLmFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IgPSBuZXcgQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMuc2VvQ29uZmlndXJhdG9yID0gbmV3IFNFT0NvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMucHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3IgPSBuZXcgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3IoYXBwKTtcclxuICAgICAgICB0aGlzLnVpVHdlYWtlckNvbmZpZ3VyYXRvciA9IG5ldyBVSVR3ZWFrZXJDb25maWd1cmF0b3IoYXBwKTtcclxuICAgICAgICB0aGlzLmltYWdlTWFuYWdlckNvbmZpZ3VyYXRvciA9IG5ldyBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3IoYXBwKTtcclxuICAgICAgICB0aGlzLmhvbWVCYXNlQ29uZmlndXJhdG9yID0gbmV3IEhvbWVCYXNlQ29uZmlndXJhdG9yKGFwcCk7XHJcbiAgICAgICAgdGhpcy5leHBsb3JlckZvY3VzQ29uZmlndXJhdG9yID0gbmV3IEV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3IoYXBwKTtcclxuICAgICAgICB0aGlzLmRhdGFGaWxlc0VkaXRvckNvbmZpZ3VyYXRvciA9IG5ldyBEYXRhRmlsZXNFZGl0b3JDb25maWd1cmF0b3IoYXBwKTtcclxuICAgICAgICB0aGlzLmVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yID0gbmV3IEVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yKGFwcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGbHVzaGVzIGN1cnJlbnQgd2l6YXJkIHN0YXRlIHRvIHZhcmlvdXMgcGx1Z2luIGNvbmZpZ3VyYXRpb24gZmlsZXMuXHJcbiAgICAgKiBUaGlzIGVuc3VyZXMgdGhlIGRpc2sgcmVmbGVjdHMgdGhlIGN1cnJlbnQgd2l6YXJkIGNvbmZpZ3VyYXRpb24gd2l0aG91dFxyXG4gICAgICogbmVlZGluZyB0byByZWFjaCB0aGUgZmluYWxpemF0aW9uIHN0ZXAuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGZsdXNoKHN0YXRlOiBXaXphcmRTdGF0ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0NvbmZpZ0ZsdXNoU2VydmljZTogU3RhcnRpbmcgY29uZmlndXJhdGlvbiBmbHVzaCcpO1xyXG5cclxuICAgICAgICAvLyAxLiBDb25maWd1cmUgQmFzZXMgQ01TXHJcbiAgICAgICAgYXdhaXQgdGhpcy5iYXNlc0NNU0NvbmZpZ3VyYXRvci5jcmVhdGVPclVwZGF0ZUJhc2VGaWxlKFxyXG4gICAgICAgICAgICBzdGF0ZS5jb250ZW50VHlwZXMsXHJcbiAgICAgICAgICAgIHN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyxcclxuICAgICAgICAgICAgc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQsXHJcbiAgICAgICAgICAgIHN0YXRlLnByb2plY3REZXRlY3Rpb24sXHJcbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPT09IHRydWVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyAyLiBDb25maWd1cmUgQXN0cm8gQ29tcG9zZXJcclxuICAgICAgICBpZiAoc3RhdGUucHJvamVjdERldGVjdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBhc3Ryb0NvbmZpZyA9IGF3YWl0IHRoaXMuYXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvci5jb25maWd1cmVBc3Ryb0NvbXBvc2VyKFxyXG4gICAgICAgICAgICAgICAgc3RhdGUuY29udGVudFR5cGVzLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCxcclxuICAgICAgICAgICAgICAgIHN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGgsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCxcclxuICAgICAgICAgICAgICAgIHN0YXRlLnByb2plY3REZXRlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGVNZHhTdXBwb3J0XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHN0YXRlLmFzdHJvQ29tcG9zZXJDb25maWcgPSBhc3Ryb0NvbmZpZztcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yLnNhdmVDb25maWcoYXN0cm9Db25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMy4gQ29uZmlndXJlIFNFT1xyXG4gICAgICAgIGNvbnN0IHNlb0NvbmZpZyA9IHRoaXMuc2VvQ29uZmlndXJhdG9yLmdlbmVyYXRlU0VPQ29uZmlnKFxyXG4gICAgICAgICAgICBzdGF0ZS5jb250ZW50VHlwZXMsXHJcbiAgICAgICAgICAgIHN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyxcclxuICAgICAgICAgICAgc3RhdGUucHJvamVjdERldGVjdGlvbixcclxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlTWR4U3VwcG9ydFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc3RhdGUuc2VvQ29uZmlnID0gc2VvQ29uZmlnO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2VvQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc2VvQ29uZmlnKTtcclxuXHJcbiAgICAgICAgLy8gNC4gQ29uZmlndXJlIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lXHJcbiAgICAgICAgY29uc3QgZmlyc3RUeXBlID0gc3RhdGUuY29udGVudFR5cGVzLmZpbmQoY3QgPT4gY3QuZW5hYmxlZCk7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQcm9wcyA9IGZpcnN0VHlwZSA/IHN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllc1tmaXJzdFR5cGUuaWRdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChmaXJzdFByb3BzICYmIGZpcnN0UHJvcHMudGl0bGVQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5wcm9wZXJ0eU92ZXJGaWxlTmFtZS5wcm9wZXJ0eUtleSA9IGZpcnN0UHJvcHMudGl0bGVQcm9wZXJ0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUuZW5hYmxlTWR4U3VwcG9ydCA9IHN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPT09IHRydWU7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZ3VyYXRvci5zYXZlQ29uZmlnKHN0YXRlLnByb3BlcnR5T3ZlckZpbGVOYW1lKTtcclxuXHJcbiAgICAgICAgLy8gNS4gQ29uZmlndXJlIFVJIFR3ZWFrZXJcclxuICAgICAgICBhd2FpdCB0aGlzLnVpVHdlYWtlckNvbmZpZ3VyYXRvci5zYXZlQ29uZmlnKHN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPT09IHRydWUpO1xyXG5cclxuICAgICAgICAvLyA2LiBDb25maWd1cmUgSW1hZ2UgTWFuYWdlclxyXG4gICAgICAgIGlmIChzdGF0ZS5lbmFibGVkUGx1Z2lucy5pbmNsdWRlcygnaW1hZ2UtbWFuYWdlcicpIHx8IE9iamVjdC5rZXlzKHN0YXRlLmltYWdlTWFuYWdlcikubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmltYWdlTWFuYWdlckNvbmZpZ3VyYXRvci5yZXNvbHZlQW5kU3luY0ltYWdlUHJvcGVydHkoc3RhdGUpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmltYWdlTWFuYWdlckNvbmZpZ3VyYXRvci5zYXZlQ29uZmlnKHN0YXRlLmltYWdlTWFuYWdlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA3LiBDb25maWd1cmUgSG9tZSBCYXNlXHJcbiAgICAgICAgaWYgKHN0YXRlLmVuYWJsZWRQbHVnaW5zLmluY2x1ZGVzKCdob21lLWJhc2UnKSB8fCBPYmplY3Qua2V5cyhzdGF0ZS5ob21lQmFzZSkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmhvbWVCYXNlQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc3RhdGUuaG9tZUJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gOC4gQ29uZmlndXJlIEV4cGxvcmVyIEZvY3VzXHJcbiAgICAgICAgaWYgKHN0YXRlLmVuYWJsZWRQbHVnaW5zLmluY2x1ZGVzKCdleHBsb3Jlci1mb2N1cycpIHx8IE9iamVjdC5rZXlzKHN0YXRlLmV4cGxvcmVyRm9jdXMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5leHBsb3JlckZvY3VzQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc3RhdGUuZXhwbG9yZXJGb2N1cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA5LiBDb25maWd1cmUgV1lTSVdZRyBUb29sYmFyICh0b2dnbGUgdmlzaWJpbGl0eSBkaXJlY3RseSlcclxuICAgICAgICBhd2FpdCB0aGlzLmVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yLnRvZ2dsZVZpc2liaWxpdHkodGhpcy5hcHAsIHN0YXRlLmVuYWJsZUVkaXRpbmdUb29sYmFyKTtcclxuXHJcbiAgICAgICAgLy8gMTAuIENvbmZpZ3VyZSBEYXRhIEZpbGVzIEVkaXRvclxyXG4gICAgICAgIGF3YWl0IHRoaXMuZGF0YUZpbGVzRWRpdG9yQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc3RhdGUuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMgPT09IHRydWUpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmRlYnVnKCdDb25maWdGbHVzaFNlcnZpY2U6IENvbmZpZ3VyYXRpb24gZmx1c2ggY29tcGxldGUnKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IENvbmZpZ0ZsdXNoU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbmZpZ0ZsdXNoU2VydmljZSc7XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBQbHVnaW5NYW5hZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvUGx1Z2luTWFuYWdlcic7XG5pbXBvcnQgeyBCYXNlc0NNU0NvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0Jhc2VzQ01TQ29uZmlnJztcblxuZXhwb3J0IGNsYXNzIEZpbmFsaXplU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcblx0cHJpdmF0ZSBwbHVnaW5NYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyO1xuXHRwcml2YXRlIGJhc2VzQ01TQ29uZmlndXJhdG9yOiBCYXNlc0NNU0NvbmZpZ3VyYXRvcjtcblx0cHJpdmF0ZSBjb25maWdGbHVzaFNlcnZpY2U6IENvbmZpZ0ZsdXNoU2VydmljZTtcblx0cHJpdmF0ZSBhcHBsaWVkOiBib29sZWFuID0gZmFsc2U7XG5cblx0aXNBcHBsaWVkKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLmFwcGxpZWQ7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xuXHRcdHN1cGVyKGFwcCwgY29udGFpbmVyRWwsIHN0YXRlLCBvbk5leHQsIG9uQmFjaywgb25DYW5jZWwpO1xuXHRcdHRoaXMucGx1Z2luTWFuYWdlciA9IG5ldyBQbHVnaW5NYW5hZ2VyKGFwcCk7XG5cdFx0dGhpcy5iYXNlc0NNU0NvbmZpZ3VyYXRvciA9IG5ldyBCYXNlc0NNU0NvbmZpZ3VyYXRvcihhcHApO1xuXHRcdHRoaXMuY29uZmlnRmx1c2hTZXJ2aWNlID0gbmV3IENvbmZpZ0ZsdXNoU2VydmljZShhcHApO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdGaW5hbGl6ZSBjb25maWd1cmF0aW9uJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcblx0XHRcdHRleHQ6ICdSZXZpZXcgeW91ciBjb25maWd1cmF0aW9uIGFuZCBjbGljayBcIkFwcGx5IGFuZCByZXN0YXJ0XCIgYmVsb3cgdG8gc2F2ZSBhbmQgYXBwbHkgYWxsIHNldHRpbmdzLidcblx0XHR9KTtcblxuXHRcdGNvbnN0IHN1bW1hcnkgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdmaW5hbGl6ZS1zdW1tYXJ5JyB9KTtcblxuXHRcdHN1bW1hcnkuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnU3VtbWFyeScgfSk7XG5cblx0XHQvLyBDb250ZW50IFR5cGVzXG5cdFx0Y29uc3QgZW5hYmxlZENvbnRlbnRUeXBlcyA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzLmZpbHRlcihjdCA9PiBjdC5lbmFibGVkKTtcblx0XHRzdW1tYXJ5LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgQ29udGVudCBUeXBlczogJHtlbmFibGVkQ29udGVudFR5cGVzLmxlbmd0aH1gIH0pO1xuXG5cdFx0Ly8gRWRpdGluZyBUb29sYmFyXG5cdFx0c3VtbWFyeS5jcmVhdGVFbCgncCcsIHsgdGV4dDogYEVkaXRpbmcgVG9vbGJhcjogJHt0aGlzLnN0YXRlLmVuYWJsZUVkaXRpbmdUb29sYmFyID8gJ0VuYWJsZWQnIDogJ0Rpc2FibGVkJ31gIH0pO1xuXG5cdFx0Ly8gQmFzZXMgQ01TIFZpZXdzIChjb3VudCBlbmFibGVkIGNvbnRlbnQgdHlwZXMgYXMgdmlld3MgdG8gYmUgY3JlYXRlZClcblx0XHRjb25zdCBiYXNlc1ZpZXdzQ291bnQgPSBlbmFibGVkQ29udGVudFR5cGVzLmxlbmd0aDtcblx0XHRzdW1tYXJ5LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgQmFzZXMgQ01TIFZpZXdzOiAke2Jhc2VzVmlld3NDb3VudH0gbmV3IHZpZXcke2Jhc2VzVmlld3NDb3VudCAhPT0gMSA/ICdzJyA6ICcnfSB0byBiZSBjcmVhdGVkYCB9KTtcblxuXHRcdC8vIFNFTyBTY2FuIERpcmVjdG9yaWVzXG5cdFx0Y29uc3Qgc2VvRGlyZWN0b3JpZXMgPSBlbmFibGVkQ29udGVudFR5cGVzLm1hcChjdCA9PiBjdC5mb2xkZXIpO1xuXHRcdGNvbnN0IHNlb0RpcmVjdG9yaWVzQ291bnQgPSBzZW9EaXJlY3Rvcmllcy5sZW5ndGg7XG5cdFx0c3VtbWFyeS5jcmVhdGVFbCgncCcsIHsgdGV4dDogYFNFTyBTY2FuIERpcmVjdG9yaWVzOiAke3Nlb0RpcmVjdG9yaWVzQ291bnR9IGRpcmVjdG9yJHtzZW9EaXJlY3Rvcmllc0NvdW50ICE9PSAxID8gJ2llcycgOiAneSd9ICgke3Nlb0RpcmVjdG9yaWVzLmpvaW4oJywgJyl9KWAgfSk7XG5cdH1cblxuXHRhc3luYyBhcHBseUNvbmZpZ3VyYXRpb24oc2hvdWxkUmVzdGFydDogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlDb25maWd1cmF0aW9uSW50ZXJuYWwoc2hvdWxkUmVzdGFydCk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGFwcGx5Q29uZmlndXJhdGlvbkludGVybmFsKHNob3VsZFJlc3RhcnQ6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmFwcGxpZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBTdGFydGluZyBjb25maWd1cmF0aW9uIGFwcGxpY2F0aW9uJyk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IEVuYWJsZWQgY29udGVudCB0eXBlczonLCB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZCkubWFwKGN0ID0+IGN0Lm5hbWUpKTtcblxuXHRcdFx0Ly8gQ29uZmlndXJlIHBsdWdpbnNcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQ29uZmlndXJpbmcgcGx1Z2luIHN0YXRlcycpO1xuXG5cdFx0XHQvLyBJZiBFeHRlbmRlZCBGaWxlIFR5cGVzIGlzIGVuYWJsZWQsIGVuc3VyZSBEYXRhIEZpbGVzIEVkaXRvciBpcyBpbiBlbmFibGVkUGx1Z2luc1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMpIHtcblx0XHRcdFx0Y29uc3QgcGx1Z2luSWQgPSAnZGF0YS1maWxlcy1lZGl0b3InO1xuXHRcdFx0XHRpZiAoIXRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luSWQpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgRmluYWxpemVTdGVwOiBFbmFibGluZyAke3BsdWdpbklkfSBiZWNhdXNlIEV4dGVuZGVkIEZpbGUgVHlwZXMgaXMgdG9nZ2xlIG9uYCk7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5wdXNoKHBsdWdpbklkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucyA9IHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zLmZpbHRlcihwID0+IHAgIT09IHBsdWdpbklkKTtcblx0XHRcdH1cblxuXHRcdFx0YXdhaXQgdGhpcy5wbHVnaW5NYW5hZ2VyLnNldFBsdWdpblN0YXRlcyh0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLCB0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucyk7XG5cblx0XHRcdC8vIEZsdXNoIGFsbCBjb25maWd1cmF0aW9ucyB1c2luZyB0aGUgY2VudHJhbGl6ZWQgc2VydmljZVxuXHRcdFx0YXdhaXQgdGhpcy5jb25maWdGbHVzaFNlcnZpY2UuZmx1c2godGhpcy5zdGF0ZSk7XG5cblx0XHRcdC8vIENvbmZpZ3VyZSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBhbmQgT2JzaWRpYW4gc2V0dGluZ3MgKGZvbGxvd2luZyBhc3Ryby1tb2R1bGFyLXNldHRpbmdzIHBhdHRlcm4pXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCkge1xuXHRcdFx0XHRjb25zdCBkZWZhdWx0VHlwZSA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzLmZpbmQoY3QgPT4gY3QuaWQgPT09IHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQpO1xuXHRcdFx0XHRpZiAoZGVmYXVsdFR5cGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IENvbmZpZ3VyaW5nIE9ic2lkaWFuIHNldHRpbmdzIGZvciBkZWZhdWx0IGNvbnRlbnQgdHlwZTonLCBkZWZhdWx0VHlwZS5uYW1lKTtcblx0XHRcdFx0XHRjb25zdCBhcHAgPSB0aGlzLmFwcCBhcyB7IHNldHRpbmc/OiB7IHNldD86IChrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pID0+IFByb21pc2U8dm9pZD47IHNhdmU/OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0gfTtcblxuXHRcdFx0XHRcdC8vIFNldCBhdHRhY2htZW50cyBmb2xkZXIgYmFzZWQgb24gZ2xvYmFsIGF0dGFjaG1lbnQgaGFuZGxpbmcgbW9kZVxuXHRcdFx0XHRcdGxldCB0YXJnZXRQYXRoID0gJy4vJztcblx0XHRcdFx0XHRpZiAodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc2FtZS1mb2xkZXInKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRQYXRoID0gJy4vJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9PT0gJ3N1YmZvbGRlcicpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGZvbGRlck5hbWUgPSB0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lIHx8ICdhdHRhY2htZW50cyc7XG5cdFx0XHRcdFx0XHR0YXJnZXRQYXRoID0gYC4vJHtmb2xkZXJOYW1lfWA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzcGVjaWZpZWQtZm9sZGVyJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgfHwgJ2F0dGFjaG1lbnRzJztcblx0XHRcdFx0XHRcdHRhcmdldFBhdGggPSBmb2xkZXJOYW1lO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE1ldGhvZCAxOiBUcnkgdG8gdXNlIHRoZSBhcHAncyBzZXR0aW5ncyBtYW5hZ2VyIGlmIGF2YWlsYWJsZSAoZm9sbG93aW5nIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgcGF0dGVybilcblx0XHRcdFx0XHRpZiAoYXBwLnNldHRpbmcgJiYgdHlwZW9mIGFwcC5zZXR0aW5nLnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBVc2luZyBhcHAuc2V0dGluZyBBUEknKTtcblx0XHRcdFx0XHRcdGF3YWl0IGFwcC5zZXR0aW5nLnNldCgnbmV3RmlsZUxvY2F0aW9uJywgJ2ZvbGRlcicpO1xuXHRcdFx0XHRcdFx0YXdhaXQgYXBwLnNldHRpbmcuc2V0KCduZXdGaWxlRm9sZGVyUGF0aCcsIGRlZmF1bHRUeXBlLmZvbGRlcik7XG5cdFx0XHRcdFx0XHRhd2FpdCBhcHAuc2V0dGluZy5zZXQoJ2F0dGFjaG1lbnRGb2xkZXJQYXRoJywgdGFyZ2V0UGF0aCk7XG5cdFx0XHRcdFx0XHRhd2FpdCBhcHAuc2V0dGluZy5zZXQoJ25ld0xpbmtGb3JtYXQnLCAncmVsYXRpdmUnKTtcblxuXHRcdFx0XHRcdFx0Ly8gU2F2ZSB0aGUgc2V0dGluZ3Ncblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgYXBwLnNldHRpbmcuc2F2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCBhcHAuc2V0dGluZy5zYXZlKCk7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogT2JzaWRpYW4gc2V0dGluZ3Mgc2F2ZWQgdmlhIGFwcC5zZXR0aW5nLnNhdmUoKScpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBNZXRob2QgMjogRmFsbGJhY2sgdG8gdmF1bHQgY29uZmlnIChmb2xsb3dpbmcgYXN0cm8tbW9kdWxhci1zZXR0aW5ncyBwYXR0ZXJuKVxuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBVc2luZyB2YXVsdC5jb25maWcgQVBJJyk7XG5cdFx0XHRcdFx0XHRjb25zdCB2YXVsdCA9IHRoaXMuYXBwLnZhdWx0IGFzIHsgY29uZmlnPzogeyBuZXdGaWxlTG9jYXRpb24/OiBzdHJpbmc7IG5ld0ZpbGVGb2xkZXJQYXRoPzogc3RyaW5nOyBhdHRhY2htZW50Rm9sZGVyUGF0aD86IHN0cmluZzsgbmV3TGlua0Zvcm1hdD86IHN0cmluZyB9OyBzYXZlQ29uZmlnPzogKCkgPT4gUHJvbWlzZTx2b2lkPiB9O1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2JzaWRpYW5TZXR0aW5ncyA9IHZhdWx0LmNvbmZpZztcblxuXHRcdFx0XHRcdFx0aWYgKCFvYnNpZGlhblNldHRpbmdzKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZpbmFsaXplU3RlcDogdmF1bHQuY29uZmlnIGlzIG5vdCBhdmFpbGFibGUnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG9ic2lkaWFuU2V0dGluZ3MubmV3RmlsZUxvY2F0aW9uID0gJ2ZvbGRlcic7XG5cdFx0XHRcdFx0XHRcdG9ic2lkaWFuU2V0dGluZ3MubmV3RmlsZUZvbGRlclBhdGggPSBkZWZhdWx0VHlwZS5mb2xkZXI7XG5cdFx0XHRcdFx0XHRcdG9ic2lkaWFuU2V0dGluZ3MuYXR0YWNobWVudEZvbGRlclBhdGggPSB0YXJnZXRQYXRoO1xuXHRcdFx0XHRcdFx0XHRvYnNpZGlhblNldHRpbmdzLm5ld0xpbmtGb3JtYXQgPSAncmVsYXRpdmUnO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdmF1bHQuc2F2ZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHZhdWx0LnNhdmVDb25maWcoKTtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IE9ic2lkaWFuIHNldHRpbmdzIHNhdmVkIHZpYSB2YXVsdC5zYXZlQ29uZmlnKCknKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdGaW5hbGl6ZVN0ZXA6IHZhdWx0LnNhdmVDb25maWcoKSBpcyBub3QgYXZhaWxhYmxlJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hcHBsaWVkID0gdHJ1ZTtcblx0XHRcdC8vIENyZWF0ZSBhIG5vdGljZSBiYXNlZCBvbiB3aGV0aGVyIHdlJ3JlIHJlc3RhcnRpbmdcblx0XHRcdGlmIChzaG91bGRSZXN0YXJ0KSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0NvbmZpZ3VyYXRpb24gYXBwbGllZC4gT2JzaWRpYW4gd2lsbCBub3cgcmVzdGFydC4uLicsIDMwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3IE5vdGljZSgnQ29uZmlndXJhdGlvbiBhcHBsaWVkIHN1Y2Nlc3NmdWxseSEgWW91IG1heSBuZWVkIHRvIHJlc3RhcnQgT2JzaWRpYW4gdG8gc2VlIGFsbCBjaGFuZ2VzLicsIDgwMDApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYXBwbHkgY29uZmlndXJhdGlvbjonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gYXBwbHkgY29uZmlndXJhdGlvbi4gUGxlYXNlIGNoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLicsIDYwMDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBGaW5kIGFueSBhY3RpdmUgQmFzZXMgdmlld3MgYW5kIHN3aXRjaCB0aGVtIHRvIHRoZSBuZXcgZGVmYXVsdCB2aWV3LlxuXHQgKiBDbG9zZXMgb2xkIHRhYnMgYW5kIHJlb3BlbnMgdGhlbSB0byBmb3JjZSBhIGNsZWFuIHJlbG9hZCBpZiBub3QgcmVzdGFydGluZy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgdXBkYXRlQWN0aXZlQmFzZXNWaWV3cyhkZWZhdWx0Vmlld05hbWU6IHN0cmluZywgc2hvdWxkUmVzdGFydDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGJhc2VGaWxlUGF0aCA9IGF3YWl0IHRoaXMuYmFzZXNDTVNDb25maWd1cmF0b3IucmVzb2x2ZUJhc2VGaWxlUGF0aCgpO1xuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XG5cblx0XHQvLyBGaW5kIGFueSBhY3RpdmUgQmFzZXMgdmlld3MgYW5kIHVwZGF0ZSB0aGVtIGluc3RlYWQgb2YgZGV0YWNoaW5nXG5cdFx0aW50ZXJmYWNlIEJhc2VzTGVhZlN0YXRlIHtcblx0XHRcdGxlYWY6IFdvcmtzcGFjZUxlYWY7XG5cdFx0XHRzdGF0ZToge1xuXHRcdFx0XHR0eXBlOiBzdHJpbmc7XG5cdFx0XHRcdGFjdGl2ZTogYm9vbGVhbjtcblx0XHRcdFx0c3RhdGU6IHtcblx0XHRcdFx0XHRmaWxlOiBzdHJpbmc7XG5cdFx0XHRcdFx0dmlldz86IHN0cmluZztcblx0XHRcdFx0XHR2aWV3TmFtZT86IHN0cmluZztcblx0XHRcdFx0XHRba2V5OiBzdHJpbmddOiB1bmtub3duO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRba2V5OiBzdHJpbmddOiB1bmtub3duO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0Y29uc3QgbGVhdmVzVG9VcGRhdGU6IEJhc2VzTGVhZlN0YXRlW10gPSBbXTtcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2UuaXRlcmF0ZUFsbExlYXZlcygobGVhZikgPT4ge1xuXHRcdFx0Y29uc3Qgdmlld1R5cGUgPSBsZWFmLnZpZXcuZ2V0Vmlld1R5cGUoKTtcblx0XHRcdGlmICh2aWV3VHlwZSA9PT0gJ2Jhc2VzJyB8fCB2aWV3VHlwZSA9PT0gJ2Jhc2VzLWNtcycpIHtcblx0XHRcdFx0Y29uc3Qgc3RhdGUgPSBsZWFmLmdldFZpZXdTdGF0ZSgpO1xuXHRcdFx0XHRpZiAoc3RhdGUuc3RhdGU/LmZpbGUgPT09IGJhc2VGaWxlUGF0aCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoYEZpbmFsaXplU3RlcDogRm91bmQgQmFzZXMgbGVhZiB0byB1cGRhdGUgKHR5cGU6ICR7dmlld1R5cGV9KWApO1xuXHRcdFx0XHRcdGxlYXZlc1RvVXBkYXRlLnB1c2goeyBsZWFmLCBzdGF0ZTogc3RhdGUgYXMgQmFzZXNMZWFmU3RhdGVbJ3N0YXRlJ10gfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFVwZGF0ZSBleGlzdGluZyBsZWF2ZXNcblx0XHRmb3IgKGNvbnN0IHsgbGVhZiwgc3RhdGUgfSBvZiBsZWF2ZXNUb1VwZGF0ZSkge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBVcGRhdGluZyBleGlzdGluZyBCYXNlcyBsZWFmIHN0YXRlJyk7XG5cdFx0XHQvLyBVcGRhdGUgZXhpc3RpbmcgbGVhZiBzdGF0ZSB0byBzd2l0Y2ggdG8gdGhlIG5ldyBkZWZhdWx0IHZpZXdcblx0XHRcdC8vIFNldCBib3RoICd2aWV3JyBhbmQgJ3ZpZXdOYW1lJyBmb3IgY29tcGF0aWJpbGl0eSBhY3Jvc3MgQmFzZXMgdmVyc2lvbnNcblx0XHRcdGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcblx0XHRcdFx0Li4uc3RhdGUsXG5cdFx0XHRcdHN0YXRlOiB7XG5cdFx0XHRcdFx0Li4uc3RhdGUuc3RhdGUsXG5cdFx0XHRcdFx0dmlldzogZGVmYXVsdFZpZXdOYW1lLFxuXHRcdFx0XHRcdHZpZXdOYW1lOiBkZWZhdWx0Vmlld05hbWVcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBJZiBubyBCYXNlcyB2aWV3cyB3ZXJlIGZvdW5kL3VwZGF0ZWQsIG9wZW4gYSBuZXcgb25lXG5cdFx0aWYgKCF1cGRhdGVkKSB7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IE9wZW5pbmcgbmV3IEJhc2VzIGxlYWYgd2l0aCBmcmVzaCBzdGF0ZScpO1xuXG5cdFx0XHQvLyBVc2UgJ2Jhc2VzLWNtcycgYXMgdGhlIHByZWZlcnJlZCB0eXBlIGZvciBuZXcgbGVhdmVzXG5cdFx0XHRjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoJ3RhYicpO1xuXHRcdFx0YXdhaXQgbGVhZi5zZXRWaWV3U3RhdGUoe1xuXHRcdFx0XHR0eXBlOiAnYmFzZXMtY21zJyxcblx0XHRcdFx0YWN0aXZlOiB0cnVlLFxuXHRcdFx0XHRzdGF0ZToge1xuXHRcdFx0XHRcdGZpbGU6IGJhc2VGaWxlUGF0aCxcblx0XHRcdFx0XHR2aWV3OiBkZWZhdWx0Vmlld05hbWUsXG5cdFx0XHRcdFx0dmlld05hbWU6IGRlZmF1bHRWaWV3TmFtZVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuYXBwLndvcmtzcGFjZS5zZXRBY3RpdmVMZWFmKGxlYWYsIHsgZm9jdXM6IHRydWUgfSk7XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBTUEVDSUFMIENBU0U6IElmIHJlc3RhcnRpbmcsIGFsc28gdHJ5IHRvIG1vZGlmeSB3b3Jrc3BhY2UuanNvbiBkaXJlY3RseVxuXHRcdC8vIFRoaXMgaXMgYSBcImJlbHQgYW5kIHN1c3BlbmRlcnNcIiBhcHByb2FjaCBiZWNhdXNlIE9ic2lkaWFuIG1pZ2h0IG92ZXJ3cml0ZVxuXHRcdC8vIHRoZSBpbi1tZW1vcnkgY2hhbmdlcyB3aGVuIGl0IGNsb3NlcyBpZiB0aGUgdmlldyBoYXNuJ3QgZnVsbHkgc3luY2VkIHlldC5cblx0XHRpZiAoc2hvdWxkUmVzdGFydCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0XHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcjtcblx0XHRcdFx0Y29uc3Qgd29ya3NwYWNlUGF0aCA9IGAke2NvbmZpZ0Rpcn0vd29ya3NwYWNlLmpzb25gO1xuXG5cdFx0XHRcdGlmIChhd2FpdCBhZGFwdGVyLmV4aXN0cyh3b3Jrc3BhY2VQYXRoKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQXR0ZW1wdGluZyBkaXJlY3Qgd29ya3NwYWNlLmpzb24gbW9kaWZpY2F0aW9uJyk7XG5cdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IGFkYXB0ZXIucmVhZCh3b3Jrc3BhY2VQYXRoKTtcblxuXHRcdFx0XHRcdGludGVyZmFjZSBXb3Jrc3BhY2VOb2RlIHtcblx0XHRcdFx0XHRcdHR5cGU/OiBzdHJpbmc7XG5cdFx0XHRcdFx0XHRzdGF0ZT86IHtcblx0XHRcdFx0XHRcdFx0dHlwZT86IHN0cmluZztcblx0XHRcdFx0XHRcdFx0c3RhdGU/OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmlsZT86IHN0cmluZztcblx0XHRcdFx0XHRcdFx0XHR2aWV3Pzogc3RyaW5nO1xuXHRcdFx0XHRcdFx0XHRcdHZpZXdOYW1lPzogc3RyaW5nO1xuXHRcdFx0XHRcdFx0XHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Y2hpbGRyZW4/OiBXb3Jrc3BhY2VOb2RlW10gfCBXb3Jrc3BhY2VOb2RlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGludGVyZmFjZSBXb3Jrc3BhY2VEYXRhIHtcblx0XHRcdFx0XHRcdG1haW4/OiBXb3Jrc3BhY2VOb2RlO1xuXHRcdFx0XHRcdFx0bGVmdD86IFdvcmtzcGFjZU5vZGU7XG5cdFx0XHRcdFx0XHRyaWdodD86IFdvcmtzcGFjZU5vZGU7XG5cdFx0XHRcdFx0XHRba2V5OiBzdHJpbmddOiB1bmtub3duO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHdvcmtzcGFjZSA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgV29ya3NwYWNlRGF0YTtcblxuXHRcdFx0XHRcdGxldCBtb2RpZmllZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gUmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGZpbmQgYW5kIHVwZGF0ZSBCYXNlcyBsZWF2ZXMgaW4gd29ya3NwYWNlLmpzb25cblx0XHRcdFx0XHRjb25zdCB1cGRhdGVOb2RlID0gKG5vZGU6IFdvcmtzcGFjZU5vZGUgfCB1bmRlZmluZWQpID0+IHtcblx0XHRcdFx0XHRcdGlmICghbm9kZSkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRpZiAobm9kZS50eXBlID09PSAnbGVhZicgJiYgbm9kZS5zdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoKG5vZGUuc3RhdGUudHlwZSA9PT0gJ2Jhc2VzJyB8fCBub2RlLnN0YXRlLnR5cGUgPT09ICdiYXNlcy1jbXMnKSAmJlxuXHRcdFx0XHRcdFx0XHRcdG5vZGUuc3RhdGUuc3RhdGU/LmZpbGUgPT09IGJhc2VGaWxlUGF0aCkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoYEZpbmFsaXplU3RlcDogRm91bmQgQmFzZXMgbGVhZiBpbiB3b3Jrc3BhY2UuanNvbiwgdXBkYXRpbmcgdG8gJHtkZWZhdWx0Vmlld05hbWV9YCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5vZGUuc3RhdGUuc3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUuc3RhdGUuc3RhdGUudmlldyA9IGRlZmF1bHRWaWV3TmFtZTtcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUuc3RhdGUuc3RhdGUudmlld05hbWUgPSBkZWZhdWx0Vmlld05hbWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChub2RlLmNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdXBkYXRlTm9kZShjaGlsZCkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUobm9kZS5jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0dXBkYXRlTm9kZSh3b3Jrc3BhY2UubWFpbik7XG5cdFx0XHRcdFx0dXBkYXRlTm9kZSh3b3Jrc3BhY2UubGVmdCk7XG5cdFx0XHRcdFx0dXBkYXRlTm9kZSh3b3Jrc3BhY2UucmlnaHQpO1xuXG5cdFx0XHRcdFx0aWYgKG1vZGlmaWVkKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCBhZGFwdGVyLndyaXRlKHdvcmtzcGFjZVBhdGgsIEpTT04uc3RyaW5naWZ5KHdvcmtzcGFjZSwgbnVsbCwgMikpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBTdWNjZXNzZnVsbHkgbW9kaWZpZWQgd29ya3NwYWNlLmpzb24nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmluYWxpemVTdGVwOiBGYWlsZWQgdG8gbW9kaWZ5IHdvcmtzcGFjZS5qc29uIGRpcmVjdGx5OicsIGVycm9yKTtcblx0XHRcdFx0Ly8gRG9uJ3QgdGhyb3csIHdlIHN0aWxsIGhhdmUgdGhlIGluLW1lbW9yeSB1cGRhdGVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHQvLyBBbHdheXMgcmV0dXJuIHRydWUgZm9yIGZpbmFsaXplIHN0ZXAgLSB2YWxpZGF0aW9uIGhhcHBlbnMgd2hlbiBBcHBseSBpcyBjbGlja2VkXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnRmluYWxpemUnO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ1JldmlldyBhbmQgYXBwbHkgY29uZmlndXJhdGlvbic7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcbmltcG9ydCB7IFdlbGNvbWVTdGVwIH0gZnJvbSAnLi9XZWxjb21lU3RlcCc7XG5pbXBvcnQgeyBQcm9qZWN0RGV0ZWN0aW9uU3RlcCB9IGZyb20gJy4vUHJvamVjdERldGVjdGlvblN0ZXAnO1xuaW1wb3J0IHsgQ29udGVudFR5cGVTdGVwIH0gZnJvbSAnLi9Db250ZW50VHlwZVN0ZXAnO1xuaW1wb3J0IHsgRGVmYXVsdENvbnRlbnRUeXBlU3RlcCB9IGZyb20gJy4vRGVmYXVsdENvbnRlbnRUeXBlU3RlcCc7XG5pbXBvcnQgeyBGcm9udG1hdHRlclByb3BlcnRpZXNTdGVwIH0gZnJvbSAnLi9Gcm9udG1hdHRlclByb3BlcnRpZXNTdGVwJztcbmltcG9ydCB7IEVkaXRpbmdUb29sYmFyU3RlcCB9IGZyb20gJy4vRWRpdGluZ1Rvb2xiYXJTdGVwJztcbmltcG9ydCB7IEJhc2VzQ01TQ29uZmlnU3RlcCB9IGZyb20gJy4vQmFzZXNDTVNDb25maWdTdGVwJztcbmltcG9ydCB7IEFzdHJvQ29tcG9zZXJTdGVwIH0gZnJvbSAnLi9Bc3Ryb0NvbXBvc2VyU3RlcCc7XG5pbXBvcnQgeyBTRU9Db25maWdTdGVwIH0gZnJvbSAnLi9TRU9Db25maWdTdGVwJztcbmltcG9ydCB7IE9wdGlvbmFsUGx1Z2luc1N0ZXAgfSBmcm9tICcuL09wdGlvbmFsUGx1Z2luc1N0ZXAnO1xuaW1wb3J0IHsgSWdub3JlU3RlcCB9IGZyb20gJy4vSWdub3JlU3RlcCc7XG5pbXBvcnQgeyBHaXRTZXR1cFN0ZXAgfSBmcm9tICcuL0dpdFNldHVwU3RlcCc7XG5pbXBvcnQgeyBGaW5hbGl6ZVN0ZXAgfSBmcm9tICcuL0ZpbmFsaXplU3RlcCc7XG5cbi8qKlxuICogV2l6YXJkIHN0YXRlIG1hY2hpbmUgc3RhdGVzXG4gKiBFYWNoIHN0YXRlIHJlcHJlc2VudHMgYSBsb2dpY2FsIHBoYXNlIGluIHRoZSBzZXR1cCBwcm9jZXNzXG4gKi9cbmV4cG9ydCB0eXBlIFdpemFyZE1hY2hpbmVTdGF0ZSA9XG5cdHwgJ3dlbGNvbWUnXG5cdHwgJ2RldGVjdCdcblx0fCAnY29udGVudC10eXBlcydcblx0fCAnZnJvbnRtYXR0ZXInXG5cdHwgJ3BsdWdpbnMnXG5cdHwgJ2NvbXBsZXRlJztcblxuLyoqXG4gKiBTdGVwIGNvbnN0cnVjdG9yIHR5cGUgZm9yIGNyZWF0aW5nIHdpemFyZCBzdGVwc1xuICovXG50eXBlIFN0ZXBDb25zdHJ1Y3RvciA9IG5ldyAoXG5cdGFwcDogQXBwLFxuXHRjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXG5cdHN0YXRlOiBXaXphcmRTdGF0ZSxcblx0b25OZXh0OiAoKSA9PiB2b2lkLFxuXHRvbkJhY2s6ICgpID0+IHZvaWQsXG5cdG9uQ2FuY2VsOiAoKSA9PiB2b2lkXG4pID0+IEJhc2VXaXphcmRTdGVwO1xuXG4vKipcbiAqIFN0YXRlIG1hY2hpbmUgZm9yIG1hbmFnaW5nIHdpemFyZCBmbG93XG4gKiBNYWtlcyB0cmFuc2l0aW9ucyBleHBsaWNpdCBhbmQgZWFzaWVyIHRvIGRlYnVnXG4gKi9cbmV4cG9ydCBjbGFzcyBXaXphcmRTdGF0ZU1hY2hpbmUge1xuXHRwcml2YXRlIGN1cnJlbnRTdGF0ZTogV2l6YXJkTWFjaGluZVN0YXRlO1xuXHRwcml2YXRlIHN0ZXBJbmRleDogbnVtYmVyO1xuXHRwcml2YXRlIHN0ZXBzOiBTdGVwQ29uc3RydWN0b3JbXTtcblxuXHQvLyBTdGF0ZSB0byBzdGVwIGluZGV4IG1hcHBpbmdcblx0cHJpdmF0ZSByZWFkb25seSBzdGF0ZVN0ZXBNYXA6IE1hcDxXaXphcmRNYWNoaW5lU3RhdGUsIG51bWJlcj4gPSBuZXcgTWFwKFtcblx0XHRbJ3dlbGNvbWUnLCAwXSxcblx0XHRbJ2RldGVjdCcsIDFdLFxuXHRcdFsnY29udGVudC10eXBlcycsIDJdLFxuXHRcdFsnZnJvbnRtYXR0ZXInLCA0XSxcblx0XHRbJ3BsdWdpbnMnLCA5XSxcblx0XHRbJ2NvbXBsZXRlJywgMTJdXG5cdF0pO1xuXG5cdC8vIFJldmVyc2UgbWFwcGluZzogc3RlcCBpbmRleCB0byBzdGF0ZVxuXHRwcml2YXRlIHJlYWRvbmx5IHN0ZXBTdGF0ZU1hcDogTWFwPG51bWJlciwgV2l6YXJkTWFjaGluZVN0YXRlPiA9IG5ldyBNYXAoW1xuXHRcdFswLCAnd2VsY29tZSddLFxuXHRcdFsxLCAnZGV0ZWN0J10sXG5cdFx0WzIsICdjb250ZW50LXR5cGVzJ10sXG5cdFx0WzMsICdjb250ZW50LXR5cGVzJ10sIC8vIERlZmF1bHRDb250ZW50VHlwZVN0ZXAgaXMgcGFydCBvZiBjb250ZW50LXR5cGVzXG5cdFx0WzQsICdmcm9udG1hdHRlciddLFxuXHRcdFs1LCAncGx1Z2lucyddLCAvLyBFZGl0aW5nVG9vbGJhclN0ZXAgc3RhcnRzIHBsdWdpbiBjb25maWd1cmF0aW9uXG5cdFx0WzYsICdwbHVnaW5zJ10sIC8vIEJhc2VzQ01TQ29uZmlnU3RlcFxuXHRcdFs3LCAncGx1Z2lucyddLCAvLyBBc3Ryb0NvbXBvc2VyU3RlcFxuXHRcdFs4LCAncGx1Z2lucyddLCAvLyBTRU9Db25maWdTdGVwXG5cdFx0WzksICdwbHVnaW5zJ10sIC8vIE9wdGlvbmFsUGx1Z2luc1N0ZXBcblx0XHRbMTAsICdwbHVnaW5zJ10sIC8vIElnbm9yZVN0ZXBcblx0XHRbMTEsICdwbHVnaW5zJ10sIC8vIEdpdFNldHVwU3RlcFxuXHRcdFsxMiwgJ2NvbXBsZXRlJ10gLy8gRmluYWxpemVTdGVwXG5cdF0pO1xuXG5cdC8vIFN0YXRlIHRyYW5zaXRpb24gcnVsZXNcblx0cHJpdmF0ZSByZWFkb25seSB0cmFuc2l0aW9uczogTWFwPFdpemFyZE1hY2hpbmVTdGF0ZSwgV2l6YXJkTWFjaGluZVN0YXRlW10+ID0gbmV3IE1hcChbXG5cdFx0Wyd3ZWxjb21lJywgWydkZXRlY3QnXV0sXG5cdFx0WydkZXRlY3QnLCBbJ2NvbnRlbnQtdHlwZXMnXV0sXG5cdFx0Wydjb250ZW50LXR5cGVzJywgWydmcm9udG1hdHRlciddXSxcblx0XHRbJ2Zyb250bWF0dGVyJywgWydwbHVnaW5zJ11dLFxuXHRcdFsncGx1Z2lucycsIFsnY29tcGxldGUnXV0sXG5cdFx0Wydjb21wbGV0ZScsIFtdXSAvLyBUZXJtaW5hbCBzdGF0ZVxuXHRdKTtcblxuXHRjb25zdHJ1Y3RvcihzdGVwcz86IFN0ZXBDb25zdHJ1Y3RvcltdKSB7XG5cdFx0dGhpcy5jdXJyZW50U3RhdGUgPSAnd2VsY29tZSc7XG5cdFx0dGhpcy5zdGVwSW5kZXggPSAwO1xuXHRcdHRoaXMuc3RlcHMgPSBzdGVwcyB8fCBbXG5cdFx0XHRXZWxjb21lU3RlcCxcblx0XHRcdFByb2plY3REZXRlY3Rpb25TdGVwLFxuXHRcdFx0Q29udGVudFR5cGVTdGVwLFxuXHRcdFx0RGVmYXVsdENvbnRlbnRUeXBlU3RlcCxcblx0XHRcdEZyb250bWF0dGVyUHJvcGVydGllc1N0ZXAsXG5cdFx0XHRFZGl0aW5nVG9vbGJhclN0ZXAsXG5cdFx0XHRCYXNlc0NNU0NvbmZpZ1N0ZXAsXG5cdFx0XHRBc3Ryb0NvbXBvc2VyU3RlcCxcblx0XHRcdFNFT0NvbmZpZ1N0ZXAsXG5cdFx0XHRPcHRpb25hbFBsdWdpbnNTdGVwLFxuXHRcdFx0SWdub3JlU3RlcCxcblx0XHRcdEdpdFNldHVwU3RlcCxcblx0XHRcdEZpbmFsaXplU3RlcFxuXHRcdF07XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IHN0YXRlXG5cdCAqL1xuXHRnZXRTdGF0ZSgpOiBXaXphcmRNYWNoaW5lU3RhdGUge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgc3RlcCBpbmRleFxuXHQgKi9cblx0Z2V0U3RlcEluZGV4KCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuc3RlcEluZGV4O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdG90YWwgbnVtYmVyIG9mIHN0ZXBzXG5cdCAqL1xuXHRnZXRUb3RhbFN0ZXBzKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc3RlcCBjb25zdHJ1Y3RvciBmb3IgYSBnaXZlbiBpbmRleFxuXHQgKi9cblx0Z2V0U3RlcENvbnN0cnVjdG9yKGluZGV4OiBudW1iZXIpOiBTdGVwQ29uc3RydWN0b3IgfCB1bmRlZmluZWQge1xuXHRcdHJldHVybiB0aGlzLnN0ZXBzW2luZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB3ZSBjYW4gdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGVwL3N0YXRlXG5cdCAqL1xuXHRjYW5Hb05leHQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuc3RlcEluZGV4IDwgdGhpcy5zdGVwcy5sZW5ndGggLSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGNhbiBnbyBiYWNrIHRvIHRoZSBwcmV2aW91cyBzdGVwL3N0YXRlXG5cdCAqL1xuXHRjYW5Hb0JhY2soKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuc3RlcEluZGV4ID4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNb3ZlIHRvIHRoZSBuZXh0IHN0ZXBcblx0ICogVXBkYXRlcyBib3RoIHN0ZXAgaW5kZXggYW5kIHN0YXRlXG5cdCAqL1xuXHRuZXh0KCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5jYW5Hb05leHQoKSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdXaXphcmRTdGF0ZU1hY2hpbmU6IENhbm5vdCBnbyB0byBuZXh0IHN0ZXAgLSBhbHJlYWR5IGF0IGZpbmFsIHN0ZXAnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBuZXh0U3RlcEluZGV4ID0gdGhpcy5zdGVwSW5kZXggKyAxO1xuXHRcdGNvbnN0IG5leHRTdGF0ZSA9IHRoaXMuc3RlcFN0YXRlTWFwLmdldChuZXh0U3RlcEluZGV4KTtcblxuXHRcdGlmICghbmV4dFN0YXRlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBXaXphcmRTdGF0ZU1hY2hpbmU6IE5vIHN0YXRlIG1hcHBpbmcgZm9yIHN0ZXAgaW5kZXggJHtuZXh0U3RlcEluZGV4fWApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFZhbGlkYXRlIHRyYW5zaXRpb25cblx0XHRjb25zdCBhbGxvd2VkVHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSkgfHwgW107XG5cdFx0aWYgKCFhbGxvd2VkVHJhbnNpdGlvbnMuaW5jbHVkZXMobmV4dFN0YXRlKSAmJiBuZXh0U3RhdGUgIT09IHRoaXMuY3VycmVudFN0YXRlKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdGBXaXphcmRTdGF0ZU1hY2hpbmU6IEludmFsaWQgdHJhbnNpdGlvbiBmcm9tICR7dGhpcy5jdXJyZW50U3RhdGV9IHRvICR7bmV4dFN0YXRlfWBcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGVwSW5kZXggPSBuZXh0U3RlcEluZGV4O1xuXHRcdHRoaXMuY3VycmVudFN0YXRlID0gbmV4dFN0YXRlO1xuXG5cdFx0Y29uc29sZS5kZWJ1Zyhcblx0XHRcdGBXaXphcmRTdGF0ZU1hY2hpbmU6IFRyYW5zaXRpb25lZCB0byBzdGVwICR7dGhpcy5zdGVwSW5kZXh9IChzdGF0ZTogJHt0aGlzLmN1cnJlbnRTdGF0ZX0pYFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTW92ZSB0byB0aGUgcHJldmlvdXMgc3RlcFxuXHQgKiBVcGRhdGVzIGJvdGggc3RlcCBpbmRleCBhbmQgc3RhdGVcblx0ICovXG5cdHByZXZpb3VzKCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5jYW5Hb0JhY2soKSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdXaXphcmRTdGF0ZU1hY2hpbmU6IENhbm5vdCBnbyB0byBwcmV2aW91cyBzdGVwIC0gYWxyZWFkeSBhdCBmaXJzdCBzdGVwJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgcHJldlN0ZXBJbmRleCA9IHRoaXMuc3RlcEluZGV4IC0gMTtcblx0XHRjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0ZXBTdGF0ZU1hcC5nZXQocHJldlN0ZXBJbmRleCk7XG5cblx0XHRpZiAoIXByZXZTdGF0ZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihgV2l6YXJkU3RhdGVNYWNoaW5lOiBObyBzdGF0ZSBtYXBwaW5nIGZvciBzdGVwIGluZGV4ICR7cHJldlN0ZXBJbmRleH1gKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnN0ZXBJbmRleCA9IHByZXZTdGVwSW5kZXg7XG5cdFx0dGhpcy5jdXJyZW50U3RhdGUgPSBwcmV2U3RhdGU7XG5cblx0XHRjb25zb2xlLmRlYnVnKFxuXHRcdFx0YFdpemFyZFN0YXRlTWFjaGluZTogV2VudCBiYWNrIHRvIHN0ZXAgJHt0aGlzLnN0ZXBJbmRleH0gKHN0YXRlOiAke3RoaXMuY3VycmVudFN0YXRlfSlgXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBKdW1wIHRvIGEgc3BlY2lmaWMgc3RlcCBpbmRleFxuXHQgKiBVcGRhdGVzIGJvdGggc3RlcCBpbmRleCBhbmQgc3RhdGVcblx0ICovXG5cdGp1bXBUb1N0ZXAoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIENsYW1wIGluZGV4IHRvIHZhbGlkIHJhbmdlXG5cdFx0Y29uc3QgY2xhbXBlZEluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkpO1xuXG5cdFx0Y29uc3Qgc3RhdGUgPSB0aGlzLnN0ZXBTdGF0ZU1hcC5nZXQoY2xhbXBlZEluZGV4KTtcblx0XHRpZiAoIXN0YXRlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBXaXphcmRTdGF0ZU1hY2hpbmU6IE5vIHN0YXRlIG1hcHBpbmcgZm9yIHN0ZXAgaW5kZXggJHtjbGFtcGVkSW5kZXh9YCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGVwSW5kZXggPSBjbGFtcGVkSW5kZXg7XG5cdFx0dGhpcy5jdXJyZW50U3RhdGUgPSBzdGF0ZTtcblxuXHRcdGNvbnNvbGUuZGVidWcoXG5cdFx0XHRgV2l6YXJkU3RhdGVNYWNoaW5lOiBKdW1wZWQgdG8gc3RlcCAke3RoaXMuc3RlcEluZGV4fSAoc3RhdGU6ICR7dGhpcy5jdXJyZW50U3RhdGV9KWBcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEp1bXAgdG8gYSBzcGVjaWZpYyBzdGF0ZVxuXHQgKiBUaGlzIHdpbGwgbW92ZSB0byB0aGUgZmlyc3Qgc3RlcCBvZiB0aGF0IHN0YXRlXG5cdCAqL1xuXHRqdW1wVG9TdGF0ZShzdGF0ZTogV2l6YXJkTWFjaGluZVN0YXRlKTogdm9pZCB7XG5cdFx0Y29uc3Qgc3RlcEluZGV4ID0gdGhpcy5zdGF0ZVN0ZXBNYXAuZ2V0KHN0YXRlKTtcblxuXHRcdGlmIChzdGVwSW5kZXggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihgV2l6YXJkU3RhdGVNYWNoaW5lOiBObyBzdGVwIG1hcHBpbmcgZm9yIHN0YXRlICR7c3RhdGV9YCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5qdW1wVG9TdGVwKHN0ZXBJbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHByb2dyZXNzIGFzIGEgcGVyY2VudGFnZVxuXHQgKi9cblx0Z2V0UHJvZ3Jlc3MoKTogbnVtYmVyIHtcblx0XHRpZiAodGhpcy5zdGVwcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuXHRcdHJldHVybiAoKHRoaXMuc3RlcEluZGV4ICsgMSkgLyB0aGlzLnN0ZXBzLmxlbmd0aCkgKiAxMDA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGN1cnJlbnQgc3RhdGVcblx0ICovXG5cdGdldFN0YXRlRGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRzd2l0Y2ggKHRoaXMuY3VycmVudFN0YXRlKSB7XG5cdFx0XHRjYXNlICd3ZWxjb21lJzpcblx0XHRcdFx0cmV0dXJuICdXZWxjb21lJztcblx0XHRcdGNhc2UgJ2RldGVjdCc6XG5cdFx0XHRcdHJldHVybiAnUHJvamVjdCBEZXRlY3Rpb24nO1xuXHRcdFx0Y2FzZSAnY29udGVudC10eXBlcyc6XG5cdFx0XHRcdHJldHVybiAnQ29udGVudCBUeXBlIFNldHVwJztcblx0XHRcdGNhc2UgJ2Zyb250bWF0dGVyJzpcblx0XHRcdFx0cmV0dXJuICdGcm9udG1hdHRlciBDb25maWd1cmF0aW9uJztcblx0XHRcdGNhc2UgJ3BsdWdpbnMnOlxuXHRcdFx0XHRyZXR1cm4gJ1BsdWdpbiBDb25maWd1cmF0aW9uJztcblx0XHRcdGNhc2UgJ2NvbXBsZXRlJzpcblx0XHRcdFx0cmV0dXJuICdGaW5hbGl6YXRpb24nO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuICdVbmtub3duIFN0YXRlJztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRGVidWc6IEdldCBhIHN1bW1hcnkgb2YgdGhlIGN1cnJlbnQgc3RhdGUgbWFjaGluZSBzdGF0dXNcblx0ICovXG5cdGdldERlYnVnSW5mbygpOiBzdHJpbmcge1xuXHRcdHJldHVybiBgU3RhdGU6ICR7dGhpcy5jdXJyZW50U3RhdGV9ICgke3RoaXMuZ2V0U3RhdGVEZXNjcmlwdGlvbigpfSkgfCBgICtcblx0XHRcdGBTdGVwOiAke3RoaXMuc3RlcEluZGV4ICsgMX0vJHt0aGlzLnN0ZXBzLmxlbmd0aH0gfCBgICtcblx0XHRcdGBQcm9ncmVzczogJHt0aGlzLmdldFByb2dyZXNzKCkudG9GaXhlZCgxKX0lYDtcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgTW9kYWwsIFRGaWxlLCBzZXRJY29uIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IFZhdWx0Q01TUGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgUHJvamVjdERldGVjdG9yIH0gZnJvbSAnLi4vdXRpbHMvUHJvamVjdERldGVjdG9yJztcblxuaW50ZXJmYWNlIEhlYWx0aENoZWNrUmVzdWx0IHtcblx0Y2F0ZWdvcnk6IHN0cmluZztcblx0Y2hlY2tzOiB7XG5cdFx0bmFtZTogc3RyaW5nO1xuXHRcdHN0YXR1czogJ3Bhc3MnIHwgJ2ZhaWwnIHwgJ3dhcm5pbmcnO1xuXHRcdG1lc3NhZ2U/OiBzdHJpbmc7XG5cdH1bXTtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYWx0aENoZWNrTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cdHByaXZhdGUgcGx1Z2luOiBWYXVsdENNU1BsdWdpbjtcblx0cHJpdmF0ZSByZXN1bHRzOiBIZWFsdGhDaGVja1Jlc3VsdFtdID0gW107XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogVmF1bHRDTVNQbHVnaW4pIHtcblx0XHRzdXBlcihhcHApO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0YXN5bmMgb25PcGVuKCkge1xuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xuXHRcdGNvbnRlbnRFbC5hZGRDbGFzcygndmF1bHQtY21zLWhlYWx0aC1jaGVjaycpO1xuXG5cdFx0Ly8gQWRkIHRpdGxlXG5cdFx0Y29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1ZhdWx0IENNUyBIZWFsdGggQ2hlY2snIH0pO1xuXG5cdFx0Ly8gUnVuIGFsbCBoZWFsdGggY2hlY2tzXG5cdFx0YXdhaXQgdGhpcy5ydW5IZWFsdGhDaGVja3MoKTtcblxuXHRcdC8vIERpc3BsYXkgcmVzdWx0c1xuXHRcdHRoaXMuZGlzcGxheVJlc3VsdHMoY29udGVudEVsKTtcblxuXHRcdC8vIEFkZCBjbG9zZSBidXR0b25cblx0XHRjb25zdCBmb290ZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnaGVhbHRoLWNoZWNrLWZvb3RlcicgfSk7XG5cdFx0Y29uc3QgY2xvc2VCdG4gPSBmb290ZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHtcblx0XHRcdHRleHQ6ICdDbG9zZScsXG5cdFx0XHRjbHM6ICdtb2QtY3RhJ1xuXHRcdH0pO1xuXHRcdGNsb3NlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jbG9zZSgpKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcnVuSGVhbHRoQ2hlY2tzKCkge1xuXHRcdHRoaXMucmVzdWx0cyA9IFtdO1xuXG5cdFx0Ly8gQ2hlY2sgMTogQ29tcGFuaW9uIFBsdWdpbnMgSW5zdGFsbGF0aW9uXG5cdFx0YXdhaXQgdGhpcy5jaGVja0NvbXBhbmlvblBsdWdpbnNJbnN0YWxsZWQoKTtcblxuXHRcdC8vIENoZWNrIDI6IENvbXBhbmlvbiBQbHVnaW5zIEVuYWJsZWRcblx0XHRhd2FpdCB0aGlzLmNoZWNrQ29tcGFuaW9uUGx1Z2luc0VuYWJsZWQoKTtcblxuXHRcdC8vIENoZWNrIDM6IEFzdHJvIFByb2plY3QgRGV0ZWN0aW9uXG5cdFx0YXdhaXQgdGhpcy5jaGVja0FzdHJvUHJvamVjdERldGVjdGlvbigpO1xuXG5cdFx0Ly8gQ2hlY2sgNDogUGx1Z2luIENvbmZpZ3VyYXRpb25cblx0XHRhd2FpdCB0aGlzLmNoZWNrUGx1Z2luQ29uZmlndXJhdGlvbigpO1xuXG5cdFx0Ly8gQ2hlY2sgNTogR2l0IEludGVncmF0aW9uXG5cdFx0YXdhaXQgdGhpcy5jaGVja0dpdEludGVncmF0aW9uKCk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNoZWNrQ29tcGFuaW9uUGx1Z2luc0luc3RhbGxlZCgpIHtcblx0XHRjb25zdCByZXF1aXJlZFBsdWdpbnMgPSBbXG5cdFx0XHR7IGlkOiAnYXN0cm8tY29tcG9zZXInLCBuYW1lOiAnQXN0cm8gQ29tcG9zZXInIH0sXG5cdFx0XHR7IGlkOiAnYmFzZXMtY21zJywgbmFtZTogJ0Jhc2VzIENNUycgfSxcblx0XHRcdHsgaWQ6ICdob21lLWJhc2UnLCBuYW1lOiAnSG9tZSBCYXNlJyB9LFxuXHRcdFx0eyBpZDogJ3NlbycsIG5hbWU6ICdTRU8nIH1cblx0XHRdO1xuXG5cdFx0Y29uc3Qgb3B0aW9uYWxQbHVnaW5zID0gW1xuXHRcdFx0eyBpZDogJ3Byb3BlcnR5LW92ZXItZmlsZS1uYW1lJywgbmFtZTogJ1Byb3BlcnR5IE92ZXIgRmlsZSBOYW1lJyB9LFxuXHRcdFx0eyBpZDogJ2ltYWdlLW1hbmFnZXInLCBuYW1lOiAnSW1hZ2UgTWFuYWdlcicgfVxuXHRcdF07XG5cblx0XHRjb25zdCBjaGVja3M6IEhlYWx0aENoZWNrUmVzdWx0WydjaGVja3MnXSA9IFtdO1xuXG5cdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiB7IHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB9IH0pLnBsdWdpbnM/LnBsdWdpbnMgfHwge307XG5cblx0XHQvLyBDaGVjayByZXF1aXJlZCBwbHVnaW5zXG5cdFx0Zm9yIChjb25zdCBwbHVnaW4gb2YgcmVxdWlyZWRQbHVnaW5zKSB7XG5cdFx0XHRjb25zdCBpc0luc3RhbGxlZCA9ICEhcGx1Z2luc1twbHVnaW4uaWRdO1xuXHRcdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiBgJHtwbHVnaW4ubmFtZX0gaW5zdGFsbGVkYCxcblx0XHRcdFx0c3RhdHVzOiBpc0luc3RhbGxlZCA/ICdwYXNzJyA6ICdmYWlsJyxcblx0XHRcdFx0bWVzc2FnZTogaXNJbnN0YWxsZWQgPyB1bmRlZmluZWQgOiAnUGx1Z2luIG5vdCBpbnN0YWxsZWQnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBvcHRpb25hbCBwbHVnaW5zXG5cdFx0Zm9yIChjb25zdCBwbHVnaW4gb2Ygb3B0aW9uYWxQbHVnaW5zKSB7XG5cdFx0XHRjb25zdCBpc0luc3RhbGxlZCA9ICEhcGx1Z2luc1twbHVnaW4uaWRdO1xuXHRcdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiBgJHtwbHVnaW4ubmFtZX0gaW5zdGFsbGVkYCxcblx0XHRcdFx0c3RhdHVzOiBpc0luc3RhbGxlZCA/ICdwYXNzJyA6ICd3YXJuaW5nJyxcblx0XHRcdFx0bWVzc2FnZTogaXNJbnN0YWxsZWQgPyB1bmRlZmluZWQgOiAnT3B0aW9uYWwgcGx1Z2luIG5vdCBpbnN0YWxsZWQnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLnJlc3VsdHMucHVzaCh7XG5cdFx0XHRjYXRlZ29yeTogJ1BsdWdpbiBJbnN0YWxsYXRpb24nLFxuXHRcdFx0Y2hlY2tzXG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNoZWNrQ29tcGFuaW9uUGx1Z2luc0VuYWJsZWQoKSB7XG5cdFx0Y29uc3QgcmVxdWlyZWRQbHVnaW5zID0gW1xuXHRcdFx0eyBpZDogJ2FzdHJvLWNvbXBvc2VyJywgbmFtZTogJ0FzdHJvIENvbXBvc2VyJyB9LFxuXHRcdFx0eyBpZDogJ2Jhc2VzLWNtcycsIG5hbWU6ICdCYXNlcyBDTVMnIH0sXG5cdFx0XHR7IGlkOiAnaG9tZS1iYXNlJywgbmFtZTogJ0hvbWUgQmFzZScgfSxcblx0XHRcdHsgaWQ6ICdzZW8nLCBuYW1lOiAnU0VPJyB9XG5cdFx0XTtcblxuXHRcdGNvbnN0IGNoZWNrczogSGVhbHRoQ2hlY2tSZXN1bHRbJ2NoZWNrcyddID0gW107XG5cblx0XHRjb25zdCBwbHVnaW5zQVBJID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgZW5hYmxlZFBsdWdpbnM/OiBTZXQ8c3RyaW5nPiB9IH0pLnBsdWdpbnM7XG5cdFx0Y29uc3QgZW5hYmxlZFBsdWdpbnMgPSBwbHVnaW5zQVBJPy5lbmFibGVkUGx1Z2lucyB8fCBuZXcgU2V0PHN0cmluZz4oKTtcblxuXHRcdGZvciAoY29uc3QgcGx1Z2luIG9mIHJlcXVpcmVkUGx1Z2lucykge1xuXHRcdFx0Y29uc3QgaXNFbmFibGVkID0gZW5hYmxlZFBsdWdpbnMuaGFzKHBsdWdpbi5pZCk7XG5cdFx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRcdG5hbWU6IGAke3BsdWdpbi5uYW1lfSBlbmFibGVkYCxcblx0XHRcdFx0c3RhdHVzOiBpc0VuYWJsZWQgPyAncGFzcycgOiAnZmFpbCcsXG5cdFx0XHRcdG1lc3NhZ2U6IGlzRW5hYmxlZCA/IHVuZGVmaW5lZCA6ICdQbHVnaW4gaXMgaW5zdGFsbGVkIGJ1dCBub3QgZW5hYmxlZCdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMucmVzdWx0cy5wdXNoKHtcblx0XHRcdGNhdGVnb3J5OiAnUGx1Z2luIFN0YXR1cycsXG5cdFx0XHRjaGVja3Ncblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY2hlY2tBc3Ryb1Byb2plY3REZXRlY3Rpb24oKSB7XG5cdFx0Y29uc3QgY2hlY2tzOiBIZWFsdGhDaGVja1Jlc3VsdFsnY2hlY2tzJ10gPSBbXTtcblxuXHRcdC8vIENoZWNrIGlmIHByb2plY3QgaXMgZGV0ZWN0ZWQgaW4gc2V0dGluZ3Ncblx0XHRjb25zdCBoYXNQcm9qZWN0Um9vdCA9ICEhdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvamVjdFJvb3Q7XG5cdFx0Y29uc3QgaGFzQ29uZmlnRmlsZSA9ICEhdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29uZmlnRmlsZVBhdGg7XG5cblx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRuYW1lOiAnUHJvamVjdCByb290IGNvbmZpZ3VyZWQnLFxuXHRcdFx0c3RhdHVzOiBoYXNQcm9qZWN0Um9vdCA/ICdwYXNzJyA6ICdmYWlsJyxcblx0XHRcdG1lc3NhZ2U6IGhhc1Byb2plY3RSb290ID8gdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvamVjdFJvb3QgOiAnUHJvamVjdCByb290IG5vdCBzZXQnXG5cdFx0fSk7XG5cblx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRuYW1lOiAnQ29uZmlnIGZpbGUgZGV0ZWN0ZWQnLFxuXHRcdFx0c3RhdHVzOiBoYXNDb25maWdGaWxlID8gJ3Bhc3MnIDogJ2ZhaWwnLFxuXHRcdFx0bWVzc2FnZTogaGFzQ29uZmlnRmlsZSA/IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoIDogJ0NvbmZpZyBmaWxlIG5vdCBmb3VuZCdcblx0XHR9KTtcblxuXHRcdC8vIFRyeSB0byBkZXRlY3QgcHJvamVjdCBzdHJ1Y3R1cmVcblx0XHRpZiAoaGFzUHJvamVjdFJvb3QgJiYgaGFzQ29uZmlnRmlsZSkge1xuXHRcdFx0Y29uc3QgZGV0ZWN0b3IgPSBuZXcgUHJvamVjdERldGVjdG9yKHRoaXMuYXBwKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGlvbiA9IGF3YWl0IGRldGVjdG9yLmRldGVjdFByb2plY3QoKTtcblx0XHRcdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0XHRcdG5hbWU6ICdQcm9qZWN0IHN0cnVjdHVyZSB2YWxpZCcsXG5cdFx0XHRcdFx0c3RhdHVzOiBkZXRlY3Rpb24gPyAncGFzcycgOiAnd2FybmluZycsXG5cdFx0XHRcdFx0bWVzc2FnZTogZGV0ZWN0aW9uID8gYEZvdW5kICR7ZGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRofWAgOiAnQ291bGQgbm90IHZhbGlkYXRlIHByb2plY3Qgc3RydWN0dXJlJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdFx0XHRuYW1lOiAnUHJvamVjdCBzdHJ1Y3R1cmUgdmFsaWQnLFxuXHRcdFx0XHRcdHN0YXR1czogJ3dhcm5pbmcnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGBFcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBjb250ZW50IHR5cGVzXG5cdFx0Y29uc3QgaGFzQ29udGVudFR5cGVzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29udGVudFR5cGVzICYmIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbnRlbnRUeXBlcy5sZW5ndGggPiAwO1xuXHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdG5hbWU6ICdDb250ZW50IHR5cGVzIGNvbmZpZ3VyZWQnLFxuXHRcdFx0c3RhdHVzOiBoYXNDb250ZW50VHlwZXMgPyAncGFzcycgOiAnd2FybmluZycsXG5cdFx0XHRtZXNzYWdlOiBoYXNDb250ZW50VHlwZXMgPyBgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb250ZW50VHlwZXMubGVuZ3RofSBjb250ZW50IHR5cGUocykgY29uZmlndXJlZGAgOiAnTm8gY29udGVudCB0eXBlcyBjb25maWd1cmVkJ1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZXN1bHRzLnB1c2goe1xuXHRcdFx0Y2F0ZWdvcnk6ICdBc3RybyBQcm9qZWN0Jyxcblx0XHRcdGNoZWNrc1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBjaGVja1BsdWdpbkNvbmZpZ3VyYXRpb24oKSB7XG5cdFx0Y29uc3QgY2hlY2tzOiBIZWFsdGhDaGVja1Jlc3VsdFsnY2hlY2tzJ10gPSBbXTtcblxuXHRcdC8vIFJlYWQgYWN0dWFsIHBsdWdpbiBjb25maWdzIGZyb20gdGhlaXIgZGF0YS5qc29uIGZpbGVzXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXG5cdFx0Ly8gQ2hlY2sgQXN0cm8gQ29tcG9zZXIgY29uZmlndXJhdGlvbiAodHJ5IHBsdWdpbiBBUEkgZmlyc3QsIHRoZW4gZmlsZSlcblx0XHRsZXQgYXN0cm9Db21wb3NlckNvbnRlbnRUeXBlcyA9IDA7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSBwbHVnaW4gQVBJIGZpcnN0IChtb3JlIHJlbGlhYmxlKVxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiB7IHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCB7IHNldHRpbmdzPzogeyBjb250ZW50VHlwZXM/OiB1bmtub3duW10gfSB9PiB9IH0pLnBsdWdpbnM7XG5cdFx0XHRjb25zdCBhc3Ryb0NvbXBvc2VyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uWydhc3Ryby1jb21wb3NlciddO1xuXHRcdFx0aWYgKGFzdHJvQ29tcG9zZXJQbHVnaW4/LnNldHRpbmdzPy5jb250ZW50VHlwZXMpIHtcblx0XHRcdFx0YXN0cm9Db21wb3NlckNvbnRlbnRUeXBlcyA9IGFzdHJvQ29tcG9zZXJQbHVnaW4uc2V0dGluZ3MuY29udGVudFR5cGVzLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgcmVhZGluZ1xuXHRcdFx0XHRjb25zdCBhc3Ryb0NvbXBvc2VyUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy9hc3Ryby1jb21wb3Nlci9kYXRhLmpzb25gO1xuXHRcdFx0XHRjb25zdCBhc3Ryb0ZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYXN0cm9Db21wb3NlclBhdGgpO1xuXHRcdFx0XHRpZiAoYXN0cm9GaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChhc3Ryb0ZpbGUpO1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIHsgY29udGVudFR5cGVzPzogdW5rbm93bltdIH07XG5cdFx0XHRcdFx0YXN0cm9Db21wb3NlckNvbnRlbnRUeXBlcyA9IGRhdGEuY29udGVudFR5cGVzPy5sZW5ndGggfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2gge1xuXHRcdFx0Ly8gUGx1Z2luIG5vdCBjb25maWd1cmVkIG9yIGZpbGUgZG9lc24ndCBleGlzdFxuXHRcdH1cblxuXHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdG5hbWU6ICdBc3RybyBDb21wb3NlciBjb25maWd1cmVkJyxcblx0XHRcdHN0YXR1czogYXN0cm9Db21wb3NlckNvbnRlbnRUeXBlcyA+IDAgPyAncGFzcycgOiAnd2FybmluZycsXG5cdFx0XHRtZXNzYWdlOiBhc3Ryb0NvbXBvc2VyQ29udGVudFR5cGVzID4gMCA/XG5cdFx0XHRcdGAke2FzdHJvQ29tcG9zZXJDb250ZW50VHlwZXN9IGNvbnRlbnQgdHlwZShzKWAgOlxuXHRcdFx0XHQnTm8gY29udGVudCB0eXBlcyBjb25maWd1cmVkJ1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ2hlY2sgQmFzZXMgQ01TIGNvbmZpZ3VyYXRpb24gKGNoZWNrIGZvciBiYXNlIGZpbGUgZXhpc3RlbmNlKVxuXHRcdGxldCBiYXNlc0NvbmZpZ3VyZWQgPSBmYWxzZTtcblx0XHRsZXQgYmFzZXNNZXNzYWdlID0gJ05vIGJhc2UgZmlsZSBmb3VuZCc7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGZvciBfYmFzZXMvSG9tZS5iYXNlIG9yIGJhc2VzL0hvbWUuYmFzZVxuXHRcdFx0Y29uc3QgYmFzZXNGaWxlMSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCgnX2Jhc2VzL0hvbWUuYmFzZScpO1xuXHRcdFx0Y29uc3QgYmFzZXNGaWxlMiA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCgnYmFzZXMvSG9tZS5iYXNlJyk7XG5cdFx0XHRpZiAoYmFzZXNGaWxlMSB8fCBiYXNlc0ZpbGUyKSB7XG5cdFx0XHRcdGJhc2VzQ29uZmlndXJlZCA9IHRydWU7XG5cdFx0XHRcdGJhc2VzTWVzc2FnZSA9IGJhc2VzRmlsZTEgPyAnX2Jhc2VzL0hvbWUuYmFzZSBmb3VuZCcgOiAnYmFzZXMvSG9tZS5iYXNlIGZvdW5kJztcblx0XHRcdH1cblx0XHR9IGNhdGNoIHtcblx0XHRcdC8vIEZpbGUgZG9lc24ndCBleGlzdFxuXHRcdH1cblxuXHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdG5hbWU6ICdCYXNlcyBDTVMgY29uZmlndXJlZCcsXG5cdFx0XHRzdGF0dXM6IGJhc2VzQ29uZmlndXJlZCA/ICdwYXNzJyA6ICd3YXJuaW5nJyxcblx0XHRcdG1lc3NhZ2U6IGJhc2VzTWVzc2FnZVxuXHRcdH0pO1xuXG5cdFx0Ly8gQ2hlY2sgU0VPIGNvbmZpZ3VyYXRpb24gKHRyeSBwbHVnaW4gQVBJIGZpcnN0LCB0aGVuIGZpbGUpXG5cdFx0bGV0IHNlb1NjYW5EaXJzID0gJyc7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSBwbHVnaW4gQVBJIGZpcnN0IChtb3JlIHJlbGlhYmxlKVxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiB7IHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCB7IHNldHRpbmdzPzogeyBzY2FuRGlyZWN0b3JpZXM/OiBzdHJpbmcgfSB9PiB9IH0pLnBsdWdpbnM7XG5cdFx0XHRjb25zdCBzZW9QbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bJ3NlbyddO1xuXHRcdFx0aWYgKHNlb1BsdWdpbj8uc2V0dGluZ3M/LnNjYW5EaXJlY3Rvcmllcykge1xuXHRcdFx0XHRzZW9TY2FuRGlycyA9IHNlb1BsdWdpbi5zZXR0aW5ncy5zY2FuRGlyZWN0b3JpZXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIHJlYWRpbmdcblx0XHRcdFx0Y29uc3Qgc2VvUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy9zZW8vZGF0YS5qc29uYDtcblx0XHRcdFx0Y29uc3Qgc2VvRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzZW9QYXRoKTtcblx0XHRcdFx0aWYgKHNlb0ZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKHNlb0ZpbGUpO1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIHsgc2NhbkRpcmVjdG9yaWVzPzogc3RyaW5nIH07XG5cdFx0XHRcdFx0c2VvU2NhbkRpcnMgPSBkYXRhLnNjYW5EaXJlY3RvcmllcyB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2gge1xuXHRcdFx0Ly8gUGx1Z2luIG5vdCBjb25maWd1cmVkIG9yIGZpbGUgZG9lc24ndCBleGlzdFxuXHRcdH1cblxuXHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdG5hbWU6ICdTRU8gcGx1Z2luIGNvbmZpZ3VyZWQnLFxuXHRcdFx0c3RhdHVzOiBzZW9TY2FuRGlycy5sZW5ndGggPiAwID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0bWVzc2FnZTogc2VvU2NhbkRpcnMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdGBTY2FubmluZzogJHtzZW9TY2FuRGlyc31gIDpcblx0XHRcdFx0J05vIHNjYW4gZGlyZWN0b3JpZXMgY29uZmlndXJlZCdcblx0XHR9KTtcblxuXHRcdC8vIENoZWNrIGRlZmF1bHQgY29udGVudCB0eXBlIC0gc2hvdyBkaXNwbGF5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdGNvbnN0IGhhc0RlZmF1bHRDb250ZW50VHlwZSA9ICEhdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdENvbnRlbnRUeXBlSWQ7XG5cdFx0bGV0IGRlZmF1bHRDb250ZW50VHlwZU5hbWUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0Q29udGVudFR5cGVJZCB8fCAnJztcblx0XHRpZiAoaGFzRGVmYXVsdENvbnRlbnRUeXBlKSB7XG5cdFx0XHQvLyBUcnkgdG8gbG9vayB1cCB0aGUgZGlzcGxheSBuYW1lIGZyb20gQXN0cm8gQ29tcG9zZXIncyBjb250ZW50IHR5cGVzXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHsgc2V0dGluZ3M/OiB7IGNvbnRlbnRUeXBlcz86IEFycmF5PHsgaWQ/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmcgfT4gfSB9PiB9IH0pLnBsdWdpbnM7XG5cdFx0XHRcdGNvbnN0IGFzdHJvQ29tcG9zZXJQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bJ2FzdHJvLWNvbXBvc2VyJ107XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlcyA9IGFzdHJvQ29tcG9zZXJQbHVnaW4/LnNldHRpbmdzPy5jb250ZW50VHlwZXM7XG5cdFx0XHRcdGlmIChjb250ZW50VHlwZXMpIHtcblx0XHRcdFx0XHRjb25zdCBtYXRjaGluZ1R5cGUgPSBjb250ZW50VHlwZXMuZmluZChjdCA9PiBjdC5pZCA9PT0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdENvbnRlbnRUeXBlSWQpO1xuXHRcdFx0XHRcdGlmIChtYXRjaGluZ1R5cGU/Lm5hbWUpIHtcblx0XHRcdFx0XHRcdGRlZmF1bHRDb250ZW50VHlwZU5hbWUgPSBtYXRjaGluZ1R5cGUubmFtZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHQvLyBLZWVwIHRoZSBJRCBhcyBmYWxsYmFja1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRuYW1lOiAnRGVmYXVsdCBjb250ZW50IHR5cGUgc2V0Jyxcblx0XHRcdHN0YXR1czogaGFzRGVmYXVsdENvbnRlbnRUeXBlID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0bWVzc2FnZTogaGFzRGVmYXVsdENvbnRlbnRUeXBlID8gZGVmYXVsdENvbnRlbnRUeXBlTmFtZSA6ICdObyBkZWZhdWx0IGNvbnRlbnQgdHlwZSdcblx0XHR9KTtcblxuXHRcdHRoaXMucmVzdWx0cy5wdXNoKHtcblx0XHRcdGNhdGVnb3J5OiAnUGx1Z2luIENvbmZpZ3VyYXRpb24nLFxuXHRcdFx0Y2hlY2tzXG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNoZWNrR2l0SW50ZWdyYXRpb24oKSB7XG5cdFx0Y29uc3QgY2hlY2tzOiBIZWFsdGhDaGVja1Jlc3VsdFsnY2hlY2tzJ10gPSBbXTtcblx0XHRjb25zdCB7IGdpdENvbmZpZywgcHJvamVjdFJvb3QgfSA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuXG5cdFx0Ly8gMS4gQ2hlY2sgaWYgR2l0IGlzIGEgcmVwb1xuXHRcdGlmIChwcm9qZWN0Um9vdCkge1xuXHRcdFx0Y29uc3QgeyBHaXRNYW5hZ2VyIH0gPSBhd2FpdCBpbXBvcnQoJy4uL3V0aWxzL0dpdE1hbmFnZXInKTtcblx0XHRcdGNvbnN0IGlzUmVwbyA9IGF3YWl0IEdpdE1hbmFnZXIuaXNSZXBvKHByb2plY3RSb290KTtcblx0XHRcdGNvbnN0IHJlbW90ZVVybCA9IGlzUmVwbyA/IGF3YWl0IEdpdE1hbmFnZXIuZ2V0UmVtb3RlVXJsKHByb2plY3RSb290KSA6IG51bGw7XG5cblx0XHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdFx0bmFtZTogJ0dpdCByZXBvc2l0b3J5IGluaXRpYWxpemVkJyxcblx0XHRcdFx0c3RhdHVzOiBpc1JlcG8gPyAncGFzcycgOiAnZmFpbCcsXG5cdFx0XHRcdG1lc3NhZ2U6IGlzUmVwbyA/ICdSZXBvc2l0b3J5IGRldGVjdGVkIGF0IHByb2plY3Qgcm9vdCcgOiAnTm8gcmVwb3NpdG9yeSBmb3VuZCBhdCBwcm9qZWN0IHJvb3QnXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGlzUmVwbykge1xuXHRcdFx0XHQvLyAyLiBDaGVjayBSZW1vdGUgLyBDb25maWdcblx0XHRcdFx0Y29uc3QgaXNDb25maWd1cmVkID0gZ2l0Q29uZmlnLmVuYWJsZWQgfHwgISFyZW1vdGVVcmw7XG5cblx0XHRcdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0XHRcdG5hbWU6ICdHaXQgaW50ZWdyYXRpb24gc3RhdHVzJyxcblx0XHRcdFx0XHRzdGF0dXM6IGlzQ29uZmlndXJlZCA/ICdwYXNzJyA6ICd3YXJuaW5nJyxcblx0XHRcdFx0XHRtZXNzYWdlOiByZW1vdGVVcmxcblx0XHRcdFx0XHRcdD8gYENvbm5lY3RlZCB0byAke3JlbW90ZVVybH1gXG5cdFx0XHRcdFx0XHQ6IChnaXRDb25maWcuZW5hYmxlZCA/ICdJbnRlZ3JhdGlvbiBhY3RpdmUnIDogJ05vdCBjb25maWd1cmVkIChPcHRpb25hbCknKVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyAzLiBDaGVjayBHaXRIdWIgUEFUXG5cdFx0XHRcdGNvbnN0IHNhdmVkU2VjcmV0ID0gKHRoaXMuYXBwIGFzIGFueSkuc2VjcmV0U3RvcmFnZT8uZ2V0U2VjcmV0KCd2YXVsdC1jbXMtZ2l0aHViLXBhdCcpO1xuXHRcdFx0XHRjb25zdCBoYXNQYXQgPSAhIShnaXRDb25maWcucGF0IHx8IHNhdmVkU2VjcmV0KTtcblxuXHRcdFx0XHQvLyBPbmx5IHNob3cgUEFUIGNoZWNrIGlmIHRoZXkndmUgZXhwbGljaXRseSBlbmFibGVkIGludGVncmF0aW9uIE9SIGlmIGl0J3MgbWlzc2luZyBidXQgdGhleSBzdGFydGVkIHRoZSBzZXR1cFxuXHRcdFx0XHRpZiAoZ2l0Q29uZmlnLmVuYWJsZWQpIHtcblx0XHRcdFx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiAnR2l0SHViIFBBVCBjb25maWd1cmVkJyxcblx0XHRcdFx0XHRcdHN0YXR1czogaGFzUGF0ID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogaGFzUGF0ID8gJ1Rva2VuIHByZXNlbnQnIDogJ05vIHRva2VuIGZvdW5kIGluIHNldHRpbmdzJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdFx0bmFtZTogJ0dpdCByZXBvc2l0b3J5IGNoZWNrJyxcblx0XHRcdFx0c3RhdHVzOiAnZmFpbCcsXG5cdFx0XHRcdG1lc3NhZ2U6ICdQcm9qZWN0IHJvb3Qgbm90IGNvbmZpZ3VyZWQnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLnJlc3VsdHMucHVzaCh7XG5cdFx0XHRjYXRlZ29yeTogJ0dpdCBJbnRlZ3JhdGlvbicsXG5cdFx0XHRjaGVja3Ncblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZGlzcGxheVJlc3VsdHMoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuXHRcdGNvbnN0IHJlc3VsdHNDb250YWluZXIgPSBjb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnaGVhbHRoLWNoZWNrLXJlc3VsdHMnIH0pO1xuXG5cdFx0Zm9yIChjb25zdCByZXN1bHQgb2YgdGhpcy5yZXN1bHRzKSB7XG5cdFx0XHRjb25zdCBjYXRlZ29yeVNlY3Rpb24gPSByZXN1bHRzQ29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ2hlYWx0aC1jaGVjay1jYXRlZ29yeScgfSk7XG5cdFx0XHRjYXRlZ29yeVNlY3Rpb24uY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiByZXN1bHQuY2F0ZWdvcnkgfSk7XG5cblx0XHRcdGNvbnN0IGNoZWNrc0xpc3QgPSBjYXRlZ29yeVNlY3Rpb24uY3JlYXRlRGl2KHsgY2xzOiAnaGVhbHRoLWNoZWNrLWxpc3QnIH0pO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGNoZWNrIG9mIHJlc3VsdC5jaGVja3MpIHtcblx0XHRcdFx0Y29uc3QgY2hlY2tJdGVtID0gY2hlY2tzTGlzdC5jcmVhdGVEaXYoeyBjbHM6ICdoZWFsdGgtY2hlY2staXRlbScgfSk7XG5cblx0XHRcdFx0Ly8gQWRkIHN0YXR1cyBpY29uXG5cdFx0XHRcdGNvbnN0IHN0YXR1c0ljb24gPSBjaGVja0l0ZW0uY3JlYXRlU3Bhbih7IGNsczogJ2hlYWx0aC1jaGVjay1pY29uJyB9KTtcblx0XHRcdFx0aWYgKGNoZWNrLnN0YXR1cyA9PT0gJ3Bhc3MnKSB7XG5cdFx0XHRcdFx0c2V0SWNvbihzdGF0dXNJY29uLCAnbHVjaWRlLWNoZWNrLWNpcmNsZS0yJyk7XG5cdFx0XHRcdFx0c3RhdHVzSWNvbi5hZGRDbGFzcygnaGVhbHRoLWNoZWNrLXBhc3MnKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaGVjay5zdGF0dXMgPT09ICdmYWlsJykge1xuXHRcdFx0XHRcdHNldEljb24oc3RhdHVzSWNvbiwgJ2x1Y2lkZS1hbGVydC1jaXJjbGUnKTtcblx0XHRcdFx0XHRzdGF0dXNJY29uLmFkZENsYXNzKCdoZWFsdGgtY2hlY2stZmFpbCcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldEljb24oc3RhdHVzSWNvbiwgJ2x1Y2lkZS1oZWxwLWNpcmNsZScpO1xuXHRcdFx0XHRcdHN0YXR1c0ljb24uYWRkQ2xhc3MoJ2hlYWx0aC1jaGVjay13YXJuaW5nJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgY2hlY2sgbmFtZVxuXHRcdFx0XHRjb25zdCBjaGVja05hbWUgPSBjaGVja0l0ZW0uY3JlYXRlU3Bhbih7XG5cdFx0XHRcdFx0dGV4dDogY2hlY2submFtZSxcblx0XHRcdFx0XHRjbHM6ICdoZWFsdGgtY2hlY2stbmFtZSdcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gQWRkIG1lc3NhZ2UgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoY2hlY2subWVzc2FnZSkge1xuXHRcdFx0XHRcdGNvbnN0IGNoZWNrTWVzc2FnZSA9IGNoZWNrSXRlbS5jcmVhdGVEaXYoe1xuXHRcdFx0XHRcdFx0dGV4dDogY2hlY2subWVzc2FnZSxcblx0XHRcdFx0XHRcdGNsczogJ2hlYWx0aC1jaGVjay1tZXNzYWdlJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIENTUyBzdHlsZXNcblx0XHR0aGlzLmFkZFN0eWxlcyhjb250YWluZXIpO1xuXHR9XG5cblx0cHJpdmF0ZSBhZGRTdHlsZXMoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuXHRcdGNvbnN0IHN0eWxlID0gY29udGFpbmVyLmNyZWF0ZUVsKCdzdHlsZScpO1xuXHRcdHN0eWxlLnRleHRDb250ZW50ID0gYFxuXHRcdFx0LnZhdWx0LWNtcy1oZWFsdGgtY2hlY2sge1xuXHRcdFx0XHRwYWRkaW5nOiAyMHB4O1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLXJlc3VsdHMge1xuXHRcdFx0XHRtYXJnaW46IDIwcHggMDtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1jYXRlZ29yeSB7XG5cdFx0XHRcdG1hcmdpbi1ib3R0b206IDMwcHg7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2stY2F0ZWdvcnkgaDMge1xuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAxMHB4O1xuXHRcdFx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xuXHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogNXB4O1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLWxpc3Qge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRnYXA6IDEwcHg7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2staXRlbSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuXHRcdFx0XHRnYXA6IDEwcHg7XG5cdFx0XHRcdHBhZGRpbmc6IDhweDtcblx0XHRcdFx0YmFja2dyb3VuZDogdmFyKC0tYmFja2dyb3VuZC1zZWNvbmRhcnkpO1xuXHRcdFx0XHRib3JkZXItcmFkaXVzOiA0cHg7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2staWNvbiB7XG5cdFx0XHRcdGZvbnQtc2l6ZTogMThweDtcblx0XHRcdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XG5cdFx0XHRcdG1pbi13aWR0aDogMjRweDtcblx0XHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLXBhc3Mge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGV4dC1zdWNjZXNzKTtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1mYWlsIHtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRleHQtZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLXdhcm5pbmcge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGV4dC13YXJuaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1pY29uIHN2ZyB7XG5cdFx0XHRcdHdpZHRoOiAxOHB4O1xuXHRcdFx0XHRoZWlnaHQ6IDE4cHg7XG5cdFx0XHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLWljb24ge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRcdFx0bWluLXdpZHRoOiAyNHB4O1xuXHRcdFx0XHRoZWlnaHQ6IDI0cHg7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2stbmFtZSB7XG5cdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdGZvbnQtd2VpZ2h0OiA1MDA7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2stbWVzc2FnZSB7XG5cdFx0XHRcdGZvbnQtc2l6ZTogMC45ZW07XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10ZXh0LW11dGVkKTtcblx0XHRcdFx0bWFyZ2luLWxlZnQ6IDM0cHg7XG5cdFx0XHRcdG1hcmdpbi10b3A6IDRweDtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1mb290ZXIge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuXHRcdFx0XHRtYXJnaW4tdG9wOiAyMHB4O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogMTVweDtcblx0XHRcdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKTtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0b25DbG9zZSgpIHtcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcblx0fVxufVxuIiwgImltcG9ydCB7IFNldHRpbmcsIHJlcXVpcmVBcGlWZXJzaW9uIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgZGVmaW5pdGlvbiBmb3IgU2V0dGluZ0dyb3VwIGNvbnN0cnVjdG9yXHJcbiAqIE5vdGU6IFNldHRpbmdHcm91cCBtYXkgZXhpc3QgYXQgcnVudGltZSBpbiAxLjExLjArIGJ1dCBtYXkgbm90IGJlIGluIFR5cGVTY3JpcHQgZGVmaW5pdGlvbnNcclxuICogXHJcbiAqIElNUE9SVEFOVDogVGhpcyB0eXBlIHNpZ25hdHVyZSBpcyBpbmZlcnJlZCBmcm9tIHVzYWdlIHBhdHRlcm5zLiBXaGVuIC5yZWYvb2JzaWRpYW4tYXBpL29ic2lkaWFuLmQudHNcclxuICogaXMgYXZhaWxhYmxlLCB2ZXJpZnkgdGhlIGFjdHVhbCBzaWduYXR1cmUgdGhlcmUuIFRoZSBzaWduYXR1cmUgc2hvd24gaGVyZSBtYXRjaGVzIHRoZSBleHBlY3RlZFxyXG4gKiBiZWhhdmlvciBiYXNlZCBvbiBPYnNpZGlhbidzIEFQSSBkZXNpZ24gcGF0dGVybnMuXHJcbiAqL1xyXG50eXBlIFNldHRpbmdHcm91cENvbnN0cnVjdG9yID0gbmV3IChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpID0+IHtcclxuXHRzZXRIZWFkaW5nKGhlYWRpbmc6IHN0cmluZyk6IHtcclxuXHRcdGFkZFNldHRpbmcoY2I6IChzZXR0aW5nOiBTZXR0aW5nKSA9PiB2b2lkKTogdm9pZDtcclxuXHR9O1xyXG5cdGFkZFNldHRpbmcoY2I6IChzZXR0aW5nOiBTZXR0aW5nKSA9PiB2b2lkKTogdm9pZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgdGhhdCB3b3JrcyB3aXRoIGJvdGggU2V0dGluZ0dyb3VwIGFuZCBmYWxsYmFjayBjb250YWluZXJcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3NDb250YWluZXIge1xyXG5cdGFkZFNldHRpbmcoY2I6IChzZXR0aW5nOiBTZXR0aW5nKSA9PiB2b2lkKTogdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXR0aW5ncyBjb250YWluZXIgdGhhdCB1c2VzIFNldHRpbmdHcm91cCBpZiBhdmFpbGFibGUgKEFQSSAxLjExLjArKSxcclxuICogb3RoZXJ3aXNlIGZhbGxzIGJhY2sgdG8gY3JlYXRpbmcgYSBoZWFkaW5nIGFuZCB1c2luZyB0aGUgY29udGFpbmVyIGRpcmVjdGx5LlxyXG4gKiBcclxuICogVXNlcyByZXF1aXJlQXBpVmVyc2lvbignMS4xMS4wJykgdG8gY2hlY2sgaWYgU2V0dGluZ0dyb3VwIGlzIGF2YWlsYWJsZS5cclxuICogVGhpcyBpcyB0aGUgb2ZmaWNpYWwgT2JzaWRpYW4gQVBJIG1ldGhvZCBmb3IgdmVyc2lvbiBjaGVja2luZy5cclxuICogXHJcbiAqIElNUE9SVEFOVDogV2UgdXNlIGR5bmFtaWMgcmVxdWlyZSgpIGluc3RlYWQgb2YgZGlyZWN0IGltcG9ydCBiZWNhdXNlIFNldHRpbmdHcm91cFxyXG4gKiBtYXkgbm90IGJlIGluIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyBldmVuIGlmIGl0IGV4aXN0cyBhdCBydW50aW1lIGluIDEuMTEuMCsuXHJcbiAqIFRoaXMgYXZvaWRzIGNvbXBpbGUtdGltZSBUeXBlU2NyaXB0IGVycm9ycyB3aGlsZSBzdGlsbCB3b3JraW5nIGF0IHJ1bnRpbWUuXHJcbiAqIFxyXG4gKiBAcGFyYW0gY29udGFpbmVyRWwgLSBUaGUgY29udGFpbmVyIGVsZW1lbnQgZm9yIHNldHRpbmdzXHJcbiAqIEBwYXJhbSBoZWFkaW5nIC0gT3B0aW9uYWwgaGVhZGluZyB0ZXh0IGZvciB0aGUgc2V0dGluZ3MgZ3JvdXAuIElmIG9taXR0ZWQsIG5vIGhlYWRpbmcgaXMgY3JlYXRlZC5cclxuICogQHBhcmFtIG1hbmlmZXN0SWQgLSBUaGUgcGx1Z2luJ3MgbWFuaWZlc3QgSUQgZm9yIENTUyBzY29waW5nIChyZXF1aXJlZCBmb3IgZmFsbGJhY2sgbW9kZSlcclxuICogQHJldHVybnMgQSBjb250YWluZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgc2V0dGluZ3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXR0aW5nc0dyb3VwKFxyXG5cdGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcclxuXHRoZWFkaW5nPzogc3RyaW5nLFxyXG5cdG1hbmlmZXN0SWQ/OiBzdHJpbmdcclxuKTogU2V0dGluZ3NDb250YWluZXIge1xyXG5cdC8vIENoZWNrIGlmIFNldHRpbmdHcm91cCBpcyBhdmFpbGFibGUgKEFQSSAxLjExLjArKVxyXG5cdC8vIHJlcXVpcmVBcGlWZXJzaW9uIGlzIHRoZSBvZmZpY2lhbCBPYnNpZGlhbiBBUEkgbWV0aG9kIGZvciB2ZXJzaW9uIGNoZWNraW5nXHJcblx0aWYgKHJlcXVpcmVBcGlWZXJzaW9uKCcxLjExLjAnKSkge1xyXG5cdFx0Ly8gVXNlIGR5bmFtaWMgcmVxdWlyZSgpIHRvIGFjY2VzcyBTZXR0aW5nR3JvdXAgYXQgcnVudGltZVxyXG5cdFx0Ly8gVGhpcyBhdm9pZHMgVHlwZVNjcmlwdCBlcnJvcnMgd2hlbiBTZXR0aW5nR3JvdXAgaXNuJ3QgaW4gdHlwZSBkZWZpbml0aW9uc1xyXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgT2JzaWRpYW4gQVBJXHJcblx0XHRjb25zdCBvYnNpZGlhbiA9IHJlcXVpcmUoJ29ic2lkaWFuJykgYXMgeyBTZXR0aW5nR3JvdXA/OiBTZXR0aW5nR3JvdXBDb25zdHJ1Y3RvciB9O1xyXG5cdFx0Y29uc3QgU2V0dGluZ0dyb3VwID0gb2JzaWRpYW4uU2V0dGluZ0dyb3VwIGFzIFNldHRpbmdHcm91cENvbnN0cnVjdG9yO1xyXG5cdFx0XHJcblx0XHQvLyBVc2UgU2V0dGluZ0dyb3VwIC0gaXQncyBndWFyYW50ZWVkIHRvIGV4aXN0IGlmIHJlcXVpcmVBcGlWZXJzaW9uIHJldHVybnMgdHJ1ZVxyXG5cdFx0Ly8gSWYgaGVhZGluZyBpcyBwcm92aWRlZCwgdXNlIHNldEhlYWRpbmcoKTsgb3RoZXJ3aXNlIHVzZSBTZXR0aW5nR3JvdXAgZGlyZWN0bHlcclxuXHRcdGNvbnN0IGdyb3VwID0gaGVhZGluZyBcclxuXHRcdFx0PyBuZXcgU2V0dGluZ0dyb3VwKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKGhlYWRpbmcpXHJcblx0XHRcdDogbmV3IFNldHRpbmdHcm91cChjb250YWluZXJFbCk7XHJcblx0XHRcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFkZFNldHRpbmcoY2I6IChzZXR0aW5nOiBTZXR0aW5nKSA9PiB2b2lkKSB7XHJcblx0XHRcdFx0Z3JvdXAuYWRkU2V0dGluZyhjYik7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIEZhbGxiYWNrIHBhdGggKGVpdGhlciBBUEkgPCAxLjExLjAgb3IgU2V0dGluZ0dyb3VwIG5vdCBmb3VuZClcclxuXHRcdC8vIEFkZCBzY29waW5nIGNsYXNzIHRvIGNvbnRhaW5lckVsIHRvIHNjb3BlIENTUyB0byBvbmx5IHRoaXMgcGx1Z2luJ3Mgc2V0dGluZ3NcclxuXHRcdGlmIChtYW5pZmVzdElkKSB7XHJcblx0XHRcdGNvbnRhaW5lckVsLmFkZENsYXNzKGAke21hbmlmZXN0SWR9LXNldHRpbmdzLWNvbXBhdGApO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBGYWxsYmFjazogQ3JlYXRlIGEgaGVhZGluZyBtYW51YWxseSAoaWYgcHJvdmlkZWQpIGFuZCB1c2UgY29udGFpbmVyIGRpcmVjdGx5XHJcblx0XHRpZiAoaGVhZGluZykge1xyXG5cdFx0XHRjb25zdCBoZWFkaW5nRWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ3NldHRpbmctZ3JvdXAtaGVhZGluZycpO1xyXG5cdFx0XHRoZWFkaW5nRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiBoZWFkaW5nIH0pO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRhZGRTZXR0aW5nKGNiOiAoc2V0dGluZzogU2V0dGluZykgPT4gdm9pZCkge1xyXG5cdFx0XHRcdGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCk7XHJcblx0XHRcdFx0Y2Ioc2V0dGluZyk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG59XHJcblxyXG4iLCAiaW1wb3J0IHsgQXBwLCByZXF1ZXN0VXJsLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBBcHBseVByZXNldE1vZGFsIH0gZnJvbSAnLi4vdWkvQXBwbHlQcmVzZXRNb2RhbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0SHViRmlsZSB7XG5cdHBhdGg6IHN0cmluZztcblx0dHlwZTogJ2ZpbGUnIHwgJ2Rpcic7XG5cdGRvd25sb2FkX3VybDogc3RyaW5nIHwgbnVsbDtcblx0dXJsOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBPYnNpZGlhbkFwcFdpdGhDb21tYW5kcyBleHRlbmRzIEFwcCB7XG5cdGNvbW1hbmRzOiB7XG5cdFx0ZXhlY3V0ZUNvbW1hbmRCeUlkOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcblx0fTtcbn1cblxuZXhwb3J0IGNsYXNzIFByZXNldE1hbmFnZXIge1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdH1cblxuXHRhc3luYyBhcHBseVByZXNldChyZXBvOiBzdHJpbmcsIHByZXNldE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghcmVwbyB8fCAhcHJlc2V0TmFtZSkge1xuXHRcdFx0bmV3IE5vdGljZSgnUGxlYXNlIGNvbmZpZ3VyZSBib3RoIHJlcG9zaXRvcnkgYW5kIHByZXNldCBuYW1lIGluIHNldHRpbmdzLicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRuZXcgTm90aWNlKGBGZXRjaGluZyBwcmVzZXQgXCIke3ByZXNldE5hbWV9XCIgZnJvbSAke3JlcG99Li4uYCk7XG5cdFx0XHRjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMuZmV0Y2hQcmVzZXRGaWxlc1JlY3Vyc2l2ZShyZXBvLCBwcmVzZXROYW1lKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRuZXcgTm90aWNlKGBObyBmaWxlcyBmb3VuZCBmb3IgcHJlc2V0IFwiJHtwcmVzZXROYW1lfVwiIGluIHJlcG8gJHtyZXBvfS5gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXcgTm90aWNlKCdCYWNraW5nIHVwIGNvbmZpZ3VyYXRpb24gZm9sZGVyLi4uJyk7XG5cdFx0XHRjb25zdCBiYWNrdXBQYXRoID0gYXdhaXQgdGhpcy5iYWNrdXBPYnNpZGlhbkZvbGRlcigpO1xuXG5cdFx0XHRuZXcgTm90aWNlKGBEb3dubG9hZGluZyBhbmQgYXBwbHlpbmcgJHtmaWxlcy5sZW5ndGh9IGZpbGVzLi4uYCk7XG5cdFx0XHRsZXQgc3VjY2Vzc0NvdW50ID0gMDtcblx0XHRcdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuXHRcdFx0XHRpZiAoZmlsZS5kb3dubG9hZF91cmwpIHtcblx0XHRcdFx0XHQvLyBNYXAgcGF0aDogcmVtb3ZlIFwicHJlc2V0TmFtZS9cIiBwcmVmaXhcblx0XHRcdFx0XHRjb25zdCByZWxhdGl2ZVBhdGggPSBmaWxlLnBhdGguc3Vic3RyaW5nKHByZXNldE5hbWUubGVuZ3RoICsgMSk7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuZG93bmxvYWRBbmRXcml0ZUZpbGUoZmlsZS5kb3dubG9hZF91cmwsIHJlbGF0aXZlUGF0aCk7XG5cdFx0XHRcdFx0XHRzdWNjZXNzQ291bnQrKztcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZG93bmxvYWQgJHtyZWxhdGl2ZVBhdGh9OmAsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRuZXcgTm90aWNlKGBBcHBsaWVkICR7c3VjY2Vzc0NvdW50fSBmaWxlcy5gKTtcblxuXHRcdFx0bmV3IEFwcGx5UHJlc2V0TW9kYWwodGhpcy5hcHAsIGJhY2t1cFBhdGgsIChkZWxldGVCYWNrdXApID0+IHtcblx0XHRcdFx0dm9pZCAoYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGlmIChkZWxldGVCYWNrdXApIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucm1kaXIoYmFja3VwUGF0aCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0JhY2t1cCBkZWxldGVkLicpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGJhY2t1cDonLCBlKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGRlbGV0ZSBiYWNrdXAgZm9sZGVyLiBZb3UgbWF5IG5lZWQgdG8gcmVtb3ZlIGl0IG1hbnVhbGx5LicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHJlbG9hZFxuXHRcdFx0XHRcdGNvbnN0IGFwcFdpdGhDb21tYW5kcyA9IHRoaXMuYXBwIGFzIE9ic2lkaWFuQXBwV2l0aENvbW1hbmRzO1xuXHRcdFx0XHRcdGlmIChhcHBXaXRoQ29tbWFuZHMuY29tbWFuZHMgJiYgdHlwZW9mIGFwcFdpdGhDb21tYW5kcy5jb21tYW5kcy5leGVjdXRlQ29tbWFuZEJ5SWQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdGFwcFdpdGhDb21tYW5kcy5jb21tYW5kcy5leGVjdXRlQ29tbWFuZEJ5SWQoJ2FwcDpyZWxvYWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHR9KS5vcGVuKCk7XG5cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGFwcGx5IHByZXNldDonLCBlcnJvcik7XG5cdFx0XHRjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuXHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIGFwcGx5IHByZXNldDogJHttZXNzYWdlfWApO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZmV0Y2hQcmVzZXRGaWxlc1JlY3Vyc2l2ZShyZXBvOiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IFByb21pc2U8R2l0SHViRmlsZVtdPiB7XG5cdFx0Y29uc3QgdXJsID0gYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtyZXBvfS9jb250ZW50cy8ke3BhdGh9YDtcblx0XHRcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHsgdXJsIH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBHaXRIdWIgQVBJIHJldHVybmVkIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaXRlbXMgPSByZXNwb25zZS5qc29uIGFzIEdpdEh1YkZpbGVbXTtcblx0XHRcdGxldCBhbGxGaWxlczogR2l0SHViRmlsZVtdID0gW107XG5cblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuXHRcdFx0XHRpZiAoaXRlbS50eXBlID09PSAnZGlyJykge1xuXHRcdFx0XHRcdGNvbnN0IHN1YkZpbGVzID0gYXdhaXQgdGhpcy5mZXRjaFByZXNldEZpbGVzUmVjdXJzaXZlKHJlcG8sIGl0ZW0ucGF0aCk7XG5cdFx0XHRcdFx0YWxsRmlsZXMgPSBhbGxGaWxlcy5jb25jYXQoc3ViRmlsZXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ2ZpbGUnKSB7XG5cdFx0XHRcdFx0YWxsRmlsZXMucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWxsRmlsZXM7XG5cdFx0fSBjYXRjaCAoZTogdW5rbm93bikge1xuXHRcdFx0aWYgKGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdzdGF0dXMnIGluIGUgJiYgZS5zdGF0dXMgPT09IDQwNCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFByZXNldCBmb2xkZXIgXCIke3BhdGh9XCIgbm90IGZvdW5kIGluIHJlcG9zaXRvcnkgXCIke3JlcG99XCIuYCk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgYmFja3VwT2JzaWRpYW5Gb2xkZXIoKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0XHRjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWzouXS9nLCAnLScpLnNwbGl0KCdUJylbMF0gKyAnLScgKyBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XG5cdFx0Y29uc3QgYmFja3VwUGF0aCA9IGAke2NvbmZpZ0Rpcn1fYmFja3VwXyR7dGltZXN0YW1wfWA7XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0XG5cdFx0Ly8gQ3JlYXRlIGJhY2t1cCBkaXJlY3Rvcnlcblx0XHRhd2FpdCBhZGFwdGVyLm1rZGlyKGJhY2t1cFBhdGgpO1xuXHRcdFxuXHRcdC8vIENvcHkgY29uZmlndXJhdGlvbiBkaXJlY3RvcnkgcmVjdXJzaXZlbHlcblx0XHRhd2FpdCB0aGlzLmNvcHlSZWN1cnNpdmUoY29uZmlnRGlyLCBgJHtiYWNrdXBQYXRofS8ke2NvbmZpZ0Rpcn1gKTtcblx0XHRcblx0XHRyZXR1cm4gYmFja3VwUGF0aDtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY29weVJlY3Vyc2l2ZShzb3VyY2U6IHN0cmluZywgZGVzdGluYXRpb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdFxuXHRcdGlmICghKGF3YWl0IGFkYXB0ZXIuZXhpc3RzKHNvdXJjZSkpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3RhdHMgPSBhd2FpdCBhZGFwdGVyLmxpc3Qoc291cmNlKTtcblx0XHRcblx0XHRpZiAoIShhd2FpdCBhZGFwdGVyLmV4aXN0cyhkZXN0aW5hdGlvbikpKSB7XG5cdFx0XHRhd2FpdCBhZGFwdGVyLm1rZGlyKGRlc3RpbmF0aW9uKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gQ29weSBmaWxlc1xuXHRcdGZvciAoY29uc3QgZmlsZSBvZiBzdGF0cy5maWxlcykge1xuXHRcdFx0Y29uc3QgZmlsZU5hbWUgPSBmaWxlLnNwbGl0KCcvJykucG9wKCk7XG5cdFx0XHRpZiAoZmlsZU5hbWUpIHtcblx0XHRcdFx0Y29uc3QgZGVzdEZpbGUgPSBkZXN0aW5hdGlvbiArICcvJyArIGZpbGVOYW1lO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGF3YWl0IGFkYXB0ZXIuY29weShmaWxlLCBkZXN0RmlsZSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY29weSBmaWxlICR7ZmlsZX0gdG8gJHtkZXN0RmlsZX06YCwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gUmVjdXJzZSBpbnRvIGZvbGRlcnNcblx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBzdGF0cy5mb2xkZXJzKSB7XG5cdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gZm9sZGVyLnNwbGl0KCcvJykucG9wKCk7XG5cdFx0XHRpZiAoZm9sZGVyTmFtZSkge1xuXHRcdFx0XHRjb25zdCBkZXN0Rm9sZGVyID0gZGVzdGluYXRpb24gKyAnLycgKyBmb2xkZXJOYW1lO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNvcHlSZWN1cnNpdmUoZm9sZGVyLCBkZXN0Rm9sZGVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGRvd25sb2FkQW5kV3JpdGVGaWxlKHVybDogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoeyB1cmwgfSk7XG5cdFx0XG5cdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkb3dubG9hZCAke3BhdGh9IGZyb20gJHt1cmx9YCk7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHBhcmVudCBkaXJlY3RvcnkgZXhpc3RzXG5cdFx0Y29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZGlyID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbignLycpO1xuXHRcdFx0XHRpZiAoIShhd2FpdCBhZGFwdGVyLmV4aXN0cyhkaXIpKSkge1xuXHRcdFx0XHRcdGF3YWl0IGFkYXB0ZXIubWtkaXIoZGlyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFdyaXRlIHRoZSBmaWxlICh1c2luZyBhcnJheUJ1ZmZlciB0byBoYW5kbGUgYmluYXJ5IGZpbGVzIHNhZmVseSlcblx0XHRhd2FpdCBhZGFwdGVyLndyaXRlQmluYXJ5KHBhdGgsIHJlc3BvbnNlLmFycmF5QnVmZmVyKTtcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBBcHBseVByZXNldE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXHRwcml2YXRlIG9uQ29uZmlybTogKGRlbGV0ZUJhY2t1cDogYm9vbGVhbikgPT4gdm9pZDtcblx0cHJpdmF0ZSBiYWNrdXBQYXRoOiBzdHJpbmc7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGJhY2t1cFBhdGg6IHN0cmluZywgb25Db25maXJtOiAoZGVsZXRlQmFja3VwOiBib29sZWFuKSA9PiB2b2lkKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLmJhY2t1cFBhdGggPSBiYWNrdXBQYXRoO1xuXHRcdHRoaXMub25Db25maXJtID0gb25Db25maXJtO1xuXHR9XG5cblx0b25PcGVuKCkge1xuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1ByZXNldCBhcHBsaWVkIHN1Y2Nlc3NmdWxseScgfSk7XG5cdFx0Y29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnVGhlIHByZXNldCBoYXMgYmVlbiBhcHBsaWVkIHN1Y2Nlc3NmdWxseS4gWW91IG5lZWQgdG8gcmVsb2FkIE9ic2lkaWFuIGZvciBhbGwgY2hhbmdlcyB0byB0YWtlIGVmZmVjdC4nIH0pO1xuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogYEEgYmFja3VwIG9mIHlvdXIgb3JpZ2luYWwgY29uZmlndXJhdGlvbiBmb2xkZXIgd2FzIGNyZWF0ZWQgYXQ6ICR7dGhpcy5iYWNrdXBQYXRofWAgfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250ZW50RWwpXG5cdFx0XHQuc2V0TmFtZSgnRGVsZXRlIGJhY2t1cCBhbmQgcmVsb2FkJylcblx0XHRcdC5zZXREZXNjKCdSZW1vdmUgdGhlIGJhY2t1cCBmb2xkZXIgYW5kIHJlbG9hZCBPYnNpZGlhbi4gVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgXCJjbGVhblwiIG9wdGlvbi4nKVxuXHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdEZWxldGUgYW5kIHJlbG9hZCcpXG5cdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0XHRcdHRoaXMub25Db25maXJtKHRydWUpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250ZW50RWwpXG5cdFx0XHQuc2V0TmFtZSgnS2VlcCBiYWNrdXAgYW5kIHJlbG9hZCcpXG5cdFx0XHQuc2V0RGVzYygnS2VlcCB0aGUgYmFja3VwIGZvbGRlciBmb3Igc2FmZXR5IGFuZCByZWxvYWQgT2JzaWRpYW4uJylcblx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnS2VlcCBhbmQgcmVsb2FkJylcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdFx0XHR0aGlzLm9uQ29uZmlybShmYWxzZSk7XG5cdFx0XHRcdH0pKTtcblx0fVxuXG5cdG9uQ2xvc2UoKSB7XG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBTZXR1cFdpemFyZE1vZGFsIH0gZnJvbSAnLi4vdWkvU2V0dXBXaXphcmRNb2RhbCc7XHJcbmltcG9ydCB7IEhlYWx0aENoZWNrTW9kYWwgfSBmcm9tICcuLi91aS9IZWFsdGhDaGVja01vZGFsJztcclxuaW1wb3J0IFZhdWx0Q01TUGx1Z2luIGZyb20gJy4uL21haW4nO1xyXG5pbXBvcnQgeyBQcmVzZXRNYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvUHJlc2V0TWFuYWdlcic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kcyhwbHVnaW46IFZhdWx0Q01TUGx1Z2luKTogdm9pZCB7XHJcblx0cGx1Z2luLmFkZENvbW1hbmQoe1xyXG5cdFx0aWQ6ICdvcGVuLXdpemFyZCcsXHJcblx0XHRuYW1lOiAnT3BlbiBzZXR1cCB3aXphcmQnLFxyXG5cdFx0Y2FsbGJhY2s6ICgpID0+IHtcclxuXHRcdFx0Y29uc3Qgd2l6YXJkID0gbmV3IFNldHVwV2l6YXJkTW9kYWwocGx1Z2luLmFwcCwgcGx1Z2luLnNldHRpbmdzLCBwbHVnaW4pO1xyXG5cdFx0XHQvLyBOb3RlOiBzZXRTYXZlQ2FsbGJhY2sgaXMgZGVwcmVjYXRlZCAtIHN0YXRlIGlzIG5vdyBtYW5hZ2VkIGF1dG9tYXRpY2FsbHkgYnkgU2V0dXBXaXphcmRNb2RhbFxyXG5cdFx0XHR3aXphcmQub3BlbigpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRwbHVnaW4uYWRkQ29tbWFuZCh7XHJcblx0XHRpZDogJ2hlYWx0aC1jaGVjaycsXHJcblx0XHRuYW1lOiAnQ2hlY2sgVmF1bHQgQ01TIHNldHVwJyxcclxuXHRcdGNhbGxiYWNrOiAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGhlYWx0aENoZWNrID0gbmV3IEhlYWx0aENoZWNrTW9kYWwocGx1Z2luLmFwcCwgcGx1Z2luKTtcclxuXHRcdFx0aGVhbHRoQ2hlY2sub3BlbigpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRwbHVnaW4uYWRkQ29tbWFuZCh7XHJcblx0XHRpZDogJ2Rvd25sb2FkLWFwcGx5LXByZXNldCcsXHJcblx0XHRuYW1lOiAnRG93bmxvYWQgYW5kIGFwcGx5IHByZXNldCcsXHJcblx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCBtYW5hZ2VyID0gbmV3IFByZXNldE1hbmFnZXIocGx1Z2luLmFwcCk7XHJcblx0XHRcdGF3YWl0IG1hbmFnZXIuYXBwbHlQcmVzZXQocGx1Z2luLnNldHRpbmdzLnByZXNldHNSZXBvLCBwbHVnaW4uc2V0dGluZ3MucHJlc2V0TmFtZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQUNBLHNCQUNBLGFBQ0FDLE9BQ0FDLEtBRU0sV0FPTztBQWJiO0FBQUE7QUFBQSxJQUFBRixvQkFBNEM7QUFDNUMsMkJBQXFCO0FBQ3JCLGtCQUEwQjtBQUMxQixJQUFBQyxRQUFzQjtBQUN0QixJQUFBQyxNQUFvQjtBQUVwQixJQUFNLGdCQUFZLHVCQUFVLHlCQUFJO0FBT3pCLElBQU0sYUFBTixNQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSXBCLGFBQWEsT0FBTyxhQUF1QztBQUN2RCxZQUFJLENBQUMsWUFBYSxRQUFPO0FBRXpCLFlBQUk7QUFDQSxnQkFBTSxlQUFvQixjQUFRLFdBQVc7QUFDN0MsZ0JBQU0sYUFBa0IsV0FBSyxjQUFjLE1BQU07QUFDakQsZ0JBQU0sU0FBWSxlQUFXLFVBQVU7QUFFdkMsa0JBQVEsTUFBTSw0QkFBNEI7QUFBQSxZQUN0QztBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0osQ0FBQztBQUVELGNBQUksQ0FBSSxlQUFXLFlBQVksRUFBRyxRQUFPO0FBSXpDLGlCQUFPO0FBQUEsUUFDWCxTQUFTLE9BQU87QUFDWixrQkFBUSxNQUFNLDRCQUE0QixLQUFLO0FBQy9DLGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGFBQWEsU0FBUyxhQUFvQztBQUN0RCxjQUFNLFVBQVUsWUFBWSxFQUFFLEtBQUssWUFBWSxDQUFDO0FBQUEsTUFDcEQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGFBQWEsVUFBVSxhQUFxQixLQUFhLGFBQXFCLFVBQXlCO0FBQ25HLFlBQUk7QUFDQSxnQkFBTSxVQUFV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R0EscUJBQWlCLElBQUk7QUFHckIsU0FBSyxjQUFjLElBQUksWUFBWSxLQUFLLEtBQUssSUFBSSxDQUFDO0FBR2xELFFBQUksS0FBSyxTQUFTLG9CQUFvQjtBQUNyQyxXQUFLLElBQUksVUFBVSxjQUFjLE1BQU07QUFFdEMsYUFBSyxtQkFBbUIsT0FBTyxXQUFXLE1BQU07QUFDL0MsZ0JBQU0sWUFBWTtBQUVqQixrQkFBTSxLQUFLLGFBQWE7QUFDeEIsZ0JBQUksS0FBSyxTQUFTLG9CQUFvQjtBQUNyQyxvQkFBTSxTQUFTLElBQUksaUJBQWlCLEtBQUssS0FBSyxRQUFXLElBQUk7QUFDN0QscUJBQU8sS0FBSztBQUFBLFlBQ2I7QUFBQSxVQUNELEdBQUc7QUFBQSxRQUNKLEdBQUcsR0FBSTtBQUFBLE1BQ1IsQ0FBQztBQUFBLElBQ0Y7QUFBQSxFQUNEO0FBQUEsRUFFQSxXQUFXO0FBQ1YsUUFBSSxLQUFLLGtCQUFrQjtBQUMxQixhQUFPLGFBQWEsS0FBSyxnQkFBZ0I7QUFBQSxJQUMxQztBQUFBLEVBQ0Q7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBOEI7QUFBQSxFQUN2RztBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ2xDO0FBQ0Q7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgImZzIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJlc29sdmUiLCAicmVsYXRpdmUiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiZnMiLCAicGF0aCIsICJmcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJmcyIsICJzZXRDc3NQcm9wcyIsICJyZXNvbHZlIiwgIl9hIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0aW1lc3RhbXAiLCAicmVsYXRpdmUiLCAic2V0Q3NzUHJvcHMiLCAicGF0aCIsICJpbXBvcnRlZFR5cGVzIiwgImNvbnRlbnQiLCAiZGF0YSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgInJlcyIsICJyZXMiLCAiX2EiLCAibWFwIiwgInNjaGVtYSIsICJub2RlIiwgInNjaGVtYSIsICJwYXRoIiwgImkiLCAiZW5kIiwgImlzQmxvY2siLCAiX2EiLCAibWFwIiwgInZhbHVlIiwgIm1hcCIsICJzY2hlbWEiLCAic3RyaW5naWZ5IiwgImNvbW1lbnQiLCAic3RyIiwgInNjaGVtYSIsICJtYXAiLCAibWFwIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2VxIiwgInNlcSIsICJzY2hlbWEiLCAiaW50SWRlbnRpZnkiLCAic2NoZW1hIiwgInNlcSIsICJzY2hlbWEiLCAicGFpcnMiLCAibWFwIiwgInNjaGVtYSIsICJwYWlycyIsICJvbWFwIiwgInNlcSIsICJmbG9hdE5hTiIsICJmbG9hdEV4cCIsICJmbG9hdCIsICJpbnRJZGVudGlmeSIsICJpbnRSZXNvbHZlIiwgIm4iLCAiaW50U3RyaW5naWZ5IiwgImludE9jdCIsICJpbnQiLCAiaW50SGV4IiwgInNjaGVtYSIsICJzZXQiLCAibWFwIiwgInJlcyIsICJzY2hlbWEiLCAiaW50T2N0IiwgImludCIsICJpbnRIZXgiLCAiZmxvYXROYU4iLCAiZmxvYXRFeHAiLCAiZmxvYXQiLCAic2NoZW1hIiwgInRhZ3MiLCAibWVyZ2UiLCAic2NoZW1hIiwgInBhdGgiLCAicmVzIiwgImNvbXBvc2VOb2RlIiwgImNvbXBvc2VFbXB0eU5vZGUiLCAibWFwIiwgInNlcCIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgInNlcSIsICJzZXAiLCAiY29tcG9zZU5vZGUiLCAiY29tcG9zZUVtcHR5Tm9kZSIsICJpc01hcCIsICJzZXAiLCAibWFwIiwgIkNOIiwgInZhbHVlIiwgImVuZCIsICJzZXAiLCAic2VwIiwgInNjaGVtYSIsICJ0YWciLCAiX2EiLCAiQlJFQUsiLCAiU0tJUCIsICJSRU1PVkUiLCAidmlzaXQiLCAicGF0aCIsICJTQ0FMQVIiLCAiU0NBTEFSIiwgImkiLCAiY2giLCAiU0NBTEFSIiwgInNlcCIsICJtYXAiLCAic3RhcnQiLCAiZnMiLCAic2VxIiwgInBhcnNlIiwgInBhcnNlIiwgInNldENzc1Byb3BzIiwgImV4YW1wbGUiLCAidmFsdWUiLCAiZGV0ZWN0ZWQiLCAicGF0aFJlc29sdmVyIiwgImZvbGRlclBhdGgiLCAiYWdncmVnYXRlUHJvcHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJzZXRDc3NQcm9wcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAic2V0Q3NzUHJvcHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgImZzIiwgInNldENzc1Byb3BzIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGFyc2UiLCAicmVzb2x2ZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgIl9hIiwgImltcG9ydF9vYnNpZGlhbiIsICJzZXRDc3NQcm9wcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiR2l0TWFuYWdlciIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgInRpbWVzdGFtcCIsICJHaXRNYW5hZ2VyIiwgInBhdGgiXQp9Cg==
