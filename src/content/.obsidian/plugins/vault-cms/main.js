/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/GitManager.ts
var GitManager_exports = {};
__export(GitManager_exports, {
  GitManager: () => GitManager
});
var import_obsidian15, import_child_process, import_util, path7, fs6, execAsync, GitManager;
var init_GitManager = __esm({
  "src/utils/GitManager.ts"() {
    import_obsidian15 = require("obsidian");
    import_child_process = require("child_process");
    import_util = require("util");
    path7 = __toESM(require("path"), 1);
    fs6 = __toESM(require("fs"), 1);
    execAsync = (0, import_util.promisify)(import_child_process.exec);
    GitManager = class {
      /**
       * Checks if a directory is a Git repository.
       */
      static async isRepo(projectRoot) {
        if (!projectRoot) return false;
        try {
          const absolutePath = path7.resolve(projectRoot);
          const dotGitPath = path7.join(absolutePath, ".git");
          const exists = fs6.existsSync(dotGitPath);
          console.debug("GitManager.isRepo check:", {
            projectRoot,
            absolutePath,
            dotGitPath,
            exists
          });
          if (!fs6.existsSync(absolutePath)) return false;
          return exists;
        } catch (error) {
          console.error("GitManager.isRepo error:", error);
          return false;
        }
      }
      /**
       * Initializes a new Git repository at the given path.
       */
      static async initRepo(projectRoot) {
        await execAsync("git init", { cwd: projectRoot });
      }
      /**
       * Sets the remote URL for the repository.
       */
      static async setRemote(projectRoot, url, remoteName = "origin") {
        try {
          await execAsync(`git remote add ${remoteName} ${url}`, { cwd: projectRoot });
        } catch (error) {
          if (error instanceof Error && error.message.includes("already exists")) {
            await execAsync(`git remote set-url ${remoteName} ${url}`, { cwd: projectRoot });
          } else {
            throw error;
          }
        }
      }
      /**
       * Gets the remote URL for the repository, scrubbing any tokens for security.
       */
      static async getRemoteUrl(projectRoot, remoteName = "origin") {
        try {
          const { stdout } = await execAsync(`git remote get-url ${remoteName}`, { cwd: projectRoot });
          let url = stdout.trim() || null;
          if (url && url.includes("@github.com")) {
            url = url.replace(/https:\/\/.*@github\.com/, "https://github.com");
          }
          return url;
        } catch (e) {
          return null;
        }
      }
      /**
       * Gets the current local branch name.
       */
      static async getCurrentBranch(projectRoot) {
        try {
          const { stdout } = await execAsync("git branch --show-current", { cwd: projectRoot });
          return stdout.trim() || "main";
        } catch (e) {
          return "main";
        }
      }
      /**
       * Creates an initial commit and pushes to the remote, setting the upstream.
       */
      static async initialCommitAndPush(projectRoot, branch, remoteName = "origin", token) {
        try {
          console.debug("GitManager.initialCommitAndPush: starting", { projectRoot, branch, remoteName, hasToken: !!token });
          try {
            await execAsync("git config user.name", { cwd: projectRoot });
          } catch (e) {
            console.debug("GitManager: Setting local git user.name");
            await execAsync('git config user.name "Vault CMS User"', { cwd: projectRoot });
            await execAsync('git config user.email "vault-cms@example.com"', { cwd: projectRoot });
          }
          await execAsync("git add .", { cwd: projectRoot });
          try {
            await execAsync('git commit -m "Initial commit from Vault CMS"', { cwd: projectRoot });
          } catch (commitError) {
            const errorMessage = commitError instanceof Error ? commitError.message : String(commitError);
            if (errorMessage.includes("nothing to commit") || errorMessage.includes("working tree clean")) {
              console.debug("GitManager: Nothing to commit");
            } else {
              throw commitError;
            }
          }
          await execAsync(`git branch -M ${branch}`, { cwd: projectRoot });
          if (token) {
            const remoteUrl = await this.getRemoteUrl(projectRoot, remoteName);
            if (remoteUrl && remoteUrl.startsWith("https://")) {
              const authenticatedUrl = remoteUrl.replace("https://", `https://${token}@`);
              console.debug("GitManager: Pushing with temporary token auth");
              await execAsync(`git remote set-url ${remoteName} ${authenticatedUrl}`, { cwd: projectRoot });
              try {
                await execAsync(`git push -u ${remoteName} ${branch}`, { cwd: projectRoot });
              } finally {
                await execAsync(`git remote set-url ${remoteName} ${remoteUrl}`, { cwd: projectRoot });
              }
            } else {
              await execAsync(`git push -u ${remoteName} ${branch}`, { cwd: projectRoot });
            }
          } else {
            await execAsync(`git push -u ${remoteName} ${branch}`, { cwd: projectRoot });
          }
        } catch (error) {
          console.error("GitManager.initialCommitAndPush failed:", error);
          throw error;
        }
      }
      /**
       * Creates a new repository on GitHub.
       */
      static async createGitHubRepo(token, name, description, isPrivate) {
        var _a, _b;
        const params = {
          url: "https://api.github.com/user/repos",
          method: "POST",
          headers: {
            "Authorization": `token ${token}`,
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            name,
            description,
            private: isPrivate
          })
        };
        try {
          const response = await (0, import_obsidian15.requestUrl)(params);
          if (response.status === 422) {
            throw new Error("Repository name already exists on your GitHub account.");
          }
          if (response.status !== 201) {
            let errorMessage = `GitHub API Error: ${response.status}`;
            try {
              const errorData = typeof response.json === "string" ? JSON.parse(response.json) : response.json;
              if (errorData == null ? void 0 : errorData.message) {
                errorMessage = `GitHub API Error: ${errorData.message}`;
                if ((_b = (_a = errorData.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) {
                  errorMessage += ` (${errorData.errors[0].message})`;
                }
              }
            } catch (e) {
            }
            throw new Error(errorMessage);
          }
          return response.json;
        } catch (error) {
          if (error instanceof Error && (error.message.includes("already exists") || error.message.includes("GitHub API Error"))) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          if (message.includes("422") || message.includes("already exists")) {
            throw new Error("Repository name already exists on your GitHub account.");
          }
          throw error;
        }
      }
      /**
       * Verifies if the GitHub PAT is valid and returns the username.
       */
      static async verifyToken(token) {
        var _a;
        try {
          const params = {
            url: "https://api.github.com/user",
            method: "GET",
            headers: {
              "Authorization": `token ${token}`,
              "Accept": "application/vnd.github.v3+json"
            }
          };
          const response = await (0, import_obsidian15.requestUrl)(params);
          if (response.status === 200) {
            return ((_a = response.json) == null ? void 0 : _a.login) || null;
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultCMSPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  projectRoot: "",
  configFilePath: "",
  contentTypes: [],
  frontmatterProperties: {},
  attachmentHandlingMode: "subfolder",
  attachmentFolderName: void 0,
  preset: "vanilla",
  presetName: "",
  presetsRepo: "davidvkimball/vault-cms-presets",
  enableEditingToolbar: false,
  enableExtendedFileTypes: false,
  enabledPlugins: [],
  disabledPlugins: [],
  theme: "",
  basesCMSConfig: {
    views: []
  },
  astroComposerConfig: {
    customContentTypes: [],
    defaultTemplate: "",
    configFilePath: "",
    terminalProjectRootPath: ""
  },
  seoConfig: {
    titleProperty: "title",
    descriptionProperty: void 0,
    scanDirectories: "",
    useFilenameAsTitle: false,
    useFilenameAsSlug: true,
    enableMDXSupport: false
  },
  propertyOverFileName: {
    propertyKey: "title"
  },
  imageManager: {},
  homeBase: {},
  explorerFocus: {},
  ignoreConfig: {
    gitIgnoreConfigured: false,
    viteIgnoreConfigured: false
  },
  gitConfig: {
    enabled: false,
    isPrivate: true,
    branchName: "main",
    autoConfigureObsidianGit: true
  },
  runWizardOnStartup: true,
  wizardCompleted: false
};

// src/ui/SettingsTab.ts
var import_obsidian28 = require("obsidian");

// src/ui/SetupWizardModal.ts
var import_obsidian23 = require("obsidian");

// src/utils/ImageManagerConfig.ts
var import_obsidian = require("obsidian");
var ImageManagerConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async loadConfig() {
    var _a;
    const pluginId = "image-manager";
    try {
      const plugins = this.app.plugins;
      const imageManagerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (imageManagerPlugin && imageManagerPlugin.settings) {
        return imageManagerPlugin.settings;
      }
    } catch (error) {
      console.warn("Failed to load Image Manager config from plugin API:", error);
    }
    return await this.loadConfigFallback();
  }
  async loadConfigFallback() {
    const pluginId = "image-manager";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      try {
        const existingData = JSON.parse(await this.app.vault.read(dataFile));
        return existingData;
      } catch (error) {
        console.warn("Failed to parse existing Image Manager data.json:", error);
        return {};
      }
    }
    return {};
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "image-manager";
    try {
      const plugins = this.app.plugins;
      const imageManagerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (imageManagerPlugin && imageManagerPlugin.settings) {
        const pluginSettings = imageManagerPlugin.settings;
        Object.assign(pluginSettings, config);
        if (typeof imageManagerPlugin.saveSettings === "function") {
          await imageManagerPlugin.saveSettings();
          console.debug("ImageManagerConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Image Manager config:", error);
      try {
        await this.saveConfigFallback(config);
      } catch (fallbackError) {
        console.error("Failed to save Image Manager config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "image-manager";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Image Manager data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(mergedData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
  /**
   * Resolves the image property from the wizard state and syncs it to Image Manager settings
   */
  async resolveAndSyncImageProperty(state) {
    var _a, _b;
    const contentTypes = state.contentTypes || [];
    const frontmatterProperties = state.frontmatterProperties || {};
    const defaultTypeId = state.defaultContentTypeId;
    let resolvedImageProperty;
    if (defaultTypeId && ((_a = frontmatterProperties[defaultTypeId]) == null ? void 0 : _a.imageProperty)) {
      resolvedImageProperty = frontmatterProperties[defaultTypeId].imageProperty;
    }
    if (!resolvedImageProperty) {
      for (const type of contentTypes) {
        if ((_b = frontmatterProperties[type.id]) == null ? void 0 : _b.imageProperty) {
          resolvedImageProperty = frontmatterProperties[type.id].imageProperty;
          break;
        }
      }
    }
    if (resolvedImageProperty) {
      const config = await this.loadConfig();
      config.defaultPropertyName = resolvedImageProperty;
      if (config.banner) {
        if (typeof config.banner === "object") {
          if (!config.banner.properties) {
            config.banner.properties = {};
          }
          config.banner.properties.imageProperty = resolvedImageProperty;
        }
      } else {
        config.banner = {
          properties: {
            imageProperty: resolvedImageProperty
          }
        };
      }
      await this.saveConfig(config);
      if (state.imageManager) {
        state.imageManager.defaultPropertyName = resolvedImageProperty;
        if (state.imageManager.banner) {
          if (typeof state.imageManager.banner === "object") {
            if (!state.imageManager.banner.properties) {
              state.imageManager.banner.properties = {};
            }
            state.imageManager.banner.properties.imageProperty = resolvedImageProperty;
          }
        } else {
          state.imageManager.banner = {
            properties: {
              imageProperty: resolvedImageProperty
            }
          };
        }
      }
      console.debug(`ImageManagerConfigurator: Synced image property "${resolvedImageProperty}" to Image Manager and state`);
    }
  }
};

// src/utils/HomeBaseConfig.ts
var import_obsidian2 = require("obsidian");
var HomeBaseConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async loadConfig() {
    var _a;
    const pluginId = "home-base";
    try {
      const plugins = this.app.plugins;
      const homeBasePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (homeBasePlugin && homeBasePlugin.settings) {
        return homeBasePlugin.settings;
      }
    } catch (error) {
      console.warn("Failed to load Home Base config from plugin API:", error);
    }
    return await this.loadConfigFallback();
  }
  async loadConfigFallback() {
    const pluginId = "home-base";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      try {
        const existingData = JSON.parse(await this.app.vault.read(dataFile));
        return existingData;
      } catch (error) {
        console.warn("Failed to parse existing Home Base data.json:", error);
        return {};
      }
    }
    return {};
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "home-base";
    try {
      const plugins = this.app.plugins;
      const homeBasePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (homeBasePlugin && homeBasePlugin.settings) {
        const pluginSettings = homeBasePlugin.settings;
        Object.assign(pluginSettings, config);
        if (typeof homeBasePlugin.saveSettings === "function") {
          await homeBasePlugin.saveSettings();
          console.debug("HomeBaseConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Home Base config:", error);
      try {
        await this.saveConfigFallback(config);
      } catch (fallbackError) {
        console.error("Failed to save Home Base config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "home-base";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Home Base data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian2.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(mergedData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
};

// src/utils/ExplorerFocusConfig.ts
var import_obsidian3 = require("obsidian");
var ExplorerFocusConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "explorer-focus";
    try {
      const plugins = this.app.plugins;
      const explorerFocusPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (explorerFocusPlugin && explorerFocusPlugin.settings) {
        console.debug("ExplorerFocusConfig: Using plugin.settings API");
        const settings = explorerFocusPlugin.settings;
        for (const [key, value] of Object.entries(config)) {
          settings[key] = value;
        }
        if (typeof explorerFocusPlugin.saveSettings === "function") {
          await explorerFocusPlugin.saveSettings();
          console.debug("ExplorerFocusConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("ExplorerFocusConfig: Plugin API not available, using fallback file method");
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Explorer Focus config:", error);
      await this.saveConfigFallback(config);
    }
  }
  async loadConfig() {
    const pluginId = "explorer-focus";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.read(dataFile);
        return JSON.parse(content);
      }
    } catch (error) {
      console.warn("Failed to load Explorer Focus config:", error);
    }
    return null;
  }
  async saveConfigFallback(config) {
    const pluginId = "explorer-focus";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian3.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing explorer-focus data.json:", error);
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(mergedData, null, 2);
    if (dataFile instanceof import_obsidian3.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("ExplorerFocusConfig: Successfully saved explorer-focus config via fallback");
  }
};

// src/utils/EditingToolbarConfig.ts
var import_obsidian4 = require("obsidian");
var EditingToolbarConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Enable/disable the editing toolbar visibility
   */
  async toggleVisibility(app, enable) {
    var _a;
    console.debug(`EditingToolbarConfig: toggleVisibility called with enable=${enable}`);
    try {
      const plugins = app.plugins;
      if (!plugins) {
        console.warn("EditingToolbarConfig: Plugins API not available");
        return;
      }
      const editingToolbarPlugin = (_a = plugins.plugins) == null ? void 0 : _a["editing-toolbar"];
      if (!editingToolbarPlugin) {
        console.warn("EditingToolbarConfig: Editing Toolbar plugin not found");
        return;
      }
      console.debug(`EditingToolbarConfig: Editing Toolbar plugin found, enabled=${editingToolbarPlugin.enabled}`);
      console.debug(`EditingToolbarConfig: Plugin settings available:`, !!editingToolbarPlugin.settings);
      if (editingToolbarPlugin.settings) {
        console.debug(`EditingToolbarConfig: Current cMenuVisibility:`, editingToolbarPlugin.settings.cMenuVisibility);
      }
      if (editingToolbarPlugin.settings && typeof editingToolbarPlugin.saveSettings === "function") {
        console.debug("EditingToolbarConfig: Using plugin.saveSettings() method");
        const oldValue = editingToolbarPlugin.settings.cMenuVisibility;
        editingToolbarPlugin.settings.cMenuVisibility = enable;
        console.debug(`EditingToolbarConfig: Set cMenuVisibility from ${oldValue} to ${enable}`);
        await editingToolbarPlugin.saveSettings();
        console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via plugin.saveSettings()");
        console.debug("EditingToolbarConfig: Dispatching editingToolbar-NewCommand event");
        window.dispatchEvent(new Event("editingToolbar-NewCommand"));
        if (enable) {
          console.debug("EditingToolbarConfig: Waiting for settings to persist...");
          await new Promise((resolve9) => setTimeout(resolve9, 500));
          if (typeof editingToolbarPlugin.loadSettings === "function") {
            console.debug("EditingToolbarConfig: Reloading editing toolbar plugin settings");
            await editingToolbarPlugin.loadSettings();
          }
          if (typeof editingToolbarPlugin.refresh === "function") {
            console.debug("EditingToolbarConfig: Refreshing editing toolbar plugin");
            editingToolbarPlugin.refresh();
          }
        }
        return;
      } else {
        console.debug("EditingToolbarConfig: Plugin saveSettings not available, using fallback");
      }
      await this.toggleVisibilityFallback(app, enable);
    } catch (error) {
      console.error("EditingToolbarConfig: Failed to toggle editing toolbar plugin:", error);
      try {
        await this.toggleVisibilityFallback(app, enable);
      } catch (fallbackError) {
        console.error("EditingToolbarConfig: Failed to toggle editing toolbar via fallback:", fallbackError);
      }
    }
  }
  async toggleVisibilityFallback(app, enable) {
    const pluginId = "editing-toolbar";
    const configDir = app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian4.TFile) {
      try {
        existingData = JSON.parse(await app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing editing-toolbar data.json, starting fresh:", error);
        existingData = {};
      }
    }
    existingData.cMenuVisibility = enable;
    if (dataFile instanceof import_obsidian4.TFile) {
      await app.vault.modify(dataFile, JSON.stringify(existingData, null, 2));
      console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via file modify");
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
            throw error;
          }
        }
      }
      try {
        await app.vault.create(pluginDataPath, JSON.stringify(existingData, null, 2));
        console.debug("EditingToolbarConfig: Successfully created editing-toolbar data.json");
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian4.TFile) {
            await app.vault.modify(retryFile, JSON.stringify(existingData, null, 2));
            console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via retry modify");
          } else {
            await new Promise((resolve9) => setTimeout(resolve9, 200));
            const retryFile2 = app.vault.getAbstractFileByPath(pluginDataPath);
            if (retryFile2 instanceof import_obsidian4.TFile) {
              await app.vault.modify(retryFile2, JSON.stringify(existingData, null, 2));
              console.debug("EditingToolbarConfig: Successfully saved editing-toolbar via delayed retry modify");
            } else {
              throw error;
            }
          }
        } else {
          throw error;
        }
      }
    }
  }
  /**
   * Get the current visibility of the editing toolbar
   */
  async getVisibility(app) {
    var _a;
    try {
      const plugins = app.plugins;
      const editingToolbarPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["editing-toolbar"];
      if (editingToolbarPlugin == null ? void 0 : editingToolbarPlugin.settings) {
        return editingToolbarPlugin.settings.cMenuVisibility;
      }
      const configDir = app.vault.configDir;
      const pluginDataPath = `${configDir}/plugins/editing-toolbar/data.json`;
      const dataFile = app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian4.TFile) {
        const existingData = JSON.parse(await app.vault.read(dataFile));
        return existingData.cMenuVisibility;
      }
    } catch (error) {
      console.warn("EditingToolbarConfig: Failed to get editing toolbar visibility:", error);
    }
    return void 0;
  }
};

// src/ui/wizard/WizardStateManager.ts
var WizardStateManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.editingToolbarConfigurator = new EditingToolbarConfigurator(plugin.app);
    const settings = plugin.settings;
    this.state = this.initializeState(settings);
  }
  initializeState(settings) {
    var _a, _b, _c;
    const savedProjectDetection = settings.projectRoot && settings.configFilePath ? {
      projectRoot: settings.projectRoot,
      configFilePath: settings.configFilePath,
      vaultLocation: "content"
    } : void 0;
    let attachmentHandlingMode = settings.attachmentHandlingMode;
    let attachmentFolderName = settings.attachmentFolderName;
    if (!attachmentHandlingMode) {
      const vault = this.plugin.app.vault;
      const obsidianConfig = vault.config;
      if (obsidianConfig == null ? void 0 : obsidianConfig.attachmentFolderPath) {
        const folderPath = obsidianConfig.attachmentFolderPath;
        if (folderPath === "./") {
          attachmentHandlingMode = "same-folder";
        } else if (folderPath.startsWith("./")) {
          attachmentHandlingMode = "subfolder";
          attachmentFolderName = folderPath.substring(2);
        } else {
          attachmentHandlingMode = "specified-folder";
          attachmentFolderName = folderPath;
        }
      }
    }
    return {
      currentStep: 0,
      projectDetection: savedProjectDetection,
      contentTypes: settings.contentTypes || [],
      frontmatterProperties: settings.frontmatterProperties || {},
      defaultContentTypeId: settings.defaultContentTypeId,
      attachmentHandlingMode: attachmentHandlingMode || "subfolder",
      attachmentFolderName,
      preset: settings.preset || "vanilla",
      presetName: settings.presetName || "",
      presetsRepo: settings.presetsRepo || "davidvkimball/vault-cms-presets",
      enableEditingToolbar: (_b = (_a = settings.enableEditingToolbar) != null ? _a : settings.enableWYSIWYG) != null ? _b : false,
      enableMdxSupport: settings.enableMdxSupport,
      enableExtendedFileTypes: settings.enableExtendedFileTypes,
      enabledPlugins: settings.enabledPlugins || [],
      disabledPlugins: settings.disabledPlugins || [],
      theme: settings.theme || "",
      basesCMSConfig: settings.basesCMSConfig || { views: [] },
      astroComposerConfig: settings.astroComposerConfig || {
        customContentTypes: [],
        defaultTemplate: "",
        configFilePath: "",
        terminalProjectRootPath: ""
      },
      seoConfig: settings.seoConfig || {
        titleProperty: "title",
        scanDirectories: "",
        useFilenameAsTitle: false,
        useFilenameAsSlug: true,
        enableMDXSupport: (_c = settings.enableMdxSupport) != null ? _c : false
      },
      propertyOverFileName: settings.propertyOverFileName || { propertyKey: "title" },
      imageManager: settings.imageManager || {},
      homeBase: settings.homeBase || {},
      explorerFocus: settings.explorerFocus || {},
      ignoreConfig: settings.ignoreConfig || { gitIgnoreConfigured: false, viteIgnoreConfigured: false },
      gitConfig: settings.gitConfig || { enabled: false, autoConfigureObsidianGit: true }
    };
  }
  getState() {
    return this.state;
  }
  updateState(updates) {
    this.state = { ...this.state, ...updates };
  }
  setState(updates) {
    this.state = { ...this.state, ...updates };
  }
  nextStep(totalSteps) {
    if (this.state.currentStep < totalSteps - 1) {
      this.state.currentStep++;
    }
  }
  previousStep() {
    if (this.state.currentStep > 0) {
      this.state.currentStep--;
    }
  }
  canGoNext(totalSteps) {
    return this.state.currentStep < totalSteps - 1;
  }
  canGoPrevious() {
    return this.state.currentStep > 0;
  }
  getProgress(totalSteps) {
    if (totalSteps === 0) return 0;
    return (this.state.currentStep + 1) / totalSteps * 100;
  }
  async refreshState() {
    var _a, _b;
    const settings = this.plugin.settings;
    if (settings.projectRoot && settings.configFilePath) {
      this.state.projectDetection = {
        projectRoot: settings.projectRoot,
        configFilePath: settings.configFilePath,
        vaultLocation: "content"
      };
    } else {
      this.state.projectDetection = void 0;
    }
    this.state.contentTypes = settings.contentTypes || [];
    this.state.frontmatterProperties = settings.frontmatterProperties || {};
    this.state.defaultContentTypeId = settings.defaultContentTypeId;
    if (settings.attachmentHandlingMode) {
      this.state.attachmentHandlingMode = settings.attachmentHandlingMode;
      this.state.attachmentFolderName = settings.attachmentFolderName;
    } else {
      const vault = this.plugin.app.vault;
      const obsidianConfig = vault.config;
      if (obsidianConfig == null ? void 0 : obsidianConfig.attachmentFolderPath) {
        const folderPath = obsidianConfig.attachmentFolderPath;
        if (folderPath === "./") {
          this.state.attachmentHandlingMode = "same-folder";
          this.state.attachmentFolderName = void 0;
        } else if (folderPath.startsWith("./")) {
          this.state.attachmentHandlingMode = "subfolder";
          this.state.attachmentFolderName = folderPath.substring(2);
        } else {
          this.state.attachmentHandlingMode = "specified-folder";
          this.state.attachmentFolderName = folderPath;
        }
      } else {
        this.state.attachmentHandlingMode = "subfolder";
        this.state.attachmentFolderName = void 0;
      }
    }
    this.state.preset = settings.preset || "vanilla";
    this.state.presetName = settings.presetName || "";
    this.state.presetsRepo = settings.presetsRepo || "vaultcms/vault-cms-presets";
    const actualVisibility = await this.editingToolbarConfigurator.getVisibility(this.plugin.app);
    if (actualVisibility !== void 0) {
      this.state.enableEditingToolbar = actualVisibility;
    } else {
      this.state.enableEditingToolbar = (_b = (_a = settings.enableEditingToolbar) != null ? _a : settings.enableWYSIWYG) != null ? _b : false;
    }
    this.state.enableMdxSupport = settings.enableMdxSupport;
    this.state.enableExtendedFileTypes = settings.enableExtendedFileTypes;
    this.state.enabledPlugins = settings.enabledPlugins || [];
    this.state.disabledPlugins = settings.disabledPlugins || [];
    this.state.theme = settings.theme || "";
    this.state.basesCMSConfig = settings.basesCMSConfig || { views: [] };
    this.state.astroComposerConfig = settings.astroComposerConfig || {
      customContentTypes: [],
      defaultTemplate: "",
      configFilePath: "",
      terminalProjectRootPath: ""
    };
    this.state.seoConfig = settings.seoConfig || {
      titleProperty: "title",
      scanDirectories: "",
      useFilenameAsTitle: false,
      useFilenameAsSlug: true
    };
    this.state.propertyOverFileName = settings.propertyOverFileName || { propertyKey: "title" };
    this.state.explorerFocus = settings.explorerFocus || {};
    if (!this.state.imageManager || Object.keys(this.state.imageManager).length === 0) {
      try {
        const imageManagerConfigurator = new ImageManagerConfigurator(this.plugin.app);
        const loadedConfig = await imageManagerConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.imageManager = loadedConfig;
        } else {
          this.state.imageManager = settings.imageManager || {};
        }
      } catch (error) {
        console.warn("Failed to load Image Manager config during refresh:", error);
        this.state.imageManager = settings.imageManager || {};
      }
    } else {
      this.state.imageManager = settings.imageManager || {};
    }
    if (!this.state.homeBase || Object.keys(this.state.homeBase).length === 0) {
      try {
        const homeBaseConfigurator = new HomeBaseConfigurator(this.plugin.app);
        const loadedConfig = await homeBaseConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.homeBase = loadedConfig;
        } else {
          this.state.homeBase = settings.homeBase || {};
        }
      } catch (error) {
        console.warn("Failed to load Home Base config during refresh:", error);
        this.state.homeBase = settings.homeBase || {};
      }
    } else {
      this.state.homeBase = settings.homeBase || {};
    }
    if (!this.state.explorerFocus || Object.keys(this.state.explorerFocus).length === 0) {
      try {
        const explorerFocusConfigurator = new ExplorerFocusConfigurator(this.plugin.app);
        const loadedConfig = await explorerFocusConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.explorerFocus = loadedConfig;
        } else {
          this.state.explorerFocus = settings.explorerFocus || {};
        }
      } catch (error) {
        console.warn("Failed to load Explorer Focus config during refresh:", error);
        this.state.explorerFocus = settings.explorerFocus || {};
      }
    } else {
      this.state.explorerFocus = settings.explorerFocus || {};
    }
    this.state.gitConfig = settings.gitConfig || { enabled: false, autoConfigureObsidianGit: true };
    this.state.ignoreConfig = settings.ignoreConfig || { gitIgnoreConfigured: false, viteIgnoreConfigured: false };
  }
  async buildFinalSettings() {
    var _a, _b, _c, _d;
    const settings = this.plugin.settings;
    settings.projectRoot = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) || "";
    settings.configFilePath = ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath) || "";
    settings.contentTypes = this.state.contentTypes;
    settings.frontmatterProperties = this.state.frontmatterProperties;
    settings.defaultContentTypeId = this.state.defaultContentTypeId;
    settings.attachmentHandlingMode = this.state.attachmentHandlingMode;
    settings.attachmentFolderName = this.state.attachmentFolderName;
    settings.preset = this.state.preset;
    settings.presetName = this.state.presetName || "";
    settings.presetsRepo = this.state.presetsRepo || "davidvkimball/vault-cms-presets";
    settings.enableEditingToolbar = this.state.enableEditingToolbar;
    if (settings.enableWYSIWYG !== void 0) {
      delete settings.enableWYSIWYG;
    }
    settings.enableMdxSupport = (_c = this.state.enableMdxSupport) != null ? _c : false;
    settings.enableExtendedFileTypes = (_d = this.state.enableExtendedFileTypes) != null ? _d : false;
    settings.enabledPlugins = this.state.enabledPlugins;
    settings.disabledPlugins = this.state.disabledPlugins;
    settings.theme = this.state.theme;
    settings.basesCMSConfig = this.state.basesCMSConfig;
    settings.astroComposerConfig = this.state.astroComposerConfig;
    settings.seoConfig = this.state.seoConfig;
    settings.propertyOverFileName = this.state.propertyOverFileName;
    const settingsRecord = settings;
    if (settingsRecord.uiTweaker) {
      delete settingsRecord.uiTweaker;
    }
    if (settingsRecord.tabBarCommands) {
      delete settingsRecord.tabBarCommands;
    }
    if (settingsRecord.commanderConfig) {
      delete settingsRecord.commanderConfig;
    }
    if (settingsRecord.imageInserter) {
      delete settingsRecord.imageInserter;
    }
    settings.imageManager = this.state.imageManager;
    settings.homeBase = this.state.homeBase;
    settings.explorerFocus = this.state.explorerFocus;
    settings.ignoreConfig = this.state.ignoreConfig;
    settings.gitConfig = { ...this.state.gitConfig };
    delete settings.gitConfig.pat;
    try {
      const imageManagerConfigurator = new ImageManagerConfigurator(this.plugin.app);
      await imageManagerConfigurator.resolveAndSyncImageProperty(this.state);
    } catch (error) {
      console.warn("WizardStateManager: Failed to sync image property with Image Manager:", error);
    }
  }
};

// src/ui/wizard/BaseWizardStep.ts
var BaseWizardStep = class {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    this.showNextButton = true;
    this.app = app;
    this.containerEl = containerEl;
    this.state = state;
    this.onNext = onNext;
    this.onBack = onBack;
    this.onCancel = onCancel;
  }
  /**
   * Check if this step should be automatically skipped
   */
  async shouldSkip() {
    return false;
  }
  /**
   * Convert absolute path to relative path from vault root
   */
  toRelativePath(absolutePath) {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return absolutePath;
    }
    const vaultNormalized = vaultPath.replace(/\\/g, "/").replace(/\/$/, "");
    const absoluteNormalized = absolutePath.replace(/\\/g, "/").replace(/\/$/, "");
    if (absoluteNormalized.startsWith(vaultNormalized)) {
      const relative5 = absoluteNormalized.slice(vaultNormalized.length);
      const trimmedRelative = relative5.startsWith("/") ? relative5.slice(1) : relative5;
      return trimmedRelative || ".";
    }
    try {
      const vaultParts = vaultNormalized.split("/").filter((p) => p);
      const absoluteParts = absoluteNormalized.split("/").filter((p) => p);
      let commonLength = 0;
      while (commonLength < vaultParts.length && commonLength < absoluteParts.length && vaultParts[commonLength] === absoluteParts[commonLength]) {
        commonLength++;
      }
      const upLevels = vaultParts.length - commonLength;
      const relativeParts = absoluteParts.slice(commonLength);
      const relative5 = (upLevels > 0 ? "../".repeat(upLevels) : "") + relativeParts.join("/");
      return relative5 || absolutePath;
    } catch (e) {
      return absolutePath;
    }
  }
};

// src/ui/wizard/WelcomeStep.ts
function setCssProps(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var WelcomeStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Welcome to Vault CMS" });
    containerEl.createEl("p", {
      text: "This wizard will help you configure Vault CMS for your project. We'll guide you through:"
    });
    const list = containerEl.createEl("ul");
    list.createEl("li", { text: "Detecting your Astro project structure" });
    list.createEl("li", { text: "Identifying your content types" });
    list.createEl("li", { text: "Mapping frontmatter properties" });
    list.createEl("li", { text: "Configuring plugins and themes" });
    list.createEl("li", { text: "Setting up Home Base content views" });
    list.createEl("li", { text: "Configuring Astro Composer and SEO plugins" });
    containerEl.createEl("p", {
      text: "Choose an option to continue:"
    });
    const buttonContainer = containerEl.createDiv("wizard-welcome-buttons");
    setCssProps(buttonContainer, {
      display: "flex",
      gap: "10px",
      marginTop: "20px"
    });
    const getStartedBtn = buttonContainer.createEl("button", {
      text: "Get started",
      cls: "mod-button mod-cta"
    });
    getStartedBtn.addEventListener("click", () => {
      this.onNext();
    });
    const selectPresetBtn = buttonContainer.createEl("button", {
      text: "Select preset",
      cls: "mod-button"
    });
    selectPresetBtn.addEventListener("click", () => {
      this.onCancel();
      const appWithSetting = this.app;
      if (appWithSetting.setting && typeof appWithSetting.setting.open === "function") {
        appWithSetting.setting.open();
        if (typeof appWithSetting.setting.openTabById === "function") {
          appWithSetting.setting.openTabById("vault-cms");
        }
      }
    });
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Welcome";
  }
  getDescription() {
    return "Introduction to Vault CMS setup";
  }
};

// src/ui/wizard/ProjectDetectionStep.ts
var import_obsidian6 = require("obsidian");
var path4 = __toESM(require("path"), 1);
var fs4 = __toESM(require("fs"), 1);

// src/utils/ProjectDetector.ts
var path = __toESM(require("path"), 1);
var fs = __toESM(require("fs"), 1);
var ProjectDetector = class {
  constructor(app) {
    this.app = app;
  }
  detectProject() {
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return null;
    }
    const configResult = this.searchUpwardForConfig(vaultPath);
    if (!configResult) {
      return null;
    }
    const vaultLocation = this.detectVaultLocation(vaultPath, configResult.projectRoot);
    return {
      projectRoot: configResult.projectRoot,
      configFilePath: configResult.configFilePath,
      vaultLocation
    };
  }
  /**
   * Search upward from the vault path to find an Astro config file.
   * This allows the vault to be anywhere within the Astro project structure.
   * Bias towards src/config.ts if it exists alongside a root config file.
   */
  searchUpwardForConfig(startPath) {
    const rootConfigFileNames = [
      "astro.config.mjs",
      "astro.config.ts",
      "astro.config.js",
      "astro.config.mts",
      "astro.config.cjs",
      "astro.config.yml",
      "astro.config.yaml"
    ];
    const srcConfigFileName = "src/config.ts";
    let currentDir = path.resolve(startPath);
    const root = path.parse(currentDir).root;
    while (currentDir !== root) {
      const srcConfigPath = path.join(currentDir, srcConfigFileName);
      try {
        if (fs.existsSync(srcConfigPath) && fs.statSync(srcConfigPath).isFile()) {
          return {
            projectRoot: currentDir,
            configFilePath: srcConfigPath
          };
        }
      } catch (e) {
      }
      for (const fileName of rootConfigFileNames) {
        const configPath = path.join(currentDir, fileName);
        try {
          if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {
            return {
              projectRoot: currentDir,
              configFilePath: configPath
            };
          }
        } catch (e) {
        }
      }
      const parentDir = path.dirname(currentDir);
      if (parentDir === currentDir) {
        break;
      }
      currentDir = parentDir;
    }
    return null;
  }
  /**
   * Determine vault location relative to the detected project root.
   */
  detectVaultLocation(vaultPath, projectRoot) {
    const normalizedVaultPath = path.normalize(vaultPath);
    const normalizedProjectRoot = path.normalize(projectRoot);
    if (!normalizedVaultPath.startsWith(normalizedProjectRoot)) {
      return "root";
    }
    const relativePath = path.relative(normalizedProjectRoot, normalizedVaultPath);
    const pathParts = relativePath.split(path.sep).filter((part) => part.length > 0);
    const contentIndex = pathParts.findIndex((part) => part.toLowerCase() === "content");
    if (contentIndex > 0) {
      const parentIndex = contentIndex - 1;
      if (parentIndex >= 0 && pathParts[parentIndex].toLowerCase() === "src") {
        return "content";
      }
    }
    const srcIndex = pathParts.findIndex((part) => part.toLowerCase() === "src");
    if (srcIndex >= 0 && srcIndex < pathParts.length - 1) {
      const nextPart = pathParts[srcIndex + 1];
      if (nextPart.toLowerCase() === "content") {
        return "nested-content";
      }
    }
    return "root";
  }
};

// src/utils/MdxDetector.ts
var path2 = __toESM(require("path"), 1);
var fs2 = __toESM(require("fs"), 1);
var MdxDetector = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Detect if MDX files are present in the content folders
   * Scans all content type folders (posts, pages, etc.) for .mdx files
   */
  detectMdxUsage(projectDetection, contentTypes) {
    console.debug("MdxDetector.detectMdxUsage: called with", {
      projectRoot: projectDetection == null ? void 0 : projectDetection.projectRoot,
      vaultLocation: projectDetection == null ? void 0 : projectDetection.vaultLocation,
      contentTypesCount: contentTypes == null ? void 0 : contentTypes.length
    });
    if (!projectDetection) {
      console.debug("MdxDetector: No projectDetection, returning false");
      return false;
    }
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    console.debug("MdxDetector: vaultPath =", vaultPath);
    if (!vaultPath) {
      console.debug("MdxDetector: No vaultPath, returning false");
      return false;
    }
    const projectRoot = projectDetection.projectRoot;
    let projectRootPath;
    if (path2.isAbsolute(projectRoot)) {
      projectRootPath = projectRoot;
    } else {
      projectRootPath = path2.resolve(vaultPath, projectRoot);
    }
    console.debug("MdxDetector: projectRootPath =", projectRootPath);
    let contentBasePath;
    if (projectDetection.vaultLocation === "content") {
      contentBasePath = vaultPath;
    } else if (projectDetection.vaultLocation === "nested-content") {
      contentBasePath = path2.resolve(vaultPath, "..");
    } else {
      contentBasePath = path2.join(projectRootPath, "src", "content");
    }
    console.debug("MdxDetector: contentBasePath =", contentBasePath);
    console.debug("MdxDetector: vaultLocation =", projectDetection.vaultLocation);
    console.debug("MdxDetector: contentTypes to scan =", contentTypes.map((ct) => `${ct.name} (${ct.folder})`));
    for (const contentType of contentTypes) {
      let contentTypePath;
      if (contentType.folder.startsWith("src/content/")) {
        contentTypePath = path2.join(projectRootPath, contentType.folder);
      } else {
        contentTypePath = path2.join(contentBasePath, contentType.folder);
      }
      console.debug("MdxDetector: scanning", contentTypePath, "(enabled:", contentType.enabled, ")");
      try {
        if (fs2.existsSync(contentTypePath) && fs2.statSync(contentTypePath).isDirectory()) {
          const foundMdx = this.scanDirectoryForMdx(contentTypePath);
          console.debug("MdxDetector: found MDX in", contentTypePath, "=", foundMdx);
          if (foundMdx) {
            return true;
          }
        } else {
          console.debug("MdxDetector: path does not exist or is not a directory:", contentTypePath, "exists:", fs2.existsSync(contentTypePath));
        }
      } catch (error) {
        console.debug("MdxDetector: error scanning", contentTypePath, error);
        continue;
      }
    }
    console.debug("MdxDetector: no MDX files found");
    return false;
  }
  /**
   * Recursively scan a directory for .mdx files
   */
  scanDirectoryForMdx(dirPath) {
    try {
      const entries = fs2.readdirSync(dirPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path2.join(dirPath, entry.name);
        if (entry.isFile() && entry.name.endsWith(".mdx")) {
          return true;
        }
        if (entry.isDirectory()) {
          if (this.scanDirectoryForMdx(fullPath)) {
            return true;
          }
        }
      }
    } catch (e) {
      return false;
    }
    return false;
  }
};

// src/utils/ContentTypeDetector.ts
var import_obsidian5 = require("obsidian");
var path3 = __toESM(require("path"), 1);
var fs3 = __toESM(require("fs"), 1);
var ContentTypeDetector = class {
  constructor(app) {
    this.app = app;
  }
  detectContentTypes(projectDetection) {
    const contentFolder = this.findContentDirectory(projectDetection);
    if (!contentFolder) {
      return this.detectContentTypesFromFolder(this.app.vault.getRoot());
    }
    return this.detectContentTypesFromFolder(contentFolder);
  }
  /**
   * Detect content types based on immediate subfolders of the given root.
   */
  detectContentTypesFromFolder(rootFolder) {
    const contentTypes = [];
    const subfolders = this.getTopLevelFolders(rootFolder);
    if (subfolders.length > 0) {
      for (const folder of subfolders) {
        const contentType = this.detectContentType(folder);
        if (contentType) {
          contentTypes.push(contentType);
        }
      }
    } else {
      if (rootFolder.name === "/" && rootFolder.children.length === 0) {
        return [];
      }
      const contentType = this.detectContentType(rootFolder);
      if (contentType) {
        contentTypes.push(contentType);
      }
    }
    return contentTypes;
  }
  /**
   * Find the src/content directory regardless of where the vault is located.
   * Handles cases where vault is at:
   * - src level (need to go into src/content)
   * - src/content level (already there)
   * - src/content/post level (vault is inside a content type, can't access parent, return null to use fallback)
   */
  findContentDirectory(projectDetection) {
    if (!projectDetection || !projectDetection.projectRoot) {
      return null;
    }
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return null;
    }
    let projectRoot;
    if (path3.isAbsolute(projectDetection.projectRoot)) {
      projectRoot = projectDetection.projectRoot;
    } else {
      projectRoot = path3.resolve(vaultPath, projectDetection.projectRoot);
    }
    const expectedContentPath = path3.join(projectRoot, "src", "content");
    if (!fs3.existsSync(expectedContentPath) || !fs3.statSync(expectedContentPath).isDirectory()) {
      return null;
    }
    const vaultRoot = vault.getRoot();
    if (!(vaultRoot instanceof import_obsidian5.TFolder)) {
      return null;
    }
    const vaultNormalized = path3.resolve(vaultPath).toLowerCase();
    const contentNormalized = path3.resolve(expectedContentPath).toLowerCase();
    if (contentNormalized.startsWith(vaultNormalized)) {
      const relativePath = path3.relative(path3.resolve(vaultPath), path3.resolve(expectedContentPath));
      const normalizedRelativePath = relativePath.split(path3.sep).join("/");
      const pathParts = normalizedRelativePath.split("/").filter((part) => part.length > 0);
      if (pathParts.length === 0) {
        return vaultRoot;
      }
      let currentFolder = vaultRoot;
      for (const part of pathParts) {
        if (!currentFolder.children) {
          return null;
        }
        const child = currentFolder.children.find((c) => c instanceof import_obsidian5.TFolder && c.name === part);
        if (!(child instanceof import_obsidian5.TFolder)) {
          return null;
        }
        currentFolder = child;
      }
      return currentFolder;
    }
    return null;
  }
  getTopLevelFolders(folder) {
    const folders = [];
    if (!folder.children) {
      return folders;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFolder) {
        const configDir = this.app.vault.configDir;
        if (!child.name.startsWith(".") && child.name !== "bases" && child.name !== "_bases" && child.name !== "home" && child.name !== "_home" && child.name !== "base" && child.name !== "_base" && child.name !== "node_modules" && child.name !== configDir) {
          folders.push(child);
        }
      }
    }
    return folders;
  }
  detectContentType(folder) {
    const name = this.capitalizeFirst(folder.name);
    return {
      id: `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
      name,
      folder: folder.path,
      // Use vault-relative path instead of just the folder name
      fileOrganization: "file",
      enabled: true,
      // Enable all discovered content types by default
      indexFileName: "index"
    };
  }
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
};

// src/ui/wizard/ProjectDetectionStep.ts
function setCssProps2(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var ProjectDetectionStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.detected = false;
    this.projectRootDisplay = null;
    this.configFileDisplay = null;
    this.projectDetector = new ProjectDetector(app);
    this.mdxDetector = new MdxDetector(app);
    this.contentTypeDetector = new ContentTypeDetector(app);
  }
  async display() {
    var _a, _b;
    console.debug("ProjectDetectionStep.display: called");
    const { containerEl } = this;
    containerEl.empty();
    const hasSavedValues = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath);
    console.debug("ProjectDetectionStep.display: hasSavedValues =", hasSavedValues);
    console.debug("ProjectDetectionStep.display: current enableMdxSupport =", this.state.enableMdxSupport);
    if (!hasSavedValues) {
      containerEl.createEl("h2", { text: "Project detection" });
      containerEl.createEl("p", {
        text: "Detecting your Astro project structure..."
      });
      const result = this.projectDetector.detectProject();
      console.debug("ProjectDetectionStep.display: detection result =", result);
      if (result) {
        this.state.projectDetection = {
          projectRoot: result.projectRoot,
          configFilePath: result.configFilePath,
          vaultLocation: result.vaultLocation
        };
        console.debug("ProjectDetectionStep.display: set projectDetection =", this.state.projectDetection);
        this.detected = true;
      } else {
        this.detected = false;
      }
    } else {
      console.debug("ProjectDetectionStep.display: using saved projectDetection =", this.state.projectDetection);
      this.detected = true;
    }
    if (this.state.projectDetection && (this.detected || hasSavedValues)) {
      await new Promise((resolve9) => setTimeout(resolve9, 500));
      containerEl.empty();
      containerEl.createEl("h2", { text: "Project detected" });
      containerEl.createEl("p", {
        text: 'Project structure detected successfully. You can modify the paths below if needed, then click "Next" to continue.'
      });
      const projectRootSetting = new import_obsidian6.Setting(containerEl).setName("Project root").setDesc("Select the folder containing your Astro project root");
      this.projectRootDisplay = projectRootSetting.descEl.createDiv({
        text: this.state.projectDetection.projectRoot ? this.toRelativePath(this.state.projectDetection.projectRoot) : "No folder selected",
        cls: "vault-cms-path-display"
      });
      setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
      projectRootSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          const selectedPath = this.selectFolder();
          if (selectedPath) {
            this.state.projectDetection.projectRoot = selectedPath;
            if (this.projectRootDisplay) {
              this.projectRootDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
            }
            this.detected = false;
          }
        })();
      }));
      const configFileSetting = new import_obsidian6.Setting(containerEl).setName("Config file").setDesc("Select your Astro config file (astro.config.mjs, astro.config.js, src/config.ts, etc.)");
      this.configFileDisplay = configFileSetting.descEl.createDiv({
        text: this.state.projectDetection.configFilePath ? this.toRelativePath(this.state.projectDetection.configFilePath) : "No file selected",
        cls: "vault-cms-path-display"
      });
      setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
      configFileSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          var _a2;
          const defaultPath = ((_a2 = this.state.projectDetection) == null ? void 0 : _a2.projectRoot) || this.getVaultPath();
          const selectedPath = this.selectConfigFile(defaultPath);
          if (selectedPath) {
            this.state.projectDetection.configFilePath = selectedPath;
            if (this.configFileDisplay) {
              this.configFileDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
            }
            this.detected = false;
          }
        })();
      }));
      let autoDetectedMdx = false;
      if (this.state.projectDetection) {
        try {
          console.debug("ProjectDetectionStep: Starting MDX detection");
          console.debug("ProjectDetectionStep: projectDetection =", this.state.projectDetection);
          console.debug("ProjectDetectionStep: existing contentTypes =", this.state.contentTypes.length);
          let contentTypesToUse = this.state.contentTypes;
          if (contentTypesToUse.length === 0) {
            console.debug("ProjectDetectionStep: No content types in state, detecting now...");
            contentTypesToUse = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
            console.debug("ProjectDetectionStep: Detected content types =", contentTypesToUse.length, contentTypesToUse.map((ct) => `${ct.name} (${ct.folder}, enabled: ${ct.enabled})`));
          } else {
            console.debug("ProjectDetectionStep: Using existing content types =", contentTypesToUse.map((ct) => `${ct.name} (${ct.folder}, enabled: ${ct.enabled})`));
          }
          if (contentTypesToUse.length > 0) {
            console.debug("ProjectDetectionStep: Calling mdxDetector.detectMdxUsage...");
            autoDetectedMdx = this.mdxDetector.detectMdxUsage(
              this.state.projectDetection,
              contentTypesToUse
            );
            console.debug("ProjectDetectionStep: MDX detection result =", autoDetectedMdx);
          } else {
            console.debug("ProjectDetectionStep: No content types to scan");
          }
        } catch (error) {
          console.error("ProjectDetectionStep: MDX detection failed:", error);
          autoDetectedMdx = false;
        }
      } else {
        console.debug("ProjectDetectionStep: No projectDetection, skipping MDX detection");
      }
      if (this.state.enableMdxSupport === void 0) {
        this.state.enableMdxSupport = autoDetectedMdx;
        console.debug("ProjectDetectionStep: Set enableMdxSupport to", autoDetectedMdx, "based on auto-detection");
      } else {
        console.debug("ProjectDetectionStep: enableMdxSupport already set to", this.state.enableMdxSupport, ", skipping auto-detection overwrite");
      }
      const mdxSetting = new import_obsidian6.Setting(containerEl).setName("MDX file support").setDesc("Enable MDX file support for Astro Composer, Property Over File Name, SEO, and UI Tweaker plugins.");
      mdxSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableMdxSupport) != null ? _a2 : false).onChange((value) => {
          this.state.enableMdxSupport = value;
        });
        if (autoDetectedMdx && this.state.enableMdxSupport) {
          const autoDetectMsg = mdxSetting.descEl.createDiv({
            text: "MDX files detected in content folders",
            cls: "vault-cms-auto-detect-msg"
          });
          setCssProps2(autoDetectMsg, {
            color: "var(--text-muted)",
            fontSize: "0.9em",
            marginTop: "4px"
          });
        }
      });
      const extendedFileTypesSetting = new import_obsidian6.Setting(containerEl).setName("Extended file types").setDesc("Enable support to view, edit, and create .json and .astro files via the Data Files Editor plugin.");
      extendedFileTypesSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableExtendedFileTypes) != null ? _a2 : false).onChange((value) => {
          this.state.enableExtendedFileTypes = value;
        });
      });
    } else {
      containerEl.empty();
      containerEl.createEl("h2", { text: "Project detection failed" });
      containerEl.createEl("p", {
        text: "Could not detect Astro project structure. Please select your Astro project root and config file manually."
      });
      if (!this.state.projectDetection) {
        this.state.projectDetection = {
          projectRoot: "",
          configFilePath: "",
          vaultLocation: "root"
        };
      }
      const projectRootSetting = new import_obsidian6.Setting(containerEl).setName("Project root").setDesc("Select the folder containing your Astro project root");
      this.projectRootDisplay = projectRootSetting.descEl.createDiv({
        text: this.state.projectDetection.projectRoot ? this.toRelativePath(this.state.projectDetection.projectRoot) : "No folder selected",
        cls: "vault-cms-path-display"
      });
      if (this.state.projectDetection.projectRoot) {
        setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
      } else {
        setCssProps2(this.projectRootDisplay, { color: "var(--text-muted)" });
      }
      projectRootSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          const selectedPath = this.selectFolder();
          if (selectedPath) {
            this.state.projectDetection.projectRoot = selectedPath;
            if (this.projectRootDisplay) {
              this.projectRootDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
            }
          }
        })();
      }));
      const configFileSetting = new import_obsidian6.Setting(containerEl).setName("Config file").setDesc("Select your Astro config file (astro.config.mjs, astro.config.js, src/config.ts, etc.)");
      this.configFileDisplay = configFileSetting.descEl.createDiv({
        text: this.state.projectDetection.configFilePath ? this.toRelativePath(this.state.projectDetection.configFilePath) : "No file selected",
        cls: "vault-cms-path-display"
      });
      if (this.state.projectDetection.configFilePath) {
        setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
      } else {
        setCssProps2(this.configFileDisplay, { color: "var(--text-muted)" });
      }
      configFileSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          var _a2;
          const defaultPath = ((_a2 = this.state.projectDetection) == null ? void 0 : _a2.projectRoot) || this.getVaultPath();
          const selectedPath = this.selectConfigFile(defaultPath);
          if (selectedPath) {
            this.state.projectDetection.configFilePath = selectedPath;
            if (this.configFileDisplay) {
              this.configFileDisplay.textContent = this.toRelativePath(selectedPath);
              setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
            }
          }
        })();
      }));
      let autoDetectedMdx = false;
      if (this.state.projectDetection && this.state.projectDetection.projectRoot && this.state.projectDetection.configFilePath) {
        try {
          const detectedContentTypes = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
          if (detectedContentTypes.length > 0) {
            autoDetectedMdx = this.mdxDetector.detectMdxUsage(
              this.state.projectDetection,
              detectedContentTypes
            );
          }
        } catch (e) {
          autoDetectedMdx = false;
        }
      }
      if (this.state.enableMdxSupport === void 0) {
        this.state.enableMdxSupport = autoDetectedMdx;
        console.debug("ProjectDetectionStep (manual): Set enableMdxSupport to", autoDetectedMdx, "based on auto-detection");
      } else {
        console.debug("ProjectDetectionStep (manual): enableMdxSupport already set to", this.state.enableMdxSupport, ", skipping auto-detection overwrite");
      }
      const mdxSetting = new import_obsidian6.Setting(containerEl).setName("MDX file support").setDesc("Enable MDX file support for Astro Composer, Property Over File Name, SEO, and UI Tweaker plugins.");
      mdxSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableMdxSupport) != null ? _a2 : false).onChange((value) => {
          this.state.enableMdxSupport = value;
        });
        if (autoDetectedMdx && this.state.enableMdxSupport) {
          const autoDetectMsg = mdxSetting.descEl.createDiv({
            text: "MDX files detected in content folders",
            cls: "vault-cms-auto-detect-msg"
          });
          setCssProps2(autoDetectMsg, {
            color: "var(--text-muted)",
            fontSize: "0.9em",
            marginTop: "4px"
          });
        }
      });
      const extendedFileTypesSetting = new import_obsidian6.Setting(containerEl).setName("Extended file types").setDesc("Enable support to view, edit, and create .json and .astro files via the Data Files Editor plugin.");
      extendedFileTypesSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableExtendedFileTypes) != null ? _a2 : false).onChange((value) => {
          this.state.enableExtendedFileTypes = value;
        });
      });
    }
  }
  /**
   * Open native folder picker dialog
   */
  selectFolder() {
    var _a, _b, _c;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      let defaultPath = ((_c = this.state.projectDetection) == null ? void 0 : _c.projectRoot) || vaultPath;
      if (defaultPath && !path4.isAbsolute(defaultPath)) {
        defaultPath = path4.resolve(vaultPath, defaultPath);
      }
      const result = dialog.showOpenDialogSync({
        title: "Select Astro Project Root Folder",
        defaultPath,
        properties: ["openDirectory"]
      });
      if (result && result.length > 0) {
        return path4.normalize(result[0]);
      }
    } catch (error) {
      console.error("Error opening folder picker:", error);
      new import_obsidian6.Notice("Unable to open folder picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Open native file picker dialog for config file
   */
  selectConfigFile(defaultPath) {
    var _a, _b, _c;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      let startPath = defaultPath || vaultPath;
      if (!defaultPath && ((_c = this.state.projectDetection) == null ? void 0 : _c.configFilePath)) {
        const configPath = this.state.projectDetection.configFilePath;
        if (path4.isAbsolute(configPath)) {
          startPath = path4.dirname(configPath);
        } else {
          startPath = path4.dirname(path4.resolve(vaultPath, configPath));
        }
      } else if (defaultPath && !path4.isAbsolute(defaultPath)) {
        startPath = path4.resolve(vaultPath, defaultPath);
        if (path4.extname(startPath)) {
          startPath = path4.dirname(startPath);
        }
      } else if (defaultPath && path4.isAbsolute(defaultPath)) {
        if (path4.extname(defaultPath)) {
          startPath = path4.dirname(defaultPath);
        } else {
          startPath = defaultPath;
        }
      }
      const result = dialog.showOpenDialogSync({
        title: "Select Astro Config File",
        defaultPath: startPath,
        filters: [
          { name: "Astro Config Files", extensions: ["ts", "mjs", "js", "mts", "cjs", "yml", "yaml"] },
          { name: "All Files", extensions: ["*"] }
        ],
        properties: ["openFile"]
      });
      if (result && result.length > 0) {
        return path4.normalize(result[0]);
      }
    } catch (error) {
      console.error("Error opening file picker:", error);
      new import_obsidian6.Notice("Unable to open file picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (vaultPath) {
      if (vaultPath.startsWith("/") || /^[A-Z]:/.test(vaultPath)) {
        return vaultPath.replace(/\\/g, "/");
      }
      return vaultPath.replace(/\\/g, "/");
    }
    return "/";
  }
  validate() {
    var _a, _b;
    if (this.detected) {
      return true;
    }
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    const configFilePath = (_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath;
    if (!projectRoot || !configFilePath) {
      return false;
    }
    try {
      const vaultPath = this.getVaultPath();
      const resolvedProjectRoot = path4.isAbsolute(projectRoot) ? projectRoot : path4.join(vaultPath, projectRoot);
      const resolvedConfigFilePath = path4.isAbsolute(configFilePath) ? configFilePath : path4.join(vaultPath, configFilePath);
      if (!fs4.existsSync(resolvedProjectRoot) || !fs4.statSync(resolvedProjectRoot).isDirectory()) {
        return false;
      }
      if (!fs4.existsSync(resolvedConfigFilePath) || !fs4.statSync(resolvedConfigFilePath).isFile()) {
        return false;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  getTitle() {
    return "Project detection";
  }
  getDescription() {
    return "Detect Astro project structure";
  }
};

// src/ui/wizard/ContentTypeStep.ts
var import_obsidian8 = require("obsidian");

// src/utils/PathResolver.ts
var path5 = __toESM(require("path"), 1);
var PathResolver = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Get the folder path from vault root to the content type folder.
   * This is used by Bases CMS filters and Astro Composer folder settings.
   * 
   * Examples:
   * - Vault at src level, content type "docs": returns "content/docs"
   * - Vault at src/content level, content type "docs": returns "docs"
   * - Vault at src/content/post level, content type "docs": returns "../docs" (if accessible) or "docs" (if vault is the content type folder)
   * 
   * @param folderName The content type folder name (e.g., "docs", "posts")
   * @param projectDetection Project detection result with project root and vault location
   * @returns Path from vault root to content type folder, or null if cannot be determined
   */
  getFolderPathFromVaultRoot(folderName, projectDetection) {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    const file = this.app.vault.getAbstractFileByPath(folderName);
    if (file) {
      return folderName;
    }
    if (projectDetection && projectDetection.projectRoot && vaultPath) {
      const projectRoot = path5.isAbsolute(projectDetection.projectRoot) ? projectDetection.projectRoot : path5.resolve(vaultPath, projectDetection.projectRoot);
      let contentTypeAbsolutePath;
      if (folderName.startsWith("src/content/") || folderName.includes("/src/content/")) {
        contentTypeAbsolutePath = path5.resolve(projectRoot, folderName);
      } else {
        contentTypeAbsolutePath = path5.resolve(projectRoot, "src", "content", folderName);
      }
      const vaultAbsolutePath = path5.resolve(vaultPath);
      const relativePath = path5.relative(vaultAbsolutePath, contentTypeAbsolutePath);
      if (!relativePath.startsWith("..") && !path5.isAbsolute(relativePath)) {
        return relativePath.split(path5.sep).join("/") || ".";
      }
    }
    return folderName;
  }
  /**
   * Get the folder path from project root to the content type folder.
   * This is always "src/content/{folderName}" relative to project root.
   * 
   * @param folderName The content type folder name (e.g., "docs", "posts")
   * @returns Path from project root (e.g., "src/content/docs")
   */
  getFolderPathFromProjectRoot(folderName) {
    return `src/content/${folderName}`;
  }
  /**
   * Get the folder path for Astro Composer, which needs the path relative to vault root
   * but should work correctly regardless of vault location.
   * 
   * @param folderName The content type folder name
   * @param projectDetection Project detection result
   * @returns Path from vault root to content type folder
   */
  getAstroComposerFolderPath(folderName, projectDetection) {
    return this.getFolderPathFromVaultRoot(folderName, projectDetection);
  }
  /**
   * Get the folder path for Bases CMS filter, which needs to match files
   * in the content type folder regardless of vault location.
   * 
   * @param folderName The content type folder name
   * @param projectDetection Project detection result
   * @returns Path from vault root to content type folder (for use in file.folder.startsWith filter)
   */
  getBasesCMSFolderPath(folderName, projectDetection) {
    return this.getFolderPathFromVaultRoot(folderName, projectDetection);
  }
};

// src/utils/SafeConfigWriter.ts
var import_obsidian7 = require("obsidian");
var SafeConfigWriter = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Validates that a value is a valid JSON object
   */
  validateJSON(data) {
    if (!data || typeof data !== "object" || Array.isArray(data)) {
      return false;
    }
    try {
      JSON.parse(JSON.stringify(data));
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Creates a backup of a plugin's data.json file
   */
  async createBackup(pluginId, originalFile) {
    try {
      const content = await this.app.vault.read(originalFile);
      const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const backupPath = `${this.app.vault.configDir}/plugins/${pluginId}/data.json.backup-${timestamp2}`;
      await this.app.vault.create(backupPath, content);
      console.debug(`SafeConfigWriter: Created backup at ${backupPath}`);
    } catch (error) {
      console.warn(`SafeConfigWriter: Failed to create backup for ${pluginId}:`, error);
    }
  }
  /**
   * Safely reads a plugin's data.json file
   */
  async readConfig(pluginId) {
    const configPath = `${this.app.vault.configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(configPath);
    if (!dataFile || !(dataFile instanceof import_obsidian7.TFile)) {
      console.debug(`SafeConfigWriter: Config file not found for ${pluginId}`);
      return null;
    }
    try {
      const content = await this.app.vault.read(dataFile);
      const parsed = JSON.parse(content);
      if (!this.validateJSON(parsed)) {
        console.error(`SafeConfigWriter: Invalid JSON structure in ${pluginId} config`);
        return null;
      }
      return parsed;
    } catch (error) {
      console.error(`SafeConfigWriter: Failed to read/parse config for ${pluginId}:`, error);
      return null;
    }
  }
  /**
   * Safely writes to a plugin's data.json file with backup and validation
   */
  async writeConfig(pluginId, data, options = {}) {
    const { showNotice = true, createBackup = true } = options;
    if (!this.validateJSON(data)) {
      const message = `Invalid configuration data for ${pluginId}`;
      console.error(`SafeConfigWriter: ${message}`);
      if (showNotice) {
        new import_obsidian7.Notice(`Failed to save ${pluginId} settings: Invalid data`);
      }
      return false;
    }
    const configPath = `${this.app.vault.configDir}/plugins/${pluginId}/data.json`;
    try {
      const dataFile = this.app.vault.getAbstractFileByPath(configPath);
      if (dataFile && dataFile instanceof import_obsidian7.TFile) {
        if (createBackup) {
          await this.createBackup(pluginId, dataFile);
        }
        const content = JSON.stringify(data, null, 2);
        await this.app.vault.modify(dataFile, content);
        console.debug(`SafeConfigWriter: Successfully updated ${pluginId} config`);
      } else {
        const pluginDir = `${this.app.vault.configDir}/plugins/${pluginId}`;
        const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
        if (!pluginDirFile) {
          await this.app.vault.createFolder(pluginDir);
        }
        const content = JSON.stringify(data, null, 2);
        await this.app.vault.create(configPath, content);
        console.debug(`SafeConfigWriter: Successfully created ${pluginId} config`);
      }
      return true;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      console.error(`SafeConfigWriter: Failed to write config for ${pluginId}:`, error);
      if (showNotice) {
        new import_obsidian7.Notice(`Failed to save ${pluginId} settings: ${message}`);
      }
      return false;
    }
  }
  /**
   * Safely merges new settings into existing plugin config
   */
  async mergeConfig(pluginId, updates, options = {}) {
    const existingConfig = await this.readConfig(pluginId) || {};
    const mergedConfig = { ...existingConfig, ...updates };
    return this.writeConfig(pluginId, mergedConfig, options);
  }
};

// src/utils/AstroComposerConfig.ts
var AstroComposerConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
    this.safeWriter = new SafeConfigWriter(app);
  }
  configureAstroComposer(contentTypes, frontmatterProperties, projectRoot, configFilePath, defaultContentTypeId, projectDetection, enableMdxSupport) {
    this.frontmatterProperties = frontmatterProperties;
    this.contentTypes = contentTypes;
    const config = {
      customContentTypes: [],
      defaultTemplate: "",
      configFilePath: this.relativePath(configFilePath),
      terminalProjectRootPath: this.relativePath(projectRoot),
      showMdxFilesInExplorer: enableMdxSupport != null ? enableMdxSupport : false
    };
    const defaultContentType = defaultContentTypeId ? contentTypes.find((ct) => ct.id === defaultContentTypeId && ct.enabled) : null;
    const otherContentTypes = contentTypes.filter((ct) => ct.enabled && (!defaultContentTypeId || ct.id !== defaultContentTypeId));
    if (defaultContentType) {
      const props = frontmatterProperties[defaultContentType.id];
      let linkBasePath = defaultContentType.linkBasePath;
      if (linkBasePath === void 0 || linkBasePath === "") {
        const pathParts = defaultContentType.folder.split("/").filter((p) => p.length > 0);
        const folderName = pathParts[pathParts.length - 1] || defaultContentType.folder;
        linkBasePath = `/${folderName}/`;
      }
      const folderPath = this.pathResolver.getAstroComposerFolderPath(defaultContentType.folder, projectDetection);
      config.customContentTypes.push({
        id: defaultContentType.id,
        name: defaultContentType.name,
        folder: folderPath,
        template: (props == null ? void 0 : props.template) || this.generateTemplate(props),
        enabled: true,
        linkBasePath,
        creationMode: defaultContentType.fileOrganization,
        indexFileName: defaultContentType.indexFileName || "index"
      });
      config.postsFolder = folderPath;
      config.postsCreationMode = defaultContentType.fileOrganization;
      config.postsIndexFileName = defaultContentType.indexFileName || "index";
      config.defaultTemplate = (props == null ? void 0 : props.template) || this.generateTemplate(props);
    }
    for (const contentType of otherContentTypes) {
      const props = frontmatterProperties[contentType.id];
      let linkBasePath = contentType.linkBasePath;
      if (linkBasePath === void 0 || linkBasePath === "") {
        const pathParts = contentType.folder.split("/").filter((p) => p.length > 0);
        const folderName = pathParts[pathParts.length - 1] || contentType.folder;
        linkBasePath = `/${folderName}/`;
      }
      const folderPath = this.pathResolver.getAstroComposerFolderPath(contentType.folder, projectDetection);
      config.customContentTypes.push({
        id: contentType.id,
        name: contentType.name,
        folder: folderPath,
        // Use template from props if available, otherwise generate
        template: (props == null ? void 0 : props.template) || this.generateTemplate(props),
        enabled: true,
        linkBasePath,
        creationMode: contentType.fileOrganization,
        indexFileName: contentType.indexFileName || "index"
      });
    }
    return Promise.resolve(config);
  }
  generateTemplate(props) {
    if (props == null ? void 0 : props.template) {
      return props.template;
    }
    if (!props) {
      return '---\ntitle: "{{title}}"\n---\n';
    }
    let template = "---\n";
    template += `${props.titleProperty || "title"}: "{{title}}"
`;
    if (props.dateProperty) {
      template += `${props.dateProperty}: {{date}}
`;
    }
    if (props.descriptionProperty) {
      template += `${props.descriptionProperty}: ""
`;
    }
    if (props.tagsProperty) {
      template += `${props.tagsProperty}: []
`;
    }
    if (props.draftProperty) {
      const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
      template += `${props.draftProperty}: ${draftValue}
`;
    }
    template += "---\n";
    return template;
  }
  getCreationModeFromAttachmentHandling(mode) {
    return mode === "same-folder" ? "folder" : "file";
  }
  relativePath(inputPath) {
    if (!inputPath.startsWith("/") && !/^[A-Z]:/.test(inputPath)) {
      return inputPath;
    }
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return inputPath;
    }
    const vaultNormalized = vaultPath.replace(/\\/g, "/").replace(/\/$/, "");
    const absoluteNormalized = inputPath.replace(/\\/g, "/").replace(/\/$/, "");
    if (absoluteNormalized.startsWith(vaultNormalized)) {
      const relative5 = absoluteNormalized.slice(vaultNormalized.length);
      return relative5.startsWith("/") ? relative5.slice(1) : relative5;
    }
    return inputPath;
  }
  async saveConfig(config) {
    var _a, _b;
    try {
      const plugins = this.app.plugins;
      const astroComposerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["astro-composer"];
      if (!astroComposerPlugin) {
        console.warn("AstroComposerConfig: Astro Composer plugin not found, using fallback file method");
        await this.saveConfigFallback(config);
        return;
      }
      if (!astroComposerPlugin.settings) {
        console.warn("AstroComposerConfig: Astro Composer plugin settings not available, using fallback file method");
        await this.saveConfigFallback(config);
        return;
      }
      const pluginSettings = astroComposerPlugin.settings;
      if (config.defaultTemplate) {
        pluginSettings.defaultTemplate = config.defaultTemplate;
      }
      if (config.pageTemplate) {
        pluginSettings.pageTemplate = config.pageTemplate;
      }
      if (config.postsFolder) {
        pluginSettings.postsFolder = config.postsFolder;
      }
      if (config.postsCreationMode) {
        pluginSettings.creationMode = config.postsCreationMode;
      }
      if (config.postsIndexFileName) {
        pluginSettings.indexFileName = config.postsIndexFileName;
      }
      if (config.enablePages !== void 0) {
        pluginSettings.enablePages = config.enablePages;
      }
      if (config.pagesFolder) {
        pluginSettings.pagesFolder = config.pagesFolder;
      }
      if (config.pagesCreationMode) {
        pluginSettings.pagesCreationMode = config.pagesCreationMode;
      }
      if (config.pagesIndexFileName) {
        pluginSettings.pagesIndexFileName = config.pagesIndexFileName;
      }
      if (config.configFilePath) {
        pluginSettings.configFilePath = config.configFilePath;
      }
      if (config.terminalProjectRootPath) {
        pluginSettings.terminalProjectRootPath = config.terminalProjectRootPath;
      }
      if (config.configFilePath && config.terminalProjectRootPath) {
        pluginSettings.enableOpenTerminalCommand = true;
        pluginSettings.enableOpenConfigFileCommand = true;
        pluginSettings.enableTerminalRibbonIcon = true;
        pluginSettings.enableConfigRibbonIcon = true;
      }
      if (config.showMdxFilesInExplorer !== void 0) {
        pluginSettings.showMdxFilesInExplorer = config.showMdxFilesInExplorer;
        console.debug("AstroComposerConfig: Set showMdxFilesInExplorer to", config.showMdxFilesInExplorer);
      } else {
        console.debug("AstroComposerConfig: showMdxFilesInExplorer is undefined, not updating");
      }
      if (!Array.isArray(pluginSettings.contentTypes)) {
        pluginSettings.contentTypes = [];
      }
      for (const newType of config.customContentTypes) {
        const contentType = (_b = this.contentTypes) == null ? void 0 : _b.find((ct) => ct.id === newType.id);
        const props = contentType && this.frontmatterProperties ? this.frontmatterProperties[contentType.id] : void 0;
        const shouldEnableUnderscorePrefix = (props == null ? void 0 : props.hasDraftStatus) === true && !(props == null ? void 0 : props.draftProperty);
        const contentTypes = pluginSettings.contentTypes || [];
        let existingIndex = -1;
        let matchedById = false;
        if (newType.id) {
          existingIndex = contentTypes.findIndex((ct) => ct.id === newType.id);
          if (existingIndex >= 0) {
            matchedById = true;
          }
        }
        if (existingIndex < 0) {
          existingIndex = contentTypes.findIndex(
            (ct) => ct.name === newType.name && ct.folder === newType.folder
          );
        }
        if (existingIndex >= 0) {
          const existingEntry = contentTypes[existingIndex];
          contentTypes[existingIndex] = {
            ...existingEntry,
            // Only update ID if we matched by ID, otherwise keep existing ID for consistency
            id: matchedById ? newType.id : existingEntry.id || newType.id,
            name: newType.name,
            folder: newType.folder,
            linkBasePath: newType.linkBasePath,
            template: newType.template,
            enabled: newType.enabled,
            creationMode: newType.creationMode,
            indexFileName: newType.indexFileName,
            enableUnderscorePrefix: shouldEnableUnderscorePrefix
          };
        } else {
          contentTypes.push({
            id: newType.id,
            name: newType.name,
            folder: newType.folder,
            linkBasePath: newType.linkBasePath,
            template: newType.template,
            enabled: newType.enabled,
            creationMode: newType.creationMode,
            indexFileName: newType.indexFileName,
            ignoreSubfolders: false,
            enableUnderscorePrefix: shouldEnableUnderscorePrefix
          });
        }
      }
      pluginSettings.customContentTypes = this.mergeCustomContentTypes(
        pluginSettings.customContentTypes || [],
        config.customContentTypes || []
      );
      if (typeof astroComposerPlugin.saveSettings === "function") {
        await astroComposerPlugin.saveSettings();
        console.debug("AstroComposerConfig: Successfully saved via plugin.saveSettings()");
      } else {
        console.warn("AstroComposerConfig: Plugin saveSettings not available, using fallback");
        await this.saveConfigFallback(config);
      }
    } catch (error) {
      console.error("Failed to save Astro Composer config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    var _a;
    const pluginId = "astro-composer";
    let existingData = await this.safeWriter.readConfig(pluginId);
    if (!existingData) {
      existingData = {};
    }
    if (config.defaultTemplate) existingData.defaultTemplate = config.defaultTemplate;
    if (config.pageTemplate) existingData.pageTemplate = config.pageTemplate;
    if (config.postsFolder) existingData.postsFolder = config.postsFolder;
    if (config.postsCreationMode) existingData.creationMode = config.postsCreationMode;
    if (config.postsIndexFileName) existingData.indexFileName = config.postsIndexFileName;
    if (config.enablePages !== void 0) existingData.enablePages = config.enablePages;
    if (config.pagesFolder) existingData.pagesFolder = config.pagesFolder;
    if (config.pagesCreationMode) existingData.pagesCreationMode = config.pagesCreationMode;
    if (config.pagesIndexFileName) existingData.pagesIndexFileName = config.pagesIndexFileName;
    if (config.configFilePath) existingData.configFilePath = config.configFilePath;
    if (config.terminalProjectRootPath) existingData.terminalProjectRootPath = config.terminalProjectRootPath;
    if (config.showMdxFilesInExplorer !== void 0) existingData.showMdxFilesInExplorer = config.showMdxFilesInExplorer;
    if (config.configFilePath && config.terminalProjectRootPath) {
      existingData.enableOpenTerminalCommand = true;
      existingData.enableOpenConfigFileCommand = true;
      existingData.enableTerminalRibbonIcon = true;
      existingData.enableConfigRibbonIcon = true;
    }
    if (!Array.isArray(existingData.contentTypes)) {
      existingData.contentTypes = [];
    }
    for (const newType of config.customContentTypes) {
      const contentType = (_a = this.contentTypes) == null ? void 0 : _a.find((ct) => ct.id === newType.id);
      const props = contentType && this.frontmatterProperties ? this.frontmatterProperties[contentType.id] : void 0;
      const shouldEnableUnderscorePrefix = (props == null ? void 0 : props.hasDraftStatus) === true && !(props == null ? void 0 : props.draftProperty);
      const contentTypes = existingData.contentTypes || [];
      let existingIndex = -1;
      let matchedById = false;
      if (newType.id) {
        existingIndex = contentTypes.findIndex((ct) => ct.id === newType.id);
        if (existingIndex >= 0) {
          matchedById = true;
        }
      }
      if (existingIndex < 0) {
        existingIndex = contentTypes.findIndex(
          (ct) => ct.name === newType.name && ct.folder === newType.folder
        );
      }
      if (existingIndex >= 0) {
        const existingEntry = contentTypes[existingIndex];
        contentTypes[existingIndex] = {
          ...existingEntry,
          // Only update ID if we matched by ID, otherwise keep existing ID for consistency
          id: matchedById ? newType.id : existingEntry.id || newType.id,
          name: newType.name,
          folder: newType.folder,
          linkBasePath: newType.linkBasePath,
          template: newType.template,
          enabled: newType.enabled,
          creationMode: newType.creationMode,
          indexFileName: newType.indexFileName,
          enableUnderscorePrefix: shouldEnableUnderscorePrefix
        };
      } else {
        contentTypes.push({
          id: newType.id,
          name: newType.name,
          folder: newType.folder,
          linkBasePath: newType.linkBasePath,
          template: newType.template,
          enabled: newType.enabled,
          creationMode: newType.creationMode,
          indexFileName: newType.indexFileName,
          ignoreSubfolders: false,
          enableUnderscorePrefix: shouldEnableUnderscorePrefix
        });
      }
    }
    existingData.customContentTypes = this.mergeCustomContentTypes(
      existingData.customContentTypes || [],
      config.customContentTypes || []
    );
    const success = await this.safeWriter.writeConfig(pluginId, existingData, {
      showNotice: true,
      createBackup: true
    });
    if (!success) {
      throw new Error("Failed to save Astro Composer configuration");
    }
  }
  mergeCustomContentTypes(existing, newTypes) {
    const merged = [...existing];
    for (const newType of newTypes) {
      const existingIndex = merged.findIndex((ct) => ct.id === newType.id);
      if (existingIndex >= 0) {
        merged[existingIndex] = { ...merged[existingIndex], ...newType };
      } else {
        merged.push(newType);
      }
    }
    return merged;
  }
};

// src/ui/wizard/ContentTypeStep.ts
function setCssProps3(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var FolderNameSuggest = class extends import_obsidian8.AbstractInputSuggest {
  constructor(app, inputEl, mode) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.mode = mode;
  }
  getSuggestions(inputStr) {
    const suggestions = [];
    const lowerInput = inputStr.toLowerCase();
    if (this.mode === "subfolder") {
      if ("attachments".toLowerCase().includes(lowerInput)) {
        suggestions.push("attachments");
      }
      const allFiles = this.app.vault.getAllLoadedFiles();
      const folderNames = /* @__PURE__ */ new Set();
      for (const file of allFiles) {
        if (file instanceof import_obsidian8.TFolder) {
          const folderName = file.name;
          if (folderName.toLowerCase().includes(lowerInput) && folderName !== "attachments") {
            folderNames.add(folderName);
          }
        }
      }
      suggestions.push(...Array.from(folderNames).slice(0, 10));
    } else {
      const allFiles = this.app.vault.getAllLoadedFiles();
      const paths = /* @__PURE__ */ new Set();
      for (const file of allFiles) {
        if (file instanceof import_obsidian8.TFolder) {
          const path10 = file.path;
          if (path10.toLowerCase().includes(lowerInput)) {
            paths.add(path10);
          }
        }
      }
      suggestions.push(...Array.from(paths).slice(0, 10));
    }
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    el.setText(suggestion);
  }
  selectSuggestion(suggestion) {
    this.inputEl.value = suggestion;
    this.inputEl.trigger("input");
    this.close();
  }
};
var ContentTypeStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.detected = false;
    this.contentTypeDetector = new ContentTypeDetector(app);
    this.astroComposerConfigurator = new AstroComposerConfigurator(app);
  }
  /**
   * Import content types from Astro Composer data.json if it exists
   * First tries plugin API, then falls back to file reading
   */
  async importFromAstroComposer() {
    var _a;
    try {
      const plugins = this.app.plugins;
      console.debug("ContentTypeStep: Checking plugins API:", !!plugins);
      if (plugins) {
        const astroComposerPlugin = (_a = plugins.plugins) == null ? void 0 : _a["astro-composer"];
        console.debug("ContentTypeStep: Astro Composer plugin found:", !!astroComposerPlugin);
        if (astroComposerPlugin) {
          console.debug("ContentTypeStep: Plugin settings available:", !!astroComposerPlugin.settings);
          console.debug("ContentTypeStep: Plugin settings keys:", astroComposerPlugin.settings ? Object.keys(astroComposerPlugin.settings) : "none");
          if (astroComposerPlugin.settings) {
            const contentTypes = astroComposerPlugin.settings.contentTypes;
            console.debug("ContentTypeStep: contentTypes from plugin:", contentTypes ? `Array with ${contentTypes.length} items` : "not found");
            if (Array.isArray(contentTypes) && contentTypes.length > 0) {
              console.debug("ContentTypeStep: Importing", contentTypes.length, "content types from Astro Composer (via plugin API)");
              const importedTypes2 = contentTypes.map((ct) => ({
                id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
                name: ct.name || this.capitalizeFirst(ct.folder),
                folder: ct.folder,
                fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
                indexFileName: ct.indexFileName || "index",
                linkBasePath: ct.linkBasePath,
                enabled: ct.enabled !== false
                // Default to enabled if not specified
              }));
              return importedTypes2;
            }
          }
        }
      }
      const configDir = this.app.vault.configDir;
      const pluginDataPath = `${configDir}/plugins/astro-composer/data.json`;
      console.debug("ContentTypeStep: Trying to read file:", pluginDataPath);
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      console.debug("ContentTypeStep: File found:", !!dataFile, dataFile ? `Type: ${dataFile.constructor.name}` : "not found");
      if (!dataFile || !(dataFile instanceof import_obsidian8.TFile)) {
        const altPaths = [
          `${configDir}/plugins/astro-composer/data.json`,
          `obsidian/plugins/astro-composer/data.json`
        ];
        for (const altPath of altPaths) {
          const altFile = this.app.vault.getAbstractFileByPath(altPath);
          if (altFile && altFile instanceof import_obsidian8.TFile) {
            console.debug("ContentTypeStep: Found file at alternative path:", altPath);
            const content2 = await this.app.vault.read(altFile);
            const data2 = JSON.parse(content2);
            if (data2.contentTypes && Array.isArray(data2.contentTypes)) {
              console.debug("ContentTypeStep: Importing", data2.contentTypes.length, "content types from Astro Composer (via file at", altPath, ")");
              const importedTypes2 = data2.contentTypes.map((ct) => ({
                id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
                name: ct.name || this.capitalizeFirst(ct.folder),
                folder: ct.folder,
                fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
                indexFileName: ct.indexFileName || "index",
                linkBasePath: ct.linkBasePath,
                enabled: ct.enabled !== false
              }));
              return importedTypes2;
            }
          }
        }
        console.debug("ContentTypeStep: No Astro Composer data.json found, will scan folders");
        return [];
      }
      const content = await this.app.vault.read(dataFile);
      const data = JSON.parse(content);
      if (!data.contentTypes || !Array.isArray(data.contentTypes)) {
        console.debug("ContentTypeStep: Astro Composer data.json has no contentTypes array. Data keys:", Object.keys(data));
        return [];
      }
      console.debug("ContentTypeStep: Importing", data.contentTypes.length, "content types from Astro Composer (via file)");
      const importedTypes = data.contentTypes.map((ct) => ({
        id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        name: ct.name || this.capitalizeFirst(ct.folder),
        folder: ct.folder,
        fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
        indexFileName: ct.indexFileName || "index",
        linkBasePath: ct.linkBasePath,
        enabled: ct.enabled !== false
        // Default to enabled if not specified
      }));
      return importedTypes;
    } catch (error) {
      console.error("ContentTypeStep: Failed to import from Astro Composer:", error);
      return [];
    }
  }
  async display() {
    const { containerEl } = this;
    const scrollableParent = containerEl.closest(".modal-content") || containerEl.parentElement;
    const currentScrollTop = scrollableParent ? scrollableParent.scrollTop : 0;
    let stepContentWrapper = containerEl.querySelector(".content-type-step-content");
    if (!stepContentWrapper) {
      containerEl.empty();
      stepContentWrapper = containerEl.createDiv({ cls: "content-type-step-content" });
    } else {
      stepContentWrapper.empty();
    }
    const restoreScroll = () => {
      if (scrollableParent && currentScrollTop > 0) {
        requestAnimationFrame(() => {
          scrollableParent.scrollTop = currentScrollTop;
        });
      }
    };
    stepContentWrapper.createEl("h2", { text: "Content types" });
    stepContentWrapper.createEl("p", {
      text: "Detecting content types in your vault..."
    });
    if (!this.detected) {
      const savedContentTypes = this.state.contentTypes || [];
      const savedContentTypesMap = new Map(savedContentTypes.map((ct) => [ct.folder, ct]));
      const importedTypes = await this.importFromAstroComposer();
      const scannedTypes = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
      const allDetectedTypes = [];
      const imported = [...importedTypes];
      for (const scanned of scannedTypes) {
        const matchingImportedIndex = imported.findIndex(
          (it) => scanned.folder === it.folder || scanned.folder.endsWith(`/${it.folder}`) || it.folder.endsWith(`/${scanned.folder}`)
        );
        if (matchingImportedIndex >= 0) {
          const importedType = imported[matchingImportedIndex];
          if (scanned.folder.length > importedType.folder.length) {
            console.debug(`ContentTypeStep: Updating imported type "${importedType.name}" folder from "${importedType.folder}" to "${scanned.folder}"`);
            imported[matchingImportedIndex] = {
              ...importedType,
              folder: scanned.folder
            };
          }
        } else {
          allDetectedTypes.push(scanned);
        }
      }
      allDetectedTypes.push(...imported);
      const detectedTypesMap = new Map(allDetectedTypes.map((ct) => [ct.folder, ct]));
      const mergedTypes = [];
      const processedFolders = /* @__PURE__ */ new Set();
      const allFolders = /* @__PURE__ */ new Set([
        ...savedContentTypes.map((ct) => ct.folder),
        ...allDetectedTypes.map((ct) => ct.folder)
      ]);
      for (const folder of allFolders) {
        if (processedFolders.has(folder)) continue;
        let savedType = savedContentTypesMap.get(folder);
        const detectedType = detectedTypesMap.get(folder);
        if (savedType && !detectedType) {
          const matchingDetected = allDetectedTypes.find(
            (dt) => dt.folder.endsWith(`/${folder}`) || dt.folder === folder
          );
          if (matchingDetected && !processedFolders.has(matchingDetected.folder)) {
            console.debug(`ContentTypeStep: Reconciling saved folder "${folder}" with detected folder "${matchingDetected.folder}"`);
            mergedTypes.push({
              ...savedType,
              folder: matchingDetected.folder
            });
            processedFolders.add(folder);
            processedFolders.add(matchingDetected.folder);
            continue;
          }
        }
        if (savedType) {
          if (detectedType) {
            mergedTypes.push({
              ...savedType,
              // Preserve all saved settings (enabled, custom name, linkBasePath, etc.)
              // Always preserve saved folder and name (user may have customized the name)
              folder: savedType.folder,
              name: savedType.name
              // Always use saved name (may be customized)
            });
          } else {
            mergedTypes.push(savedType);
          }
        } else if (detectedType) {
          mergedTypes.push(detectedType);
        }
        processedFolders.add(folder);
      }
      mergedTypes.sort((a, b) => a.name.localeCompare(b.name));
      this.state.contentTypes = mergedTypes;
      this.detected = true;
    }
    stepContentWrapper.empty();
    stepContentWrapper.createEl("h2", { text: "Content types" });
    stepContentWrapper.createEl("p", {
      text: "Select and configure your content types:"
    });
    stepContentWrapper.createEl("h3", { text: "Attachment handling", cls: "vault-cms-section-header" });
    stepContentWrapper.createEl("p", {
      text: "How should attachments be stored globally?",
      cls: "vault-cms-section-desc"
    });
    new import_obsidian8.Setting(stepContentWrapper).setName("How are attachments handled?").setDesc("Choose how attachments are stored for all content types").addDropdown((dropdown) => dropdown.addOption("same-folder", "Same folder as current file").addOption("specified-folder", "In the specified folder").addOption("subfolder", "In subfolder under current folder").setValue(this.state.attachmentHandlingMode || "subfolder").onChange((value) => {
      this.state.attachmentHandlingMode = value;
      if (value === "same-folder") {
        this.state.attachmentFolderName = void 0;
      }
      void this.display();
    }));
    if (this.state.attachmentHandlingMode === "specified-folder" || this.state.attachmentHandlingMode === "subfolder") {
      const descText = this.state.attachmentHandlingMode === "specified-folder" ? 'Enter the exact path to the folder for attachments (e.g., "attachments" or "images/attachments"). Leave blank to use "attachments" as default.' : 'Enter the name of the subfolder for attachments (e.g., "attachments"). Leave blank to use "attachments" as default.';
      const folderNameSetting = new import_obsidian8.Setting(stepContentWrapper).setName("Attachment folder").setDesc(descText);
      folderNameSetting.addText((text) => {
        text.setPlaceholder("attachments").setValue(this.state.attachmentFolderName || "").onChange((value) => {
          this.state.attachmentFolderName = value || void 0;
        });
        if (this.state.attachmentHandlingMode !== "same-folder") {
          new FolderNameSuggest(this.app, text.inputEl, this.state.attachmentHandlingMode);
        }
      });
    }
    stepContentWrapper.createEl("hr", { cls: "vault-cms-divider" });
    stepContentWrapper.createEl("h3", { text: "Content types", cls: "vault-cms-section-header" });
    for (const contentType of this.state.contentTypes) {
      const setting = new import_obsidian8.Setting(stepContentWrapper);
      const nameContainer = setting.nameEl.createDiv({ cls: "vault-cms-editable-name" });
      setCssProps3(nameContainer, { display: "flex", alignItems: "center", gap: "0.5rem" });
      const createNameDisplay = (name) => {
        nameContainer.empty();
        const display = nameContainer.createSpan({
          text: name,
          cls: "vault-cms-name-display"
        });
        const iconContainer = nameContainer.createDiv({ cls: "vault-cms-edit-icon" });
        setCssProps3(iconContainer, { opacity: "0.6" });
        (0, import_obsidian8.setIcon)(iconContainer, "lucide-pencil-line");
        const startEdit = () => {
          const currentName = contentType.name;
          nameContainer.empty();
          const nameInput = nameContainer.createEl("input", {
            type: "text",
            value: currentName
          });
          nameInput.addClass("mod-text-input");
          nameInput.focus();
          nameInput.select();
          const saveName = () => {
            nameInput.removeEventListener("blur", saveName);
            let newName = nameInput.value.trim();
            if (!newName) {
              newName = currentName;
            }
            newName = newName.replace(/[<>:"/\\|?*\x00-\x1F]/g, "");
            if (!newName.trim()) {
              newName = currentName;
            } else {
              newName = newName.trim();
            }
            contentType.name = newName;
            void this.display();
          };
          nameInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              saveName();
            } else if (e.key === "Escape") {
              e.preventDefault();
              createNameDisplay(currentName);
            }
          });
          nameInput.addEventListener("blur", saveName);
        };
        display.addEventListener("click", startEdit);
        iconContainer.addEventListener("click", startEdit);
        iconContainer.addEventListener("mouseenter", () => {
          setCssProps3(iconContainer, { opacity: "1" });
        });
        iconContainer.addEventListener("mouseleave", () => {
          setCssProps3(iconContainer, { opacity: "0.6" });
        });
        return display;
      };
      createNameDisplay(contentType.name);
      setting.setDesc(`Folder: ${contentType.folder}`).addToggle((toggle) => toggle.setValue(contentType.enabled).onChange((value) => {
        contentType.enabled = value;
      }));
      new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - File organization`).setDesc("Choose how content is organized for this content type").addDropdown((dropdown) => dropdown.addOption("file", "File-based").addOption("folder", "Folder-based").setValue(contentType.fileOrganization || "file").onChange((value) => {
        contentType.fileOrganization = value;
        void this.display();
      }));
      if (contentType.fileOrganization === "folder") {
        new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - Index file name`).setDesc("Name of the index file in folder-based organization").addText((text) => text.setValue(contentType.indexFileName || "index").onChange((value) => {
          contentType.indexFileName = value || "index";
        }));
      }
      const pathParts = contentType.folder.split("/").filter((p) => p.length > 0);
      const folderName = pathParts[pathParts.length - 1] || contentType.folder;
      const defaultLinkBasePath = `/${folderName}/`;
      new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - Link base path`).setDesc(`URL path for this content type (e.g., "/posts/" or "/" for root). Leave blank to use default: ${defaultLinkBasePath}`).addText((text) => text.setPlaceholder(defaultLinkBasePath).setValue(contentType.linkBasePath || "").onChange((value) => {
        contentType.linkBasePath = value || void 0;
      }));
    }
    const addButton = stepContentWrapper.createEl("button", {
      text: "Add additional content type",
      cls: "mod-cta"
    });
    setCssProps3(addButton, { marginTop: "20px", marginBottom: "30px" });
    addButton.addEventListener("click", () => {
      void (async () => {
        const selectedFolder = this.selectContentTypeFolder();
        if (selectedFolder) {
          const vaultPath = this.getVaultPath();
          let folderPath = selectedFolder;
          if (selectedFolder.startsWith(vaultPath)) {
            folderPath = selectedFolder.substring(vaultPath.length).replace(/^[/\\]+/, "");
          }
          const pathParts = folderPath.split(/[/\\]/).filter((p) => p.length > 0);
          const leafFolderName = pathParts[pathParts.length - 1] || folderPath;
          const newType = {
            id: `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
            name: this.capitalizeFirst(leafFolderName),
            folder: folderPath,
            fileOrganization: "file",
            enabled: true,
            // Enable by default so it shows up in Step 5
            indexFileName: "index"
          };
          this.state.contentTypes.push(newType);
          await this.display();
        }
      })();
    });
    restoreScroll();
  }
  /**
   * Select folder for additional content type
   */
  selectContentTypeFolder() {
    var _a, _b;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      const result = dialog.showOpenDialogSync({
        title: "Select Content Type Folder",
        defaultPath: vaultPath,
        properties: ["openDirectory"]
      });
      if (result && result.length > 0) {
        return result[0].replace(/\\/g, "/").replace(/\/$/, "");
      }
    } catch (error) {
      console.error("Error opening folder picker:", error);
      new import_obsidian8.Notice("Unable to open folder picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (vaultPath) {
      if (vaultPath.startsWith("/") || /^[A-Z]:/.test(vaultPath)) {
        return vaultPath.replace(/\\/g, "/");
      }
      return vaultPath.replace(/\\/g, "/");
    }
    return "/";
  }
  /**
   * Capitalize first letter
   */
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  validate() {
    return this.state.contentTypes.some((ct) => ct.enabled);
  }
  getTitle() {
    return "Content types";
  }
  getDescription() {
    return "Configure content types";
  }
};

// src/ui/wizard/FrontmatterPropertiesStep.ts
var import_obsidian10 = require("obsidian");

// src/utils/FrontmatterAnalyzer.ts
var import_obsidian9 = require("obsidian");

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path10) {
  const ctrl = callVisitor(key, node, visitor, path10);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path10, ctrl);
    return visit_(key, ctrl, visitor, path10);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path10 = Object.freeze(path10.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path10);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path10 = Object.freeze(path10.concat(node));
      const ck = visit_("key", node.key, visitor, path10);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path10);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path10) {
  const ctrl = await callVisitor(key, node, visitor, path10);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path10, ctrl);
    return visitAsync_(key, ctrl, visitor, path10);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path10 = Object.freeze(path10.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path10);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path10 = Object.freeze(path10.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path10);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path10);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path10) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path10);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path10);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path10);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path10);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path10);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path10);
  return void 0;
}
function replaceNode(key, path10, node) {
  const parent = path10[path10.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class _Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      prevAnchors != null ? prevAnchors : prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc, ctx) {
    let nodes;
    if (ctx == null ? void 0 : ctx.aliasResolveCache) {
      nodes = ctx.aliasResolveCache;
    } else {
      nodes = [];
      visit(doc, {
        Node: (_key, node) => {
          if (isAlias(node) || hasAnchor(node))
            nodes.push(node);
        }
      });
      if (ctx)
        ctx.aliasResolveCache = nodes;
    }
    let found = void 0;
    for (const node of nodes) {
      if (node === this)
        break;
      if (node.anchor === this.source)
        found = node;
    }
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc, ctx);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if ((data == null ? void 0 : data.res) === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a;
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = (_a = match.find((t) => !t.format)) != null ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => {
    var _a2;
    return ((_a2 = t.identify) == null ? void 0 : _a2.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b, _c, _d;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      (_c = ref.anchor) != null ? _c : ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_d = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _d.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path10, value) {
  let v = value;
  for (let i = path10.length - 1; i >= 0; --i) {
    const k = path10[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path10) => path10 == null || typeof path10 === "object" && !!path10[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path10, value) {
    if (isEmptyPath(path10))
      this.add(value);
    else {
      const [key, ...rest] = path10;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path10) {
    const [key, ...rest] = path10;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path10, keepScalar) {
    const [key, ...rest] = path10;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path10) {
    const [key, ...rest] = path10;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path10, value) {
    const [key, ...rest] = path10;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch (e) {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t) => t.format === item.format)) != null ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags.filter((t) => {
      var _a2;
      return (_a2 = t.identify) == null ? void 0 : _a2.call(t, obj);
    });
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = (_b = match.find((t) => t.format === item.format)) != null ? _b : match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : obj === null ? "null" : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  var _a;
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = (_a = node.tag) != null ? _a : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  tagObj != null ? tagObj : tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  var _a, _b;
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n" && valueComment)
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = (_b = (_a = ctx.inFlow) != null ? _a : value.flow) != null ? _b : value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
var MERGE_KEY = "<<";
var merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && (ctx == null ? void 0 : ctx.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default));
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class _Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new _Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) != null ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar(node) ? node.value : node) != null ? _a : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    type != null ? type : type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) != null ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class _YAMLSet extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = _YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => {
    var _a;
    return (_a = value == null ? void 0 : value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) != null ? _a : "";
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class _Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/Document.js
var Document = class _Document {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path10, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path10, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path10) {
    if (isEmptyPath(path10)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path10) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path10, keepScalar) {
    if (isEmptyPath(path10))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path10, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path10) {
    if (isEmptyPath(path10))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path10) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path10, value) {
    if (isEmptyPath(path10)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path10), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path10, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if ((end == null ? void 0 : end.line) === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || (next == null ? void 0 : next.type) !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        start != null ? start : start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        start != null ? start : start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow != null ? flow : "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || (next == null ? void 0 : next.type) === "block-map" || (next == null ? void 0 : next.type) === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start != null ? start : end
  };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  var _a, _b;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep: sep4, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep4 == null ? void 0 : sep4[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep4) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_b = keyProps.found) == null ? void 0 : _b.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep4 != null ? sep4 : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep4, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd != null ? commentEnd : offset];
  return map2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  var _a;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if ((value == null ? void 0 : value.type) === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd != null ? commentEnd : offset];
  return seq2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep4 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep4 + cb;
          sep4 = "";
          break;
        }
        case "newline":
          if (comment)
            sep4 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  var _a, _b, _c;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : isMap2 ? YAMLMap : YAMLSeq;
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep: sep4, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep4 == null ? void 0 : sep4[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep4 && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_b = prev.value) != null ? _b : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep4 && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep4, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep4 != null ? sep4 : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep4)
            for (const st of sep4) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && ((_c = value.source) == null ? void 0 : _c[0]) === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep4, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode != null ? valueNode : keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if ((ce == null ? void 0 : ce.source) === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  var _a, _b, _c;
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor != null ? anchor : tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if ((kt == null ? void 0 : kt.collection) === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${(_a = kt.collection) != null ? _a : "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = (_c = (_b = tag.resolve) == null ? void 0 : _b.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) != null ? _c : coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep4 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep4 + indent.slice(trimIndent) + content;
      sep4 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep4 === " ")
        sep4 = "\n";
      else if (!prevMoreIndented && sep4 === "\n")
        sep4 = "\n\n";
      value += sep4 + indent.slice(trimIndent) + content;
      sep4 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep4 === "\n")
        value += "\n";
      else
        sep4 = "\n";
    } else {
      value += sep4 + content;
      sep4 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (e) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep4 = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep4 === "\n")
        res += sep4;
      else
        sep4 = "\n";
    } else {
      res += sep4 + match[1];
      sep4 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep4 + ((_a = match == null ? void 0 : match[1]) != null ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  var _a;
  const tag = schema4.tags.find((tag2) => {
    var _a2;
    return (tag2.default === true || atKey && tag2.default === "key") && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a = schema4.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
    })) != null ? _a : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    pos != null ? pos : pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag != null ? tag : token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value != null ? value : end == null ? void 0 : end[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) == null ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path10) => {
  let item = cst;
  for (const [field, index] of path10) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path10) => {
  const parent = visit2.itemAtPath(cst, path10.slice(0, -1));
  const field = path10[path10.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path10, item, visitor) {
  let ctrl = visitor(item, path10);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path10.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path10);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path10) : ctrl;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) != null ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next = this.buffer[i2 + 1];
          if (!next && !this.atEnd)
            return this.setNext("block-scalar");
          if (next === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (((_a = prev[++i]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (top == null ? void 0 : top.type) !== "doc-end") {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error != null ? error : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep4;
      if (scalar.end) {
        sep4 = scalar.end;
        sep4.push(this.sourceToken);
        delete scalar.end;
      } else
        sep4 = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep: sep4 }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep4 = it.sep;
              sep4.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep: sep4 }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs7 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs7, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs7);
          } else {
            Object.assign(it, { key: fs7, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while ((top == null ? void 0 : top.type) === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs7 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs7, sep: [] });
          else if (it.sep)
            this.stack.push(fs7);
          else
            Object.assign(it, { key: fs7, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep4 = fc.end.splice(1, fc.end.length);
        sep4.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep: sep4 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse2(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}

// src/utils/FrontmatterAnalyzer.ts
var FrontmatterAnalyzer = class {
  constructor(app) {
    this.app = app;
  }
  async findExampleFile(folderPath, includeMdx = false) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      return null;
    }
    if (folder instanceof import_obsidian9.TFile) {
      const ext = folder.extension;
      if (ext === "md" || includeMdx && ext === "mdx") {
        return await this.parseFrontmatter(folder);
      }
      return null;
    }
    if (!(folder instanceof import_obsidian9.TFolder)) {
      return null;
    }
    let files = this.getMarkdownFiles(folder, false, void 0, 0, includeMdx);
    if (files.length === 0) {
      files = this.getMarkdownFiles(folder, true, 1, 0, includeMdx);
      if (files.length === 0) {
        files = this.getMarkdownFiles(folder, true, 2, 0, includeMdx);
      }
      if (files.length === 0) {
        files = this.getMarkdownFiles(folder, true, void 0, 0, includeMdx);
      }
    }
    for (const file of files) {
      const example = await this.parseFrontmatter(file);
      if (example) {
        return example;
      }
    }
    return null;
  }
  /**
   * Scans multiple files in a folder to aggregate all unique frontmatter properties.
   * This ensures properties aren't missed just because they're not in the single "latest" file.
   */
  async getPropertiesInFolder(folderPath, includeMdx = false, limit = 50) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!(folder instanceof import_obsidian9.TFolder)) {
      return /* @__PURE__ */ new Set();
    }
    const files = this.getMarkdownFiles(folder, true, void 0, 0, includeMdx);
    const aggregateProps = /* @__PURE__ */ new Set();
    const filesToScan = files.slice(0, limit);
    for (const file of filesToScan) {
      if (file.extension === "md") {
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache && cache.frontmatter) {
          Object.keys(cache.frontmatter).forEach((key) => aggregateProps.add(key));
        }
      } else if (includeMdx && file.extension === "mdx") {
        const example = await this.parseFrontmatter(file);
        if (example && example.frontmatter) {
          Object.keys(example.frontmatter).forEach((key) => aggregateProps.add(key));
        }
      }
    }
    return aggregateProps;
  }
  hasUnderscoreFiles(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!(folder instanceof import_obsidian9.TFolder)) {
      return Promise.resolve(false);
    }
    const files = this.getMarkdownFiles(folder, true);
    return Promise.resolve(files.some((file) => file.name.startsWith("_")));
  }
  getMarkdownFiles(folder, recursive = true, maxDepth, currentDepth = 0, includeMdx = false) {
    const files = [];
    if (!folder.children) {
      return files;
    }
    if (maxDepth !== void 0 && currentDepth >= maxDepth) {
      return files;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian9.TFile) {
        if (child.extension === "md" || includeMdx && child.extension === "mdx") {
          files.push(child);
        }
      } else if (recursive && child instanceof import_obsidian9.TFolder && child.children) {
        files.push(...this.getMarkdownFiles(child, recursive, maxDepth, currentDepth + 1, includeMdx));
      }
    }
    return files;
  }
  async parseFrontmatter(file) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const yamlContent = match[1];
      const frontmatter = parse2(yamlContent);
      if (!frontmatter || typeof frontmatter !== "object") {
        return null;
      }
      return {
        file: file.path,
        frontmatter,
        rawYaml: yamlContent
      };
    } catch (e) {
      return null;
    }
  }
  autoDetectTitleProperty(frontmatter) {
    const titleProperties = ["title", "name", "headline", "heading", "subject"];
    for (const prop of titleProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
  autoDetectDateProperty(frontmatter) {
    const dateProperties = ["date", "pubDate", "publishedDate", "publishDate", "created", "updated", "modified"];
    for (const prop of dateProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        const value = frontmatter[prop];
        if (this.looksLikeDate(value)) {
          return prop;
        }
      }
    }
    for (const prop in frontmatter) {
      if (prop.toLowerCase().includes("date") && this.looksLikeDate(frontmatter[prop])) {
        return prop;
      }
    }
    return null;
  }
  looksLikeDate(value) {
    if (value instanceof Date) return true;
    if (typeof value === "string") {
      return /^\d{4}-\d{2}-\d{2}/.test(value);
    }
    if (typeof value === "number") {
      return value > 1e9;
    }
    return false;
  }
  autoDetectDescriptionProperty(frontmatter) {
    const descriptionProperties = ["description", "summary", "excerpt", "intro", "snippet", "blurb"];
    for (const prop of descriptionProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
  autoDetectTagsProperty(frontmatter) {
    if (frontmatter.hasOwnProperty("tags")) {
      return "tags";
    }
    return null;
  }
  autoDetectDraftProperty(frontmatter) {
    if (frontmatter.hasOwnProperty("draft")) {
      const val = frontmatter["draft"];
      if (typeof val === "boolean") {
        return { property: "draft", logic: "true-draft" };
      }
    }
    if (frontmatter.hasOwnProperty("published")) {
      const val = frontmatter["published"];
      if (typeof val === "boolean") {
        return { property: "published", logic: "false-draft" };
      }
    }
    if (frontmatter.hasOwnProperty("visible")) {
      const val = frontmatter["visible"];
      if (typeof val === "boolean") {
        return { property: "visible", logic: "false-draft" };
      }
    }
    return null;
  }
  autoDetectImageProperty(frontmatter) {
    const imageProperties = ["image", "cover", "coverImage", "thumbnail", "featuredImage"];
    for (const prop of imageProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
};

// src/ui/wizard/FrontmatterPropertiesStep.ts
function setCssProps4(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var FrontmatterPropertiesStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.examples = {};
    this.frontmatterAnalyzer = new FrontmatterAnalyzer(app);
  }
  async display() {
    const { containerEl } = this;
    const existingWrapper = containerEl.querySelector(".frontmatter-step-content");
    if (existingWrapper) {
      existingWrapper.remove();
    }
    const stepContentWrapper = containerEl.createDiv({ cls: "frontmatter-step-content" });
    stepContentWrapper.createEl("h2", { text: "Frontmatter properties" });
    stepContentWrapper.createEl("p", {
      text: "Map frontmatter properties for each content type. We'll find example files to help you."
    });
    for (const contentType of this.state.contentTypes) {
      if (!contentType.enabled) {
        continue;
      }
      const contentTypeWrapper = stepContentWrapper.createDiv({ cls: "content-type-settings" });
      const pathResolver = new PathResolver(this.app);
      const folderPath = pathResolver.getFolderPathFromVaultRoot(contentType.folder, this.state.projectDetection);
      if (!this.examples[contentType.id]) {
        const example2 = await this.frontmatterAnalyzer.findExampleFile(folderPath, this.state.enableMdxSupport);
        if (example2) {
          this.examples[contentType.id] = example2;
        }
      }
      const example = this.examples[contentType.id];
      const aggregateProps = await this.frontmatterAnalyzer.getPropertiesInFolder(folderPath, this.state.enableMdxSupport);
      const dummyFrontmatter = {};
      aggregateProps.forEach((key) => dummyFrontmatter[key] = null);
      contentTypeWrapper.createEl("h3", { text: contentType.name });
      if (example) {
        contentTypeWrapper.createEl("p", { text: `Example file: ${example.file}` });
        const preEl = contentTypeWrapper.createEl("pre", {
          text: example.rawYaml,
          cls: "frontmatter-example"
        });
        setCssProps4(preEl, {
          fontFamily: "var(--font-monospace)",
          fontSize: "0.85em",
          whiteSpace: "pre-wrap",
          overflowWrap: "break-word",
          maxWidth: "100%",
          padding: "10px",
          backgroundColor: "var(--background-secondary)",
          borderRadius: "4px",
          border: "1px solid var(--background-modifier-border)"
        });
      }
      if (!this.state.frontmatterProperties[contentType.id]) {
        const detectedDraft = this.frontmatterAnalyzer.autoDetectDraftProperty(dummyFrontmatter);
        const detectedTags = this.frontmatterAnalyzer.autoDetectTagsProperty(dummyFrontmatter);
        const detectedImage = this.frontmatterAnalyzer.autoDetectImageProperty(dummyFrontmatter);
        const detectedDesc = this.frontmatterAnalyzer.autoDetectDescriptionProperty(dummyFrontmatter);
        const detectedTitle = this.frontmatterAnalyzer.autoDetectTitleProperty(dummyFrontmatter);
        const detectedDate = this.frontmatterAnalyzer.autoDetectDateProperty(dummyFrontmatter);
        const hasUnderscoreFiles = await this.frontmatterAnalyzer.hasUnderscoreFiles(folderPath);
        this.state.frontmatterProperties[contentType.id] = {
          titleProperty: detectedTitle || void 0,
          // Only set if detected, otherwise blank
          dateProperty: detectedDate || void 0,
          // Only set if detected, otherwise blank
          descriptionProperty: detectedDesc || void 0,
          tagsProperty: detectedTags || void 0,
          draftProperty: detectedDraft == null ? void 0 : detectedDraft.property,
          draftLogic: (detectedDraft == null ? void 0 : detectedDraft.property) === "published" ? "false-draft" : detectedDraft ? "true-draft" : void 0,
          hasDraftStatus: !!(detectedDraft == null ? void 0 : detectedDraft.property) || hasUnderscoreFiles,
          // Track if draft status is enabled
          imageProperty: detectedImage || void 0
        };
      }
      const props = this.state.frontmatterProperties[contentType.id];
      new import_obsidian10.Setting(contentTypeWrapper).setName("Title property").setDesc("The frontmatter property that contains the title (e.g., title, name, heading). Leave blank to use full file name instead.").addText((text) => {
        const detected = "title";
        text.setPlaceholder(detected).setValue(props.titleProperty || "").onChange((value) => {
          props.titleProperty = value.trim() || void 0;
        });
      });
      new import_obsidian10.Setting(contentTypeWrapper).setName("Date property").setDesc("The frontmatter property that contains the date (e.g., date, pubDate, publishedDate, publishDate). Leave blank to use file created date instead.").addText((text) => {
        const detected = example ? this.frontmatterAnalyzer.autoDetectDateProperty(example.frontmatter) : null;
        text.setPlaceholder(detected || "date").setValue(props.dateProperty || "").onChange((value) => {
          props.dateProperty = value.trim() || void 0;
        });
      });
      const descSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Has description/summary?").setDesc("Does this content type have a description or summary field?");
      let descTextSetting = null;
      descSetting.addToggle((toggle) => toggle.setValue(!!props.descriptionProperty).onChange((value) => {
        if (value && !props.descriptionProperty) {
          props.descriptionProperty = example ? this.frontmatterAnalyzer.autoDetectDescriptionProperty(example.frontmatter) || "description" : "description";
          if (!descTextSetting) {
            descTextSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Description property").setDesc("The frontmatter property that contains the description (e.g., description, summary, excerpt, intro, snippet, blurb)").addText((text) => text.setValue(props.descriptionProperty || "").onChange((value2) => {
              props.descriptionProperty = value2.trim() || void 0;
            }));
            descTextSetting.settingEl.remove();
            descSetting.settingEl.insertAdjacentElement("afterend", descTextSetting.settingEl);
          }
        } else if (!value) {
          props.descriptionProperty = void 0;
          if (descTextSetting) {
            descTextSetting.settingEl.remove();
            descTextSetting = null;
          }
        }
      }));
      if (props.descriptionProperty) {
        descTextSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Description property").setDesc("The frontmatter property that contains the description (e.g., description, summary, excerpt, intro, snippet, blurb)").addText((text) => text.setValue(props.descriptionProperty || "").onChange((value) => {
          props.descriptionProperty = value.trim() || void 0;
        }));
        descTextSetting.settingEl.remove();
        descSetting.settingEl.insertAdjacentElement("afterend", descTextSetting.settingEl);
      }
      const tagsSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Has tags?").setDesc("Does this content type have tags?");
      let tagsTextSetting = null;
      tagsSetting.addToggle((toggle) => toggle.setValue(!!props.tagsProperty).onChange((value) => {
        if (value && !props.tagsProperty) {
          const detected = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
          props.tagsProperty = detected || "tags";
          if (!tagsTextSetting) {
            tagsTextSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Tags property").setDesc("The frontmatter property that contains tags (e.g., tags, tag, categories, category). Leave blank if not applicable.").addText((text) => {
              const detected2 = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
              text.setPlaceholder(detected2 || "tags").setValue(props.tagsProperty || "").onChange((value2) => {
                props.tagsProperty = value2.trim() || void 0;
              });
            });
            tagsTextSetting.settingEl.remove();
            tagsSetting.settingEl.insertAdjacentElement("afterend", tagsTextSetting.settingEl);
          }
        } else if (!value) {
          props.tagsProperty = void 0;
          if (tagsTextSetting) {
            tagsTextSetting.settingEl.remove();
            tagsTextSetting = null;
          }
        }
      }));
      if (props.tagsProperty) {
        tagsTextSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Tags property").setDesc("The frontmatter property that contains tags (e.g., tags, tag, categories, category). Leave blank if not applicable.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
          text.setPlaceholder(detected || "tags").setValue(props.tagsProperty || "").onChange((value) => {
            props.tagsProperty = value.trim() || void 0;
          });
        });
        tagsTextSetting.settingEl.remove();
        tagsSetting.settingEl.insertAdjacentElement("afterend", tagsTextSetting.settingEl);
      }
      const draftSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Has draft status?").setDesc("Does this content type have draft status?");
      let draftPropertySetting = null;
      let draftLogicSetting = null;
      if (props.hasDraftStatus === void 0) {
        props.hasDraftStatus = !!props.draftProperty;
      }
      draftSetting.addToggle((toggle) => {
        var _a;
        return toggle.setValue((_a = props.hasDraftStatus) != null ? _a : !!props.draftProperty).onChange((value) => {
          props.hasDraftStatus = value;
          if (value && !props.draftProperty) {
            const detectedDraft = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
            props.draftProperty = (detectedDraft == null ? void 0 : detectedDraft.property) || "draft";
            if ((detectedDraft == null ? void 0 : detectedDraft.property) === "published") {
              props.draftLogic = "false-draft";
            } else {
              props.draftLogic = "true-draft";
            }
            if (!draftPropertySetting) {
              draftPropertySetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Draft property").setDesc("The frontmatter property that contains draft status. Leave blank to use an underscore prefix instead.").addText((text) => {
                const detected = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
                text.setPlaceholder((detected == null ? void 0 : detected.property) || "draft").setValue(props.draftProperty || "").onChange((value2) => {
                  props.draftProperty = value2.trim() || void 0;
                  if (value2 === "published") {
                    props.draftLogic = "false-draft";
                  } else if (value2) {
                    props.draftLogic = "true-draft";
                  }
                  if (value2 && !draftLogicSetting) {
                    draftLogicSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((dropdownValue) => {
                      props.draftLogic = dropdownValue;
                    }));
                    draftLogicSetting.settingEl.remove();
                    if (draftPropertySetting) {
                      draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
                    }
                  } else if (!value2 && draftLogicSetting) {
                    draftLogicSetting.settingEl.remove();
                    draftLogicSetting = null;
                  }
                });
              });
              draftPropertySetting.settingEl.remove();
              draftSetting.settingEl.insertAdjacentElement("afterend", draftPropertySetting.settingEl);
            }
            if (props.draftProperty && !draftLogicSetting) {
              draftLogicSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((value2) => {
                props.draftLogic = value2;
              }));
              draftLogicSetting.settingEl.remove();
              if (draftPropertySetting !== null) {
                draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
              }
            }
          } else if (!value) {
            props.draftProperty = void 0;
            props.draftLogic = void 0;
            props.hasDraftStatus = false;
            if (draftPropertySetting) {
              draftPropertySetting.settingEl.remove();
              draftPropertySetting = null;
            }
            if (draftLogicSetting) {
              draftLogicSetting.settingEl.remove();
              draftLogicSetting = null;
            }
          }
        });
      });
      if (props.hasDraftStatus) {
        draftPropertySetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Draft property").setDesc("The frontmatter property that contains draft status. Leave blank to use an underscore prefix instead.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
          text.setPlaceholder((detected == null ? void 0 : detected.property) || "draft").setValue(props.draftProperty || "").onChange((value) => {
            props.draftProperty = value.trim() || void 0;
            if (value === "published") {
              props.draftLogic = "false-draft";
            } else if (value) {
              props.draftLogic = "true-draft";
            }
            if (value && !draftLogicSetting) {
              draftLogicSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((dropdownValue) => {
                props.draftLogic = dropdownValue;
              }));
              draftLogicSetting.settingEl.remove();
              if (draftPropertySetting) {
                draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
              }
            } else if (!value && draftLogicSetting) {
              draftLogicSetting.settingEl.remove();
              draftLogicSetting = null;
            }
          });
        });
        draftPropertySetting.settingEl.remove();
        draftSetting.settingEl.insertAdjacentElement("afterend", draftPropertySetting.settingEl);
        if (props.draftProperty) {
          draftLogicSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((value) => {
            props.draftLogic = value;
          }));
          draftLogicSetting.settingEl.remove();
          if (draftPropertySetting !== null) {
            draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
          }
        }
      }
      const imageSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Has image/cover property?").setDesc("Does this content type have an image or cover property? Used for Bases CMS cover images and Image Manager.");
      let imageTextSetting = null;
      imageSetting.addToggle((toggle) => toggle.setValue(!!props.imageProperty).onChange((value) => {
        if (value && !props.imageProperty) {
          const detected = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
          props.imageProperty = detected || "image";
          if (!imageTextSetting) {
            imageTextSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Image property").setDesc("The frontmatter property that contains the image/cover (e.g., image, cover, coverImage, thumbnail, featuredImage). Leave blank if not applicable.").addText((text) => {
              const detected2 = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
              text.setPlaceholder(detected2 || "image").setValue(props.imageProperty || "").onChange((value2) => {
                props.imageProperty = value2.trim() || void 0;
              });
            });
            imageTextSetting.settingEl.remove();
            imageSetting.settingEl.insertAdjacentElement("afterend", imageTextSetting.settingEl);
          }
        } else if (!value) {
          props.imageProperty = void 0;
          if (imageTextSetting) {
            imageTextSetting.settingEl.remove();
            imageTextSetting = null;
          }
        }
      }));
      if (props.imageProperty) {
        imageTextSetting = new import_obsidian10.Setting(contentTypeWrapper).setName("Image property").setDesc("The frontmatter property that contains the image/cover (e.g., image, cover, coverImage, thumbnail, featuredImage). Leave blank if not applicable.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
          text.setPlaceholder(detected || "image").setValue(props.imageProperty || "").onChange((value) => {
            props.imageProperty = value.trim() || void 0;
          });
        });
        imageTextSetting.settingEl.remove();
        imageSetting.settingEl.insertAdjacentElement("afterend", imageTextSetting.settingEl);
      }
      contentTypeWrapper.createEl("h4", { text: "Template" });
      contentTypeWrapper.createEl("p", {
        text: 'Edit the template that will be used when creating new files of this content type. Use {{title}} and {{date}} as variables. Note: {{title}} should be in quotes (e.g., title: "{{title}}"), while {{date}} should not be in quotes (e.g., date: {{date}}).'
      });
      if (!props.template) {
        const pathResolver2 = new PathResolver(this.app);
        const folderPath2 = pathResolver2.getFolderPathFromVaultRoot(contentType.folder, this.state.projectDetection);
        const aggregateProps2 = await this.frontmatterAnalyzer.getPropertiesInFolder(folderPath2, this.state.enableMdxSupport);
        props.template = this.generateDefaultTemplate(props, example, aggregateProps2);
      }
      const templateTextArea = contentTypeWrapper.createEl("textarea", {
        cls: "template-editor",
        attr: {
          rows: "10",
          style: "width: 100%; font-family: monospace;",
          spellcheck: "false"
        }
      });
      templateTextArea.value = props.template || "";
      templateTextArea.addEventListener("input", (e) => {
        const target = e.target;
        props.template = target.value;
      });
    }
  }
  generateDefaultTemplate(props, example, aggregateProps) {
    let template = "---\n";
    if (example && example.rawYaml) {
      const lines = example.rawYaml.split("\n");
      const processedProps = /* @__PURE__ */ new Set();
      let titleAdded = false;
      if (props.titleProperty) {
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) continue;
          const colonIndex = trimmed.indexOf(":");
          if (colonIndex > 0) {
            const prop = trimmed.substring(0, colonIndex).trim();
            if (prop === props.titleProperty) {
              template += `${props.titleProperty}: "{{title}}"
`;
              titleAdded = true;
              processedProps.add(prop);
              continue;
            }
          }
        }
        if (!titleAdded) {
          template += `${props.titleProperty}: "{{title}}"
`;
        }
      }
      let dateAdded = false;
      if (props.dateProperty) {
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) continue;
          const colonIndex = trimmed.indexOf(":");
          if (colonIndex > 0) {
            const prop = trimmed.substring(0, colonIndex).trim();
            if (prop === props.dateProperty && !processedProps.has(prop)) {
              template += `${props.dateProperty}: {{date}}
`;
              dateAdded = true;
              processedProps.add(prop);
              continue;
            }
          }
        }
        if (!dateAdded && !processedProps.has(props.dateProperty)) {
          template += `${props.dateProperty}: {{date}}
`;
          processedProps.add(props.dateProperty);
        }
      }
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith("#")) continue;
        const colonIndex = trimmed.indexOf(":");
        if (colonIndex > 0) {
          const prop = trimmed.substring(0, colonIndex).trim();
          if (processedProps.has(prop)) {
            continue;
          }
          if (prop === props.descriptionProperty) {
            template += `${prop}: ""
`;
            processedProps.add(prop);
            continue;
          }
          const value = example.frontmatter[prop];
          if (value === null || value === void 0) {
            template += `${prop}:
`;
          } else if (Array.isArray(value)) {
            template += `${prop}: []
`;
          } else if (typeof value === "boolean") {
            template += `${prop}: ${value}
`;
          } else if (typeof value === "number") {
            template += `${prop}: ${value}
`;
          } else if (typeof value === "string") {
            template += `${prop}: ""
`;
          } else {
            template += `${prop}: ""
`;
          }
          processedProps.add(prop);
        }
      }
      for (const prop of aggregateProps) {
        if (processedProps.has(prop)) continue;
        if (prop === props.titleProperty) {
          template += `${prop}: "{{title}}"
`;
        } else if (prop === props.dateProperty) {
          template += `${prop}: {{date}}
`;
        } else if (prop === props.descriptionProperty) {
          template += `${prop}: ""
`;
        } else if (prop === props.tagsProperty) {
          template += `${prop}: []
`;
        } else if (prop === props.imageProperty) {
          template += `${prop}: ""
`;
        } else if (prop === props.draftProperty) {
          const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
          template += `${prop}: ${draftValue}
`;
        } else {
          template += `${prop}: ""
`;
        }
        processedProps.add(prop);
      }
    } else {
      if (props.titleProperty) {
        template += `${props.titleProperty}: "{{title}}"
`;
      }
      if (props.dateProperty) {
        template += `${props.dateProperty}: {{date}}
`;
      }
      if (props.descriptionProperty) {
        template += `${props.descriptionProperty}: ""
`;
      }
      if (props.tagsProperty) {
        template += `${props.tagsProperty}: []
`;
      }
      if (props.draftProperty) {
        const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
        template += `${props.draftProperty}: ${draftValue}
`;
      }
    }
    template += "---\n";
    return template;
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Frontmatter properties";
  }
  getDescription() {
    return "Map frontmatter properties";
  }
};

// src/ui/wizard/PluginConfigurationStep.ts
var import_obsidian11 = require("obsidian");
function setCssProps5(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var PluginConfigurationStep = class extends BaseWizardStep {
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Plugin Configuration" });
    containerEl.createEl("p", {
      text: "Your plugins will be automatically configured using your mapped frontmatter properties. Review the settings below."
    });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    if (enabledTypes.length === 0) {
      containerEl.createEl("p", {
        text: "No content types enabled. Please go back and enable at least one content type."
      });
      return;
    }
    const basesCMSDiv = containerEl.createDiv({ cls: "plugin-config-section", attr: { style: "margin-bottom: 2rem;" } });
    basesCMSDiv.createEl("b", { text: "Base views to be created:", attr: { style: "display: block; margin-bottom: 0.5rem;" } });
    const basesList = basesCMSDiv.createEl("ul", { attr: { style: "margin-top: 0;" } });
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        const properties = [];
        if (props.titleProperty) properties.push(props.titleProperty);
        if (props.dateProperty) properties.push(props.dateProperty);
        if (props.descriptionProperty) properties.push(props.descriptionProperty);
        if (props.tagsProperty) properties.push(props.tagsProperty);
        if (props.imageProperty) properties.push(props.imageProperty);
        if (props.draftProperty) properties.push(props.draftProperty);
        const propertiesText = properties.length > 0 ? properties.join(", ") : "default properties";
        basesList.createEl("li", {
          text: `${contentType.name}: ${propertiesText}`
        });
      }
    }
    const astroComposerDiv = containerEl.createDiv({ cls: "plugin-config-section", attr: { style: "margin-bottom: 2rem;" } });
    astroComposerDiv.createEl("b", { text: "Creation logic:", attr: { style: "display: block; margin-bottom: 0.5rem;" } });
    const astroList = astroComposerDiv.createEl("ul", { attr: { style: "margin-top: 0;" } });
    for (const contentType of enabledTypes) {
      const modeLabel = contentType.fileOrganization === "folder" ? "folder-based" : "file-based";
      astroList.createEl("li", {
        text: `${contentType.name} (${contentType.folder}): ${modeLabel}`
      });
    }
    const configDiv = containerEl.createDiv({ cls: "plugin-config-section", attr: { style: "border-top: 1px solid var(--background-modifier-border); padding-top: 1rem;" } });
    const titleProperties = /* @__PURE__ */ new Set();
    const descriptionProperties = /* @__PURE__ */ new Set();
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        if (props.titleProperty) titleProperties.add(props.titleProperty);
        if (props.descriptionProperty) descriptionProperties.add(props.descriptionProperty);
      }
    }
    if (titleProperties.size > 1 || descriptionProperties.size > 1) {
      const warningDiv = configDiv.createDiv({ cls: "vault-cms-warning" });
      setCssProps5(warningDiv, {
        padding: "10px",
        backgroundColor: "var(--background-modifier-border)",
        borderLeft: "3px solid var(--text-warning)",
        marginBottom: "15px"
      });
      warningDiv.createEl("p", {
        text: "\u26A0\uFE0F Warning: Different content types use different properties for title or description. SEO will use the first content type's defaults.",
        attr: { style: "margin: 0; font-size: 0.9em;" }
      });
    }
    new import_obsidian11.Setting(configDiv).setName("Default content type").setDesc("Choose the default content type for new notes and Home base").addDropdown((dropdown) => {
      var _a2;
      enabledTypes.forEach((ct) => {
        dropdown.addOption(ct.id, ct.name);
      });
      dropdown.setValue(this.state.defaultContentTypeId || (((_a2 = enabledTypes[0]) == null ? void 0 : _a2.id) || ""));
      dropdown.onChange((value) => {
        this.state.defaultContentTypeId = value;
      });
    });
    const pathResolver = new PathResolver(this.app);
    const defaultScanDirs = this.state.contentTypes.filter((ct) => ct.enabled).map((ct) => pathResolver.getFolderPathFromVaultRoot(ct.folder, this.state.projectDetection)).join(",");
    const savedScanDirs = (_a = this.state.seoConfig) == null ? void 0 : _a.scanDirectories;
    const initialScanDirs = savedScanDirs && savedScanDirs.trim() ? savedScanDirs : defaultScanDirs;
    if (!this.state.seoConfig.scanDirectories || !this.state.seoConfig.scanDirectories.trim()) {
      this.state.seoConfig.scanDirectories = initialScanDirs;
    }
    new import_obsidian11.Setting(configDiv).setName("SEO Scan directories").setDesc("Comma-separated list of directories to scan").addText((text) => text.setValue(initialScanDirs).onChange((value) => {
      if (this.state.seoConfig) {
        this.state.seoConfig.scanDirectories = value;
      }
    }));
  }
  validate() {
    return this.state.contentTypes.some((ct) => ct.enabled);
  }
  getTitle() {
    return "Plugin configuration";
  }
  getDescription() {
    return "Configure Bases, Astro Composer, SEO, and Default Type";
  }
};

// src/ui/wizard/OptionalPluginsStep.ts
var import_obsidian12 = require("obsidian");

// src/utils/PluginManager.ts
var PluginManager = class {
  constructor(app) {
    this.app = app;
  }
  async enablePlugin(pluginId) {
    var _a, _b;
    const plugins = this.app.plugins;
    if (!plugins) {
      return;
    }
    const plugin = (_a = plugins.plugins) == null ? void 0 : _a[pluginId];
    if (plugin && !plugin.enabled) {
      await ((_b = plugins.enablePlugin) == null ? void 0 : _b.call(plugins, pluginId));
    }
  }
  async disablePlugin(pluginId) {
    var _a, _b;
    const plugins = this.app.plugins;
    if (!plugins) {
      return;
    }
    const plugin = (_a = plugins.plugins) == null ? void 0 : _a[pluginId];
    if (plugin && plugin.enabled) {
      await ((_b = plugins.disablePlugin) == null ? void 0 : _b.call(plugins, pluginId));
    }
  }
  async setPluginStates(enabled, disabled) {
    const corePlugins = ["bases-cms", "astro-composer", "vault-cms"];
    const safeDisabled = disabled.filter((p) => !corePlugins.includes(p));
    for (const pluginId of safeDisabled) {
      await this.disablePlugin(pluginId);
    }
    for (const pluginId of enabled) {
      await this.enablePlugin(pluginId);
    }
  }
  getPresetPlugins(preset) {
    const corePlugins = [
      "astro-composer",
      "bases-cms",
      "homepage",
      "new-tab-default-page",
      "property-over-file-name",
      "settings-search",
      "statusbar-organizer",
      "seo",
      "ui-tweaker",
      "zenmode",
      "cmdr",
      "simple-focus",
      "tag-wrangler"
    ];
    const optionalPlugins = [
      "editing-toolbar",
      "insert-unsplash-image",
      "custom-save",
      "title-only-tab",
      "obsidian-paste-image-rename",
      "obsidian42-brat",
      "obsidian-hider",
      "disable-tabs",
      "obsidian-style-settings",
      "mdx-as-md-obsidian",
      "explorer-focus"
    ];
    const opinionatedPlugins = [
      "obsidian-oxygen",
      "obsidian-style-settings"
    ];
    if (preset === "vanilla") {
      return {
        enabled: [...corePlugins, ...optionalPlugins.filter((p) => !opinionatedPlugins.includes(p))],
        disabled: opinionatedPlugins
      };
    } else if (preset === "opinionated") {
      return {
        enabled: [...corePlugins, ...optionalPlugins],
        disabled: []
      };
    } else {
      return {
        enabled: [],
        disabled: []
      };
    }
  }
};

// src/ui/wizard/OptionalPluginsStep.ts
function setCssProps6(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var OptionalPluginsStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.pluginManager = new PluginManager(app);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Plugin detection" });
    containerEl.createEl("p", {
      text: "Review and configure your installed plugins. Essential plugins are recommended for the core Vault CMS experience."
    });
    const allPlugins = [
      { id: "astro-composer", name: "Astro Composer", category: "essential" },
      { id: "bases-cms", name: "Bases CMS", category: "essential" },
      { id: "new-tab-default-page", name: "Default New Tab Page", category: "essential" },
      { id: "editing-toolbar", name: "Editing Toolbar", category: "essential" },
      { id: "home-base", name: "Home Base", category: "essential" },
      { id: "homepage", name: "Homepage", category: "essential" },
      { id: "image-manager", name: "Image Manager", category: "essential" },
      { id: "obsidian-paste-image-rename", name: "Paste Image Rename", category: "essential" },
      { id: "property-over-file-name", name: "Property Over File Name", category: "essential" },
      { id: "seo", name: "SEO", category: "essential" },
      { id: "ui-tweaker", name: "UI Tweaker", category: "essential" },
      { id: "simple-focus", name: "Simple Focus", category: "essential" },
      { id: "statusbar-organizer", name: "Status Bar Organizer", category: "essential" },
      { id: "alias-file-name-history", name: "Alias File Name History", category: "nice-to-have" },
      { id: "data-files-editor", name: "Data Files Editor", category: "nice-to-have" },
      { id: "iconic", name: "Iconic", category: "nice-to-have" },
      { id: "paste-image-into-property", name: "Paste Image Into Property", category: "nice-to-have" },
      { id: "settings-search", name: "Settings Search", category: "nice-to-have" },
      { id: "tag-wrangler", name: "Tag Wrangler", category: "nice-to-have" },
      { id: "zenmode", name: "Zen Mode", category: "nice-to-have" },
      { id: "explorer-focus", name: "Explorer Focus", category: "nice-to-have" }
    ];
    const plugins = this.app.plugins;
    const installedPluginIds = (plugins == null ? void 0 : plugins.plugins) ? Object.keys(plugins.plugins) : [];
    const ignoredPlugins = ["obsidian42-brat", "astro-modular-settings", "folder-notes", "disable-tabs", "vault-cms"];
    const essentialPlugins = allPlugins.filter(
      (p) => p.category === "essential" && installedPluginIds.includes(p.id) && !ignoredPlugins.includes(p.id)
    );
    const niceToHavePlugins = allPlugins.filter(
      (p) => p.category === "nice-to-have" && installedPluginIds.includes(p.id) && !ignoredPlugins.includes(p.id)
    ).sort((a, b) => a.name.localeCompare(b.name));
    if (essentialPlugins.length > 0) {
      const details = containerEl.createEl("details", { attr: { style: "margin-bottom: 1rem;" } });
      details.createEl("summary", {
        text: `Essential plugins (${essentialPlugins.length} found)`,
        attr: { style: "font-weight: bold; cursor: pointer; padding: 0.5rem 0;" }
      });
      const content = details.createDiv({ attr: { style: "padding: 0.5rem 0.5rem 0.5rem 1.5rem; border-left: 2px solid var(--background-modifier-border);" } });
      for (const plugin of essentialPlugins) {
        this.renderPluginStatus(content, plugin, plugins);
      }
    }
    if (niceToHavePlugins.length > 0) {
      const details = containerEl.createEl("details", { attr: { style: "margin-bottom: 2rem;" } });
      details.createEl("summary", {
        text: `Nice to have plugins (${niceToHavePlugins.length} found)`,
        attr: { style: "font-weight: bold; cursor: pointer; padding: 0.5rem 0;" }
      });
      const content = details.createDiv({ attr: { style: "padding: 0.5rem 0.5rem 0.5rem 1.5rem; border-left: 2px solid var(--background-modifier-border);" } });
      for (const plugin of niceToHavePlugins) {
        this.renderPluginStatus(content, plugin, plugins);
      }
    }
    if (essentialPlugins.length === 0 && niceToHavePlugins.length === 0) {
      containerEl.createEl("p", { text: "No Vault CMS plugins detected." });
    }
    const toolbarDiv = containerEl.createDiv({
      attr: { style: "margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--background-modifier-border);" }
    });
    new import_obsidian12.Setting(toolbarDiv).setName("Enable Editing Toolbar").setDesc("Show the visual editing toolbar for formatting text").addToggle((toggle) => toggle.setValue(this.state.enableEditingToolbar).onChange((value) => {
      this.state.enableEditingToolbar = value;
    }));
  }
  renderPluginStatus(container, plugin, plugins) {
    var _a, _b, _c, _d, _e;
    const pluginInstance = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[plugin.id];
    const isInstalled = !!pluginInstance;
    const pluginInstanceTyped = pluginInstance;
    const isCurrentlyEnabled = (_e = (_d = (_c = (_b = plugins == null ? void 0 : plugins.enabledPlugins) == null ? void 0 : _b.has) == null ? void 0 : _c.call(_b, plugin.id)) != null ? _d : pluginInstanceTyped == null ? void 0 : pluginInstanceTyped.enabled) != null ? _e : false;
    if (isInstalled && isCurrentlyEnabled) {
      if (!this.state.enabledPlugins.includes(plugin.id)) {
        this.state.enabledPlugins.push(plugin.id);
      }
      this.state.disabledPlugins = this.state.disabledPlugins.filter((p) => p !== plugin.id);
    } else if (isInstalled && !isCurrentlyEnabled) {
      this.state.enabledPlugins = this.state.enabledPlugins.filter((p) => p !== plugin.id);
      if (!this.state.disabledPlugins.includes(plugin.id)) {
        this.state.disabledPlugins.push(plugin.id);
      }
    }
    const setting = new import_obsidian12.Setting(container).setName(plugin.name).setDesc(isCurrentlyEnabled ? "Installed and enabled" : "Installed but disabled");
    setting.nameEl.style.fontSize = "0.9em";
    setting.descEl.style.fontSize = "0.8em";
    const iconContainer = setting.controlEl.createDiv({ cls: "vault-cms-plugin-status" });
    if (isCurrentlyEnabled) {
      (0, import_obsidian12.setIcon)(iconContainer, "lucide-check-circle-2");
      setCssProps6(iconContainer, { color: "var(--text-success)" });
    } else {
      (0, import_obsidian12.setIcon)(iconContainer, "lucide-x-circle");
      setCssProps6(iconContainer, { color: "var(--text-error)" });
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Optional Plugins";
  }
  getDescription() {
    return "Configure optional plugins and detection";
  }
};

// src/ui/wizard/IgnoreStep.ts
var import_obsidian14 = require("obsidian");

// src/utils/ProjectOptimizer.ts
var import_obsidian13 = require("obsidian");
var path6 = __toESM(require("path"), 1);
var fs5 = __toESM(require("fs"), 1);
function setCssProps7(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var ProjectOptimizer = class {
  constructor(app, state) {
    this.app = app;
    this.state = state;
  }
  async getStatus() {
    var _a, _b;
    const status = {
      gitIgnoreStatus: "not-configured",
      viteIgnoreStatus: "not-configured"
    };
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) {
      console.debug("[Vault CMS] ProjectOptimizer: No projectRoot in state");
      return status;
    }
    const configDir = this.app.vault.configDir;
    console.debug("[Vault CMS] ProjectOptimizer: Checking status for root:", projectRoot, "configDir:", configDir);
    const gitIgnorePath = path6.join(projectRoot, ".gitignore");
    if (fs5.existsSync(gitIgnorePath)) {
      const content = fs5.readFileSync(gitIgnorePath, "utf8");
      const isConfigured = content.includes(`${configDir}/workspace.json`) || content.includes(`**/${configDir}/workspace.json`);
      console.debug("[Vault CMS] ProjectOptimizer: .gitignore exists, configured:", isConfigured);
      if (isConfigured) {
        status.gitIgnoreStatus = "configured";
      }
    } else {
      console.debug("[Vault CMS] ProjectOptimizer: .gitignore NOT found at:", gitIgnorePath);
    }
    const astroConfigNames = ["astro.config.ts", "astro.config.mjs", "astro.config.js", "astro.config.mts", "astro.config.cjs"];
    let resolvedViteConfigPath = "";
    for (const name of astroConfigNames) {
      const p = path6.join(projectRoot, name);
      if (fs5.existsSync(p)) {
        resolvedViteConfigPath = p;
        break;
      }
    }
    if (!resolvedViteConfigPath && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath)) {
      resolvedViteConfigPath = this.state.projectDetection.configFilePath;
    }
    if (resolvedViteConfigPath && fs5.existsSync(resolvedViteConfigPath)) {
      console.debug("[Vault CMS] ProjectOptimizer: Checking Vite config at:", resolvedViteConfigPath);
      const content = fs5.readFileSync(resolvedViteConfigPath, "utf8");
      const hasWatchIgnored = content.includes("server.watch.ignored") || content.includes("ignored:");
      const hasConfigDir = content.includes(configDir);
      const hasBasesPattern = content.includes("bases") || content.includes("home") || content.includes("base");
      console.debug("[Vault CMS] ProjectOptimizer: Vite config has patterns:", { hasWatchIgnored, hasConfigDir, hasBasesPattern });
      if (hasWatchIgnored && (hasConfigDir || hasBasesPattern)) {
        status.viteIgnoreStatus = "configured";
      }
    } else {
      console.debug("[Vault CMS] ProjectOptimizer: No valid Astro config found to check");
    }
    return status;
  }
  async configureGitIgnore() {
    var _a;
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) {
      console.error("[Vault CMS] ProjectOptimizer: No projectRoot for Git configuration");
      return false;
    }
    const configDir = this.app.vault.configDir;
    const gitIgnorePath = path6.join(projectRoot, ".gitignore");
    const rules = `
# Obsidian workspace files
**/${configDir}/workspace.json
**/${configDir}/workspace-mobile.json
`;
    console.debug("[Vault CMS] ProjectOptimizer: Configuring Git ignore at:", gitIgnorePath);
    try {
      if (fs5.existsSync(gitIgnorePath)) {
        let content = fs5.readFileSync(gitIgnorePath, "utf8");
        const hasNewPattern = content.includes(`**/${configDir}/workspace.json`);
        const hasOldPattern = content.includes(`*/${configDir}/workspace.json`) || content.includes(`${configDir}/workspace.json`);
        if (hasOldPattern && !hasNewPattern) {
          console.debug("[Vault CMS] ProjectOptimizer: Updating old Git patterns");
          content = content.replace(new RegExp(`\\*?/?${configDir}/workspace\\.json`, "g"), `**/${configDir}/workspace.json`);
          content = content.replace(new RegExp(`\\*?/?${configDir}/workspace-mobile\\.json`, "g"), `**/${configDir}/workspace-mobile.json`);
          fs5.writeFileSync(gitIgnorePath, content, "utf8");
        } else if (!hasNewPattern) {
          console.debug("[Vault CMS] ProjectOptimizer: Adding new Git patterns");
          content += rules;
          fs5.writeFileSync(gitIgnorePath, content, "utf8");
        } else {
          console.debug("[Vault CMS] ProjectOptimizer: Git patterns already present");
        }
      } else {
        console.debug("[Vault CMS] ProjectOptimizer: Creating new .gitignore");
        fs5.writeFileSync(gitIgnorePath, rules, "utf8");
      }
      return true;
    } catch (error) {
      console.error("[Vault CMS] Failed to update .gitignore:", error);
      throw error;
    }
  }
  async configureViteIgnore() {
    var _a, _b;
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) return false;
    const configDir = this.app.vault.configDir;
    const astroConfigNames = ["astro.config.ts", "astro.config.mjs", "astro.config.js", "astro.config.mts", "astro.config.cjs"];
    let resolvedConfigPath = "";
    let configFileName = "";
    for (const name of astroConfigNames) {
      const p = path6.join(projectRoot, name);
      if (fs5.existsSync(p)) {
        resolvedConfigPath = p;
        configFileName = name;
        break;
      }
    }
    if (!resolvedConfigPath && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath)) {
      resolvedConfigPath = this.state.projectDetection.configFilePath;
      configFileName = path6.basename(resolvedConfigPath);
    }
    if (!resolvedConfigPath || !fs5.existsSync(resolvedConfigPath)) {
      console.error("[Vault CMS] ProjectOptimizer: Vite config NOT found in:", projectRoot);
      throw new Error(`Astro config file not found in: ${projectRoot}`);
    }
    console.debug("[Vault CMS] ProjectOptimizer: Configuring Vite ignore at:", resolvedConfigPath);
    try {
      const content = fs5.readFileSync(resolvedConfigPath, "utf8");
      if (content.includes("server.watch.ignored") && content.includes(configDir)) {
        return true;
      }
      const exportIdx = content.lastIndexOf("export default");
      let startIndex = -1;
      let endIndex = -1;
      let configBody = "";
      let isWholeFile = false;
      if (exportIdx !== -1) {
        startIndex = content.indexOf("{", exportIdx);
        if (startIndex !== -1) {
          let braceCount = 0;
          for (let i = startIndex; i < content.length; i++) {
            if (content[i] === "{") braceCount++;
            else if (content[i] === "}") braceCount--;
            if (braceCount === 0) {
              endIndex = i;
              break;
            }
          }
          if (endIndex !== -1) {
            configBody = content.substring(startIndex + 1, endIndex);
          }
        }
      }
      if (!configBody && (content.includes("vite:") || content.includes("server:"))) {
        configBody = content;
        isWholeFile = true;
      }
      if (configBody) {
        if (configBody.includes("vite:")) {
          if (configBody.includes("server:")) {
            if (configBody.includes("watch:")) {
              if (configBody.includes("ignored:")) {
                if (!configBody.includes(configDir)) {
                  const ignorePatterns = `'**/${configDir}/**', '**/_bases/**', '**/bases/**', '**/_home/**', '**/home/**', '**/_base/**', '**/base/**'`;
                  configBody = configBody.replace(/ignored:\s*\[([^\]]*)\]/, (_m, p1) => {
                    const existing = p1.trim();
                    const separator = existing ? ", " : "";
                    return `ignored: [${existing}${separator}${ignorePatterns}]`;
                  });
                }
              } else {
                configBody = configBody.replace(/watch:\s*\{/, `watch: {
      ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**', '**/_home/**', '**/home/**', '**/_base/**', '**/base/**'],`);
              }
            } else {
              configBody = configBody.replace(/server:\s*\{/, `server: {
    watch: {
      ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**', '**/_home/**', '**/home/**', '**/_base/**', '**/base/**']
    },`);
            }
          } else {
            configBody = configBody.replace(/vite:\s*\{/, `vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**', '**/_home/**', '**/home/**', '**/_base/**', '**/base/**']
      }
    },`);
          }
        } else {
          if (isWholeFile) {
            if (content.includes("defineConfig")) {
              configBody = configBody.replace(/defineConfig\s*\(\s*\{/, `defineConfig({
  vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**', '**/_home/**', '**/home/**', '**/_base/**', '**/base/**']
      }
    }
  },`);
            } else {
              throw new Error(`Could not find a clear place to insert Vite config in ${configFileName}.`);
            }
          } else {
            configBody = `
  vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**', '**/_home/**', '**/home/**', '**/_base/**', '**/base/**']
      }
    }
  },` + configBody;
          }
        }
        const updatedContent = isWholeFile ? configBody : content.substring(0, startIndex + 1) + configBody + content.substring(endIndex);
        fs5.writeFileSync(resolvedConfigPath, updatedContent, "utf8");
        return true;
      } else {
        throw new Error(`Could not parse configuration in ${configFileName}.`);
      }
    } catch (error) {
      console.error(`ProjectOptimizer: Error updating ${configFileName}:`, error);
      throw error;
    }
  }
  renderStatus(container, status) {
    const statusEl = container.createDiv({ cls: "vault-cms-plugin-status" });
    if (status === "configured") {
      (0, import_obsidian13.setIcon)(statusEl, "lucide-check-circle-2");
      setCssProps7(statusEl, { color: "var(--text-success)" });
    } else {
      (0, import_obsidian13.setIcon)(statusEl, "lucide-alert-circle");
      setCssProps7(statusEl, { color: "var(--text-warning)" });
    }
  }
};

// src/ui/wizard/IgnoreStep.ts
var IgnoreStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.optimizer = new ProjectOptimizer(app, state);
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const status = await this.optimizer.getStatus();
    this.state.ignoreConfig.gitIgnoreConfigured = status.gitIgnoreStatus === "configured";
    this.state.ignoreConfig.viteIgnoreConfigured = status.viteIgnoreStatus === "configured";
    containerEl.createEl("h2", { text: "Project optimization (optional)" });
    containerEl.createEl("p", {
      text: "Optimize your project by ignoring Obsidian-specific files in Git and Vite."
    });
    this.gitSetting = new import_obsidian14.Setting(containerEl);
    this.updateGitSetting(status.gitIgnoreStatus);
    this.viteSetting = new import_obsidian14.Setting(containerEl);
    this.updateViteSetting(status.viteIgnoreStatus);
    return Promise.resolve();
  }
  updateGitSetting(status) {
    this.gitSetting.setName("Ignore workspace files in Git").setDesc("Add Obsidian workspace files to .gitignore to prevent them from being tracked.").clear();
    this.gitSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureGitIgnore();
          this.state.ignoreConfig.gitIgnoreConfigured = true;
          new import_obsidian14.Notice(".gitignore updated");
          const newStatus = await this.optimizer.getStatus();
          this.updateGitSetting(newStatus.gitIgnoreStatus);
        } catch (error) {
          new import_obsidian14.Notice(`Failed to update .gitignore: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.gitSetting.controlEl, status);
  }
  updateViteSetting(status) {
    this.viteSetting.setName("Ignore workspace and Home Base folders in Vite").setDesc("Configure Vite to ignore Obsidian and Home Base folders.").clear();
    this.viteSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureViteIgnore();
          this.state.ignoreConfig.viteIgnoreConfigured = true;
          new import_obsidian14.Notice("Vite optimization applied");
          const newStatus = await this.optimizer.getStatus();
          this.updateViteSetting(newStatus.viteIgnoreStatus);
        } catch (error) {
          new import_obsidian14.Notice(`Failed to update Vite config: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.viteSetting.controlEl, status);
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Project optimization (optional)";
  }
  getDescription() {
    return "Configure project-level ignores";
  }
};

// src/ui/wizard/GitSetupStep.ts
var import_obsidian20 = require("obsidian");
init_GitManager();

// src/utils/BasesCMSConfig.ts
var import_obsidian16 = require("obsidian");
var BasesCMSConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
  }
  async resolveBaseFilePath() {
    const candidateFolders = ["_bases", "bases", "_home", "home", "_base", "base"];
    const candidateFiles = ["Home.base", "home.base", "index.base"];
    for (const folder of candidateFolders) {
      for (const file of candidateFiles) {
        const fullPath = `${folder}/${file}`;
        if (await this.app.vault.adapter.exists(fullPath)) {
          return fullPath;
        }
      }
    }
    for (const folder of candidateFolders) {
      if (await this.app.vault.adapter.exists(folder)) {
        return `${folder}/Home.base`;
      }
    }
    return "_bases/Home.base";
  }
  async createOrUpdateBaseFile(contentTypes, frontmatterProperties, defaultContentTypeId, projectDetection, enableMdxSupport) {
    const baseFilePath = await this.resolveBaseFilePath();
    const folderPath = baseFilePath.split("/")[0];
    const basesFolder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!basesFolder) {
      try {
        await this.app.vault.createFolder(folderPath);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (!errorMessage || !errorMessage.includes("already exists")) {
          console.warn(`BasesCMSConfig: Could not create ${folderPath} folder:`, error);
        }
      }
    }
    const baseFileAbstract = this.app.vault.getAbstractFileByPath(baseFilePath);
    let baseFile = baseFileAbstract instanceof import_obsidian16.TFile ? baseFileAbstract : null;
    let existingBase = null;
    if (baseFile) {
      try {
        const content = await this.app.vault.read(baseFile);
        existingBase = parse2(content);
      } catch (error) {
        console.error("BasesCMSConfig: Failed to parse existing base file:", error);
      }
    }
    const enabledTypes = contentTypes.filter((ct) => ct.enabled);
    console.debug("BasesCMSConfig: Generating base content for", contentTypes.length, "content types");
    console.debug("BasesCMSConfig: Enabled content types:", enabledTypes.map((ct) => ct.name));
    const baseContent = this.generateBaseContent(contentTypes, frontmatterProperties, defaultContentTypeId, existingBase, projectDetection, enableMdxSupport);
    const viewMatches = baseContent.match(/^\s*-\s+type:\s+bases-cms/gm);
    const viewCount = viewMatches ? viewMatches.length : 0;
    console.debug("BasesCMSConfig: Generated", viewCount, "views in base content");
    const baseFileAbstract2 = this.app.vault.getAbstractFileByPath(baseFilePath);
    baseFile = baseFileAbstract2 instanceof import_obsidian16.TFile ? baseFileAbstract2 : null;
    if (baseFile) {
      console.debug(`BasesCMSConfig: Modifying existing ${baseFilePath} file`);
      try {
        await this.app.vault.modify(baseFile, baseContent);
        console.debug(`BasesCMSConfig: Successfully modified ${baseFilePath} file`);
        return;
      } catch (error) {
        console.error("BasesCMSConfig: Failed to modify file:", error);
        throw error;
      }
    }
    console.debug(`BasesCMSConfig: Creating new ${baseFilePath} file`);
    try {
      await this.app.vault.create(baseFilePath, baseContent);
      console.debug(`BasesCMSConfig: Successfully created ${baseFilePath} file`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
        console.debug("BasesCMSConfig: File existed, attempting direct modify via path");
        try {
          const adapter = this.app.vault.adapter;
          if (adapter && typeof adapter.write === "function") {
            await adapter.write(baseFilePath, baseContent);
            console.debug("BasesCMSConfig: Successfully wrote Home.base file via adapter");
          } else {
            console.debug("BasesCMSConfig: Adapter write not available, retrying getAbstractFileByPath");
            for (let i = 0; i < 10; i++) {
              await new Promise((resolve9) => setTimeout(resolve9, 200));
              const retryFileAbstract = this.app.vault.getAbstractFileByPath(baseFilePath);
              const retryFile = retryFileAbstract instanceof import_obsidian16.TFile ? retryFileAbstract : null;
              if (retryFile) {
                await this.app.vault.modify(retryFile, baseContent);
                console.debug(`BasesCMSConfig: Successfully modified Home.base file on retry ${i + 1}`);
                return;
              }
            }
            console.error("BasesCMSConfig: File exists but cannot be found after all retries");
            throw new Error(`File exists but cannot be accessed. Please try again or manually edit ${baseFilePath}`);
          }
        } catch (writeError) {
          console.error("BasesCMSConfig: Failed to write file via adapter:", writeError);
          throw writeError;
        }
      } else {
        console.error("BasesCMSConfig: Failed to create base file:", error);
        throw error;
      }
    }
  }
  generateBaseContent(contentTypes, frontmatterProperties, defaultContentTypeId, existingBase, projectDetection, enableMdxSupport) {
    const lines = [];
    const defaultContentType = defaultContentTypeId ? contentTypes.find((ct) => ct.id === defaultContentTypeId && ct.enabled) : null;
    if (defaultContentType) {
      lines.push(`defaultView: "${defaultContentType.name}"`);
    }
    if (existingBase == null ? void 0 : existingBase.formulas) {
      lines.push("formulas:");
      for (const [key, value] of Object.entries(existingBase.formulas)) {
        if (typeof value === "string") {
          lines.push(`  ${key}: |-`);
          const formulaLines = value.split("\n");
          for (const formulaLine of formulaLines) {
            lines.push(`    ${formulaLine}`);
          }
        }
      }
      lines.push("");
    }
    lines.push("filters:");
    if (enableMdxSupport) {
      lines.push("  or:");
      lines.push('    - file.ext == "md"');
      lines.push('    - file.ext == "mdx"');
    } else {
      lines.push("  and:");
      lines.push('    - file.ext == "md"');
    }
    lines.push("");
    const allProperties = /* @__PURE__ */ new Set();
    for (const contentType of contentTypes) {
      const props = frontmatterProperties[contentType.id];
      if (props) {
        if (props.titleProperty) allProperties.add(`note.${props.titleProperty}`);
        if (props.dateProperty) allProperties.add(`note.${props.dateProperty}`);
        if (props.descriptionProperty) allProperties.add(`note.${props.descriptionProperty}`);
        if (props.tagsProperty) allProperties.add(`note.${props.tagsProperty}`);
        if (props.draftProperty) allProperties.add(`note.${props.draftProperty}`);
        if (props.imageProperty) allProperties.add(`note.${props.imageProperty}`);
      }
    }
    allProperties.add("note.title");
    allProperties.add("note.date");
    allProperties.add("note.pubDate");
    allProperties.add("note.draft");
    allProperties.add("file.fullname");
    allProperties.add("file.name");
    if (existingBase == null ? void 0 : existingBase.properties) {
      for (const prop of Object.keys(existingBase.properties)) {
        if (prop.startsWith("formula.")) {
          allProperties.add(prop);
        }
      }
    }
    if (allProperties.size > 0) {
      lines.push("properties:");
      const existingProps = (existingBase == null ? void 0 : existingBase.properties) || {};
      for (const prop of Array.from(allProperties).sort()) {
        lines.push(`  ${prop}:`);
        const existingProp = existingProps[prop];
        if (existingProp == null ? void 0 : existingProp.displayName) {
          lines.push(`    displayName: ${existingProp.displayName}`);
        } else if (prop === "file.fullname") {
          lines.push(`    displayName: Full File Name`);
        } else {
          const propName = prop.replace("note.", "").replace("file.", "");
          lines.push(`    displayName: ${this.capitalizeFirst(propName)}`);
        }
      }
      lines.push("");
    }
    lines.push("views:");
    const existingViews = (existingBase == null ? void 0 : existingBase.views) || [];
    const viewsByName = /* @__PURE__ */ new Map();
    for (const view of existingViews) {
      if (view.name) viewsByName.set(view.name, view);
    }
    const finalViews = [];
    const processedViewNames = /* @__PURE__ */ new Set();
    const enabledTypes = contentTypes.filter((ct) => ct.enabled);
    const defaultType = defaultContentTypeId ? enabledTypes.find((ct) => ct.id === defaultContentTypeId) : null;
    const otherTypes = enabledTypes.filter((ct) => ct !== defaultType);
    const processType = (ct) => {
      const props = frontmatterProperties[ct.id];
      if (!props) return;
      const existingView = viewsByName.get(ct.name);
      const generatedView = this.generateViewForContentType(ct, props, projectDetection);
      if (existingView) {
        const coreUpdates = {
          filters: generatedView.filters,
          newNoteLocation: generatedView.newNoteLocation,
          titleProperty: generatedView.titleProperty,
          dateProperty: generatedView.dateProperty,
          draftStatusProperty: generatedView.draftStatusProperty,
          tagsProperty: generatedView.tagsProperty,
          showTags: generatedView.showTags,
          showDraftStatus: generatedView.showDraftStatus,
          draftStatusReverse: generatedView.draftStatusReverse,
          draftStatusUseFilenamePrefix: generatedView.draftStatusUseFilenamePrefix
        };
        finalViews.push({ ...existingView, ...coreUpdates });
        processedViewNames.add(ct.name);
      } else {
        finalViews.push(generatedView);
        processedViewNames.add(ct.name);
      }
    };
    if (defaultType) processType(defaultType);
    for (const ct of otherTypes) processType(ct);
    for (const view of existingViews) {
      if (view.name === "Vault CMS Guide" || view.name === "Guide" || processedViewNames.has(view.name)) continue;
      finalViews.push(view);
    }
    let guideView = viewsByName.get("Vault CMS Guide") || viewsByName.get("Guide");
    if (guideView) {
      guideView = { ...guideView, name: "Vault CMS Guide" };
      finalViews.push(guideView);
    }
    for (const view of finalViews) {
      lines.push(...this.serializeView(view));
    }
    return lines.join("\n");
  }
  generateViewForContentType(contentType, props, projectDetection) {
    const folderPath = this.pathResolver.getBasesCMSFolderPath(contentType.folder, projectDetection);
    const view = {
      type: "bases-cms",
      name: contentType.name,
      filters: {
        and: [
          folderPath === "" || folderPath === "." ? 'file.folder == "/"' : `file.folder.startsWith("${folderPath}")`
        ]
      },
      imageFormat: "cover",
      showDate: true,
      customizeNewButton: true,
      newNoteLocation: folderPath,
      fallbackToEmbeds: "if-empty",
      propertyDisplay1: "file.fullname",
      showTextPreview: true,
      propertyLabels: "above",
      sort: [
        {
          property: props.dateProperty ? `note.${props.dateProperty}` : "file.ctime",
          direction: "DESC"
        }
      ]
    };
    if (props.titleProperty) {
      view.titleProperty = `note.${props.titleProperty}`;
    } else {
      view.titleProperty = `file.fullname`;
    }
    if (props.dateProperty) {
      view.dateProperty = `note.${props.dateProperty}`;
    } else {
      view.dateProperty = `file.ctime`;
    }
    if (props.descriptionProperty) {
      view.descriptionProperty = `note.${props.descriptionProperty}`;
    }
    if (props.imageProperty) {
      view.imageProperty = `note.${props.imageProperty}`;
    }
    view.showTags = !!props.tagsProperty;
    if (props.tagsProperty) {
      view.tagsProperty = `note.${props.tagsProperty}`;
    }
    view.showDraftStatus = !!props.hasDraftStatus;
    if (props.hasDraftStatus) {
      if (props.draftProperty) {
        view.draftStatusProperty = `note.${props.draftProperty}`;
        view.draftStatusReverse = props.draftLogic === "false-draft";
      } else {
        view.draftStatusUseFilenamePrefix = true;
      }
    }
    return view;
  }
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  /**
   * Serialize a view object to YAML lines (with proper indentation)
   */
  serializeView(view) {
    const viewLines = [];
    viewLines.push("  - type: bases-cms");
    viewLines.push(`    name: "${view.name}"`);
    if (view.filters) {
      viewLines.push("    filters:");
      if (view.filters.and) {
        if (view.filters.and.length === 0) {
          viewLines.push("      and: []");
        } else {
          viewLines.push("      and:");
          for (const filter of view.filters.and) {
            if (typeof filter === "string") {
              viewLines.push(`        - ${filter}`);
            } else if (typeof filter === "object") {
              for (const [key, value] of Object.entries(filter)) {
                const valueStr = typeof value === "string" ? `"${value}"` : String(value);
                viewLines.push(`        - ${key}: ${valueStr}`);
              }
            }
          }
        }
      }
    }
    if (view.groupBy) {
      viewLines.push("    groupBy:");
      if (typeof view.groupBy === "object") {
        if (view.groupBy.property) viewLines.push(`      property: ${view.groupBy.property}`);
        if (view.groupBy.direction) viewLines.push(`      direction: ${view.groupBy.direction}`);
      } else if (typeof view.groupBy === "string") {
        viewLines.push(`      ${view.groupBy}`);
      }
    }
    if (view.order) {
      if (view.order.length === 0) {
        viewLines.push("    order: []");
      } else {
        viewLines.push("    order:");
        for (const orderItem of view.order) {
          viewLines.push(`      - ${orderItem}`);
        }
      }
    }
    if (view.sort) {
      if (view.sort.length === 0) {
        viewLines.push("    sort: []");
      } else {
        viewLines.push("    sort:");
        for (const sortItem of view.sort) {
          if (typeof sortItem === "object" && sortItem.property) {
            viewLines.push(`      - property: ${sortItem.property}`);
            viewLines.push(`        direction: ${sortItem.direction || "ASC"}`);
          }
        }
      }
    }
    const skipProps = ["type", "name", "filters", "groupBy", "order", "sort"];
    for (const prop of Object.keys(view)) {
      if (skipProps.includes(prop) || view[prop] === void 0) {
        continue;
      }
      const value = view[prop];
      if (value === null) {
        viewLines.push(`    ${prop}: null`);
      } else if (typeof value === "boolean") {
        viewLines.push(`    ${prop}: ${value}`);
      } else if (typeof value === "number") {
        viewLines.push(`    ${prop}: ${value}`);
      } else if (typeof value === "string") {
        if (value === "") {
          viewLines.push(`    ${prop}: ""`);
          continue;
        }
        const isPropertyRef = (prop.includes("Property") || prop.startsWith("propertyDisplay")) && (value.startsWith("note.") || value.startsWith("file."));
        if (isPropertyRef) {
          viewLines.push(`    ${prop}: ${value}`);
        } else if (prop === "newNoteLocation") {
          viewLines.push(`    ${prop}: "${value}"`);
        } else {
          viewLines.push(`    ${prop}: "${value}"`);
        }
      }
    }
    return viewLines;
  }
};

// src/utils/SEOConfig.ts
var SEOConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
    this.safeWriter = new SafeConfigWriter(app);
  }
  generateSEOConfig(contentTypes, frontmatterProperties, projectDetection, enableMdxSupport) {
    const firstType = contentTypes.find((ct) => ct.enabled);
    const firstProps = firstType ? frontmatterProperties[firstType.id] : void 0;
    const scanDirectories = contentTypes.filter((ct) => ct.enabled).map((ct) => this.pathResolver.getFolderPathFromVaultRoot(ct.folder, projectDetection)).join(",");
    const config = {
      // Only set titleProperty if it exists (not blank) - this comes from the wizard
      titleProperty: (firstProps == null ? void 0 : firstProps.titleProperty) && firstProps.titleProperty.trim() !== "" ? firstProps.titleProperty : "title",
      // Default fallback
      // Only set descriptionProperty if it exists (not blank) - this comes from the wizard
      descriptionProperty: (firstProps == null ? void 0 : firstProps.descriptionProperty) && firstProps.descriptionProperty.trim() !== "" ? firstProps.descriptionProperty : void 0,
      scanDirectories,
      // Don't set these - we don't collect them in the wizard
      keywordProperty: void 0,
      useFilenameAsTitle: false,
      useFilenameAsSlug: true,
      enableMDXSupport: enableMdxSupport != null ? enableMdxSupport : false
    };
    return config;
  }
  async saveConfig(config) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const seoPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["seo"];
      if (seoPlugin && seoPlugin.settings) {
        const pluginSettings = seoPlugin.settings;
        if (config.scanDirectories) {
          pluginSettings.scanDirectories = config.scanDirectories;
        }
        if (config.titleProperty !== void 0) {
          pluginSettings.titleProperty = config.titleProperty;
        }
        if (config.descriptionProperty !== void 0) {
          pluginSettings.descriptionProperty = config.descriptionProperty;
        }
        if (config.enableMDXSupport !== void 0) {
          pluginSettings.enableMDXSupport = config.enableMDXSupport;
        }
        if (typeof seoPlugin.saveSettings === "function") {
          await seoPlugin.saveSettings();
          console.debug("SEOConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save SEO config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "seo";
    try {
      let existingData = await this.safeWriter.readConfig(pluginId);
      if (!existingData) {
        existingData = {};
      }
      const mergedData = {
        ...existingData,
        // Always update scanDirectories
        scanDirectories: config.scanDirectories,
        // Update titleProperty if provided (from wizard)
        ...config.titleProperty !== void 0 && { titleProperty: config.titleProperty },
        // Update descriptionProperty if provided (from wizard)
        ...config.descriptionProperty !== void 0 && { descriptionProperty: config.descriptionProperty },
        // Update enableMDXSupport if provided (from wizard)
        ...config.enableMDXSupport !== void 0 && { enableMDXSupport: config.enableMDXSupport }
        // All other properties (keywordProperty, useFilenameAsTitle, useFilenameAsSlug, etc.)
        // are preserved from existingData - we don't collect them in the wizard
      };
      const success = await this.safeWriter.writeConfig(pluginId, mergedData, {
        showNotice: true,
        createBackup: true
      });
      if (!success) {
        throw new Error("Failed to save SEO configuration");
      }
      console.debug("SEOConfig: Successfully saved SEO plugin configuration");
    } catch (error) {
      console.error("Failed to save SEO config (fallback):", error);
      throw error;
    }
  }
};

// src/utils/PropertyOverFileNameConfig.ts
var import_obsidian17 = require("obsidian");
var PropertyOverFileNameConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(config) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const propertyOverFileNamePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["property-over-file-name"];
      if (propertyOverFileNamePlugin && propertyOverFileNamePlugin.settings) {
        const pluginSettings = propertyOverFileNamePlugin.settings;
        console.debug("PropertyOverFileNameConfig: Using plugin.saveSettings() method");
        console.debug("PropertyOverFileNameConfig: Input config.enableMdxSupport =", config.enableMdxSupport);
        if (config.propertyKey) {
          pluginSettings.propertyKey = config.propertyKey;
        }
        if (config.enableMdxSupport !== void 0) {
          pluginSettings.enableMdxSupport = config.enableMdxSupport;
          console.debug("PropertyOverFileNameConfig: Set pluginSettings.enableMdxSupport to", config.enableMdxSupport);
        } else {
          console.warn("PropertyOverFileNameConfig: config.enableMdxSupport is undefined!");
        }
        if (typeof propertyOverFileNamePlugin.saveSettings === "function") {
          await propertyOverFileNamePlugin.saveSettings();
          console.debug("PropertyOverFileNameConfig: Successfully saved via plugin.saveSettings()");
          return;
        } else {
          console.warn("PropertyOverFileNameConfig: Plugin saveSettings not available, using fallback");
        }
      } else {
        console.warn("PropertyOverFileNameConfig: Plugin not found or settings not available, using fallback");
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Property Over File Name config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "property-over-file-name";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      let existingData = {};
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian17.TFile) {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      }
      console.debug("PropertyOverFileNameConfig: Using fallback file method");
      console.debug("PropertyOverFileNameConfig: Input config =", JSON.stringify(config));
      console.debug("PropertyOverFileNameConfig: Input config.enableMdxSupport =", config.enableMdxSupport);
      console.debug("PropertyOverFileNameConfig: Existing data =", JSON.stringify(existingData));
      const mergedData = {
        ...existingData,
        ...config
      };
      if (config.enableMdxSupport !== void 0) {
        mergedData.enableMdxSupport = config.enableMdxSupport;
        console.debug("PropertyOverFileNameConfig: Explicitly set enableMdxSupport to", config.enableMdxSupport);
      } else {
        console.warn("PropertyOverFileNameConfig: config.enableMdxSupport is undefined!");
      }
      console.debug("PropertyOverFileNameConfig: Final mergedData.enableMdxSupport =", mergedData.enableMdxSupport);
      console.debug("PropertyOverFileNameConfig: Final mergedData =", JSON.stringify(mergedData));
      if (dataFile instanceof import_obsidian17.TFile) {
        await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
      } else {
        const pluginDir = `${configDir}/plugins/${pluginId}`;
        const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
        if (!pluginDirFile) {
          try {
            await this.app.vault.createFolder(pluginDir);
          } catch (error) {
            if (error instanceof Error && !error.message.includes("already exists")) {
              throw error;
            }
          }
        }
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      }
    } catch (error) {
      console.error("Failed to save Property Over File Name config (fallback):", error);
      throw error;
    }
  }
};

// src/utils/UITweakerConfig.ts
var import_obsidian18 = require("obsidian");
var UITweakerConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(enableMdxSupport) {
    var _a;
    const pluginId = "ui-tweaker";
    try {
      const plugins = this.app.plugins;
      const uiTweakerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (uiTweakerPlugin && uiTweakerPlugin.settings) {
        console.debug("UITweakerConfig: Using plugin.settings API");
        const settings = uiTweakerPlugin.settings;
        this.forceMdxUpdate(settings, enableMdxSupport);
        if (typeof uiTweakerPlugin.saveSettings === "function") {
          await uiTweakerPlugin.saveSettings();
          console.debug("UITweakerConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("UITweakerConfig: Plugin API not available, using fallback file method");
      await this.saveConfigFallback(enableMdxSupport);
    } catch (error) {
      console.error("Failed to save UI Tweaker config:", error);
      await this.saveConfigFallback(enableMdxSupport);
    }
  }
  forceMdxUpdate(settings, enableMdxSupport) {
    const mdxFileTypes = enableMdxSupport ? "md,mdx" : "md";
    if (!settings.tabBarCommands || !Array.isArray(settings.tabBarCommands)) {
      settings.tabBarCommands = [];
    }
    const tabBarCommands = settings.tabBarCommands;
    const toolbarCommandIndex = tabBarCommands.findIndex((cmd) => cmd.id === "editing-toolbar:hide-show-menu");
    if (toolbarCommandIndex !== -1) {
      tabBarCommands[toolbarCommandIndex] = {
        ...tabBarCommands[toolbarCommandIndex],
        "showOnFileTypes": mdxFileTypes
      };
      console.debug(`UITweakerConfig: Updated existing toolbar command showOnFileTypes to ${mdxFileTypes}`);
    } else {
      tabBarCommands.push({
        "id": "editing-toolbar:hide-show-menu",
        "icon": "lucide-panel-top-open",
        "name": "Toggle editing toolbar",
        "displayName": "Editing Toolbar: Hide/Show ",
        "mode": "desktop",
        "toggleIcon": "lucide-panel-top-close",
        "showOnFileTypes": mdxFileTypes
      });
      console.debug(`UITweakerConfig: Added missing toolbar command with showOnFileTypes=${mdxFileTypes}`);
    }
  }
  async saveConfigFallback(enableMdxSupport) {
    const pluginId = "ui-tweaker";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian18.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing ui-tweaker data.json:", error);
      }
    }
    this.forceMdxUpdate(existingData, enableMdxSupport);
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(existingData, null, 2);
    if (dataFile instanceof import_obsidian18.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("UITweakerConfig: Successfully saved ui-tweaker config via fallback");
  }
};

// src/utils/DataFilesEditorConfig.ts
var import_obsidian19 = require("obsidian");
var DataFilesEditorConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(enabled) {
    var _a;
    const pluginId = "data-files-editor";
    try {
      const plugins = this.app.plugins;
      const plugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (plugin && plugin.settings) {
        console.debug("DataFilesEditorConfig: Using plugin.settings API");
        const settings = plugin.settings;
        this.applySettings(settings, enabled);
        if (typeof plugin.saveSettings === "function") {
          await plugin.saveSettings();
          console.debug("DataFilesEditorConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("DataFilesEditorConfig: Plugin API not available or settings not loaded, using fallback file method");
      await this.saveConfigFallback(enabled);
    } catch (error) {
      console.error("Failed to save Data Files Editor config:", error);
      await this.saveConfigFallback(enabled);
    }
  }
  applySettings(settings, enabled) {
    settings.doLoadJson = enabled;
    settings.doCreateJson = enabled;
    settings.doLoadAstro = enabled;
    settings.doCreateAstro = enabled;
    settings.doLoadTxt = false;
    settings.doCreateTxt = false;
    settings.doLoadXml = false;
    settings.doCreateXml = false;
    settings.doLoadYaml = false;
    settings.doCreateYaml = false;
    settings.doLoadTs = false;
    settings.doCreateTs = false;
    settings.doLoadCss = false;
    settings.doCreateCss = false;
    settings.doLoadHtml = false;
    settings.doCreateHtml = false;
    settings.doLoadJs = false;
    settings.doCreateJs = false;
    settings.doLoadMjs = false;
    settings.doCreateMjs = false;
    settings.doAutosaveFiles = true;
    settings.lineWrapping = true;
  }
  async saveConfigFallback(enabled) {
    const pluginId = "data-files-editor";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian19.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing data-files-editor data.json:", error);
      }
    }
    this.applySettings(existingData, enabled);
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(existingData, null, 2);
    if (dataFile instanceof import_obsidian19.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("DataFilesEditorConfig: Successfully saved data-files-editor config via fallback");
  }
};

// src/utils/ConfigFlushService.ts
var ConfigFlushService = class {
  constructor(app) {
    this.app = app;
    this.basesCMSConfigurator = new BasesCMSConfigurator(app);
    this.astroComposerConfigurator = new AstroComposerConfigurator(app);
    this.seoConfigurator = new SEOConfigurator(app);
    this.propertyOverFileNameConfigurator = new PropertyOverFileNameConfigurator(app);
    this.uiTweakerConfigurator = new UITweakerConfigurator(app);
    this.imageManagerConfigurator = new ImageManagerConfigurator(app);
    this.homeBaseConfigurator = new HomeBaseConfigurator(app);
    this.explorerFocusConfigurator = new ExplorerFocusConfigurator(app);
    this.dataFilesEditorConfigurator = new DataFilesEditorConfigurator(app);
    this.editingToolbarConfigurator = new EditingToolbarConfigurator(app);
  }
  /**
   * Flushes current wizard state to various plugin configuration files.
   * This ensures the disk reflects the current wizard configuration without
   * needing to reach the finalization step.
   */
  async flush(state) {
    console.debug("ConfigFlushService: Starting configuration flush");
    await this.basesCMSConfigurator.createOrUpdateBaseFile(
      state.contentTypes,
      state.frontmatterProperties,
      state.defaultContentTypeId,
      state.projectDetection,
      state.enableMdxSupport === true
    );
    if (state.projectDetection) {
      const astroConfig = await this.astroComposerConfigurator.configureAstroComposer(
        state.contentTypes,
        state.frontmatterProperties,
        state.projectDetection.projectRoot,
        state.projectDetection.configFilePath,
        state.defaultContentTypeId,
        state.projectDetection,
        state.enableMdxSupport
      );
      state.astroComposerConfig = astroConfig;
      await this.astroComposerConfigurator.saveConfig(astroConfig);
    }
    const seoConfig = this.seoConfigurator.generateSEOConfig(
      state.contentTypes,
      state.frontmatterProperties,
      state.projectDetection,
      state.enableMdxSupport
    );
    state.seoConfig = seoConfig;
    await this.seoConfigurator.saveConfig(seoConfig);
    const firstType = state.contentTypes.find((ct) => ct.enabled);
    const firstProps = firstType ? state.frontmatterProperties[firstType.id] : void 0;
    if (firstProps && firstProps.titleProperty) {
      state.propertyOverFileName.propertyKey = firstProps.titleProperty;
    }
    state.propertyOverFileName.enableMdxSupport = state.enableMdxSupport === true;
    await this.propertyOverFileNameConfigurator.saveConfig(state.propertyOverFileName);
    await this.uiTweakerConfigurator.saveConfig(state.enableMdxSupport === true);
    if (state.enabledPlugins.includes("image-manager") || Object.keys(state.imageManager).length > 0) {
      await this.imageManagerConfigurator.resolveAndSyncImageProperty(state);
      await this.imageManagerConfigurator.saveConfig(state.imageManager);
    }
    if (state.enabledPlugins.includes("home-base") || Object.keys(state.homeBase).length > 0) {
      await this.homeBaseConfigurator.saveConfig(state.homeBase);
    }
    if (state.enabledPlugins.includes("explorer-focus") || Object.keys(state.explorerFocus).length > 0) {
      await this.explorerFocusConfigurator.saveConfig(state.explorerFocus);
    }
    await this.editingToolbarConfigurator.toggleVisibility(this.app, state.enableEditingToolbar);
    await this.dataFilesEditorConfigurator.saveConfig(state.enableExtendedFileTypes === true);
    console.debug("ConfigFlushService: Configuration flush complete");
  }
};

// src/ui/wizard/GitSetupStep.ts
var path8 = __toESM(require("path"), 1);
var GitSetupStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.hasAdvanced = false;
    this.gitManager = GitManager;
    this.configFlushService = new ConfigFlushService(app);
    this.safeConfigWriter = new SafeConfigWriter(app);
    this.showNextButton = false;
  }
  getAbsoluteProjectRoot() {
    var _a;
    const relativeRoot = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) || ".";
    if (path8.isAbsolute(relativeRoot)) {
      return relativeRoot;
    }
    const adapter = this.app.vault.adapter;
    const vaultRoot = adapter.getBasePath ? adapter.getBasePath() : "";
    return path8.resolve(vaultRoot, relativeRoot);
  }
  async display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Git Integration" });
    containerEl.createEl("p", {
      text: "Connect your project to GitHub to enable sync and deployment. Note: if you skip this step, the Deployment step will also be skipped.",
      attr: { style: "font-style: italic; opacity: 0.8; margin-bottom: 2rem;" }
    });
    const projectRoot = this.getAbsoluteProjectRoot();
    const rootInfo = containerEl.createDiv({ cls: "git-root-info", attr: { style: "margin-bottom: 1rem;" } });
    rootInfo.createEl("b", { text: "Project Root: " });
    rootInfo.createSpan({ text: projectRoot });
    const statusEl = containerEl.createDiv({
      cls: "git-status-message",
      attr: { style: "margin-bottom: 2rem; padding: 1rem; border: 1px solid var(--background-modifier-border); border-radius: 4px; min-height: 50px;" }
    });
    statusEl.createEl("i", { text: "Checking Git status...", attr: { style: "opacity: 0.5;" } });
    let isRepo = false;
    let remoteUrl = null;
    if (projectRoot) {
      isRepo = await this.gitManager.isRepo(projectRoot);
      if (isRepo) {
        remoteUrl = await this.gitManager.getRemoteUrl(projectRoot);
      }
    }
    statusEl.empty();
    if (isRepo) {
      statusEl.createEl("b", { text: "Status: " });
      statusEl.createSpan({
        text: "Git is already initialized.",
        attr: { style: "color: var(--text-success); font-weight: bold;" }
      });
      if (remoteUrl) {
        const remoteEl = statusEl.createDiv({ attr: { style: "margin-top: 0.5rem;" } });
        remoteEl.createEl("b", { text: "Remote: " });
        remoteEl.createSpan({ text: remoteUrl });
      }
    } else {
      statusEl.createEl("b", { text: "Status: " });
      statusEl.createSpan({ text: "Not a Git repository." });
    }
    const configContainer = containerEl.createDiv({ cls: "git-config-container" });
    let setupContent = configContainer;
    if (isRepo) {
      const details = configContainer.createEl("details", { attr: { style: "margin-bottom: 2rem;" } });
      details.createEl("summary", {
        text: "Update Settings",
        attr: { style: "font-weight: bold; cursor: pointer; padding: 0.5rem 0; opacity: 0.8;" }
      });
      setupContent = details.createDiv({ attr: { style: "padding: 1rem; border-left: 2px solid var(--background-modifier-border);" } });
    }
    const instructions = setupContent.createDiv({ cls: "git-instructions" });
    instructions.createEl("p", {
      text: 'Connect your project to GitHub to publish your site. Click "Skip" to skip Git setup now and set it up later.'
    });
    const gitDownload = instructions.createEl("p");
    gitDownload.createSpan({ text: "1. " });
    gitDownload.createEl("a", {
      text: "Download and install Git",
      href: "https://git-scm.com/"
    });
    const tokenLink = instructions.createEl("p");
    tokenLink.createSpan({ text: "2. " });
    tokenLink.createEl("a", {
      text: "Generate a new GitHub Personal access token",
      href: `https://github.com/settings/tokens/new?scopes=repo&description=${encodeURIComponent((this.state.gitConfig.repoName || "Project") + " (Vault CMS)")}`
    });
    const tokenHelp = instructions.createEl("ul");
    tokenHelp.createEl("li", { text: `Set a Note (e.g., "${this.state.gitConfig.repoName || "Project"} (Vault CMS)")` });
    tokenHelp.createEl("li", { text: 'Set Expiration to "No expiration"' });
    tokenHelp.createEl("li", { text: 'Check the "repo" box (so all top options are selected)' });
    tokenHelp.createEl("li", { text: 'Click "Generate token" at the bottom, copy it, and paste it below.' });
    if (!remoteUrl) {
      setupContent.createEl("h3", { text: isRepo ? "Connect to GitHub" : "Create New Repository" });
    } else {
      setupContent.createEl("h3", { text: "Update GitHub Connection" });
    }
    const patSetting = new import_obsidian20.Setting(setupContent).setName("GitHub Personal Access Token").setDesc("Stored securely in Obsidian Secrets.").addExtraButton((btn) => {
      btn.setIcon("link").setTooltip("Generate a new Personal access token on GitHub").onClick(() => {
        const description = encodeURIComponent((this.state.gitConfig.repoName || "Project") + " (Vault CMS)");
        window.open(`https://github.com/settings/tokens/new?scopes=repo&description=${description}`);
      });
    });
    const secretId = "vault-cms-github-pat";
    let secretValue = (_a = this.app.secretStorage) == null ? void 0 : _a.getSecret(secretId);
    if (secretValue && !this.state.gitConfig.pat) {
    }
    patSetting.addText((text) => {
      text.setPlaceholder("ghp_xxxxxxxxxxxx").setValue(secretValue ? "********" : "").onChange((value) => {
        this.state.gitConfig.pat = value.trim();
      });
      text.inputEl.type = "password";
    });
    const patStatus = setupContent.createDiv({ cls: "pat-status-info", attr: { style: "margin-bottom: 1rem; font-size: 0.9em; color: var(--text-muted);" } });
    if (secretValue) {
      patStatus.createSpan({ text: "\u2713 Linked to Obsidian Secret: ", attr: { style: "color: var(--text-success); font-weight: bold;" } });
      patStatus.createSpan({ text: secretId });
    }
    patSetting.addButton((button) => {
      button.setButtonText("Verify Token").onClick(async () => {
        var _a2;
        let token = this.state.gitConfig.pat;
        if (!token || token === "********" || token === "vault-cms-github-pat") {
          token = (_a2 = this.app.secretStorage) == null ? void 0 : _a2.getSecret("vault-cms-github-pat");
        }
        if (!token) {
          new import_obsidian20.Notice("Please enter or paste your GitHub Personal Access Token.");
          return;
        }
        button.setDisabled(true);
        button.setButtonText("Verifying...");
        patStatus.empty();
        try {
          const username = await this.gitManager.verifyToken(token);
          if (username) {
            new import_obsidian20.Notice(`Token verified successfully as ${username}!`);
            patStatus.createSpan({ text: `\u2713 Verified as `, attr: { style: "color: var(--text-success);" } });
            patStatus.createEl("b", { text: username });
            if (this.app.secretStorage) {
              await this.app.secretStorage.setSecret("vault-cms-github-pat", token);
            }
            try {
              this.app.saveLocalStorage("obsidian-git:username", username);
            } catch (e) {
              localStorage.setItem("obsidian-git:username", username);
            }
            this.state.gitConfig.enabled = true;
            button.setButtonText("Verified");
            button.buttonEl.style.backgroundColor = "var(--interactive-accent)";
            button.buttonEl.style.color = "var(--text-on-accent)";
          } else {
            new import_obsidian20.Notice("Invalid token or GitHub API error.");
            patStatus.createSpan({ text: "\u2717 Invalid token or GitHub API error.", attr: { style: "color: var(--text-error);" } });
            button.setButtonText("Verify Token");
            button.setDisabled(false);
          }
        } catch (e) {
          new import_obsidian20.Notice("Verification failed. Check your connection.");
          patStatus.createSpan({ text: "\u2717 Verification failed. Check your connection.", attr: { style: "color: var(--text-error);" } });
          button.setButtonText("Verify Token");
          button.setDisabled(false);
        }
      });
    });
    new import_obsidian20.Setting(setupContent).setName(remoteUrl ? "New Repository Name" : "Repository Name").setDesc("The name of your GitHub repository.").addText((text) => {
      const defaultName = projectRoot ? projectRoot.split(/[\\/]/).pop() : "";
      const initialValue = this.state.gitConfig.repoName || defaultName || "";
      if (!this.state.gitConfig.repoName) {
        this.state.gitConfig.repoName = initialValue;
      }
      text.setPlaceholder("my-blog").setValue(initialValue).onChange((value) => {
        this.state.gitConfig.repoName = value.trim();
      });
    });
    new import_obsidian20.Setting(setupContent).setName("Description").setDesc("A short description for your repository.").addText((text) => {
      text.setPlaceholder("My personal blog").setValue(this.state.gitConfig.repoDescription || "").onChange((value) => {
        this.state.gitConfig.repoDescription = value.trim();
      });
    });
    new import_obsidian20.Setting(setupContent).setName("Private Repository").setDesc("Keep this repository private and hidden from the public.").addToggle((toggle) => {
      toggle.setValue(this.state.gitConfig.isPrivate).onChange((value) => {
        this.state.gitConfig.isPrivate = value;
      });
    });
    new import_obsidian20.Setting(setupContent).setName("Default Branch").setDesc('The name of the initial branch (e.g., "main" or "master").').addText((text) => {
      const initialBranch = this.state.gitConfig.branchName || "main";
      if (!this.state.gitConfig.branchName) {
        this.state.gitConfig.branchName = initialBranch;
      }
      text.setPlaceholder("main").setValue(initialBranch).onChange((value) => {
        this.state.gitConfig.branchName = value.trim() || "main";
      });
    });
    new import_obsidian20.Setting(setupContent).setName("Auto-configure Git plugin").setDesc('Automatically set up the "Git" plugin to work with this project.').addToggle((toggle) => {
      toggle.setValue(this.state.gitConfig.autoConfigureObsidianGit).onChange((value) => {
        this.state.gitConfig.autoConfigureObsidianGit = value;
      });
    });
    const actionContainer = setupContent.createDiv({ cls: "git-action-container", attr: { style: "margin-top: 2rem;" } });
    let buttonText = isRepo ? remoteUrl ? "Update Remote & Push" : "Connect to GitHub" : "Initialize & Push to GitHub";
    const createBtn = new import_obsidian20.ButtonComponent(actionContainer).setButtonText(buttonText).setCta().onClick(async () => {
      await this.handleGitSetup(createBtn, isRepo, !!remoteUrl);
    });
    configContainer.createEl("p", {
      cls: "git-skip-info",
      attr: { style: "font-size: 0.8em; color: var(--text-muted); margin-top: 1rem; border-top: 1px solid var(--background-modifier-border); padding-top: 1rem;" },
      text: 'Click "Skip" to skip Git setup.'
    });
  }
  async handleGitSetup(button, alreadyRepo, alreadyHasRemote) {
    var _a;
    if (this.hasAdvanced) return;
    let { pat } = this.state.gitConfig;
    const { repoName, repoDescription, isPrivate, branchName } = this.state.gitConfig;
    const projectRoot = this.getAbsoluteProjectRoot();
    const branch = branchName || "main";
    if (!pat || pat === "********" || pat === "vault-cms-github-pat") {
      pat = ((_a = this.app.secretStorage) == null ? void 0 : _a.getSecret("vault-cms-github-pat")) || pat;
    }
    const token = pat;
    if (!token || token === "********" || token === "vault-cms-github-pat" || !projectRoot) {
      new import_obsidian20.Notice("Please provide a valid Token and ensure project root is detected.");
      button.setDisabled(false);
      return;
    }
    if (!alreadyHasRemote && !repoName) {
      new import_obsidian20.Notice("Please provide a Repository Name.");
      button.setDisabled(false);
      return;
    }
    button.setDisabled(true);
    button.setButtonText(alreadyHasRemote ? "Updating..." : "Initializing...");
    try {
      if (!alreadyRepo) {
        await this.gitManager.initRepo(projectRoot);
        new import_obsidian20.Notice("Local Git repository initialized.");
      }
      new import_obsidian20.Notice(alreadyHasRemote ? "Creating new GitHub repository..." : "Creating GitHub repository...");
      const repoInfo = await this.gitManager.createGitHubRepo(token, repoName, repoDescription || "", isPrivate);
      await this.gitManager.setRemote(projectRoot, repoInfo.clone_url);
      new import_obsidian20.Notice(`Successfully ${alreadyHasRemote ? "updated" : "connected"} to ${repoInfo.html_url}`);
      try {
        await this.configFlushService.flush(this.state);
        console.debug("GitSetupStep: Early configuration flush successful");
      } catch (flushError) {
        console.warn("GitSetupStep: Early configuration flush failed, but continuing with sync:", flushError);
      }
      try {
        await this.gitManager.initialCommitAndPush(projectRoot, branch, "origin", token);
        new import_obsidian20.Notice("Successfully synced with GitHub!");
      } catch (pushError) {
        console.error("Sync failed:", pushError);
        new import_obsidian20.Notice("Initial sync failed. Please ensure you have Git configured locally and your credentials are set up (e.g. Git Credential Manager).");
      }
      if (this.state.gitConfig.autoConfigureObsidianGit) {
        await this.configureObsidianGit(token, projectRoot, branch);
      }
      if (pat && this.app.secretStorage) {
        await this.app.secretStorage.setSecret("vault-cms-github-pat", pat);
      }
      this.state.gitConfig.pat = "";
      this.state.gitConfig.enabled = true;
      button.setButtonText("Success!");
      new import_obsidian20.Notice("Git setup complete!");
      if (!this.hasAdvanced) {
        this.hasAdvanced = true;
        setTimeout(() => this.onNext(), 1500);
      }
    } catch (error) {
      console.error("Git integration failed:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new import_obsidian20.Notice(`Setup failed: ${errorMessage}`);
      button.setDisabled(false);
      button.setButtonText(alreadyHasRemote ? "Update Settings & Sync" : "Initialize & Push to GitHub");
    }
  }
  async configureObsidianGit(pat, projectRoot, branch) {
    var _a;
    console.debug("GitSetupStep: Configuring Obsidian Git plugin...");
    try {
      this.app.saveLocalStorage("obsidian-git:password", pat);
    } catch (e) {
      localStorage.setItem("obsidian-git:password", pat);
    }
    const adapter = this.app.vault.adapter;
    const vaultRoot = adapter.getBasePath ? adapter.getBasePath() : "";
    if (vaultRoot && projectRoot) {
      const absoluteProjectRoot = path8.isAbsolute(projectRoot) ? projectRoot : path8.resolve(vaultRoot, projectRoot);
      const relativePath = path8.relative(vaultRoot, absoluteProjectRoot).replace(/\\/g, "/");
      const configUpdates = {
        basePath: relativePath || "",
        gitRemote: "origin",
        remoteName: "origin",
        // Some versions use this
        mainBranch: branch,
        branch,
        // Some versions use this
        currentRemote: "origin"
      };
      const gitPlugin = (_a = this.app.plugins) == null ? void 0 : _a.getPlugin("obsidian-git");
      if (gitPlugin) {
        console.debug("GitSetupStep: Found running Obsidian Git plugin, updating in-memory settings");
        gitPlugin.settings = {
          ...gitPlugin.settings,
          ...configUpdates
        };
        if (typeof gitPlugin.saveSettings === "function") {
          await gitPlugin.saveSettings();
        }
      }
      await this.safeConfigWriter.mergeConfig("obsidian-git", configUpdates);
    }
    new import_obsidian20.Notice("Obsidian Git plugin configured.");
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Git Integration";
  }
  getDescription() {
    return "Connect to GitHub";
  }
};

// src/ui/wizard/DeploymentStep.ts
var import_obsidian21 = require("obsidian");
init_GitManager();
var DeploymentStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.remoteUrl = null;
    this.showNextButton = false;
  }
  getTailoredInstructions() {
    var _a, _b;
    const vaultLocation = ((_a = this.state.projectDetection) == null ? void 0 : _a.vaultLocation) || "root";
    const projectRoot = ((_b = this.state.projectDetection) == null ? void 0 : _b.projectRoot) || "";
    let rootDir = "/";
    let buildCommand = "npm run build";
    let outputDir = "dist";
    if (vaultLocation === "nested-content" || vaultLocation === "content") {
    }
    return {
      rootDir,
      buildCommand,
      outputDir
    };
  }
  async shouldSkip() {
    var _a;
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (projectRoot) {
      this.remoteUrl = await GitManager.getRemoteUrl(projectRoot);
    }
    return !this.remoteUrl;
  }
  async display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Deployment Setup" });
    containerEl.createEl("p", {
      text: "Your site is ready to be published! Choose a deployment platform to host your Astro site. Select 'skip' if you've already set this up."
    });
    const instructions = this.getTailoredInstructions();
    const platformContainer = containerEl.createDiv({
      cls: "deployment-platforms",
      attr: { style: "min-height: 400px;" }
    });
    platformContainer.createEl("i", {
      text: "Resolving repository details...",
      attr: { style: "opacity: 0.5;" }
    });
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (projectRoot) {
      this.remoteUrl = await GitManager.getRemoteUrl(projectRoot);
    }
    platformContainer.empty();
    this.renderPlatform(platformContainer, {
      name: "Netlify",
      description: "Fast and reliable hosting. Great developer experience.",
      url: this.getNetlifyDeployUrl(),
      instructions: [
        `Base directory: ${instructions.rootDir === "/" ? "(leave empty)" : instructions.rootDir}`,
        `Build command: ${instructions.buildCommand}`,
        `Publish directory: ${instructions.outputDir}`
      ]
    });
    this.renderPlatform(platformContainer, {
      name: "Vercel",
      description: "Optimized for frontend frameworks with zero-config deployment.",
      url: this.getVercelDeployUrl(),
      instructions: [
        `Framework Preset: Astro`,
        `Root Directory: ${instructions.rootDir}`,
        `Build Command: ${instructions.buildCommand}`
      ]
    });
    this.renderPlatform(platformContainer, {
      name: "Cloudflare",
      description: "Host your site on Cloudflare Pages or Workers.",
      url: this.getCloudflareDeployUrl(),
      instructions: [
        `Framework Preset: Astro`,
        `Root Directory: ${instructions.rootDir}`,
        `Build Command: ${instructions.buildCommand}`,
        `Output Directory: ${instructions.outputDir}`
      ]
    });
    this.renderPlatform(platformContainer, {
      name: "GitHub",
      description: "Host directly from your GitHub repository. (Requires Public repository for free accounts)",
      url: this.getGitHubPagesUrl(),
      instructions: [
        "Requires a GitHub Action to build and deploy.",
        "Go to Repository Settings > Pages > Build and deployment > Source: GitHub Actions.",
        "Ensure your repository is PUBLIC to use GH Pages for free."
      ]
    });
  }
  getNetlifyDeployUrl() {
    if (this.remoteUrl) {
      return `https://app.netlify.com/start/deploy?repository=${encodeURIComponent(this.remoteUrl)}`;
    }
    return "https://app.netlify.com/";
  }
  getVercelDeployUrl() {
    if (this.remoteUrl) {
      return `https://vercel.com/new/clone?repository-url=${encodeURIComponent(this.remoteUrl)}`;
    }
    return "https://vercel.com/new";
  }
  getCloudflareDeployUrl() {
    if (this.remoteUrl) {
      return `https://deploy.workers.cloudflare.com/?url=${encodeURIComponent(this.remoteUrl)}`;
    }
    return "https://dash.cloudflare.com/";
  }
  getGitHubPagesUrl() {
    if (this.remoteUrl) {
      let cleanUrl = this.remoteUrl.trim();
      if (cleanUrl.endsWith(".git")) {
        cleanUrl = cleanUrl.slice(0, -4);
      }
      return `${cleanUrl}/settings/pages`;
    }
    return "https://github.com/features/pages";
  }
  renderPlatform(container, platform) {
    const platformEl = container.createDiv({
      cls: "deployment-platform",
      attr: { style: "margin-bottom: 2rem; padding: 1rem; border: 1px solid var(--background-modifier-border); border-radius: 8px;" }
    });
    const header = platformEl.createEl("h3", { attr: { style: "margin-top: 0;" } });
    header.createSpan({ text: platform.name });
    if (platform.recommended) {
      header.createSpan({
        text: " RECOMMENDED",
        attr: { style: "font-size: 0.6em; vertical-align: middle; background: var(--interactive-accent); color: var(--text-on-accent); padding: 2px 6px; border-radius: 4px; margin-left: 10px;" }
      });
    }
    platformEl.createEl("p", { text: platform.description });
    const instructionList = platformEl.createEl("ul");
    platform.instructions.forEach((inst) => {
      instructionList.createEl("li", { text: inst });
    });
    new import_obsidian21.Setting(platformEl).addButton((btn) => btn.setButtonText(`Set up on ${platform.name}`).setCta().onClick(() => window.open(platform.url)));
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Deployment";
  }
  getDescription() {
    return "Publish your site";
  }
};

// src/ui/wizard/FinalizeStep.ts
var import_obsidian22 = require("obsidian");
var FinalizeStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.applied = false;
    this.pluginManager = new PluginManager(app);
    this.basesCMSConfigurator = new BasesCMSConfigurator(app);
    this.configFlushService = new ConfigFlushService(app);
  }
  isApplied() {
    return this.applied;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Finalize configuration" });
    containerEl.createEl("p", {
      text: 'Review your configuration and click "Apply and restart" below to save and apply all settings.'
    });
    const summary = containerEl.createEl("div", { cls: "finalize-summary" });
    summary.createEl("h3", { text: "Summary" });
    const enabledContentTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    summary.createEl("p", { text: `Content Types: ${enabledContentTypes.length}` });
    summary.createEl("p", { text: `Editing Toolbar: ${this.state.enableEditingToolbar ? "Enabled" : "Disabled"}` });
    const basesViewsCount = enabledContentTypes.length;
    summary.createEl("p", { text: `Bases CMS Views: ${basesViewsCount} new view${basesViewsCount !== 1 ? "s" : ""} to be created` });
    const seoDirectories = enabledContentTypes.map((ct) => ct.folder);
    const seoDirectoriesCount = seoDirectories.length;
    summary.createEl("p", { text: `SEO Scan Directories: ${seoDirectoriesCount} director${seoDirectoriesCount !== 1 ? "ies" : "y"} (${seoDirectories.join(", ")})` });
  }
  async applyConfiguration(shouldRestart = false) {
    return this.applyConfigurationInternal(shouldRestart);
  }
  async applyConfigurationInternal(shouldRestart = false) {
    if (this.applied) {
      return;
    }
    try {
      console.debug("FinalizeStep: Starting configuration application");
      console.debug("FinalizeStep: Enabled content types:", this.state.contentTypes.filter((ct) => ct.enabled).map((ct) => ct.name));
      console.debug("FinalizeStep: Configuring plugin states");
      if (this.state.enableExtendedFileTypes) {
        const pluginId = "data-files-editor";
        if (!this.state.enabledPlugins.includes(pluginId)) {
          console.debug(`FinalizeStep: Enabling ${pluginId} because Extended File Types is toggle on`);
          this.state.enabledPlugins.push(pluginId);
        }
        this.state.disabledPlugins = this.state.disabledPlugins.filter((p) => p !== pluginId);
      }
      await this.pluginManager.setPluginStates(this.state.enabledPlugins, this.state.disabledPlugins);
      await this.configFlushService.flush(this.state);
      if (this.state.defaultContentTypeId) {
        const defaultType = this.state.contentTypes.find((ct) => ct.id === this.state.defaultContentTypeId);
        if (defaultType) {
          console.debug("FinalizeStep: Configuring Obsidian settings for default content type:", defaultType.name);
          const app = this.app;
          let targetPath = "./";
          if (this.state.attachmentHandlingMode === "same-folder") {
            targetPath = "./";
          } else if (this.state.attachmentHandlingMode === "subfolder") {
            const folderName = this.state.attachmentFolderName || "attachments";
            targetPath = `./${folderName}`;
          } else if (this.state.attachmentHandlingMode === "specified-folder") {
            const folderName = this.state.attachmentFolderName || "attachments";
            targetPath = folderName;
          }
          if (app.setting && typeof app.setting.set === "function") {
            console.debug("FinalizeStep: Using app.setting API");
            await app.setting.set("newFileLocation", "folder");
            await app.setting.set("newFileFolderPath", defaultType.folder);
            await app.setting.set("attachmentFolderPath", targetPath);
            await app.setting.set("newLinkFormat", "relative");
            if (typeof app.setting.save === "function") {
              await app.setting.save();
              console.debug("FinalizeStep: Obsidian settings saved via app.setting.save()");
            }
          } else {
            console.debug("FinalizeStep: Using vault.config API");
            const vault = this.app.vault;
            const obsidianSettings = vault.config;
            if (!obsidianSettings) {
              console.error("FinalizeStep: vault.config is not available");
            } else {
              obsidianSettings.newFileLocation = "folder";
              obsidianSettings.newFileFolderPath = defaultType.folder;
              obsidianSettings.attachmentFolderPath = targetPath;
              obsidianSettings.newLinkFormat = "relative";
              if (typeof vault.saveConfig === "function") {
                await vault.saveConfig();
                console.debug("FinalizeStep: Obsidian settings saved via vault.saveConfig()");
              } else {
                console.error("FinalizeStep: vault.saveConfig() is not available");
              }
            }
          }
        }
      }
      this.applied = true;
      if (shouldRestart) {
        new import_obsidian22.Notice("Configuration applied. Obsidian will now restart...", 3e3);
      } else {
        new import_obsidian22.Notice("Configuration applied successfully! You may need to restart Obsidian to see all changes.", 8e3);
      }
    } catch (error) {
      console.error("Failed to apply configuration:", error);
      new import_obsidian22.Notice("Failed to apply configuration. Please check the console for details.", 6e3);
    }
  }
  /**
   * Find any active Bases views and switch them to the new default view.
   * Closes old tabs and reopens them to force a clean reload if not restarting.
   */
  async updateActiveBasesViews(defaultViewName, shouldRestart) {
    const baseFilePath = await this.basesCMSConfigurator.resolveBaseFilePath();
    let updated = false;
    const leavesToUpdate = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      const viewType = leaf.view.getViewType();
      if (viewType === "bases" || viewType === "bases-cms") {
        const state = leaf.getViewState();
        if (((_a = state.state) == null ? void 0 : _a.file) === baseFilePath) {
          console.debug(`FinalizeStep: Found Bases leaf to update (type: ${viewType})`);
          leavesToUpdate.push({ leaf, state });
        }
      }
    });
    for (const { leaf, state } of leavesToUpdate) {
      console.debug("FinalizeStep: Updating existing Bases leaf state");
      await leaf.setViewState({
        ...state,
        state: {
          ...state.state,
          view: defaultViewName,
          viewName: defaultViewName
        }
      });
      updated = true;
    }
    if (!updated) {
      console.debug("FinalizeStep: Opening new Bases leaf with fresh state");
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.setViewState({
        type: "bases-cms",
        active: true,
        state: {
          file: baseFilePath,
          view: defaultViewName,
          viewName: defaultViewName
        }
      });
      this.app.workspace.setActiveLeaf(leaf, { focus: true });
      updated = true;
    }
    if (shouldRestart) {
      try {
        const adapter = this.app.vault.adapter;
        const configDir = this.app.vault.configDir;
        const workspacePath = `${configDir}/workspace.json`;
        if (await adapter.exists(workspacePath)) {
          console.debug("FinalizeStep: Attempting direct workspace.json modification");
          const content = await adapter.read(workspacePath);
          const workspace = JSON.parse(content);
          let modified = false;
          const updateNode = (node) => {
            var _a;
            if (!node) return;
            if (node.type === "leaf" && node.state) {
              if ((node.state.type === "bases" || node.state.type === "bases-cms") && ((_a = node.state.state) == null ? void 0 : _a.file) === baseFilePath) {
                console.debug(`FinalizeStep: Found Bases leaf in workspace.json, updating to ${defaultViewName}`);
                if (node.state.state) {
                  node.state.state.view = defaultViewName;
                  node.state.state.viewName = defaultViewName;
                  modified = true;
                }
              }
            }
            if (node.children) {
              if (Array.isArray(node.children)) {
                node.children.forEach((child) => updateNode(child));
              } else {
                updateNode(node.children);
              }
            }
          };
          updateNode(workspace.main);
          updateNode(workspace.left);
          updateNode(workspace.right);
          if (modified) {
            await adapter.write(workspacePath, JSON.stringify(workspace, null, 2));
            console.debug("FinalizeStep: Successfully modified workspace.json");
          }
        }
      } catch (error) {
        console.warn("FinalizeStep: Failed to modify workspace.json directly:", error);
      }
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Finalize";
  }
  getDescription() {
    return "Review and apply configuration";
  }
};

// src/ui/wizard/WizardStateMachine.ts
var WizardStateMachine = class {
  constructor(steps) {
    // State to step index mapping
    this.stateStepMap = /* @__PURE__ */ new Map([
      ["welcome", 0],
      ["detect", 1],
      ["content-types", 2],
      ["frontmatter", 3],
      ["plugins", 4],
      ["complete", 9]
    ]);
    // Reverse mapping: step index to state
    this.stepStateMap = /* @__PURE__ */ new Map([
      [0, "welcome"],
      [1, "detect"],
      [2, "content-types"],
      [3, "frontmatter"],
      [4, "plugins"],
      // PluginConfigurationStep
      [5, "plugins"],
      // OptionalPluginsStep
      [6, "plugins"],
      // IgnoreStep
      [7, "plugins"],
      // GitSetupStep
      [8, "plugins"],
      // DeploymentStep
      [9, "complete"]
      // FinalizeStep
    ]);
    // State transition rules
    this.transitions = /* @__PURE__ */ new Map([
      ["welcome", ["detect"]],
      ["detect", ["content-types"]],
      ["content-types", ["frontmatter"]],
      ["frontmatter", ["plugins"]],
      ["plugins", ["complete"]],
      ["complete", []]
      // Terminal state
    ]);
    this.currentState = "welcome";
    this.stepIndex = 0;
    this.steps = steps || [
      WelcomeStep,
      ProjectDetectionStep,
      ContentTypeStep,
      FrontmatterPropertiesStep,
      PluginConfigurationStep,
      OptionalPluginsStep,
      IgnoreStep,
      GitSetupStep,
      DeploymentStep,
      FinalizeStep
    ];
  }
  /**
   * Get the current state
   */
  getState() {
    return this.currentState;
  }
  /**
   * Get the current step index
   */
  getStepIndex() {
    return this.stepIndex;
  }
  /**
   * Get the total number of steps
   */
  getTotalSteps() {
    return this.steps.length;
  }
  /**
   * Get the step constructor for a given index
   */
  getStepConstructor(index) {
    return this.steps[index];
  }
  /**
   * Check if we can transition to the next step/state
   */
  canGoNext() {
    return this.stepIndex < this.steps.length - 1;
  }
  /**
   * Check if we can go back to the previous step/state
   */
  canGoBack() {
    return this.stepIndex > 0;
  }
  /**
   * Move to the next step
   * Updates both step index and state
   */
  next() {
    if (!this.canGoNext()) {
      console.warn("WizardStateMachine: Cannot go to next step - already at final step");
      return;
    }
    const nextStepIndex = this.stepIndex + 1;
    const nextState = this.stepStateMap.get(nextStepIndex);
    if (!nextState) {
      console.error(`WizardStateMachine: No state mapping for step index ${nextStepIndex}`);
      return;
    }
    const allowedTransitions = this.transitions.get(this.currentState) || [];
    if (!allowedTransitions.includes(nextState) && nextState !== this.currentState) {
      console.warn(
        `WizardStateMachine: Invalid transition from ${this.currentState} to ${nextState}`
      );
    }
    this.stepIndex = nextStepIndex;
    this.currentState = nextState;
    console.debug(
      `WizardStateMachine: Transitioned to step ${this.stepIndex} (state: ${this.currentState})`
    );
  }
  /**
   * Move to the previous step
   * Updates both step index and state
   */
  previous() {
    if (!this.canGoBack()) {
      console.warn("WizardStateMachine: Cannot go to previous step - already at first step");
      return;
    }
    const prevStepIndex = this.stepIndex - 1;
    const prevState = this.stepStateMap.get(prevStepIndex);
    if (!prevState) {
      console.error(`WizardStateMachine: No state mapping for step index ${prevStepIndex}`);
      return;
    }
    this.stepIndex = prevStepIndex;
    this.currentState = prevState;
    console.debug(
      `WizardStateMachine: Went back to step ${this.stepIndex} (state: ${this.currentState})`
    );
  }
  /**
   * Jump to a specific step index
   * Updates both step index and state
   */
  jumpToStep(index) {
    const clampedIndex = Math.max(0, Math.min(index, this.steps.length - 1));
    const state = this.stepStateMap.get(clampedIndex);
    if (!state) {
      console.error(`WizardStateMachine: No state mapping for step index ${clampedIndex}`);
      return;
    }
    this.stepIndex = clampedIndex;
    this.currentState = state;
    console.debug(
      `WizardStateMachine: Jumped to step ${this.stepIndex} (state: ${this.currentState})`
    );
  }
  /**
   * Jump to a specific state
   * This will move to the first step of that state
   */
  jumpToState(state) {
    const stepIndex = this.stateStepMap.get(state);
    if (stepIndex === void 0) {
      console.error(`WizardStateMachine: No step mapping for state ${state}`);
      return;
    }
    this.jumpToStep(stepIndex);
  }
  /**
   * Get progress as a percentage
   */
  getProgress() {
    if (this.steps.length === 0) return 0;
    return (this.stepIndex + 1) / this.steps.length * 100;
  }
  /**
   * Get a human-readable description of the current state
   */
  getStateDescription() {
    switch (this.currentState) {
      case "welcome":
        return "Welcome";
      case "detect":
        return "Project Detection";
      case "content-types":
        return "Content Type Setup";
      case "frontmatter":
        return "Frontmatter Configuration";
      case "plugins":
        return "Plugin Configuration";
      case "complete":
        return "Finalization";
      default:
        return "Unknown State";
    }
  }
  /**
   * Debug: Get a summary of the current state machine status
   */
  getDebugInfo() {
    return `State: ${this.currentState} (${this.getStateDescription()}) | Step: ${this.stepIndex + 1}/${this.steps.length} | Progress: ${this.getProgress().toFixed(1)}%`;
  }
};

// src/ui/SetupWizardModal.ts
function setCssProps8(element, props) {
  for (const [key, value] of Object.entries(props)) {
    const cssKey = key.replace(/([A-Z])/g, "-$1").toLowerCase();
    element.style.setProperty(cssKey, value);
  }
}
var SetupWizardModal = class extends import_obsidian23.Modal {
  // Track the last step where "Next" was clicked
  constructor(app, initialState, pluginInstance) {
    var _a, _b;
    super(app);
    this.currentStepInstance = null;
    this.isCompleting = false;
    this.initialSettingsSnapshot = null;
    this.lastSavedStepIndex = -1;
    this.plugin = pluginInstance || ((_b = (_a = app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["vault-cms"]);
    if (!this.plugin) {
      throw new Error("VaultCMSPlugin instance is required");
    }
    this.stateManager = new WizardStateManager(this.plugin);
    if (initialState) {
      this.stateManager.updateState(initialState);
    }
    this.steps = [
      WelcomeStep,
      ProjectDetectionStep,
      ContentTypeStep,
      FrontmatterPropertiesStep,
      PluginConfigurationStep,
      OptionalPluginsStep,
      IgnoreStep,
      GitSetupStep,
      DeploymentStep,
      FinalizeStep
    ];
    this.stateMachine = new WizardStateMachine(this.steps);
    console.debug("SetupWizardModal: State machine initialized -", this.stateMachine.getDebugInfo());
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vault-cms-wizard");
    await this.stateManager.refreshState();
    this.initialSettingsSnapshot = this.createSettingsSnapshot();
    void this.renderCurrentStep();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.isCompleting = false;
  }
  scrollToTop() {
    const { contentEl } = this;
    let scrollableParent = contentEl;
    while (scrollableParent && scrollableParent !== document.body) {
      const style = window.getComputedStyle(scrollableParent);
      if (scrollableParent.scrollHeight > scrollableParent.clientHeight && (style.overflowY === "auto" || style.overflowY === "scroll" || style.overflow === "auto" || style.overflow === "scroll")) {
        scrollableParent.scrollTop = 0;
        break;
      }
      scrollableParent = scrollableParent.parentElement;
    }
    const modalContent = contentEl.closest(".modal-content");
    if (modalContent) {
      modalContent.scrollTop = 0;
    }
    const modalContainer = contentEl.closest(".modal-container");
    if (modalContainer) {
      modalContainer.scrollTop = 0;
    }
    contentEl.scrollTop = 0;
  }
  async renderCurrentStep() {
    const { contentEl } = this;
    const state = this.stateManager.getState();
    const stepIndex = state.currentStep;
    if (stepIndex >= 0 && stepIndex < this.steps.length) {
      const StepClass = this.steps[stepIndex];
      const tempDiv = document.createElement("div");
      const stepInstance = new StepClass(
        this.app,
        tempDiv,
        state,
        () => {
        },
        // Temporary handlers
        () => {
        },
        () => {
        }
      );
      if (await stepInstance.shouldSkip()) {
        console.debug(`SetupWizardModal: Step ${StepClass.name} requested skip. Advancing...`);
        this.stateManager.nextStep(this.steps.length);
        this.stateMachine.next();
        return this.renderCurrentStep();
      }
    }
    this.scrollToTop();
    contentEl.empty();
    contentEl.addClass("vault-cms-wizard");
    this.scrollToTop();
    this.renderProgress(contentEl);
    const stepContent = contentEl.createDiv("wizard-content");
    setCssProps8(stepContent, { minHeight: "400px" });
    await this.renderStepContent(stepContent);
    this.renderFooter(contentEl);
    requestAnimationFrame(() => {
      this.scrollToTop();
    });
  }
  renderProgress(container) {
    try {
      const state = this.stateManager.getState();
      const totalSteps = this.steps.length;
      if (!state || !this.stateMachine) {
        console.error("SetupWizardModal: state or stateMachine is missing in renderProgress");
        return;
      }
      const progress = container.createDiv("wizard-progress");
      this.stateMachine.jumpToStep(state.currentStep);
      const progressBar = progress.createDiv("progress-bar");
      const progressFill = progressBar.createDiv("progress-fill");
      const progressPercent = (state.currentStep + 1) / totalSteps * 100;
      progressFill.style.width = `${progressPercent}%`;
      const progressText = progress.createDiv("progress-text");
      progressText.textContent = `Step ${state.currentStep + 1} of ${totalSteps} - ${this.stateMachine.getStateDescription()}`;
    } catch (error) {
      console.error("SetupWizardModal: Error rendering progress bar:", error);
    }
  }
  async renderStepContent(container) {
    const state = this.stateManager.getState();
    const stepIndex = state.currentStep;
    if (stepIndex >= 0 && stepIndex < this.steps.length) {
      const StepClass = this.steps[stepIndex];
      const stepName = StepClass.name || "Unknown";
      console.debug(
        `SetupWizardModal: Displaying step ${stepIndex + 1}/${this.steps.length}: ${stepName}`,
        `[${this.stateMachine.getDebugInfo()}]`
      );
      this.currentStepInstance = new StepClass(
        this.app,
        container,
        state,
        () => {
          void (async () => {
            if (this.currentStepInstance && this.currentStepInstance.validate()) {
              await this.saveCurrentStepToWizardState();
              this.stateManager.nextStep(this.steps.length);
              this.stateMachine.next();
              console.debug("SetupWizardModal: Advanced to next step -", this.stateMachine.getDebugInfo());
              await this.renderCurrentStep();
            }
          })();
        },
        () => {
          this.discardCurrentStepChanges();
          this.stateManager.previousStep();
          this.stateMachine.previous();
          console.debug("SetupWizardModal: Went back to previous step -", this.stateMachine.getDebugInfo());
          void this.renderCurrentStep();
        },
        () => this.close()
      );
      await this.currentStepInstance.display();
    }
  }
  renderFooter(container) {
    var _a;
    const footer = container.createDiv("wizard-footer");
    setCssProps8(footer, { display: "flex", justifyContent: "space-between", alignItems: "center" });
    if (this.stateManager.getState().currentStep === 0) {
      const startupSetting = footer.createDiv("wizard-startup-setting-footer");
      const label = startupSetting.createEl("label", { cls: "wizard-checkbox-label" });
      setCssProps8(label, { cursor: "default" });
      const checkbox = label.createEl("input", { type: "checkbox" });
      setCssProps8(checkbox, { cursor: "default" });
      checkbox.checked = !this.plugin.settings.runWizardOnStartup;
      label.createSpan({ text: " I've already set up my vault, don't show on startup" });
      checkbox.addEventListener("change", () => {
        this.plugin.settings.runWizardOnStartup = !checkbox.checked;
        void this.plugin.saveSettings();
      });
    } else {
      footer.createDiv();
    }
    const buttons = footer.createDiv("wizard-buttons");
    setCssProps8(buttons, { display: "flex", gap: "10px" });
    if (this.stateManager.canGoPrevious()) {
      const prevBtn = buttons.createEl("button", {
        text: "Previous",
        cls: "mod-button"
      });
      prevBtn.addEventListener("click", () => {
        this.discardCurrentStepChanges();
        this.stateManager.previousStep();
        void this.renderCurrentStep();
      });
    }
    if (this.stateManager.canGoNext(this.steps.length)) {
      if (this.stateManager.getState().currentStep !== 0 && ((_a = this.currentStepInstance) == null ? void 0 : _a.showNextButton) !== false) {
        const nextBtn = buttons.createEl("button", {
          text: "Next",
          cls: "mod-button mod-cta"
        });
        nextBtn.addEventListener("click", () => {
          void (async () => {
            if (this.currentStepInstance && this.currentStepInstance.validate()) {
              await this.saveCurrentStepToWizardState();
              this.lastSavedStepIndex = this.stateManager.getState().currentStep;
              this.stateManager.nextStep(this.steps.length);
              await this.renderCurrentStep();
            }
          })();
        });
      }
    } else {
      if (this.currentStepInstance instanceof FinalizeStep) {
        const applyBtn = buttons.createEl("button", {
          text: "Apply",
          cls: "mod-button"
        });
        applyBtn.addEventListener("click", () => {
          void this.handleComplete(false);
        });
        const applyRestartBtn = buttons.createEl("button", {
          text: "Apply and restart",
          cls: "mod-button mod-cta"
        });
        applyRestartBtn.addEventListener("click", () => {
          void this.handleComplete(true);
        });
      } else {
        const completeBtn = buttons.createEl("button", {
          text: "Complete setup",
          cls: "mod-button mod-cta"
        });
        completeBtn.addEventListener("click", () => {
          void this.handleComplete(false);
        });
      }
    }
    if (this.stateManager.canGoNext(this.steps.length)) {
      if (this.stateManager.getState().currentStep !== 0) {
        const skipBtn = buttons.createEl("button", {
          text: "Skip",
          cls: "mod-button"
        });
        skipBtn.addClass("wizard-skip-button");
        setCssProps8(skipBtn, { opacity: "0.6" });
        skipBtn.addEventListener("click", () => {
          this.stateManager.nextStep(this.steps.length);
          void this.renderCurrentStep();
        });
      }
    }
  }
  async handleComplete(shouldRestart) {
    if (this.isCompleting) return;
    this.isCompleting = true;
    try {
      if (this.currentStepInstance && this.currentStepInstance.validate()) {
        if (this.currentStepInstance instanceof FinalizeStep) {
          await this.currentStepInstance.applyConfiguration(shouldRestart);
        } else {
          await this.saveCurrentStepToWizardState();
        }
        this.plugin.settings.wizardCompleted = true;
        this.plugin.settings.runWizardOnStartup = false;
        await this.plugin.saveSettings();
        await this.plugin.loadSettings();
        this.close();
        if (shouldRestart) {
          setTimeout(() => {
            this.app.commands.executeCommandById("app:reload");
          }, 1e3);
        }
      }
    } catch (error) {
      console.error("Error completing wizard:", error);
      new import_obsidian23.Notice("Failed to complete setup. Please check the console for details.");
    } finally {
      this.isCompleting = false;
    }
  }
  async saveCurrentStepToWizardState() {
    try {
      await this.stateManager.buildFinalSettings();
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
    } catch (error) {
      console.error("Error saving current step to data.json:", error);
    }
  }
  discardCurrentStepChanges() {
    void this.stateManager.refreshState();
  }
  async saveWizardStateToDataJson(showNotification = true) {
    try {
      await this.stateManager.buildFinalSettings();
      const hasChanges = this.hasSettingsChanged();
      if (!hasChanges) {
        return;
      }
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
      if (showNotification) {
        new import_obsidian23.Notice("Configuration saved");
      }
    } catch (error) {
      console.error("Error saving wizard state to data.json:", error);
      if (showNotification) {
        new import_obsidian23.Notice(`Failed to save configuration: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  createSettingsSnapshot() {
    const state = this.stateManager.getState();
    return JSON.parse(JSON.stringify({
      projectDetection: state.projectDetection,
      contentTypes: state.contentTypes,
      frontmatterProperties: state.frontmatterProperties,
      defaultContentTypeId: state.defaultContentTypeId,
      preset: state.preset,
      enableEditingToolbar: state.enableEditingToolbar,
      enabledPlugins: state.enabledPlugins,
      disabledPlugins: state.disabledPlugins,
      theme: state.theme,
      basesCMSConfig: state.basesCMSConfig,
      astroComposerConfig: state.astroComposerConfig,
      seoConfig: state.seoConfig,
      propertyOverFileName: state.propertyOverFileName,
      imageManager: state.imageManager,
      homeBase: state.homeBase
    }));
  }
  hasSettingsChanged() {
    if (!this.initialSettingsSnapshot) {
      return false;
    }
    const currentSnapshot = this.createSettingsSnapshot();
    return JSON.stringify(currentSnapshot.projectDetection) !== JSON.stringify(this.initialSettingsSnapshot.projectDetection) || JSON.stringify(currentSnapshot.contentTypes) !== JSON.stringify(this.initialSettingsSnapshot.contentTypes) || JSON.stringify(currentSnapshot.frontmatterProperties) !== JSON.stringify(this.initialSettingsSnapshot.frontmatterProperties) || currentSnapshot.defaultContentTypeId !== this.initialSettingsSnapshot.defaultContentTypeId || currentSnapshot.preset !== this.initialSettingsSnapshot.preset || currentSnapshot.enableEditingToolbar !== this.initialSettingsSnapshot.enableEditingToolbar || JSON.stringify(currentSnapshot.enabledPlugins) !== JSON.stringify(this.initialSettingsSnapshot.enabledPlugins) || JSON.stringify(currentSnapshot.disabledPlugins) !== JSON.stringify(this.initialSettingsSnapshot.disabledPlugins) || currentSnapshot.theme !== this.initialSettingsSnapshot.theme || JSON.stringify(currentSnapshot.basesCMSConfig) !== JSON.stringify(this.initialSettingsSnapshot.basesCMSConfig) || JSON.stringify(currentSnapshot.astroComposerConfig) !== JSON.stringify(this.initialSettingsSnapshot.astroComposerConfig) || JSON.stringify(currentSnapshot.seoConfig) !== JSON.stringify(this.initialSettingsSnapshot.seoConfig) || JSON.stringify(currentSnapshot.propertyOverFileName) !== JSON.stringify(this.initialSettingsSnapshot.propertyOverFileName) || JSON.stringify(currentSnapshot.imageManager) !== JSON.stringify(this.initialSettingsSnapshot.imageManager) || JSON.stringify(currentSnapshot.homeBase) !== JSON.stringify(this.initialSettingsSnapshot.homeBase);
  }
  getState() {
    return this.stateManager.getState();
  }
  // Callback to save state to plugin settings (kept for backward compatibility)
  setSaveCallback(callback) {
    console.warn("setSaveCallback is deprecated - state is now managed automatically");
  }
};

// src/ui/HealthCheckModal.ts
var import_obsidian24 = require("obsidian");
var HealthCheckModal = class extends import_obsidian24.Modal {
  constructor(app, plugin) {
    super(app);
    this.results = [];
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vault-cms-health-check");
    contentEl.createEl("h2", { text: "Vault CMS Health Check" });
    await this.runHealthChecks();
    this.displayResults(contentEl);
    const footer = contentEl.createDiv({ cls: "health-check-footer" });
    const closeBtn = footer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeBtn.addEventListener("click", () => this.close());
  }
  async runHealthChecks() {
    this.results = [];
    await this.checkCompanionPluginsInstalled();
    await this.checkCompanionPluginsEnabled();
    await this.checkAstroProjectDetection();
    await this.checkPluginConfiguration();
    await this.checkGitIntegration();
  }
  async checkCompanionPluginsInstalled() {
    var _a;
    const requiredPlugins = [
      { id: "astro-composer", name: "Astro Composer" },
      { id: "bases-cms", name: "Bases CMS" },
      { id: "home-base", name: "Home Base" },
      { id: "seo", name: "SEO" }
    ];
    const optionalPlugins = [
      { id: "property-over-file-name", name: "Property Over File Name" },
      { id: "image-manager", name: "Image Manager" }
    ];
    const checks = [];
    const plugins = ((_a = this.app.plugins) == null ? void 0 : _a.plugins) || {};
    for (const plugin of requiredPlugins) {
      const isInstalled = !!plugins[plugin.id];
      checks.push({
        name: `${plugin.name} installed`,
        status: isInstalled ? "pass" : "fail",
        message: isInstalled ? void 0 : "Plugin not installed"
      });
    }
    for (const plugin of optionalPlugins) {
      const isInstalled = !!plugins[plugin.id];
      checks.push({
        name: `${plugin.name} installed`,
        status: isInstalled ? "pass" : "warning",
        message: isInstalled ? void 0 : "Optional plugin not installed"
      });
    }
    this.results.push({
      category: "Plugin Installation",
      checks
    });
  }
  async checkCompanionPluginsEnabled() {
    const requiredPlugins = [
      { id: "astro-composer", name: "Astro Composer" },
      { id: "bases-cms", name: "Bases CMS" },
      { id: "home-base", name: "Home Base" },
      { id: "seo", name: "SEO" }
    ];
    const checks = [];
    const pluginsAPI = this.app.plugins;
    const enabledPlugins = (pluginsAPI == null ? void 0 : pluginsAPI.enabledPlugins) || /* @__PURE__ */ new Set();
    for (const plugin of requiredPlugins) {
      const isEnabled = enabledPlugins.has(plugin.id);
      checks.push({
        name: `${plugin.name} enabled`,
        status: isEnabled ? "pass" : "fail",
        message: isEnabled ? void 0 : "Plugin is installed but not enabled"
      });
    }
    this.results.push({
      category: "Plugin Status",
      checks
    });
  }
  async checkAstroProjectDetection() {
    const checks = [];
    const hasProjectRoot = !!this.plugin.settings.projectRoot;
    const hasConfigFile = !!this.plugin.settings.configFilePath;
    checks.push({
      name: "Project root configured",
      status: hasProjectRoot ? "pass" : "fail",
      message: hasProjectRoot ? this.plugin.settings.projectRoot : "Project root not set"
    });
    checks.push({
      name: "Config file detected",
      status: hasConfigFile ? "pass" : "fail",
      message: hasConfigFile ? this.plugin.settings.configFilePath : "Config file not found"
    });
    if (hasProjectRoot && hasConfigFile) {
      const detector = new ProjectDetector(this.app);
      try {
        const detection = await detector.detectProject();
        checks.push({
          name: "Project structure valid",
          status: detection ? "pass" : "warning",
          message: detection ? `Found ${detection.configFilePath}` : "Could not validate project structure"
        });
      } catch (error) {
        checks.push({
          name: "Project structure valid",
          status: "warning",
          message: `Error: ${error instanceof Error ? error.message : String(error)}`
        });
      }
    }
    const hasContentTypes = this.plugin.settings.contentTypes && this.plugin.settings.contentTypes.length > 0;
    checks.push({
      name: "Content types configured",
      status: hasContentTypes ? "pass" : "warning",
      message: hasContentTypes ? `${this.plugin.settings.contentTypes.length} content type(s) configured` : "No content types configured"
    });
    this.results.push({
      category: "Astro Project",
      checks
    });
  }
  async checkPluginConfiguration() {
    var _a, _b, _c, _d, _e, _f, _g;
    const checks = [];
    const configDir = this.app.vault.configDir;
    let astroComposerContentTypes = 0;
    try {
      const plugins = this.app.plugins;
      const astroComposerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["astro-composer"];
      if ((_b = astroComposerPlugin == null ? void 0 : astroComposerPlugin.settings) == null ? void 0 : _b.contentTypes) {
        astroComposerContentTypes = astroComposerPlugin.settings.contentTypes.length;
      } else {
        const astroComposerPath = `${configDir}/plugins/astro-composer/data.json`;
        const astroFile = this.app.vault.getAbstractFileByPath(astroComposerPath);
        if (astroFile instanceof import_obsidian24.TFile) {
          const content = await this.app.vault.read(astroFile);
          const data = JSON.parse(content);
          astroComposerContentTypes = ((_c = data.contentTypes) == null ? void 0 : _c.length) || 0;
        }
      }
    } catch (e) {
    }
    checks.push({
      name: "Astro Composer configured",
      status: astroComposerContentTypes > 0 ? "pass" : "warning",
      message: astroComposerContentTypes > 0 ? `${astroComposerContentTypes} content type(s)` : "No content types configured"
    });
    let basesConfigured = false;
    let basesMessage = "No base file found";
    try {
      const configurator = new BasesCMSConfigurator(this.app);
      const baseFilePath = await configurator.resolveBaseFilePath();
      if (await this.app.vault.adapter.exists(baseFilePath)) {
        basesConfigured = true;
        basesMessage = `${baseFilePath} found`;
      }
    } catch (e) {
    }
    checks.push({
      name: "Bases CMS configured",
      status: basesConfigured ? "pass" : "warning",
      message: basesMessage
    });
    let seoScanDirs = "";
    try {
      const plugins = this.app.plugins;
      const seoPlugin = (_d = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _d["seo"];
      if ((_e = seoPlugin == null ? void 0 : seoPlugin.settings) == null ? void 0 : _e.scanDirectories) {
        seoScanDirs = seoPlugin.settings.scanDirectories;
      } else {
        const seoPath = `${configDir}/plugins/seo/data.json`;
        const seoFile = this.app.vault.getAbstractFileByPath(seoPath);
        if (seoFile instanceof import_obsidian24.TFile) {
          const content = await this.app.vault.read(seoFile);
          const data = JSON.parse(content);
          seoScanDirs = data.scanDirectories || "";
        }
      }
    } catch (e) {
    }
    checks.push({
      name: "SEO plugin configured",
      status: seoScanDirs.length > 0 ? "pass" : "warning",
      message: seoScanDirs.length > 0 ? `Scanning: ${seoScanDirs}` : "No scan directories configured"
    });
    const hasDefaultContentType = !!this.plugin.settings.defaultContentTypeId;
    let defaultContentTypeName = this.plugin.settings.defaultContentTypeId || "";
    if (hasDefaultContentType) {
      try {
        const plugins = this.app.plugins;
        const astroComposerPlugin = (_f = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _f["astro-composer"];
        const contentTypes = (_g = astroComposerPlugin == null ? void 0 : astroComposerPlugin.settings) == null ? void 0 : _g.contentTypes;
        if (contentTypes) {
          const matchingType = contentTypes.find((ct) => ct.id === this.plugin.settings.defaultContentTypeId);
          if (matchingType == null ? void 0 : matchingType.name) {
            defaultContentTypeName = matchingType.name;
          }
        }
      } catch (e) {
      }
    }
    checks.push({
      name: "Default content type set",
      status: hasDefaultContentType ? "pass" : "warning",
      message: hasDefaultContentType ? defaultContentTypeName : "No default content type"
    });
    this.results.push({
      category: "Plugin Configuration",
      checks
    });
  }
  async checkGitIntegration() {
    var _a;
    const checks = [];
    const { gitConfig, projectRoot } = this.plugin.settings;
    if (projectRoot) {
      const { GitManager: GitManager2 } = await Promise.resolve().then(() => (init_GitManager(), GitManager_exports));
      const isRepo = await GitManager2.isRepo(projectRoot);
      const remoteUrl = isRepo ? await GitManager2.getRemoteUrl(projectRoot) : null;
      checks.push({
        name: "Git repository initialized",
        status: isRepo ? "pass" : "fail",
        message: isRepo ? "Repository detected at project root" : "No repository found at project root"
      });
      if (isRepo) {
        const isConfigured = gitConfig.enabled || !!remoteUrl;
        checks.push({
          name: "Git integration status",
          status: isConfigured ? "pass" : "warning",
          message: remoteUrl ? `Connected to ${remoteUrl}` : gitConfig.enabled ? "Integration active" : "Not configured (Optional)"
        });
        const savedSecret = (_a = this.app.secretStorage) == null ? void 0 : _a.getSecret("vault-cms-github-pat");
        const hasPat = !!(gitConfig.pat || savedSecret);
        if (gitConfig.enabled) {
          checks.push({
            name: "GitHub PAT configured",
            status: hasPat ? "pass" : "warning",
            message: hasPat ? "Token present" : "No token found in settings"
          });
        }
      }
    } else {
      checks.push({
        name: "Git repository check",
        status: "fail",
        message: "Project root not configured"
      });
    }
    this.results.push({
      category: "Git Integration",
      checks
    });
  }
  displayResults(container) {
    const resultsContainer = container.createDiv({ cls: "health-check-results" });
    for (const result of this.results) {
      const categorySection = resultsContainer.createDiv({ cls: "health-check-category" });
      categorySection.createEl("h3", { text: result.category });
      const checksList = categorySection.createDiv({ cls: "health-check-list" });
      for (const check of result.checks) {
        const checkItem = checksList.createDiv({ cls: "health-check-item" });
        const statusIcon = checkItem.createSpan({ cls: "health-check-icon" });
        if (check.status === "pass") {
          (0, import_obsidian24.setIcon)(statusIcon, "lucide-check-circle-2");
          statusIcon.addClass("health-check-pass");
        } else if (check.status === "fail") {
          (0, import_obsidian24.setIcon)(statusIcon, "lucide-alert-circle");
          statusIcon.addClass("health-check-fail");
        } else {
          (0, import_obsidian24.setIcon)(statusIcon, "lucide-help-circle");
          statusIcon.addClass("health-check-warning");
        }
        const checkName = checkItem.createSpan({
          text: check.name,
          cls: "health-check-name"
        });
        if (check.message) {
          const checkMessage = checkItem.createDiv({
            text: check.message,
            cls: "health-check-message"
          });
        }
      }
    }
    this.addStyles(container);
  }
  addStyles(container) {
    const style = container.createEl("style");
    style.textContent = `
			.vault-cms-health-check {
				padding: 20px;
			}

			.health-check-results {
				margin: 20px 0;
			}

			.health-check-category {
				margin-bottom: 30px;
			}

			.health-check-category h3 {
				margin-bottom: 10px;
				border-bottom: 1px solid var(--background-modifier-border);
				padding-bottom: 5px;
			}

			.health-check-list {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}

			.health-check-item {
				display: flex;
				align-items: flex-start;
				gap: 10px;
				padding: 8px;
				background: var(--background-secondary);
				border-radius: 4px;
			}

			.health-check-icon {
				font-size: 18px;
				font-weight: bold;
				min-width: 24px;
				text-align: center;
			}

			.health-check-pass {
				color: var(--text-success);
			}

			.health-check-fail {
				color: var(--text-error);
			}

			.health-check-warning {
				color: var(--text-warning);
			}

			.health-check-icon svg {
				width: 18px;
				height: 18px;
				display: block;
			}

			.health-check-icon {
				display: flex;
				align-items: center;
				justify-content: center;
				min-width: 24px;
				height: 24px;
			}

			.health-check-name {
				flex: 1;
				font-weight: 500;
			}

			.health-check-message {
				font-size: 0.9em;
				color: var(--text-muted);
				margin-left: 34px;
				margin-top: 4px;
			}

			.health-check-footer {
				display: flex;
				justify-content: flex-end;
				margin-top: 20px;
				padding-top: 15px;
				border-top: 1px solid var(--background-modifier-border);
			}
		`;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/settings-compat.ts
var import_obsidian25 = require("obsidian");
function createSettingsGroup(containerEl, heading, manifestId) {
  if ((0, import_obsidian25.requireApiVersion)("1.11.0")) {
    const obsidian = require("obsidian");
    const SettingGroup = obsidian.SettingGroup;
    const group = heading ? new SettingGroup(containerEl).setHeading(heading) : new SettingGroup(containerEl);
    return {
      addSetting(cb) {
        group.addSetting(cb);
      }
    };
  } else {
    if (manifestId) {
      containerEl.addClass(`${manifestId}-settings-compat`);
    }
    if (heading) {
      const headingEl = containerEl.createDiv("setting-group-heading");
      headingEl.createEl("h3", { text: heading });
    }
    return {
      addSetting(cb) {
        const setting = new import_obsidian25.Setting(containerEl);
        cb(setting);
      }
    };
  }
}

// src/utils/PresetManager.ts
var import_obsidian27 = require("obsidian");

// src/ui/ApplyPresetModal.ts
var import_obsidian26 = require("obsidian");
var ApplyPresetModal = class extends import_obsidian26.Modal {
  constructor(app, backupPath, onConfirm) {
    super(app);
    this.backupPath = backupPath;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Preset applied successfully" });
    contentEl.createEl("p", { text: "The preset has been applied successfully. You need to reload Obsidian for all changes to take effect." });
    contentEl.createEl("p", { text: `A backup of your original configuration folder was created at: ${this.backupPath}` });
    new import_obsidian26.Setting(contentEl).setName("Delete backup and reload").setDesc('Remove the backup folder and reload Obsidian. This is the recommended "clean" option.').addButton((button) => button.setButtonText("Delete and reload").setCta().onClick(() => {
      this.close();
      this.onConfirm(true);
    }));
    new import_obsidian26.Setting(contentEl).setName("Keep backup and reload").setDesc("Keep the backup folder for safety and reload Obsidian.").addButton((button) => button.setButtonText("Keep and reload").onClick(() => {
      this.close();
      this.onConfirm(false);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/PresetManager.ts
var PresetManager = class {
  constructor(app) {
    this.app = app;
  }
  async applyPreset(repo, presetName) {
    if (!repo || !presetName) {
      new import_obsidian27.Notice("Please configure both repository and preset name in settings.");
      return;
    }
    try {
      new import_obsidian27.Notice(`Fetching preset "${presetName}" from ${repo}...`);
      const files = await this.fetchPresetFilesRecursive(repo, presetName);
      if (files.length === 0) {
        new import_obsidian27.Notice(`No files found for preset "${presetName}" in repo ${repo}.`);
        return;
      }
      new import_obsidian27.Notice("Backing up configuration folder...");
      const backupPath = await this.backupObsidianFolder();
      new import_obsidian27.Notice(`Downloading and applying ${files.length} files...`);
      let successCount = 0;
      for (const file of files) {
        if (file.download_url) {
          const relativePath = file.path.substring(presetName.length + 1);
          try {
            await this.downloadAndWriteFile(file.download_url, relativePath);
            successCount++;
          } catch (e) {
            console.error(`Failed to download ${relativePath}:`, e);
          }
        }
      }
      new import_obsidian27.Notice(`Applied ${successCount} files.`);
      new ApplyPresetModal(this.app, backupPath, (deleteBackup) => {
        void (async () => {
          if (deleteBackup) {
            try {
              await this.app.vault.adapter.rmdir(backupPath, true);
              new import_obsidian27.Notice("Backup deleted.");
            } catch (e) {
              console.error("Failed to delete backup:", e);
              new import_obsidian27.Notice("Failed to delete backup folder. You may need to remove it manually.");
            }
          }
          const appWithCommands = this.app;
          if (appWithCommands.commands && typeof appWithCommands.commands.executeCommandById === "function") {
            appWithCommands.commands.executeCommandById("app:reload");
          }
        })();
      }).open();
    } catch (error) {
      console.error("Failed to apply preset:", error);
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian27.Notice(`Failed to apply preset: ${message}`);
    }
  }
  async fetchPresetFilesRecursive(repo, path10) {
    const url = `https://api.github.com/repos/${repo}/contents/${path10}`;
    try {
      const response = await (0, import_obsidian27.requestUrl)({ url });
      if (response.status !== 200) {
        throw new Error(`GitHub API returned status ${response.status}`);
      }
      const items = response.json;
      let allFiles = [];
      for (const item of items) {
        if (item.type === "dir") {
          const subFiles = await this.fetchPresetFilesRecursive(repo, item.path);
          allFiles = allFiles.concat(subFiles);
        } else if (item.type === "file") {
          allFiles.push(item);
        }
      }
      return allFiles;
    } catch (e) {
      if (e && typeof e === "object" && "status" in e && e.status === 404) {
        throw new Error(`Preset folder "${path10}" not found in repository "${repo}".`);
      }
      throw e;
    }
  }
  async backupObsidianFolder() {
    const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").split("T")[0] + "-" + Math.floor(Date.now() / 1e3);
    const configDir = this.app.vault.configDir;
    const backupPath = `${configDir}_backup_${timestamp2}`;
    const adapter = this.app.vault.adapter;
    await adapter.mkdir(backupPath);
    await this.copyRecursive(configDir, `${backupPath}/${configDir}`);
    return backupPath;
  }
  async copyRecursive(source, destination) {
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(source)) {
      return;
    }
    const stats = await adapter.list(source);
    if (!await adapter.exists(destination)) {
      await adapter.mkdir(destination);
    }
    for (const file of stats.files) {
      const fileName = file.split("/").pop();
      if (fileName) {
        const destFile = destination + "/" + fileName;
        try {
          await adapter.copy(file, destFile);
        } catch (e) {
          console.error(`Failed to copy file ${file} to ${destFile}:`, e);
        }
      }
    }
    for (const folder of stats.folders) {
      const folderName = folder.split("/").pop();
      if (folderName) {
        const destFolder = destination + "/" + folderName;
        await this.copyRecursive(folder, destFolder);
      }
    }
  }
  async downloadAndWriteFile(url, path10) {
    const adapter = this.app.vault.adapter;
    const response = await (0, import_obsidian27.requestUrl)({ url });
    if (response.status !== 200) {
      throw new Error(`Failed to download ${path10} from ${url}`);
    }
    const parts = path10.split("/");
    if (parts.length > 1) {
      for (let i = 1; i < parts.length; i++) {
        const dir = parts.slice(0, i).join("/");
        if (!await adapter.exists(dir)) {
          await adapter.mkdir(dir);
        }
      }
    }
    await adapter.writeBinary(path10, response.arrayBuffer);
  }
};

// src/ui/SettingsTab.ts
var SettingsTab = class extends import_obsidian28.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.icon = "lucide-vault";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.contentEl = containerEl.createDiv("vault-cms-settings-container");
    void this.render();
  }
  async render() {
    if (!this.contentEl) return;
    this.contentEl.empty();
    const generalGroup = createSettingsGroup(this.contentEl, void 0, "vault-cms");
    generalGroup.addSetting((setting) => {
      setting.setName("Open setup wizard").setDesc("Launch the setup wizard").addButton((button) => {
        button.setButtonText("Open wizard").setCta().onClick(() => {
          new SetupWizardModal(this.app, this.plugin.settings, this.plugin).open();
        });
      });
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Run wizard on startup").setDesc("Automatically open the wizard when the plugin loads").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.runWizardOnStartup).onChange(async (value) => {
          this.plugin.settings.runWizardOnStartup = value;
          await this.plugin.saveSettings();
        });
      });
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Health check").setDesc("Check plugin installation and configuration status").addButton((button) => {
        button.setButtonText("Run health check").onClick(() => {
          new HealthCheckModal(this.app, this.plugin).open();
        });
      });
    });
    const presetGroup = createSettingsGroup(this.contentEl, "Preset configuration", "vault-cms-presets");
    presetGroup.addSetting((setting) => {
      setting.setName("Preset folder name").setDesc("Folder name in the repository").addText((text) => {
        text.setPlaceholder("Example: starlight").setValue(this.plugin.settings.presetName).onChange(async (value) => {
          this.plugin.settings.presetName = value;
          await this.plugin.saveSettings();
        });
      });
    });
    presetGroup.addSetting((setting) => {
      setting.setName("Presets repository").setDesc("GitHub repository containing the presets").addText((text) => {
        text.setPlaceholder("Example: owner/repo").setValue(this.plugin.settings.presetsRepo).onChange(async (value) => {
          this.plugin.settings.presetsRepo = value;
          await this.plugin.saveSettings();
        });
      });
    });
    presetGroup.addSetting((setting) => {
      setting.setName("Download and apply preset").setDesc("Download the specified preset and apply it to your vault").addButton((button) => {
        button.setButtonText("Apply preset").onClick(async () => {
          const manager = new PresetManager(this.app);
          await manager.applyPreset(this.plugin.settings.presetsRepo, this.plugin.settings.presetName);
        });
      });
    });
    const gitGroup = createSettingsGroup(this.contentEl, "Git configuration", "vault-cms-git");
    let isFullyConfigured = false;
    if (this.plugin.settings.projectRoot && this.plugin.settings.projectRoot.trim() !== "") {
      try {
        const { GitManager: GitManager2 } = await Promise.resolve().then(() => (init_GitManager(), GitManager_exports));
        const projectRoot = this.plugin.settings.projectRoot;
        const isRepo = await GitManager2.isRepo(projectRoot);
        const remoteUrl = isRepo ? await GitManager2.getRemoteUrl(projectRoot) : null;
        isFullyConfigured = isRepo && !!remoteUrl;
        gitGroup.addSetting((setting) => {
          setting.setName("Local repository status").setDesc(isRepo ? "Git is initialized at project root." : "Git is NOT initialized at project root.");
          const statusIcon = setting.controlEl.createSpan({
            cls: isRepo ? "git-status-icon-ok" : "git-status-icon-warn",
            attr: { style: `margin-left: 10px; color: ${isRepo ? "var(--text-success)" : "var(--text-warning)"};` }
          });
          statusIcon.setText(isRepo ? "\u2713 Detected" : "\u26A0 Missing");
        });
        gitGroup.addSetting((setting) => {
          setting.setName("Project root path").setDesc("Direct path being checked for Git").addText((text) => {
            text.setValue(projectRoot).setDisabled(true);
          });
        });
        if (remoteUrl) {
          gitGroup.addSetting((setting) => {
            setting.setName("Remote URL").setDesc("Connected GitHub repository").addText((text) => {
              text.setValue(remoteUrl).setDisabled(true);
            });
          });
        }
      } catch (error) {
        console.warn("SettingsTab: Failed to check Git status:", error);
      }
    }
    if (!isFullyConfigured) {
      gitGroup.addSetting((setting) => {
        setting.setName("Manage Git integration").setDesc("Initialize repository, connect to GitHub, or update credentials.").addButton((button) => {
          button.setButtonText("Setup / Update Git...").onClick(() => {
            const modal = new SetupWizardModal(this.app, { currentStep: 11 }, this.plugin);
            modal.open();
          });
        });
      });
    }
    const optimizationGroup = createSettingsGroup(this.contentEl, "Project optimization (optional)", "vault-cms-optimization");
    if (!this.plugin.settings.projectRoot) {
      optimizationGroup.addSetting((setting) => {
        setting.setName("Project not detected").setDesc("Complete the setup wizard first to detect your Astro project before configuring optimizations.");
      });
      return;
    }
    const wizardState = {
      ...this.plugin.settings,
      currentStep: 0,
      projectDetection: {
        projectRoot: this.plugin.settings.projectRoot,
        configFilePath: this.plugin.settings.configFilePath,
        vaultLocation: "content"
      }
    };
    this.optimizer = new ProjectOptimizer(this.app, wizardState);
    const status = await this.optimizer.getStatus();
    optimizationGroup.addSetting((setting) => {
      this.gitSetting = setting;
      this.updateGitSetting(status.gitIgnoreStatus);
    });
    optimizationGroup.addSetting((setting) => {
      this.viteSetting = setting;
      this.updateViteSetting(status.viteIgnoreStatus);
    });
  }
  updateGitSetting(status) {
    this.gitSetting.setName("Ignore in Git").setDesc("Add workspace files to Git ignore").clear();
    this.gitSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          const success = await this.optimizer.configureGitIgnore();
          if (success) {
            this.plugin.settings.ignoreConfig.gitIgnoreConfigured = true;
            await this.plugin.saveSettings();
            new import_obsidian28.Notice("Git ignore updated");
          } else {
            new import_obsidian28.Notice("Could not configure Git ignore: project root not detected");
          }
          const newStatus = await this.optimizer.getStatus();
          this.updateGitSetting(newStatus.gitIgnoreStatus);
        } catch (error) {
          new import_obsidian28.Notice(`Failed to update Git ignore: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.gitSetting.controlEl, status);
  }
  updateViteSetting(status) {
    this.viteSetting.setName("Ignore workspace and Home Base folders in Vite").setDesc("Configure Vite to ignore Obsidian and Home Base folders.").clear();
    this.viteSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          const success = await this.optimizer.configureViteIgnore();
          if (success) {
            this.plugin.settings.ignoreConfig.viteIgnoreConfigured = true;
            await this.plugin.saveSettings();
            new import_obsidian28.Notice("Vite optimization applied");
          } else {
            new import_obsidian28.Notice("Could not configure Vite: project root not detected");
          }
          const newStatus = await this.optimizer.getStatus();
          this.updateViteSetting(newStatus.viteIgnoreStatus);
        } catch (error) {
          new import_obsidian28.Notice(`Failed to update Vite config: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.viteSetting.controlEl, status);
  }
};

// src/commands/index.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "open-wizard",
    name: "Open setup wizard",
    callback: () => {
      const wizard = new SetupWizardModal(plugin.app, plugin.settings, plugin);
      wizard.open();
    }
  });
  plugin.addCommand({
    id: "health-check",
    name: "Check Vault CMS setup",
    callback: () => {
      const healthCheck = new HealthCheckModal(plugin.app, plugin);
      healthCheck.open();
    }
  });
  plugin.addCommand({
    id: "download-apply-preset",
    name: "Download and apply preset",
    callback: async () => {
      const manager = new PresetManager(plugin.app);
      await manager.applyPreset(plugin.settings.presetsRepo, plugin.settings.presetName);
    }
  });
}

// src/main.ts
var path9 = __toESM(require("path"), 1);
var VaultCMSPlugin = class extends import_obsidian29.Plugin {
  async onload() {
    await this.loadSettings();
    if (this.settings.projectRoot && !path9.isAbsolute(this.settings.projectRoot)) {
      const adapter = this.app.vault.adapter;
      const vaultPath = adapter.basePath || adapter.path;
      if (vaultPath) {
        const absolutePath = path9.resolve(vaultPath, this.settings.projectRoot);
        console.debug(`[Vault CMS] Repairing relative projectRoot: ${this.settings.projectRoot} -> ${absolutePath}`);
        this.settings.projectRoot = absolutePath;
        await this.saveSettings();
      }
    }
    registerCommands(this);
    this.addSettingTab(new SettingsTab(this.app, this));
    if (this.settings.runWizardOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        this.startupTimeoutId = window.setTimeout(() => {
          void (async () => {
            await this.loadSettings();
            if (this.settings.runWizardOnStartup) {
              const wizard = new SetupWizardModal(this.app, void 0, this);
              wizard.open();
            }
          })();
        }, 2e3);
      });
    }
  }
  onunload() {
    if (this.startupTimeoutId) {
      window.clearTimeout(this.startupTimeoutId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL3V0aWxzL0dpdE1hbmFnZXIudHMiLCAic3JjL21haW4udHMiLCAic3JjL3NldHRpbmdzLnRzIiwgInNyYy91aS9TZXR0aW5nc1RhYi50cyIsICJzcmMvdWkvU2V0dXBXaXphcmRNb2RhbC50cyIsICJzcmMvdXRpbHMvSW1hZ2VNYW5hZ2VyQ29uZmlnLnRzIiwgInNyYy91dGlscy9Ib21lQmFzZUNvbmZpZy50cyIsICJzcmMvdXRpbHMvRXhwbG9yZXJGb2N1c0NvbmZpZy50cyIsICJzcmMvdXRpbHMvRWRpdGluZ1Rvb2xiYXJDb25maWcudHMiLCAic3JjL3VpL3dpemFyZC9XaXphcmRTdGF0ZU1hbmFnZXIudHMiLCAic3JjL3VpL3dpemFyZC9CYXNlV2l6YXJkU3RlcC50cyIsICJzcmMvdWkvd2l6YXJkL1dlbGNvbWVTdGVwLnRzIiwgInNyYy91aS93aXphcmQvUHJvamVjdERldGVjdGlvblN0ZXAudHMiLCAic3JjL3V0aWxzL1Byb2plY3REZXRlY3Rvci50cyIsICJzcmMvdXRpbHMvTWR4RGV0ZWN0b3IudHMiLCAic3JjL3V0aWxzL0NvbnRlbnRUeXBlRGV0ZWN0b3IudHMiLCAic3JjL3VpL3dpemFyZC9Db250ZW50VHlwZVN0ZXAudHMiLCAic3JjL3V0aWxzL1BhdGhSZXNvbHZlci50cyIsICJzcmMvdXRpbHMvU2FmZUNvbmZpZ1dyaXRlci50cyIsICJzcmMvdXRpbHMvQXN0cm9Db21wb3NlckNvbmZpZy50cyIsICJzcmMvdWkvd2l6YXJkL0Zyb250bWF0dGVyUHJvcGVydGllc1N0ZXAudHMiLCAic3JjL3V0aWxzL0Zyb250bWF0dGVyQW5hbHl6ZXIudHMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL2lkZW50aXR5LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC92aXNpdC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2RpcmVjdGl2ZXMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hbmNob3JzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvYXBwbHlSZXZpdmVyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy90b0pTLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9BbGlhcy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvU2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvY3JlYXRlTm9kZS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvQ29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbW1lbnQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9mb2xkRmxvd0xpbmVzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvbWVyZ2UuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL2FkZFBhaXJUb0pTTWFwLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9QYWlyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5Q29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvWUFNTE1hcC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9tYXAuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1lBTUxTZXEuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vc2VxLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9udWxsLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29yZS9ib29sLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5TnVtYmVyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29yZS9mbG9hdC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvaW50LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29yZS9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9qc29uL3NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2JpbmFyeS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL3BhaXJzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvb21hcC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2Jvb2wuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9mbG9hdC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2ludC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL3NldC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL3RpbWVzdGFtcC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL3NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3RhZ3MuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9TY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlEb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL0RvY3VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9lcnJvcnMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1wcm9wcy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1mbG93LWluZGVudC1jaGVjay5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS91dGlsLW1hcC1pbmNsdWRlcy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWJsb2NrLW1hcC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWJsb2NrLXNlcS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWVuZC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWZsb3ctY29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9jb21wb3NlLWNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LXNjYWxhci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9jb21wb3NlLXNjYWxhci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS91dGlsLWVtcHR5LXNjYWxhci1wb3NpdGlvbi5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9jb21wb3NlLW5vZGUuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1kb2MuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC12aXNpdC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvY3N0LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvbGluZS1jb3VudGVyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3B1YmxpYy1hcGkuanMiLCAic3JjL3VpL3dpemFyZC9QbHVnaW5Db25maWd1cmF0aW9uU3RlcC50cyIsICJzcmMvdWkvd2l6YXJkL09wdGlvbmFsUGx1Z2luc1N0ZXAudHMiLCAic3JjL3V0aWxzL1BsdWdpbk1hbmFnZXIudHMiLCAic3JjL3VpL3dpemFyZC9JZ25vcmVTdGVwLnRzIiwgInNyYy91dGlscy9Qcm9qZWN0T3B0aW1pemVyLnRzIiwgInNyYy91aS93aXphcmQvR2l0U2V0dXBTdGVwLnRzIiwgInNyYy91dGlscy9CYXNlc0NNU0NvbmZpZy50cyIsICJzcmMvdXRpbHMvU0VPQ29uZmlnLnRzIiwgInNyYy91dGlscy9Qcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZy50cyIsICJzcmMvdXRpbHMvVUlUd2Vha2VyQ29uZmlnLnRzIiwgInNyYy91dGlscy9EYXRhRmlsZXNFZGl0b3JDb25maWcudHMiLCAic3JjL3V0aWxzL0NvbmZpZ0ZsdXNoU2VydmljZS50cyIsICJzcmMvdWkvd2l6YXJkL0RlcGxveW1lbnRTdGVwLnRzIiwgInNyYy91aS93aXphcmQvRmluYWxpemVTdGVwLnRzIiwgInNyYy91aS93aXphcmQvV2l6YXJkU3RhdGVNYWNoaW5lLnRzIiwgInNyYy91aS9IZWFsdGhDaGVja01vZGFsLnRzIiwgInNyYy91dGlscy9zZXR0aW5ncy1jb21wYXQudHMiLCAic3JjL3V0aWxzL1ByZXNldE1hbmFnZXIudHMiLCAic3JjL3VpL0FwcGx5UHJlc2V0TW9kYWwudHMiLCAic3JjL2NvbW1hbmRzL2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyByZXF1ZXN0VXJsLCBSZXF1ZXN0VXJsUGFyYW0gfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcclxuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuXHJcbmNvbnN0IGV4ZWNBc3luYyA9IHByb21pc2lmeShleGVjKTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR2l0SHViUmVwb1Jlc3BvbnNlIHtcclxuICAgIGNsb25lX3VybDogc3RyaW5nO1xyXG4gICAgaHRtbF91cmw6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdpdE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSBkaXJlY3RvcnkgaXMgYSBHaXQgcmVwb3NpdG9yeS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGlzUmVwbyhwcm9qZWN0Um9vdDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgaWYgKCFwcm9qZWN0Um9vdCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUocHJvamVjdFJvb3QpO1xyXG4gICAgICAgICAgICBjb25zdCBkb3RHaXRQYXRoID0gcGF0aC5qb2luKGFic29sdXRlUGF0aCwgJy5naXQnKTtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhkb3RHaXRQYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdE1hbmFnZXIuaXNSZXBvIGNoZWNrOicsIHtcclxuICAgICAgICAgICAgICAgIHByb2plY3RSb290LFxyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgZG90R2l0UGF0aCxcclxuICAgICAgICAgICAgICAgIGV4aXN0c1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhhYnNvbHV0ZVBhdGgpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBTVFJJQ1QgQ0hFQ0s6IE9ubHkgY29uc2lkZXIgaXQgYSByZXBvIGlmIC5naXQgZXhpc3RzIEVYQUNUTFkgaW4gdGhpcyBmb2xkZXIuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgXCJnaG9zdFwiIGRldGVjdGlvbiBmcm9tIHBhcmVudCByZXBvc2l0b3JpZXMuXHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignR2l0TWFuYWdlci5pc1JlcG8gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgR2l0IHJlcG9zaXRvcnkgYXQgdGhlIGdpdmVuIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBpbml0UmVwbyhwcm9qZWN0Um9vdDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgYXdhaXQgZXhlY0FzeW5jKCdnaXQgaW5pdCcsIHsgY3dkOiBwcm9qZWN0Um9vdCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHJlbW90ZSBVUkwgZm9yIHRoZSByZXBvc2l0b3J5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgc2V0UmVtb3RlKHByb2plY3RSb290OiBzdHJpbmcsIHVybDogc3RyaW5nLCByZW1vdGVOYW1lOiBzdHJpbmcgPSAnb3JpZ2luJyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHJlbW90ZSBhZGQgJHtyZW1vdGVOYW1lfSAke3VybH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gSWYgcmVtb3RlIGFscmVhZHkgZXhpc3RzLCB1cGRhdGUgaXRcclxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXhlY0FzeW5jKGBnaXQgcmVtb3RlIHNldC11cmwgJHtyZW1vdGVOYW1lfSAke3VybH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJlbW90ZSBVUkwgZm9yIHRoZSByZXBvc2l0b3J5LCBzY3J1YmJpbmcgYW55IHRva2VucyBmb3Igc2VjdXJpdHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBnZXRSZW1vdGVVcmwocHJvamVjdFJvb3Q6IHN0cmluZywgcmVtb3RlTmFtZTogc3RyaW5nID0gJ29yaWdpbicpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHN0ZG91dCB9ID0gYXdhaXQgZXhlY0FzeW5jKGBnaXQgcmVtb3RlIGdldC11cmwgJHtyZW1vdGVOYW1lfWAsIHsgY3dkOiBwcm9qZWN0Um9vdCB9KTtcclxuICAgICAgICAgICAgbGV0IHVybCA9IHN0ZG91dC50cmltKCkgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh1cmwgJiYgdXJsLmluY2x1ZGVzKCdAZ2l0aHViLmNvbScpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY3J1YiB0b2tlbjogaHR0cHM6Ly9naHBfeHh4QGdpdGh1Yi5jb20vLi4uIC0+IGh0dHBzOi8vZ2l0aHViLmNvbS8uLi5cclxuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9odHRwczpcXC9cXC8uKkBnaXRodWJcXC5jb20vLCAnaHR0cHM6Ly9naXRodWIuY29tJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbG9jYWwgYnJhbmNoIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBnZXRDdXJyZW50QnJhbmNoKHByb2plY3RSb290OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3Rkb3V0IH0gPSBhd2FpdCBleGVjQXN5bmMoJ2dpdCBicmFuY2ggLS1zaG93LWN1cnJlbnQnLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGRvdXQudHJpbSgpIHx8ICdtYWluJztcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtYWluJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluaXRpYWwgY29tbWl0IGFuZCBwdXNoZXMgdG8gdGhlIHJlbW90ZSwgc2V0dGluZyB0aGUgdXBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBpbml0aWFsQ29tbWl0QW5kUHVzaChwcm9qZWN0Um9vdDogc3RyaW5nLCBicmFuY2g6IHN0cmluZywgcmVtb3RlTmFtZTogc3RyaW5nID0gJ29yaWdpbicsIHRva2VuPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnR2l0TWFuYWdlci5pbml0aWFsQ29tbWl0QW5kUHVzaDogc3RhcnRpbmcnLCB7IHByb2plY3RSb290LCBicmFuY2gsIHJlbW90ZU5hbWUsIGhhc1Rva2VuOiAhIXRva2VuIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gMS4gRW5zdXJlIHVzZXIgaWRlbnRpdHkgaXMgc2V0IChnaXQgY29tbWl0IGZhaWxzIHdpdGhvdXQgaXQpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoJ2dpdCBjb25maWcgdXNlci5uYW1lJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdE1hbmFnZXI6IFNldHRpbmcgbG9jYWwgZ2l0IHVzZXIubmFtZScpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXhlY0FzeW5jKCdnaXQgY29uZmlnIHVzZXIubmFtZSBcIlZhdWx0IENNUyBVc2VyXCInLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoJ2dpdCBjb25maWcgdXNlci5lbWFpbCBcInZhdWx0LWNtc0BleGFtcGxlLmNvbVwiJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAyLiBBZGQgYWxsIGZpbGVzXHJcbiAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYygnZ2l0IGFkZCAuJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gMy4gQ29tbWl0XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoJ2dpdCBjb21taXQgLW0gXCJJbml0aWFsIGNvbW1pdCBmcm9tIFZhdWx0IENNU1wiJywgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChjb21taXRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gY29tbWl0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGNvbW1pdEVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoY29tbWl0RXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnbm90aGluZyB0byBjb21taXQnKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ3dvcmtpbmcgdHJlZSBjbGVhbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnR2l0TWFuYWdlcjogTm90aGluZyB0byBjb21taXQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY29tbWl0RXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDQuIEVuc3VyZSBicmFuY2ggbmFtZSBpcyBzZXQgbG9jYWxseVxyXG4gICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoYGdpdCBicmFuY2ggLU0gJHticmFuY2h9YCwgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gNS4gUHVzaCBhbmQgc2V0IHVwc3RyZWFtXHJcbiAgICAgICAgICAgIC8vIFRvIGVuc3VyZSB0aGUgcHVzaCBzdWNjZWVkcyB3aXRob3V0IGEgY3JlZGVudGlhbCBoZWxwZXIsIHdlIHRlbXBvcmFyaWx5IHVzZSB0aGUgdG9rZW4gaW4gdGhlIFVSTFxyXG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZVVybCA9IGF3YWl0IHRoaXMuZ2V0UmVtb3RlVXJsKHByb2plY3RSb290LCByZW1vdGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVVcmwgJiYgcmVtb3RlVXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdGVkVXJsID0gcmVtb3RlVXJsLnJlcGxhY2UoJ2h0dHBzOi8vJywgYGh0dHBzOi8vJHt0b2tlbn1AYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdE1hbmFnZXI6IFB1c2hpbmcgd2l0aCB0ZW1wb3JhcnkgdG9rZW4gYXV0aCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHRlbXBvcmFyaWx5IHNldCB0aGUgcmVtb3RlIFVSTCB0byBpbmNsdWRlIHRoZSB0b2tlbiBmb3IgdGhlIHB1c2hcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBleGVjQXN5bmMoYGdpdCByZW1vdGUgc2V0LXVybCAke3JlbW90ZU5hbWV9ICR7YXV0aGVudGljYXRlZFVybH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHB1c2ggLXUgJHtyZW1vdGVOYW1lfSAke2JyYW5jaH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQUxXQVlTIHJldmVydCB0byB0aGUgY2xlYW4gVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHJlbW90ZSBzZXQtdXJsICR7cmVtb3RlTmFtZX0gJHtyZW1vdGVVcmx9YCwgeyBjd2Q6IHByb2plY3RSb290IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZXhlY0FzeW5jKGBnaXQgcHVzaCAtdSAke3JlbW90ZU5hbWV9ICR7YnJhbmNofWAsIHsgY3dkOiBwcm9qZWN0Um9vdCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWNBc3luYyhgZ2l0IHB1c2ggLXUgJHtyZW1vdGVOYW1lfSAke2JyYW5jaH1gLCB7IGN3ZDogcHJvamVjdFJvb3QgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHaXRNYW5hZ2VyLmluaXRpYWxDb21taXRBbmRQdXNoIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVwb3NpdG9yeSBvbiBHaXRIdWIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVHaXRIdWJSZXBvKHRva2VuOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgaXNQcml2YXRlOiBib29sZWFuKTogUHJvbWlzZTxHaXRIdWJSZXBvUmVzcG9uc2U+IHtcclxuICAgICAgICBjb25zdCBwYXJhbXM6IFJlcXVlc3RVcmxQYXJhbSA9IHtcclxuICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS91c2VyL3JlcG9zJyxcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYHRva2VuICR7dG9rZW59YCxcclxuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uJyxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZTogaXNQcml2YXRlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVwb3NpdG9yeSBuYW1lIGFscmVhZHkgZXhpc3RzIG9uIHlvdXIgR2l0SHViIGFjY291bnQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIG1vcmUgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZSBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgR2l0SHViIEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gdHlwZW9mIHJlc3BvbnNlLmpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShyZXNwb25zZS5qc29uKSA6IHJlc3BvbnNlLmpzb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yRGF0YT8ubWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgR2l0SHViIEFQSSBFcnJvcjogJHtlcnJvckRhdGEubWVzc2FnZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JEYXRhLmVycm9ycz8uWzBdPy5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYCAoJHtlcnJvckRhdGEuZXJyb3JzWzBdLm1lc3NhZ2V9KWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBhcnNlIGVycm9yLCB1c2UgYmFzaWMgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uIGFzIEdpdEh1YlJlcG9SZXNwb25zZTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGFscmVhZHkgYW4gRXJyb3Igd2l0aCB0aGUgbWVzc2FnZSB3ZSB3YW50XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0dpdEh1YiBBUEkgRXJyb3InKSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgdW5leHBlY3RlZCBlcnJvcnMgb3IgcmVxdWVzdCBmYWlsdXJlc1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygnNDIyJykgfHwgbWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXBvc2l0b3J5IG5hbWUgYWxyZWFkeSBleGlzdHMgb24geW91ciBHaXRIdWIgYWNjb3VudC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZmllcyBpZiB0aGUgR2l0SHViIFBBVCBpcyB2YWxpZCBhbmQgcmV0dXJucyB0aGUgdXNlcm5hbWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnlUb2tlbih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zOiBSZXF1ZXN0VXJsUGFyYW0gPSB7XHJcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2FwaS5naXRodWIuY29tL3VzZXInLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGB0b2tlbiAke3Rva2VufWAsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnYzK2pzb24nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybChwYXJhbXMpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uPy5sb2dpbiB8fCBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IFBsdWdpbiwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBWYXVsdENNU1NldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi9zZXR0aW5ncyc7XHJcbmltcG9ydCB7IFNldHRpbmdzVGFiIH0gZnJvbSAnLi91aS9TZXR0aW5nc1RhYic7XHJcbmltcG9ydCB7IFNldHVwV2l6YXJkTW9kYWwgfSBmcm9tICcuL3VpL1NldHVwV2l6YXJkTW9kYWwnO1xyXG5pbXBvcnQgeyByZWdpc3RlckNvbW1hbmRzIH0gZnJvbSAnLi9jb21tYW5kcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYXVsdENNU1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcblx0c2V0dGluZ3M6IFZhdWx0Q01TU2V0dGluZ3M7XHJcblx0cHJpdmF0ZSBzdGFydHVwVGltZW91dElkPzogbnVtYmVyO1xyXG5cclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuXHRcdC8vIFJlcGFpciByZWxhdGl2ZSBwcm9qZWN0Um9vdCB0byBhYnNvbHV0ZSBmb3IgcmVsaWFiaWxpdHlcclxuXHRcdGlmICh0aGlzLnNldHRpbmdzLnByb2plY3RSb290ICYmICFwYXRoLmlzQWJzb2x1dGUodGhpcy5zZXR0aW5ncy5wcm9qZWN0Um9vdCkpIHtcclxuXHRcdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xyXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHRcdFx0aWYgKHZhdWx0UGF0aCkge1xyXG5cdFx0XHRcdGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIHRoaXMuc2V0dGluZ3MucHJvamVjdFJvb3QpO1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYFtWYXVsdCBDTVNdIFJlcGFpcmluZyByZWxhdGl2ZSBwcm9qZWN0Um9vdDogJHt0aGlzLnNldHRpbmdzLnByb2plY3RSb290fSAtPiAke2Fic29sdXRlUGF0aH1gKTtcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnByb2plY3RSb290ID0gYWJzb2x1dGVQYXRoO1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZWdpc3RlciBjb21tYW5kc1xyXG5cdFx0cmVnaXN0ZXJDb21tYW5kcyh0aGlzKTtcclxuXHJcblx0XHQvLyBBZGQgc2V0dGluZ3MgdGFiXHJcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG5cdFx0Ly8gT3BlbiB3aXphcmQgb24gc3RhcnR1cCBpZiBjb25maWd1cmVkXHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXApIHtcclxuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xyXG5cdFx0XHRcdC8vIERlbGF5IHRoZSB3aXphcmQgdG8gbGV0IE9ic2lkaWFuIGZ1bGx5IGxvYWQgKGxpa2UgYXN0cm8tbW9kdWxhci1zZXR0aW5ncylcclxuXHRcdFx0XHR0aGlzLnN0YXJ0dXBUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHR2b2lkIChhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdC8vIFJlbG9hZCBzZXR0aW5ncyB0byBjaGVjayBpZiB1c2VyIGRpc2FibGVkIHRoZSBzZXR0aW5nXHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHdpemFyZCA9IG5ldyBTZXR1cFdpemFyZE1vZGFsKHRoaXMuYXBwLCB1bmRlZmluZWQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0XHRcdHdpemFyZC5vcGVuKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSwgMjAwMCk7IC8vIDItc2Vjb25kIGRlbGF5XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHRpZiAodGhpcy5zdGFydHVwVGltZW91dElkKSB7XHJcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zdGFydHVwVGltZW91dElkKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkgYXMgUGFydGlhbDxWYXVsdENNU1NldHRpbmdzPik7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IENvbnRlbnRUeXBlQ29uZmlnLCBGcm9udG1hdHRlclByb3BlcnRpZXMsIEJhc2VzQ01TQ29uZmlnLCBBc3Ryb0NvbXBvc2VyQ29uZmlnLCBTRU9Db25maWcsIFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnLCBJbWFnZU1hbmFnZXJDb25maWcsIEhvbWVCYXNlQ29uZmlnLCBFeHBsb3JlckZvY3VzQ29uZmlnLCBJZ25vcmVDb25maWcsIEdpdENvbmZpZyB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYXVsdENNU1NldHRpbmdzIHtcclxuXHRwcm9qZWN0Um9vdDogc3RyaW5nO1xyXG5cdGNvbmZpZ0ZpbGVQYXRoOiBzdHJpbmc7XHJcblx0Y29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdO1xyXG5cdGZyb250bWF0dGVyUHJvcGVydGllczogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIH07XHJcblx0ZGVmYXVsdENvbnRlbnRUeXBlSWQ/OiBzdHJpbmc7XHJcblx0YXR0YWNobWVudEhhbmRsaW5nTW9kZTogJ3NwZWNpZmllZC1mb2xkZXInIHwgJ3NhbWUtZm9sZGVyJyB8ICdzdWJmb2xkZXInO1xyXG5cdGF0dGFjaG1lbnRGb2xkZXJOYW1lPzogc3RyaW5nO1xyXG5cdHByZXNldDogJ3ZhbmlsbGEnIHwgJ29waW5pb25hdGVkJyB8ICdjdXN0b20nO1xyXG5cdHByZXNldE5hbWU6IHN0cmluZztcclxuXHRwcmVzZXRzUmVwbzogc3RyaW5nO1xyXG5cdGVuYWJsZUVkaXRpbmdUb29sYmFyOiBib29sZWFuO1xyXG5cdGVuYWJsZU1keFN1cHBvcnQ/OiBib29sZWFuO1xyXG5cdGVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzPzogYm9vbGVhbjtcclxuXHRlbmFibGVkUGx1Z2luczogc3RyaW5nW107XHJcblx0ZGlzYWJsZWRQbHVnaW5zOiBzdHJpbmdbXTtcclxuXHR0aGVtZTogc3RyaW5nO1xyXG5cdGJhc2VzQ01TQ29uZmlnOiBCYXNlc0NNU0NvbmZpZztcclxuXHRhc3Ryb0NvbXBvc2VyQ29uZmlnOiBBc3Ryb0NvbXBvc2VyQ29uZmlnO1xyXG5cdHNlb0NvbmZpZzogU0VPQ29uZmlnO1xyXG5cdHByb3BlcnR5T3ZlckZpbGVOYW1lOiBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZztcclxuXHRpbWFnZU1hbmFnZXI6IEltYWdlTWFuYWdlckNvbmZpZztcclxuXHRob21lQmFzZTogSG9tZUJhc2VDb25maWc7XHJcblx0ZXhwbG9yZXJGb2N1czogRXhwbG9yZXJGb2N1c0NvbmZpZztcclxuXHRpZ25vcmVDb25maWc6IElnbm9yZUNvbmZpZztcclxuXHRnaXRDb25maWc6IEdpdENvbmZpZztcclxuXHRydW5XaXphcmRPblN0YXJ0dXA6IGJvb2xlYW47XHJcblx0d2l6YXJkQ29tcGxldGVkOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogVmF1bHRDTVNTZXR0aW5ncyA9IHtcclxuXHRwcm9qZWN0Um9vdDogJycsXHJcblx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdGNvbnRlbnRUeXBlczogW10sXHJcblx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiB7fSxcclxuXHRhdHRhY2htZW50SGFuZGxpbmdNb2RlOiAnc3ViZm9sZGVyJyxcclxuXHRhdHRhY2htZW50Rm9sZGVyTmFtZTogdW5kZWZpbmVkLFxyXG5cdHByZXNldDogJ3ZhbmlsbGEnLFxyXG5cdHByZXNldE5hbWU6ICcnLFxyXG5cdHByZXNldHNSZXBvOiAnZGF2aWR2a2ltYmFsbC92YXVsdC1jbXMtcHJlc2V0cycsXHJcblx0ZW5hYmxlRWRpdGluZ1Rvb2xiYXI6IGZhbHNlLFxyXG5cdGVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzOiBmYWxzZSxcclxuXHRlbmFibGVkUGx1Z2luczogW10sXHJcblx0ZGlzYWJsZWRQbHVnaW5zOiBbXSxcclxuXHR0aGVtZTogJycsXHJcblx0YmFzZXNDTVNDb25maWc6IHtcclxuXHRcdHZpZXdzOiBbXVxyXG5cdH0sXHJcblx0YXN0cm9Db21wb3NlckNvbmZpZzoge1xyXG5cdFx0Y3VzdG9tQ29udGVudFR5cGVzOiBbXSxcclxuXHRcdGRlZmF1bHRUZW1wbGF0ZTogJycsXHJcblx0XHRjb25maWdGaWxlUGF0aDogJycsXHJcblx0XHR0ZXJtaW5hbFByb2plY3RSb290UGF0aDogJydcclxuXHR9LFxyXG5cdHNlb0NvbmZpZzoge1xyXG5cdFx0dGl0bGVQcm9wZXJ0eTogJ3RpdGxlJyxcclxuXHRcdGRlc2NyaXB0aW9uUHJvcGVydHk6IHVuZGVmaW5lZCxcclxuXHRcdHNjYW5EaXJlY3RvcmllczogJycsXHJcblx0XHR1c2VGaWxlbmFtZUFzVGl0bGU6IGZhbHNlLFxyXG5cdFx0dXNlRmlsZW5hbWVBc1NsdWc6IHRydWUsXHJcblx0XHRlbmFibGVNRFhTdXBwb3J0OiBmYWxzZVxyXG5cdH0sXHJcblx0cHJvcGVydHlPdmVyRmlsZU5hbWU6IHtcclxuXHRcdHByb3BlcnR5S2V5OiAndGl0bGUnXHJcblx0fSxcclxuXHRpbWFnZU1hbmFnZXI6IHt9LFxyXG5cdGhvbWVCYXNlOiB7fSxcclxuXHRleHBsb3JlckZvY3VzOiB7fSxcclxuXHRpZ25vcmVDb25maWc6IHtcclxuXHRcdGdpdElnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlLFxyXG5cdFx0dml0ZUlnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlXHJcblx0fSxcclxuXHRnaXRDb25maWc6IHtcclxuXHRcdGVuYWJsZWQ6IGZhbHNlLFxyXG5cdFx0aXNQcml2YXRlOiB0cnVlLFxyXG5cdFx0YnJhbmNoTmFtZTogJ21haW4nLFxyXG5cdFx0YXV0b0NvbmZpZ3VyZU9ic2lkaWFuR2l0OiB0cnVlXHJcblx0fSxcclxuXHRydW5XaXphcmRPblN0YXJ0dXA6IHRydWUsXHJcblx0d2l6YXJkQ29tcGxldGVkOiBmYWxzZVxyXG59O1xyXG5cclxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgTm90aWNlLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IFZhdWx0Q01TUGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgU2V0dXBXaXphcmRNb2RhbCB9IGZyb20gJy4vU2V0dXBXaXphcmRNb2RhbCc7XG5pbXBvcnQgeyBIZWFsdGhDaGVja01vZGFsIH0gZnJvbSAnLi9IZWFsdGhDaGVja01vZGFsJztcbmltcG9ydCB7IGNyZWF0ZVNldHRpbmdzR3JvdXAgfSBmcm9tICcuLi91dGlscy9zZXR0aW5ncy1jb21wYXQnO1xuaW1wb3J0IHsgUHJlc2V0TWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL1ByZXNldE1hbmFnZXInO1xuaW1wb3J0IHsgUHJvamVjdE9wdGltaXplciB9IGZyb20gJy4uL3V0aWxzL1Byb2plY3RPcHRpbWl6ZXInO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IFZhdWx0Q01TUGx1Z2luO1xuXHRwdWJsaWMgaWNvbiA9ICdsdWNpZGUtdmF1bHQnO1xuXHRwcml2YXRlIGNvbnRlbnRFbDogSFRNTEVsZW1lbnQ7XG5cdHByaXZhdGUgZ2l0U2V0dGluZzogU2V0dGluZztcblx0cHJpdmF0ZSB2aXRlU2V0dGluZzogU2V0dGluZztcblx0cHJpdmF0ZSBvcHRpbWl6ZXI6IFByb2plY3RPcHRpbWl6ZXI7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogVmF1bHRDTVNQbHVnaW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblx0XHR0aGlzLmNvbnRlbnRFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdigndmF1bHQtY21zLXNldHRpbmdzLWNvbnRhaW5lcicpO1xuXHRcdHZvaWQgdGhpcy5yZW5kZXIoKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcmVuZGVyKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5jb250ZW50RWwpIHJldHVybjtcblxuXHRcdHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG5cblx0XHQvLyBGaXJzdCBncm91cCAobm8gaGVhZGluZykgLSBmb2xsb3dpbmcgVUkgVHdlYWtlciBwYXR0ZXJuXG5cdFx0Y29uc3QgZ2VuZXJhbEdyb3VwID0gY3JlYXRlU2V0dGluZ3NHcm91cCh0aGlzLmNvbnRlbnRFbCwgdW5kZWZpbmVkLCAndmF1bHQtY21zJyk7XG5cblx0XHRnZW5lcmFsR3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdPcGVuIHNldHVwIHdpemFyZCcpXG5cdFx0XHRcdC5zZXREZXNjKCdMYXVuY2ggdGhlIHNldHVwIHdpemFyZCcpXG5cdFx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdPcGVuIHdpemFyZCcpXG5cdFx0XHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0bmV3IFNldHVwV2l6YXJkTW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLnNldHRpbmdzLCB0aGlzLnBsdWdpbikub3BlbigpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Z2VuZXJhbEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcblx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUnVuIHdpemFyZCBvbiBzdGFydHVwJylcblx0XHRcdFx0LnNldERlc2MoJ0F1dG9tYXRpY2FsbHkgb3BlbiB0aGUgd2l6YXJkIHdoZW4gdGhlIHBsdWdpbiBsb2FkcycpXG5cdFx0XHRcdC5hZGRUb2dnbGUodG9nZ2xlID0+IHtcblx0XHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXApXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGdlbmVyYWxHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRzZXR0aW5nLnNldE5hbWUoJ0hlYWx0aCBjaGVjaycpXG5cdFx0XHRcdC5zZXREZXNjKCdDaGVjayBwbHVnaW4gaW5zdGFsbGF0aW9uIGFuZCBjb25maWd1cmF0aW9uIHN0YXR1cycpXG5cdFx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdSdW4gaGVhbHRoIGNoZWNrJylcblx0XHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0bmV3IEhlYWx0aENoZWNrTW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luKS5vcGVuKCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBQcmVzZXQgY29uZmlndXJhdGlvbiBncm91cFxuXHRcdGNvbnN0IHByZXNldEdyb3VwID0gY3JlYXRlU2V0dGluZ3NHcm91cCh0aGlzLmNvbnRlbnRFbCwgJ1ByZXNldCBjb25maWd1cmF0aW9uJywgJ3ZhdWx0LWNtcy1wcmVzZXRzJyk7XG5cblx0XHRwcmVzZXRHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRzZXR0aW5nLnNldE5hbWUoJ1ByZXNldCBmb2xkZXIgbmFtZScpXG5cdFx0XHRcdC5zZXREZXNjKCdGb2xkZXIgbmFtZSBpbiB0aGUgcmVwb3NpdG9yeScpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdHRleHRcblx0XHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRXhhbXBsZTogc3RhcmxpZ2h0Jylcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXROYW1lKVxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXROYW1lID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cHJlc2V0R3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdQcmVzZXRzIHJlcG9zaXRvcnknKVxuXHRcdFx0XHQuc2V0RGVzYygnR2l0SHViIHJlcG9zaXRvcnkgY29udGFpbmluZyB0aGUgcHJlc2V0cycpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdHRleHRcblx0XHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRXhhbXBsZTogb3duZXIvcmVwbycpXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlc2V0c1JlcG8pXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnByZXNldHNSZXBvID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cHJlc2V0R3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdEb3dubG9hZCBhbmQgYXBwbHkgcHJlc2V0Jylcblx0XHRcdFx0LnNldERlc2MoJ0Rvd25sb2FkIHRoZSBzcGVjaWZpZWQgcHJlc2V0IGFuZCBhcHBseSBpdCB0byB5b3VyIHZhdWx0Jylcblx0XHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4ge1xuXHRcdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0FwcGx5IHByZXNldCcpXG5cdFx0XHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgUHJlc2V0TWFuYWdlcih0aGlzLmFwcCk7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IG1hbmFnZXIuYXBwbHlQcmVzZXQodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlc2V0c1JlcG8sIHRoaXMucGx1Z2luLnNldHRpbmdzLnByZXNldE5hbWUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gR2l0IENvbmZpZ3VyYXRpb24gZ3JvdXBcblx0XHRjb25zdCBnaXRHcm91cCA9IGNyZWF0ZVNldHRpbmdzR3JvdXAodGhpcy5jb250ZW50RWwsICdHaXQgY29uZmlndXJhdGlvbicsICd2YXVsdC1jbXMtZ2l0Jyk7XG5cdFx0bGV0IGlzRnVsbHlDb25maWd1cmVkID0gZmFsc2U7XG5cblx0XHQvLyBEaXNwbGF5IEdpdCBzdGF0dXMgaWYgcHJvamVjdCByb290IGlzIHNldFxuXHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0Um9vdCAmJiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0Um9vdC50cmltKCkgIT09ICcnKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCB7IEdpdE1hbmFnZXIgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXRpbHMvR2l0TWFuYWdlcicpO1xuXHRcdFx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290O1xuXHRcdFx0XHRjb25zdCBpc1JlcG8gPSBhd2FpdCBHaXRNYW5hZ2VyLmlzUmVwbyhwcm9qZWN0Um9vdCk7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVVybCA9IGlzUmVwbyA/IGF3YWl0IEdpdE1hbmFnZXIuZ2V0UmVtb3RlVXJsKHByb2plY3RSb290KSA6IG51bGw7XG5cdFx0XHRcdGlzRnVsbHlDb25maWd1cmVkID0gaXNSZXBvICYmICEhcmVtb3RlVXJsO1xuXG5cdFx0XHRcdGdpdEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcblx0XHRcdFx0XHRzZXR0aW5nLnNldE5hbWUoJ0xvY2FsIHJlcG9zaXRvcnkgc3RhdHVzJylcblx0XHRcdFx0XHRcdC5zZXREZXNjKGlzUmVwbyA/ICdHaXQgaXMgaW5pdGlhbGl6ZWQgYXQgcHJvamVjdCByb290LicgOiAnR2l0IGlzIE5PVCBpbml0aWFsaXplZCBhdCBwcm9qZWN0IHJvb3QuJyk7XG5cblx0XHRcdFx0XHRjb25zdCBzdGF0dXNJY29uID0gc2V0dGluZy5jb250cm9sRWwuY3JlYXRlU3Bhbih7XG5cdFx0XHRcdFx0XHRjbHM6IGlzUmVwbyA/ICdnaXQtc3RhdHVzLWljb24tb2snIDogJ2dpdC1zdGF0dXMtaWNvbi13YXJuJyxcblx0XHRcdFx0XHRcdGF0dHI6IHsgc3R5bGU6IGBtYXJnaW4tbGVmdDogMTBweDsgY29sb3I6ICR7aXNSZXBvID8gJ3ZhcigtLXRleHQtc3VjY2VzcyknIDogJ3ZhcigtLXRleHQtd2FybmluZyknfTtgIH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzdGF0dXNJY29uLnNldFRleHQoaXNSZXBvID8gJ1x1MjcxMyBEZXRlY3RlZCcgOiAnXHUyNkEwIE1pc3NpbmcnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Z2l0R3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUHJvamVjdCByb290IHBhdGgnKVxuXHRcdFx0XHRcdFx0LnNldERlc2MoJ0RpcmVjdCBwYXRoIGJlaW5nIGNoZWNrZWQgZm9yIEdpdCcpXG5cdFx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdFx0dGV4dC5zZXRWYWx1ZShwcm9qZWN0Um9vdClcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQodHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHJlbW90ZVVybCkge1xuXHRcdFx0XHRcdGdpdEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcblx0XHRcdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUmVtb3RlIFVSTCcpXG5cdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdDb25uZWN0ZWQgR2l0SHViIHJlcG9zaXRvcnknKVxuXHRcdFx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdFx0XHR0ZXh0LnNldFZhbHVlKHJlbW90ZVVybClcblx0XHRcdFx0XHRcdFx0XHRcdC5zZXREaXNhYmxlZCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignU2V0dGluZ3NUYWI6IEZhaWxlZCB0byBjaGVjayBHaXQgc3RhdHVzOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPbmx5IHNob3cgbWFuYWdlbWVudC9zZXR1cCBidXR0b24gaWYgTk9UIGZ1bGx5IGNvbmZpZ3VyZWRcblx0XHRpZiAoIWlzRnVsbHlDb25maWd1cmVkKSB7XG5cdFx0XHRnaXRHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnTWFuYWdlIEdpdCBpbnRlZ3JhdGlvbicpXG5cdFx0XHRcdFx0LnNldERlc2MoJ0luaXRpYWxpemUgcmVwb3NpdG9yeSwgY29ubmVjdCB0byBHaXRIdWIsIG9yIHVwZGF0ZSBjcmVkZW50aWFscy4nKVxuXHRcdFx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdFx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdTZXR1cCAvIFVwZGF0ZSBHaXQuLi4nKVxuXHRcdFx0XHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbW9kYWwgPSBuZXcgU2V0dXBXaXphcmRNb2RhbCh0aGlzLmFwcCwgeyBjdXJyZW50U3RlcDogMTEgfSwgdGhpcy5wbHVnaW4pO1xuXHRcdFx0XHRcdFx0XHRcdG1vZGFsLm9wZW4oKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBQcm9qZWN0IG9wdGltaXphdGlvbiBncm91cFxuXHRcdGNvbnN0IG9wdGltaXphdGlvbkdyb3VwID0gY3JlYXRlU2V0dGluZ3NHcm91cCh0aGlzLmNvbnRlbnRFbCwgJ1Byb2plY3Qgb3B0aW1pemF0aW9uIChvcHRpb25hbCknLCAndmF1bHQtY21zLW9wdGltaXphdGlvbicpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgcHJvamVjdCByb290IGlzIGNvbmZpZ3VyZWRcblx0XHRpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290KSB7XG5cdFx0XHRvcHRpbWl6YXRpb25Hcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUHJvamVjdCBub3QgZGV0ZWN0ZWQnKVxuXHRcdFx0XHRcdC5zZXREZXNjKCdDb21wbGV0ZSB0aGUgc2V0dXAgd2l6YXJkIGZpcnN0IHRvIGRldGVjdCB5b3VyIEFzdHJvIHByb2plY3QgYmVmb3JlIGNvbmZpZ3VyaW5nIG9wdGltaXphdGlvbnMuJyk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgb3B0aW1pemVyIGluc3RhbmNlXG5cdFx0Y29uc3Qgd2l6YXJkU3RhdGU6IFdpemFyZFN0YXRlID0ge1xuXHRcdFx0Li4udGhpcy5wbHVnaW4uc2V0dGluZ3MsXG5cdFx0XHRjdXJyZW50U3RlcDogMCxcblx0XHRcdHByb2plY3REZXRlY3Rpb246IHtcblx0XHRcdFx0cHJvamVjdFJvb3Q6IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290LFxuXHRcdFx0XHRjb25maWdGaWxlUGF0aDogdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29uZmlnRmlsZVBhdGgsXG5cdFx0XHRcdHZhdWx0TG9jYXRpb246ICdjb250ZW50J1xuXHRcdFx0fVxuXHRcdH0gYXMgV2l6YXJkU3RhdGU7XG5cblx0XHR0aGlzLm9wdGltaXplciA9IG5ldyBQcm9qZWN0T3B0aW1pemVyKHRoaXMuYXBwLCB3aXphcmRTdGF0ZSk7XG5cdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuZ2V0U3RhdHVzKCk7XG5cblx0XHRvcHRpbWl6YXRpb25Hcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XG5cdFx0XHR0aGlzLmdpdFNldHRpbmcgPSBzZXR0aW5nO1xuXHRcdFx0dGhpcy51cGRhdGVHaXRTZXR0aW5nKHN0YXR1cy5naXRJZ25vcmVTdGF0dXMpO1xuXHRcdH0pO1xuXG5cdFx0b3B0aW1pemF0aW9uR3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xuXHRcdFx0dGhpcy52aXRlU2V0dGluZyA9IHNldHRpbmc7XG5cdFx0XHR0aGlzLnVwZGF0ZVZpdGVTZXR0aW5nKHN0YXR1cy52aXRlSWdub3JlU3RhdHVzKTtcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlR2l0U2V0dGluZyhzdGF0dXM6ICdjb25maWd1cmVkJyB8ICdub3QtY29uZmlndXJlZCcpIHtcblx0XHR0aGlzLmdpdFNldHRpbmcuc2V0TmFtZSgnSWdub3JlIGluIEdpdCcpXG5cdFx0XHQuc2V0RGVzYygnQWRkIHdvcmtzcGFjZSBmaWxlcyB0byBHaXQgaWdub3JlJylcblx0XHRcdC5jbGVhcigpOyAvLyBDbGVhciBleGlzdGluZyBidXR0b25zIGFuZCBzdGF0dXNcblxuXHRcdHRoaXMuZ2l0U2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuY29uZmlndXJlR2l0SWdub3JlKCk7XG5cdFx0XHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVDb25maWcuZ2l0SWdub3JlQ29uZmlndXJlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdHaXQgaWdub3JlIHVwZGF0ZWQnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0NvdWxkIG5vdCBjb25maWd1cmUgR2l0IGlnbm9yZTogcHJvamVjdCByb290IG5vdCBkZXRlY3RlZCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc3QgbmV3U3RhdHVzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuZ2V0U3RhdHVzKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZUdpdFNldHRpbmcobmV3U3RhdHVzLmdpdElnbm9yZVN0YXR1cyk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byB1cGRhdGUgR2l0IGlnbm9yZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9KTtcblx0XHR0aGlzLm9wdGltaXplci5yZW5kZXJTdGF0dXModGhpcy5naXRTZXR0aW5nLmNvbnRyb2xFbCwgc3RhdHVzKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlVml0ZVNldHRpbmcoc3RhdHVzOiAnY29uZmlndXJlZCcgfCAnbm90LWNvbmZpZ3VyZWQnKSB7XG5cdFx0dGhpcy52aXRlU2V0dGluZy5zZXROYW1lKCdJZ25vcmUgd29ya3NwYWNlIGFuZCBIb21lIEJhc2UgZm9sZGVycyBpbiBWaXRlJylcblx0XHRcdC5zZXREZXNjKCdDb25maWd1cmUgVml0ZSB0byBpZ25vcmUgT2JzaWRpYW4gYW5kIEhvbWUgQmFzZSBmb2xkZXJzLicpXG5cdFx0XHQuY2xlYXIoKTsgLy8gQ2xlYXIgZXhpc3RpbmcgYnV0dG9ucyBhbmQgc3RhdHVzXG5cblx0XHR0aGlzLnZpdGVTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuXHRcdFx0YnV0dG9uLnNldEJ1dHRvblRleHQoc3RhdHVzID09PSAnY29uZmlndXJlZCcgPyAnUmUtY29uZmlndXJlJyA6ICdDb25maWd1cmUnKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLm9wdGltaXplci5jb25maWd1cmVWaXRlSWdub3JlKCk7XG5cdFx0XHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVDb25maWcudml0ZUlnbm9yZUNvbmZpZ3VyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnVml0ZSBvcHRpbWl6YXRpb24gYXBwbGllZCcpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnQ291bGQgbm90IGNvbmZpZ3VyZSBWaXRlOiBwcm9qZWN0IHJvb3Qgbm90IGRldGVjdGVkJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb25zdCBuZXdTdGF0dXMgPSBhd2FpdCB0aGlzLm9wdGltaXplci5nZXRTdGF0dXMoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlVml0ZVNldHRpbmcobmV3U3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gdXBkYXRlIFZpdGUgY29uZmlnOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHRoaXMub3B0aW1pemVyLnJlbmRlclN0YXR1cyh0aGlzLnZpdGVTZXR0aW5nLmNvbnRyb2xFbCwgc3RhdHVzKTtcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgTW9kYWwsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi93aXphcmQvQmFzZVdpemFyZFN0ZXAnO1xyXG5pbXBvcnQgeyBXaXphcmRTdGF0ZU1hbmFnZXIgfSBmcm9tICcuL3dpemFyZC9XaXphcmRTdGF0ZU1hbmFnZXInO1xyXG5pbXBvcnQgeyBXaXphcmRTdGF0ZU1hY2hpbmUgfSBmcm9tICcuL3dpemFyZC9XaXphcmRTdGF0ZU1hY2hpbmUnO1xyXG5pbXBvcnQgVmF1bHRDTVNQbHVnaW4gZnJvbSAnLi4vbWFpbic7XHJcbmltcG9ydCB7IFdlbGNvbWVTdGVwIH0gZnJvbSAnLi93aXphcmQvV2VsY29tZVN0ZXAnO1xyXG5pbXBvcnQgeyBQcm9qZWN0RGV0ZWN0aW9uU3RlcCB9IGZyb20gJy4vd2l6YXJkL1Byb2plY3REZXRlY3Rpb25TdGVwJztcclxuaW1wb3J0IHsgQ29udGVudFR5cGVTdGVwIH0gZnJvbSAnLi93aXphcmQvQ29udGVudFR5cGVTdGVwJztcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzU3RlcCB9IGZyb20gJy4vd2l6YXJkL0Zyb250bWF0dGVyUHJvcGVydGllc1N0ZXAnO1xyXG5pbXBvcnQgeyBQbHVnaW5Db25maWd1cmF0aW9uU3RlcCB9IGZyb20gJy4vd2l6YXJkL1BsdWdpbkNvbmZpZ3VyYXRpb25TdGVwJztcclxuaW1wb3J0IHsgT3B0aW9uYWxQbHVnaW5zU3RlcCB9IGZyb20gJy4vd2l6YXJkL09wdGlvbmFsUGx1Z2luc1N0ZXAnO1xyXG5pbXBvcnQgeyBJZ25vcmVTdGVwIH0gZnJvbSAnLi93aXphcmQvSWdub3JlU3RlcCc7XHJcbmltcG9ydCB7IEdpdFNldHVwU3RlcCB9IGZyb20gJy4vd2l6YXJkL0dpdFNldHVwU3RlcCc7XHJcbmltcG9ydCB7IERlcGxveW1lbnRTdGVwIH0gZnJvbSAnLi93aXphcmQvRGVwbG95bWVudFN0ZXAnO1xyXG5pbXBvcnQgeyBGaW5hbGl6ZVN0ZXAgfSBmcm9tICcuL3dpemFyZC9GaW5hbGl6ZVN0ZXAnO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3Igc2V0Q3NzUHJvcHNcclxuICovXHJcbmZ1bmN0aW9uIHNldENzc1Byb3BzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xyXG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xyXG5cdFx0Y29uc3QgY3NzS2V5ID0ga2V5LnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGNzc0tleSwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNldHVwV2l6YXJkTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcblx0cHJpdmF0ZSBzdGF0ZU1hbmFnZXI6IFdpemFyZFN0YXRlTWFuYWdlcjtcclxuXHRwcml2YXRlIHN0YXRlTWFjaGluZTogV2l6YXJkU3RhdGVNYWNoaW5lO1xyXG5cdHByaXZhdGUgcGx1Z2luOiBWYXVsdENNU1BsdWdpbjtcclxuXHRwcml2YXRlIHN0ZXBzOiAobmV3IChhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkgPT4gQmFzZVdpemFyZFN0ZXApW107XHJcblx0cHJpdmF0ZSBjdXJyZW50U3RlcEluc3RhbmNlOiBCYXNlV2l6YXJkU3RlcCB8IG51bGwgPSBudWxsO1xyXG5cdHByaXZhdGUgaXNDb21wbGV0aW5nOiBib29sZWFuID0gZmFsc2U7XHJcblx0cHJpdmF0ZSBpbml0aWFsU2V0dGluZ3NTbmFwc2hvdDogUGFydGlhbDxXaXphcmRTdGF0ZT4gfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIGxhc3RTYXZlZFN0ZXBJbmRleDogbnVtYmVyID0gLTE7IC8vIFRyYWNrIHRoZSBsYXN0IHN0ZXAgd2hlcmUgXCJOZXh0XCIgd2FzIGNsaWNrZWRcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGluaXRpYWxTdGF0ZT86IFBhcnRpYWw8V2l6YXJkU3RhdGU+LCBwbHVnaW5JbnN0YW5jZT86IFZhdWx0Q01TUGx1Z2luKSB7XHJcblx0XHRzdXBlcihhcHApO1xyXG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW5JbnN0YW5jZSB8fCAoYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIFZhdWx0Q01TUGx1Z2luPiB9IH0pLnBsdWdpbnM/LnBsdWdpbnM/LlsndmF1bHQtY21zJ10gYXMgVmF1bHRDTVNQbHVnaW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLnBsdWdpbikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ZhdWx0Q01TUGx1Z2luIGluc3RhbmNlIGlzIHJlcXVpcmVkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGF0ZU1hbmFnZXIgPSBuZXcgV2l6YXJkU3RhdGVNYW5hZ2VyKHRoaXMucGx1Z2luKTtcclxuXHJcblx0XHQvLyBBcHBseSBhbnkgaW5pdGlhbCBzdGF0ZSBvdmVycmlkZXNcclxuXHRcdGlmIChpbml0aWFsU3RhdGUpIHtcclxuXHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIudXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuc3RlcHMgPSBbXHJcblx0XHRcdFdlbGNvbWVTdGVwLFxyXG5cdFx0XHRQcm9qZWN0RGV0ZWN0aW9uU3RlcCxcclxuXHRcdFx0Q29udGVudFR5cGVTdGVwLFxyXG5cdFx0XHRGcm9udG1hdHRlclByb3BlcnRpZXNTdGVwLFxyXG5cdFx0XHRQbHVnaW5Db25maWd1cmF0aW9uU3RlcCxcclxuXHRcdFx0T3B0aW9uYWxQbHVnaW5zU3RlcCxcclxuXHRcdFx0SWdub3JlU3RlcCxcclxuXHRcdFx0R2l0U2V0dXBTdGVwLFxyXG5cdFx0XHREZXBsb3ltZW50U3RlcCxcclxuXHRcdFx0RmluYWxpemVTdGVwXHJcblx0XHRdO1xyXG5cclxuXHRcdHRoaXMuc3RhdGVNYWNoaW5lID0gbmV3IFdpemFyZFN0YXRlTWFjaGluZSh0aGlzLnN0ZXBzKTtcclxuXHJcblx0XHRjb25zb2xlLmRlYnVnKCdTZXR1cFdpemFyZE1vZGFsOiBTdGF0ZSBtYWNoaW5lIGluaXRpYWxpemVkIC0nLCB0aGlzLnN0YXRlTWFjaGluZS5nZXREZWJ1Z0luZm8oKSk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBvbk9wZW4oKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdFx0Y29udGVudEVsLmFkZENsYXNzKCd2YXVsdC1jbXMtd2l6YXJkJyk7XHJcblxyXG5cdFx0Ly8gUmVmcmVzaCB0aGUgd2l6YXJkIHN0YXRlIHdpdGggY3VycmVudCBzZXR0aW5nc1xyXG5cdFx0YXdhaXQgdGhpcy5zdGF0ZU1hbmFnZXIucmVmcmVzaFN0YXRlKCk7XHJcblxyXG5cdFx0Ly8gU3RvcmUgYSBzbmFwc2hvdCBvZiBpbml0aWFsIHNldHRpbmdzIHRvIGRldGVjdCBjaGFuZ2VzIGxhdGVyXHJcblx0XHR0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90ID0gdGhpcy5jcmVhdGVTZXR0aW5nc1NuYXBzaG90KCk7XHJcblxyXG5cdFx0Ly8gUmVuZGVyIGN1cnJlbnQgc3RlcCAobWF5IGJlIGFzeW5jLCBidXQgd2UgZG9uJ3QgYXdhaXQgaXQpXHJcblx0XHR2b2lkIHRoaXMucmVuZGVyQ3VycmVudFN0ZXAoKTtcclxuXHR9XHJcblxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuXHRcdC8vIFdoZW4gY2xvc2luZywgb25seSBwcmVzZXJ2ZSBjaGFuZ2VzIGZyb20gc3RlcHMgd2hlcmUgXCJOZXh0XCIgd2FzIGNsaWNrZWRcclxuXHRcdC8vIERpc2NhcmQgdW5zYXZlZCBjaGFuZ2VzIGZyb20gdGhlIGN1cnJlbnQgc3RlcCAoZXF1aXZhbGVudCB0byBcIlNraXBcIilcclxuXHRcdC8vIFRoZSBcIk5leHRcIiBidXR0b24gYWxyZWFkeSBzYXZlZCB0aG9zZSBzdGVwcywgc28gd2UgZG9uJ3QgbmVlZCB0byBzYXZlIGFnYWluXHJcblx0XHQvLyBKdXN0IGNsb3NlIHdpdGhvdXQgc2F2aW5nIC0gdGhpcyBkaXNjYXJkcyBjdXJyZW50IHN0ZXAgY2hhbmdlcyBidXQgcHJlc2VydmVzIHByZXZpb3VzIFwiTmV4dFwiIHNhdmVzXHJcblxyXG5cdFx0Ly8gUmVzZXQgdGhlIGZsYWdcclxuXHRcdHRoaXMuaXNDb21wbGV0aW5nID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHNjcm9sbFRvVG9wKCkge1xyXG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gTWV0aG9kIDE6IEZpbmQgYW5kIHNjcm9sbCB0aGUgYWN0dWFsIHNjcm9sbGFibGUgcGFyZW50XHJcblx0XHRsZXQgc2Nyb2xsYWJsZVBhcmVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gY29udGVudEVsO1xyXG5cdFx0d2hpbGUgKHNjcm9sbGFibGVQYXJlbnQgJiYgc2Nyb2xsYWJsZVBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xyXG5cdFx0XHRjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGFibGVQYXJlbnQpO1xyXG5cdFx0XHRpZiAoc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxIZWlnaHQgPiBzY3JvbGxhYmxlUGFyZW50LmNsaWVudEhlaWdodCAmJlxyXG5cdFx0XHRcdChzdHlsZS5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBzdHlsZS5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IHN0eWxlLm92ZXJmbG93ID09PSAnYXV0bycgfHwgc3R5bGUub3ZlcmZsb3cgPT09ICdzY3JvbGwnKSkge1xyXG5cdFx0XHRcdHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsVG9wID0gMDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRzY3JvbGxhYmxlUGFyZW50ID0gc2Nyb2xsYWJsZVBhcmVudC5wYXJlbnRFbGVtZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1ldGhvZCAyOiBUcnkgY29tbW9uIE9ic2lkaWFuIG1vZGFsIGNvbnRhaW5lcnNcclxuXHRcdGNvbnN0IG1vZGFsQ29udGVudCA9IGNvbnRlbnRFbC5jbG9zZXN0KCcubW9kYWwtY29udGVudCcpO1xyXG5cdFx0aWYgKG1vZGFsQ29udGVudCkge1xyXG5cdFx0XHQobW9kYWxDb250ZW50IGFzIEhUTUxFbGVtZW50KS5zY3JvbGxUb3AgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1vZGFsQ29udGFpbmVyID0gY29udGVudEVsLmNsb3Nlc3QoJy5tb2RhbC1jb250YWluZXInKTtcclxuXHRcdGlmIChtb2RhbENvbnRhaW5lcikge1xyXG5cdFx0XHQobW9kYWxDb250YWluZXIgYXMgSFRNTEVsZW1lbnQpLnNjcm9sbFRvcCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWxzbyB0cnkgY29udGVudEVsIGl0c2VsZlxyXG5cdFx0Y29udGVudEVsLnNjcm9sbFRvcCA9IDA7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHJlbmRlckN1cnJlbnRTdGVwKCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XHJcblx0XHRjb25zdCBzdGVwSW5kZXggPSBzdGF0ZS5jdXJyZW50U3RlcDtcclxuXHJcblx0XHQvLyBDaGVjayBmb3Igc2tpcHBpbmcgQkVGT1JFIGNsZWFyaW5nIGFueSBjb250ZW50IHRvIHByZXZlbnQgdmlzdWFsIGZsaWNrZXJcclxuXHRcdGlmIChzdGVwSW5kZXggPj0gMCAmJiBzdGVwSW5kZXggPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xyXG5cdFx0XHRjb25zdCBTdGVwQ2xhc3MgPSB0aGlzLnN0ZXBzW3N0ZXBJbmRleF07XHJcblx0XHRcdGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdFx0Y29uc3Qgc3RlcEluc3RhbmNlID0gbmV3IFN0ZXBDbGFzcyhcclxuXHRcdFx0XHR0aGlzLmFwcCxcclxuXHRcdFx0XHR0ZW1wRGl2LFxyXG5cdFx0XHRcdHN0YXRlLFxyXG5cdFx0XHRcdCgpID0+IHsgfSwgLy8gVGVtcG9yYXJ5IGhhbmRsZXJzXHJcblx0XHRcdFx0KCkgPT4geyB9LFxyXG5cdFx0XHRcdCgpID0+IHsgfVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0aWYgKGF3YWl0IHN0ZXBJbnN0YW5jZS5zaG91bGRTa2lwKCkpIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKGBTZXR1cFdpemFyZE1vZGFsOiBTdGVwICR7U3RlcENsYXNzLm5hbWV9IHJlcXVlc3RlZCBza2lwLiBBZHZhbmNpbmcuLi5gKTtcclxuXHRcdFx0XHR0aGlzLnN0YXRlTWFuYWdlci5uZXh0U3RlcCh0aGlzLnN0ZXBzLmxlbmd0aCk7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZU1hY2hpbmUubmV4dCgpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnJlbmRlckN1cnJlbnRTdGVwKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTY3JvbGwgdG8gdG9wIElNTUVESUFURUxZIGJlZm9yZSBjbGVhcmluZyBjb250ZW50IHRvIHByZXZlbnQgdmlzdWFsIGp1bXBcclxuXHRcdHRoaXMuc2Nyb2xsVG9Ub3AoKTtcclxuXHJcblx0XHQvLyBDbGVhciBjb250ZW50XHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHRcdGNvbnRlbnRFbC5hZGRDbGFzcygndmF1bHQtY21zLXdpemFyZCcpO1xyXG5cclxuXHRcdC8vIFNjcm9sbCB0byB0b3AgYWdhaW4gYWZ0ZXIgY2xlYXJpbmcgKGluIGNhc2UgY2xlYXJpbmcgY2hhbmdlZCBzY3JvbGwgcG9zaXRpb24pXHJcblx0XHR0aGlzLnNjcm9sbFRvVG9wKCk7XHJcblxyXG5cdFx0Ly8gUmVuZGVyIHByb2dyZXNzXHJcblx0XHR0aGlzLnJlbmRlclByb2dyZXNzKGNvbnRlbnRFbCk7XHJcblxyXG5cdFx0Ly8gUmVuZGVyIHN0ZXAgY29udGVudCAobWF5IGJlIGFzeW5jLCBidXQgd2UgZG9uJ3QgYXdhaXQgaXQpXHJcblx0XHRjb25zdCBzdGVwQ29udGVudCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoJ3dpemFyZC1jb250ZW50Jyk7XHJcblx0XHRzZXRDc3NQcm9wcyhzdGVwQ29udGVudCwgeyBtaW5IZWlnaHQ6ICc0MDBweCcgfSk7XHJcblx0XHRhd2FpdCB0aGlzLnJlbmRlclN0ZXBDb250ZW50KHN0ZXBDb250ZW50KTtcclxuXHJcblx0XHQvLyBSZW5kZXIgZm9vdGVyXHJcblx0XHR0aGlzLnJlbmRlckZvb3Rlcihjb250ZW50RWwpO1xyXG5cclxuXHRcdC8vIEZpbmFsIHNjcm9sbCB0byB0b3AgYWZ0ZXIgYWxsIHJlbmRlcmluZyBpcyBjb21wbGV0ZVxyXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuXHRcdFx0dGhpcy5zY3JvbGxUb1RvcCgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlbmRlclByb2dyZXNzKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcclxuXHRcdFx0Y29uc3QgdG90YWxTdGVwcyA9IHRoaXMuc3RlcHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCFzdGF0ZSB8fCAhdGhpcy5zdGF0ZU1hY2hpbmUpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdTZXR1cFdpemFyZE1vZGFsOiBzdGF0ZSBvciBzdGF0ZU1hY2hpbmUgaXMgbWlzc2luZyBpbiByZW5kZXJQcm9ncmVzcycpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgcHJvZ3Jlc3MgPSBjb250YWluZXIuY3JlYXRlRGl2KCd3aXphcmQtcHJvZ3Jlc3MnKTtcclxuXHJcblx0XHRcdC8vIFN5bmNocm9uaXplIHN0YXRlIG1hY2hpbmUgd2l0aCBjdXJyZW50IHN0YXRlIGluZGV4XHJcblx0XHRcdHRoaXMuc3RhdGVNYWNoaW5lLmp1bXBUb1N0ZXAoc3RhdGUuY3VycmVudFN0ZXApO1xyXG5cclxuXHRcdFx0Y29uc3QgcHJvZ3Jlc3NCYXIgPSBwcm9ncmVzcy5jcmVhdGVEaXYoJ3Byb2dyZXNzLWJhcicpO1xyXG5cdFx0XHRjb25zdCBwcm9ncmVzc0ZpbGwgPSBwcm9ncmVzc0Jhci5jcmVhdGVEaXYoJ3Byb2dyZXNzLWZpbGwnKTtcclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSBwcm9ncmVzcyBwZXJjZW50YWdlOiAoU3RlcCBYIG9mIFkpIC0+ICgoY3VycmVudFN0ZXAgKyAxKSAvIHRvdGFsU3RlcHMpICogMTAwXHJcblx0XHRcdC8vIFRoaXMgbWF0Y2hlcyB0aGUgcmVmZXJlbmNlIHByb2plY3QncyBsb2dpYyB3aGVyZSBTdGVwIDEgc2hvd3MgcHJvZ3Jlc3NcclxuXHRcdFx0Y29uc3QgcHJvZ3Jlc3NQZXJjZW50ID0gKChzdGF0ZS5jdXJyZW50U3RlcCArIDEpIC8gdG90YWxTdGVwcykgKiAxMDA7XHJcblxyXG5cdFx0XHQvLyBEaXJlY3Qgc3R5bGUgYXBwbGljYXRpb24gKG1vc3QgcmVsaWFibGUgd2l0aCB0aGUgbmV3IENTUylcclxuXHRcdFx0cHJvZ3Jlc3NGaWxsLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3NQZXJjZW50fSVgO1xyXG5cclxuXHRcdFx0Ly8gQWRkIHN0ZXAgdGV4dCBiZWxvdyB0aGUgcHJvZ3Jlc3MgYmFyIHdpdGggc3RhdGUgaW5mb3JtYXRpb25cclxuXHRcdFx0Y29uc3QgcHJvZ3Jlc3NUZXh0ID0gcHJvZ3Jlc3MuY3JlYXRlRGl2KCdwcm9ncmVzcy10ZXh0Jyk7XHJcblx0XHRcdHByb2dyZXNzVGV4dC50ZXh0Q29udGVudCA9IGBTdGVwICR7c3RhdGUuY3VycmVudFN0ZXAgKyAxfSBvZiAke3RvdGFsU3RlcHN9IC0gJHt0aGlzLnN0YXRlTWFjaGluZS5nZXRTdGF0ZURlc2NyaXB0aW9uKCl9YDtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1NldHVwV2l6YXJkTW9kYWw6IEVycm9yIHJlbmRlcmluZyBwcm9ncmVzcyBiYXI6JywgZXJyb3IpO1xyXG5cdFx0XHQvLyBEb24ndCB0aHJvdyAtIGFsbG93IHRoZSByZXN0IG9mIHRoZSB3aXphcmQgdG8gcmVuZGVyIGlmIHBvc3NpYmxlXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHJlbmRlclN0ZXBDb250ZW50KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcclxuXHRcdGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcclxuXHRcdGNvbnN0IHN0ZXBJbmRleCA9IHN0YXRlLmN1cnJlbnRTdGVwO1xyXG5cclxuXHRcdGlmIChzdGVwSW5kZXggPj0gMCAmJiBzdGVwSW5kZXggPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xyXG5cdFx0XHRjb25zdCBTdGVwQ2xhc3MgPSB0aGlzLnN0ZXBzW3N0ZXBJbmRleF07XHJcblx0XHRcdGNvbnN0IHN0ZXBOYW1lID0gU3RlcENsYXNzLm5hbWUgfHwgJ1Vua25vd24nO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKFxyXG5cdFx0XHRcdGBTZXR1cFdpemFyZE1vZGFsOiBEaXNwbGF5aW5nIHN0ZXAgJHtzdGVwSW5kZXggKyAxfS8ke3RoaXMuc3RlcHMubGVuZ3RofTogJHtzdGVwTmFtZX1gLFxyXG5cdFx0XHRcdGBbJHt0aGlzLnN0YXRlTWFjaGluZS5nZXREZWJ1Z0luZm8oKX1dYFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0dGhpcy5jdXJyZW50U3RlcEluc3RhbmNlID0gbmV3IFN0ZXBDbGFzcyhcclxuXHRcdFx0XHR0aGlzLmFwcCxcclxuXHRcdFx0XHRjb250YWluZXIsXHJcblx0XHRcdFx0c3RhdGUsXHJcblx0XHRcdFx0KCkgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gTmV4dCBoYW5kbGVyIC0gc2F2ZSBhbmQgYWR2YW5jZVxyXG5cdFx0XHRcdFx0dm9pZCAoYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jdXJyZW50U3RlcEluc3RhbmNlICYmIHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZS52YWxpZGF0ZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ3VycmVudFN0ZXBUb1dpemFyZFN0YXRlKCk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIubmV4dFN0ZXAodGhpcy5zdGVwcy5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGVNYWNoaW5lLm5leHQoKTtcclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdTZXR1cFdpemFyZE1vZGFsOiBBZHZhbmNlZCB0byBuZXh0IHN0ZXAgLScsIHRoaXMuc3RhdGVNYWNoaW5lLmdldERlYnVnSW5mbygpKTtcclxuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlbmRlckN1cnJlbnRTdGVwKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHQoKSA9PiB7XHJcblx0XHRcdFx0XHQvLyBCYWNrIGhhbmRsZXIgLSBkaXNjYXJkIGFuZCBnbyBiYWNrXHJcblx0XHRcdFx0XHR0aGlzLmRpc2NhcmRDdXJyZW50U3RlcENoYW5nZXMoKTtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLnByZXZpb3VzU3RlcCgpO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZU1hY2hpbmUucHJldmlvdXMoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1NldHVwV2l6YXJkTW9kYWw6IFdlbnQgYmFjayB0byBwcmV2aW91cyBzdGVwIC0nLCB0aGlzLnN0YXRlTWFjaGluZS5nZXREZWJ1Z0luZm8oKSk7XHJcblx0XHRcdFx0XHR2b2lkIHRoaXMucmVuZGVyQ3VycmVudFN0ZXAoKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdCgpID0+IHRoaXMuY2xvc2UoKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0Ly8gQXdhaXQgZGlzcGxheSgpIHNpbmNlIGl0IG1heSBiZSBhc3luY1xyXG5cdFx0XHRhd2FpdCB0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UuZGlzcGxheSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSByZW5kZXJGb290ZXIoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xyXG5cdFx0Y29uc3QgZm9vdGVyID0gY29udGFpbmVyLmNyZWF0ZURpdignd2l6YXJkLWZvb3RlcicpO1xyXG5cdFx0c2V0Q3NzUHJvcHMoZm9vdGVyLCB7IGRpc3BsYXk6ICdmbGV4JywganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJywgYWxpZ25JdGVtczogJ2NlbnRlcicgfSk7XHJcblxyXG5cdFx0Ly8gU3RhcnR1cCBzZXR0aW5nIGNoZWNrYm94IChvbmx5IG9uIHRoZSBmaXJzdCBzdGVwKVxyXG5cdFx0aWYgKHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkuY3VycmVudFN0ZXAgPT09IDApIHtcclxuXHRcdFx0Y29uc3Qgc3RhcnR1cFNldHRpbmcgPSBmb290ZXIuY3JlYXRlRGl2KCd3aXphcmQtc3RhcnR1cC1zZXR0aW5nLWZvb3RlcicpO1xyXG5cdFx0XHRjb25zdCBsYWJlbCA9IHN0YXJ0dXBTZXR0aW5nLmNyZWF0ZUVsKCdsYWJlbCcsIHsgY2xzOiAnd2l6YXJkLWNoZWNrYm94LWxhYmVsJyB9KTtcclxuXHRcdFx0Ly8gRW5zdXJlIGN1cnNvciBpcyBkZWZhdWx0IHdoZW4gaG92ZXJpbmcgb3ZlciB0aGUgbGFiZWwvY2hlY2tib3hcclxuXHRcdFx0c2V0Q3NzUHJvcHMobGFiZWwsIHsgY3Vyc29yOiAnZGVmYXVsdCcgfSk7XHJcblx0XHRcdGNvbnN0IGNoZWNrYm94ID0gbGFiZWwuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAnY2hlY2tib3gnIH0pO1xyXG5cdFx0XHRzZXRDc3NQcm9wcyhjaGVja2JveCwgeyBjdXJzb3I6ICdkZWZhdWx0JyB9KTtcclxuXHRcdFx0Y2hlY2tib3guY2hlY2tlZCA9ICF0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXA7XHJcblx0XHRcdGxhYmVsLmNyZWF0ZVNwYW4oeyB0ZXh0OiBcIiBJJ3ZlIGFscmVhZHkgc2V0IHVwIG15IHZhdWx0LCBkb24ndCBzaG93IG9uIHN0YXJ0dXBcIiB9KTtcclxuXHJcblx0XHRcdGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcclxuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXAgPSAhY2hlY2tib3guY2hlY2tlZDtcclxuXHRcdFx0XHR2b2lkIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEVtcHR5IGRpdiB0byBrZWVwIGJ1dHRvbnMgcHVzaGVkIHRvIHRoZSByaWdodFxyXG5cdFx0XHRmb290ZXIuY3JlYXRlRGl2KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgYnV0dG9ucyA9IGZvb3Rlci5jcmVhdGVEaXYoJ3dpemFyZC1idXR0b25zJyk7XHJcblx0XHRzZXRDc3NQcm9wcyhidXR0b25zLCB7IGRpc3BsYXk6ICdmbGV4JywgZ2FwOiAnMTBweCcgfSk7XHJcblxyXG5cdFx0Ly8gUHJldmlvdXMgYnV0dG9uXHJcblx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuY2FuR29QcmV2aW91cygpKSB7XHJcblx0XHRcdGNvbnN0IHByZXZCdG4gPSBidXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcblx0XHRcdFx0dGV4dDogJ1ByZXZpb3VzJyxcclxuXHRcdFx0XHRjbHM6ICdtb2QtYnV0dG9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cHJldkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHQvLyBEaXNjYXJkIGFueSBjaGFuZ2VzIG1hZGUgb24gY3VycmVudCBzdGVwIGFuZCBnbyBiYWNrXHJcblx0XHRcdFx0dGhpcy5kaXNjYXJkQ3VycmVudFN0ZXBDaGFuZ2VzKCk7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIucHJldmlvdXNTdGVwKCk7XHJcblx0XHRcdFx0dm9pZCB0aGlzLnJlbmRlckN1cnJlbnRTdGVwKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE5leHQvQ29tcGxldGUgYnV0dG9uXHJcblx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuY2FuR29OZXh0KHRoaXMuc3RlcHMubGVuZ3RoKSkge1xyXG5cdFx0XHQvLyBEb24ndCBzaG93IFwiTmV4dFwiIGJ1dHRvbiBvbiB0aGUgZmlyc3Qgc3RlcCAoV2VsY29tZVN0ZXApXHJcblx0XHRcdC8vIE9SIGlmIHRoZSBzdGVwIGV4cGxpY2l0bHkgaGlkZXMgaXQgKGUuZy4gR2l0U2V0dXBTdGVwKVxyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5jdXJyZW50U3RlcCAhPT0gMCAmJiB0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2U/LnNob3dOZXh0QnV0dG9uICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdGNvbnN0IG5leHRCdG4gPSBidXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcblx0XHRcdFx0XHR0ZXh0OiAnTmV4dCcsXHJcblx0XHRcdFx0XHRjbHM6ICdtb2QtYnV0dG9uIG1vZC1jdGEnXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0bmV4dEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vIFNhdmUgY3VycmVudCBzdGVwIGNoYW5nZXMgdG8gd2l6YXJkIHN0YXRlIGFuZCBkYXRhLmpzb25cclxuXHRcdFx0XHRcdHZvaWQgKGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZSAmJiB0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UudmFsaWRhdGUoKSkge1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZUN1cnJlbnRTdGVwVG9XaXphcmRTdGF0ZSgpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIFRyYWNrIHRoYXQgdGhpcyBzdGVwIHdhcyBzYXZlZFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMubGFzdFNhdmVkU3RlcEluZGV4ID0gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5jdXJyZW50U3RlcDtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlTWFuYWdlci5uZXh0U3RlcCh0aGlzLnN0ZXBzLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5yZW5kZXJDdXJyZW50U3RlcCgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBGaW5hbCBzdGVwIC0gcHJvdmlkZSBBcHBseSBhbmQgQXBwbHkgYW5kIHJlc3RhcnQgb3B0aW9uc1xyXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3RlcEluc3RhbmNlIGluc3RhbmNlb2YgRmluYWxpemVTdGVwKSB7XHJcblx0XHRcdFx0Y29uc3QgYXBwbHlCdG4gPSBidXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcblx0XHRcdFx0XHR0ZXh0OiAnQXBwbHknLFxyXG5cdFx0XHRcdFx0Y2xzOiAnbW9kLWJ1dHRvbidcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRhcHBseUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHRcdHZvaWQgdGhpcy5oYW5kbGVDb21wbGV0ZShmYWxzZSk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFwcGx5UmVzdGFydEJ0biA9IGJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuXHRcdFx0XHRcdHRleHQ6ICdBcHBseSBhbmQgcmVzdGFydCcsXHJcblx0XHRcdFx0XHRjbHM6ICdtb2QtYnV0dG9uIG1vZC1jdGEnXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0YXBwbHlSZXN0YXJ0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHRcdFx0dm9pZCB0aGlzLmhhbmRsZUNvbXBsZXRlKHRydWUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIEZhbGxiYWNrIGZvciBvdGhlciBzdGVwcyB0aGF0IG1pZ2h0IGJlIHRoZSBsYXN0IHN0ZXBcclxuXHRcdFx0XHRjb25zdCBjb21wbGV0ZUJ0biA9IGJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuXHRcdFx0XHRcdHRleHQ6ICdDb21wbGV0ZSBzZXR1cCcsXHJcblx0XHRcdFx0XHRjbHM6ICdtb2QtYnV0dG9uIG1vZC1jdGEnXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0Y29tcGxldGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdFx0XHR2b2lkIHRoaXMuaGFuZGxlQ29tcGxldGUoZmFsc2UpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2tpcCBidXR0b24gKGZvciBhbGwgc3RlcHMgZXhjZXB0IHRoZSBsYXN0KVxyXG5cdFx0aWYgKHRoaXMuc3RhdGVNYW5hZ2VyLmNhbkdvTmV4dCh0aGlzLnN0ZXBzLmxlbmd0aCkpIHtcclxuXHRcdFx0Ly8gRG9uJ3Qgc2hvdyBcIlNraXBcIiBidXR0b24gb24gdGhlIGZpcnN0IHN0ZXAgKFdlbGNvbWVTdGVwKVxyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5jdXJyZW50U3RlcCAhPT0gMCkge1xyXG5cdFx0XHRcdGNvbnN0IHNraXBCdG4gPSBidXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcblx0XHRcdFx0XHR0ZXh0OiAnU2tpcCcsXHJcblx0XHRcdFx0XHRjbHM6ICdtb2QtYnV0dG9uJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHNraXBCdG4uYWRkQ2xhc3MoJ3dpemFyZC1za2lwLWJ1dHRvbicpO1xyXG5cdFx0XHRcdHNldENzc1Byb3BzKHNraXBCdG4sIHsgb3BhY2l0eTogJzAuNicgfSk7XHJcblx0XHRcdFx0c2tpcEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vIFNraXAgd2l0aG91dCBzYXZpbmcgY3VycmVudCBzdGVwIGNoYW5nZXMgdG8gd2l6YXJkIHN0YXRlXHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlTWFuYWdlci5uZXh0U3RlcCh0aGlzLnN0ZXBzLmxlbmd0aCk7XHJcblx0XHRcdFx0XHR2b2lkIHRoaXMucmVuZGVyQ3VycmVudFN0ZXAoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBoYW5kbGVDb21wbGV0ZShzaG91bGRSZXN0YXJ0OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRpZiAodGhpcy5pc0NvbXBsZXRpbmcpIHJldHVybjtcclxuXHRcdHRoaXMuaXNDb21wbGV0aW5nID0gdHJ1ZTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3RlcEluc3RhbmNlICYmIHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZS52YWxpZGF0ZSgpKSB7XHJcblx0XHRcdFx0Ly8gSWYgd2UncmUgb24gRmluYWxpemVTdGVwLCBhcHBseSBjb25maWd1cmF0aW9uIGZpcnN0XHJcblx0XHRcdFx0aWYgKHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZSBpbnN0YW5jZW9mIEZpbmFsaXplU3RlcCkge1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5jdXJyZW50U3RlcEluc3RhbmNlLmFwcGx5Q29uZmlndXJhdGlvbihzaG91bGRSZXN0YXJ0KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gRm9yIG90aGVyIHN0ZXBzLCBqdXN0IHNhdmUgdGhlIGN1cnJlbnQgc3RlcFxyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ3VycmVudFN0ZXBUb1dpemFyZFN0YXRlKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBNYXJrIHdpemFyZCBhcyBjb21wbGV0ZWQgYW5kIGRpc2FibGUgc3RhcnR1cCB0cmlnZ2VyXHJcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3Mud2l6YXJkQ29tcGxldGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXAgPSBmYWxzZTtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcblx0XHRcdFx0Ly8gQ1JJVElDQUw6IFJlbG9hZCBzZXR0aW5ncyBmcm9tIGRpc2sgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgaXMgc3luY2hyb25pemVkXHJcblx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4ubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuXHJcblx0XHRcdFx0Ly8gVHJpZ2dlciByZXN0YXJ0IGlmIHJlcXVlc3RlZFxyXG5cdFx0XHRcdGlmIChzaG91bGRSZXN0YXJ0KSB7XHJcblx0XHRcdFx0XHQvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgTm90aWNlIGlzIHZpc2libGUgYW5kIHNldHRpbmdzIGFyZSBzYXZlZFxyXG5cdFx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGludGVyZmFjZSBBcHBXaXRoQ29tbWFuZHMgZXh0ZW5kcyBBcHAge1xyXG5cdFx0XHRcdFx0XHRcdGNvbW1hbmRzOiB7XHJcblx0XHRcdFx0XHRcdFx0XHRleGVjdXRlQ29tbWFuZEJ5SWQoaWQ6IHN0cmluZyk6IHZvaWQ7XHJcblx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQodGhpcy5hcHAgYXMgdW5rbm93biBhcyBBcHBXaXRoQ29tbWFuZHMpLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZCgnYXBwOnJlbG9hZCcpO1xyXG5cdFx0XHRcdFx0fSwgMTAwMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBjb21wbGV0aW5nIHdpemFyZDonLCBlcnJvcik7XHJcblx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjb21wbGV0ZSBzZXR1cC4gUGxlYXNlIGNoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLicpO1xyXG5cdFx0fSBmaW5hbGx5IHtcclxuXHRcdFx0dGhpcy5pc0NvbXBsZXRpbmcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUN1cnJlbnRTdGVwVG9XaXphcmRTdGF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdC8vIFNhdmUgY3VycmVudCBzdGVwIGNoYW5nZXMgdG8gd2l6YXJkIHN0YXRlIGFuZCBkYXRhLmpzb25cclxuXHRcdC8vIFRoaXMgaXMgY2FsbGVkIHdoZW4gTkVYVCBpcyBjbGlja2VkIHRvIGVuc3VyZSBkYXRhLmpzb24gc3RheXMgaW4gc3luY1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gQnVpbGQgZmluYWwgc2V0dGluZ3MgZnJvbSB3aXphcmQgc3RhdGUgKHVwZGF0ZXMgcGx1Z2luLnNldHRpbmdzKVxyXG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlTWFuYWdlci5idWlsZEZpbmFsU2V0dGluZ3MoKTtcclxuXHJcblx0XHRcdC8vIFNhdmUgdG8gZGF0YS5qc29uXHJcblx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuXHRcdFx0Ly8gUmVsb2FkIHNldHRpbmdzIHRvIGVuc3VyZSB0aGUgcGx1Z2luIGhhcyB0aGUgbGF0ZXN0IHZhbHVlc1xyXG5cdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5sb2FkU2V0dGluZ3MoKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBjdXJyZW50IHN0ZXAgdG8gZGF0YS5qc29uOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gRG9uJ3Qgc2hvdyBlcnJvciB0byB1c2VyIC0ganVzdCBsb2cgaXQsIGFzIHRoaXMgc2hvdWxkbid0IGJsb2NrIG5hdmlnYXRpb25cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZGlzY2FyZEN1cnJlbnRTdGVwQ2hhbmdlcygpOiB2b2lkIHtcclxuXHRcdC8vIERpc2NhcmQgY2hhbmdlcyBtYWRlIG9uIGN1cnJlbnQgc3RlcCAtIHRoaXMgaXMgY2FsbGVkIHdoZW4gUFJFVklPVVMgaXMgY2xpY2tlZFxyXG5cdFx0Ly8gUmVmcmVzaCB0aGUgd2l6YXJkIHN0YXRlIHRvIHNob3cgb3JpZ2luYWwgdmFsdWVzIGZyb20gZGF0YS5qc29uXHJcblx0XHR2b2lkIHRoaXMuc3RhdGVNYW5hZ2VyLnJlZnJlc2hTdGF0ZSgpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlV2l6YXJkU3RhdGVUb0RhdGFKc29uKHNob3dOb3RpZmljYXRpb246IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHQvLyBTYXZlIHdpemFyZCBzdGF0ZSBjaGFuZ2VzIHRvIGRhdGEuanNvbiB3aGVuIG1vZGFsIGlzIGNsb3NlZFxyXG5cdFx0Ly8gVGhpcyBlbnN1cmVzIGNoYW5nZXMgYXJlIHByZXNlcnZlZCBldmVuIGlmIHVzZXIgY2xvc2VzIG1vZGFsIHdpdGhvdXQgY29tcGxldGluZyB3aXphcmRcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIEJ1aWxkIGZpbmFsIHNldHRpbmdzIGZyb20gd2l6YXJkIHN0YXRlXHJcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGVNYW5hZ2VyLmJ1aWxkRmluYWxTZXR0aW5ncygpO1xyXG5cclxuXHRcdFx0Ly8gQ2hlY2sgaWYgYW55IGNoYW5nZXMgd2VyZSBhY3R1YWxseSBtYWRlXHJcblx0XHRcdGNvbnN0IGhhc0NoYW5nZXMgPSB0aGlzLmhhc1NldHRpbmdzQ2hhbmdlZCgpO1xyXG5cclxuXHRcdFx0Ly8gT25seSBzYXZlIHRvIGRhdGEuanNvbiBpZiB0aGVyZSB3ZXJlIGFjdHVhbCBjaGFuZ2VzXHJcblx0XHRcdGlmICghaGFzQ2hhbmdlcykge1xyXG5cdFx0XHRcdHJldHVybjsgLy8gTm8gY2hhbmdlcywgZG9uJ3Qgc2F2ZSBhbnl0aGluZ1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBTYXZlIHRvIGRhdGEuanNvblxyXG5cdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcblx0XHRcdC8vIFJlbG9hZCBzZXR0aW5ncyB0byBlbnN1cmUgdGhlIHBsdWdpbiBoYXMgdGhlIGxhdGVzdCB2YWx1ZXNcclxuXHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4ubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0XHQvLyBPbmx5IHNob3cgbm90aWZpY2F0aW9uIGlmIHJlcXVlc3RlZFxyXG5cdFx0XHRpZiAoc2hvd05vdGlmaWNhdGlvbikge1xyXG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0NvbmZpZ3VyYXRpb24gc2F2ZWQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHdpemFyZCBzdGF0ZSB0byBkYXRhLmpzb246JywgZXJyb3IpO1xyXG5cdFx0XHRpZiAoc2hvd05vdGlmaWNhdGlvbikge1xyXG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBzYXZlIGNvbmZpZ3VyYXRpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGNyZWF0ZVNldHRpbmdzU25hcHNob3QoKTogUGFydGlhbDxXaXphcmRTdGF0ZT4ge1xyXG5cdFx0Ly8gQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIGN1cnJlbnQgc3RhdGUgZm9yIGNvbXBhcmlzb25cclxuXHRcdGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiAtLSBKU09OLnBhcnNlIHJldHVybnMgYW55IHR5cGVcclxuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHtcclxuXHRcdFx0cHJvamVjdERldGVjdGlvbjogc3RhdGUucHJvamVjdERldGVjdGlvbixcclxuXHRcdFx0Y29udGVudFR5cGVzOiBzdGF0ZS5jb250ZW50VHlwZXMsXHJcblx0XHRcdGZyb250bWF0dGVyUHJvcGVydGllczogc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLFxyXG5cdFx0XHRkZWZhdWx0Q29udGVudFR5cGVJZDogc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQsXHJcblx0XHRcdHByZXNldDogc3RhdGUucHJlc2V0LFxyXG5cdFx0XHRlbmFibGVFZGl0aW5nVG9vbGJhcjogc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXIsXHJcblx0XHRcdGVuYWJsZWRQbHVnaW5zOiBzdGF0ZS5lbmFibGVkUGx1Z2lucyxcclxuXHRcdFx0ZGlzYWJsZWRQbHVnaW5zOiBzdGF0ZS5kaXNhYmxlZFBsdWdpbnMsXHJcblx0XHRcdHRoZW1lOiBzdGF0ZS50aGVtZSxcclxuXHRcdFx0YmFzZXNDTVNDb25maWc6IHN0YXRlLmJhc2VzQ01TQ29uZmlnLFxyXG5cdFx0XHRhc3Ryb0NvbXBvc2VyQ29uZmlnOiBzdGF0ZS5hc3Ryb0NvbXBvc2VyQ29uZmlnLFxyXG5cdFx0XHRzZW9Db25maWc6IHN0YXRlLnNlb0NvbmZpZyxcclxuXHRcdFx0cHJvcGVydHlPdmVyRmlsZU5hbWU6IHN0YXRlLnByb3BlcnR5T3ZlckZpbGVOYW1lLFxyXG5cdFx0XHRpbWFnZU1hbmFnZXI6IHN0YXRlLmltYWdlTWFuYWdlcixcclxuXHRcdFx0aG9tZUJhc2U6IHN0YXRlLmhvbWVCYXNlXHJcblx0XHR9KSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGhhc1NldHRpbmdzQ2hhbmdlZCgpOiBib29sZWFuIHtcclxuXHRcdGlmICghdGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY3VycmVudFNuYXBzaG90ID0gdGhpcy5jcmVhdGVTZXR0aW5nc1NuYXBzaG90KCk7XHJcblxyXG5cdFx0Ly8gQ29tcGFyZSBrZXkgc2V0dGluZ3MgdGhhdCBjYW4gYmUgY2hhbmdlZCBpbiB0aGUgd2l6YXJkXHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QucHJvamVjdERldGVjdGlvbikgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QucHJvamVjdERldGVjdGlvbikgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmNvbnRlbnRUeXBlcykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuY29udGVudFR5cGVzKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5mcm9udG1hdHRlclByb3BlcnRpZXMpIHx8XHJcblx0XHRcdGN1cnJlbnRTbmFwc2hvdC5kZWZhdWx0Q29udGVudFR5cGVJZCAhPT0gdGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5kZWZhdWx0Q29udGVudFR5cGVJZCB8fFxyXG5cdFx0XHRjdXJyZW50U25hcHNob3QucHJlc2V0ICE9PSB0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LnByZXNldCB8fFxyXG5cdFx0XHRjdXJyZW50U25hcHNob3QuZW5hYmxlRWRpdGluZ1Rvb2xiYXIgIT09IHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuZW5hYmxlRWRpdGluZ1Rvb2xiYXIgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmVuYWJsZWRQbHVnaW5zKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5lbmFibGVkUGx1Z2lucykgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmRpc2FibGVkUGx1Z2lucykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuZGlzYWJsZWRQbHVnaW5zKSB8fFxyXG5cdFx0XHRjdXJyZW50U25hcHNob3QudGhlbWUgIT09IHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QudGhlbWUgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmJhc2VzQ01TQ29uZmlnKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5iYXNlc0NNU0NvbmZpZykgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmFzdHJvQ29tcG9zZXJDb25maWcpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmFzdHJvQ29tcG9zZXJDb25maWcpIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5zZW9Db25maWcpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LnNlb0NvbmZpZykgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LnByb3BlcnR5T3ZlckZpbGVOYW1lKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5wcm9wZXJ0eU92ZXJGaWxlTmFtZSkgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmltYWdlTWFuYWdlcikgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuaW1hZ2VNYW5hZ2VyKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuaG9tZUJhc2UpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmhvbWVCYXNlKVxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdGdldFN0YXRlKCk6IFdpemFyZFN0YXRlIHtcclxuXHRcdHJldHVybiB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xyXG5cdH1cclxuXHJcblx0Ly8gQ2FsbGJhY2sgdG8gc2F2ZSBzdGF0ZSB0byBwbHVnaW4gc2V0dGluZ3MgKGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXHJcblx0c2V0U2F2ZUNhbGxiYWNrKGNhbGxiYWNrOiAoc3RhdGU6IFdpemFyZFN0YXRlKSA9PiBQcm9taXNlPHZvaWQ+KSB7XHJcblx0XHQvLyBUaGlzIGlzIG5vdyBoYW5kbGVkIGJ5IHNhdmVDdXJyZW50U3RlcFRvV2l6YXJkU3RhdGUgYW5kIHNhdmVXaXphcmRTdGF0ZVRvRGF0YUpzb25cclxuXHRcdC8vIEJ1dCB3ZSBrZWVwIHRoZSBtZXRob2QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuXHRcdGNvbnNvbGUud2Fybignc2V0U2F2ZUNhbGxiYWNrIGlzIGRlcHJlY2F0ZWQgLSBzdGF0ZSBpcyBub3cgbWFuYWdlZCBhdXRvbWF0aWNhbGx5Jyk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBJbWFnZU1hbmFnZXJDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG50eXBlIEltYWdlTWFuYWdlclBsdWdpbiA9IHtcclxuXHRzZXR0aW5ncz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIEltYWdlTWFuYWdlclBsdWdpbj47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgSW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRhc3luYyBsb2FkQ29uZmlnKCk6IFByb21pc2U8SW1hZ2VNYW5hZ2VyQ29uZmlnPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbWFnZS1tYW5hZ2VyJztcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNldHRpbmdzIEFQSSBmaXJzdFxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc3QgaW1hZ2VNYW5hZ2VyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHJcblx0XHRcdGlmIChpbWFnZU1hbmFnZXJQbHVnaW4gJiYgaW1hZ2VNYW5hZ2VyUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Ly8gUmV0dXJuIHBsdWdpbiBzZXR0aW5ncyBhcyBjb25maWdcclxuXHRcdFx0XHRyZXR1cm4gaW1hZ2VNYW5hZ2VyUGx1Z2luLnNldHRpbmdzIGFzIEltYWdlTWFuYWdlckNvbmZpZztcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBJbWFnZSBNYW5hZ2VyIGNvbmZpZyBmcm9tIHBsdWdpbiBBUEk6JywgZXJyb3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXHJcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5sb2FkQ29uZmlnRmFsbGJhY2soKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgbG9hZENvbmZpZ0ZhbGxiYWNrKCk6IFByb21pc2U8SW1hZ2VNYW5hZ2VyQ29uZmlnPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbWFnZS1tYW5hZ2VyJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblxyXG5cdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cclxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgZGF0YSBpZiBmaWxlIGV4aXN0c1xyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjb25zdCBleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdEYXRhIGFzIEltYWdlTWFuYWdlckNvbmZpZztcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBJbWFnZSBNYW5hZ2VyIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdFx0cmV0dXJuIHt9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHt9O1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZUNvbmZpZyhjb25maWc6IEltYWdlTWFuYWdlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaW1hZ2UtbWFuYWdlcic7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyKVxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc3QgaW1hZ2VNYW5hZ2VyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHJcblx0XHRcdGlmIChpbWFnZU1hbmFnZXJQbHVnaW4gJiYgaW1hZ2VNYW5hZ2VyUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Ly8gVXBkYXRlIHZpYSBwbHVnaW4gc2V0dGluZ3MgQVBJIChtYXRjaGluZyBhc3Ryby1tb2R1bGFyLXNldHRpbmdzIHBhdHRlcm4pXHJcblx0XHRcdFx0Y29uc3QgcGx1Z2luU2V0dGluZ3MgPSBpbWFnZU1hbmFnZXJQbHVnaW4uc2V0dGluZ3M7XHJcblxyXG5cdFx0XHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIHBsdWdpbiBzZXR0aW5nc1xyXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24ocGx1Z2luU2V0dGluZ3MsIGNvbmZpZyk7XHJcblxyXG5cdFx0XHRcdGlmICh0eXBlb2YgaW1hZ2VNYW5hZ2VyUGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0YXdhaXQgaW1hZ2VNYW5hZ2VyUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnSW1hZ2VNYW5hZ2VyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2QgKGxpa2UgQXN0cm8gQ29tcG9zZXIgZmFsbGJhY2spXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBJbWFnZSBNYW5hZ2VyIGNvbmZpZzonLCBlcnJvcik7XHJcblx0XHRcdC8vIFRyeSBmYWxsYmFjayBldmVuIGlmIHBsdWdpbiBtZXRob2QgZmFpbHNcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xyXG5cdFx0XHR9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgSW1hZ2UgTWFuYWdlciBjb25maWcgdmlhIGZhbGxiYWNrOicsIGZhbGxiYWNrRXJyb3IpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHNhdmVDb25maWdGYWxsYmFjayhjb25maWc6IEltYWdlTWFuYWdlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaW1hZ2UtbWFuYWdlcic7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cclxuXHRcdGxldCBleGlzdGluZ0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XHJcblx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblxyXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIEltYWdlIE1hbmFnZXIgZGF0YS5qc29uLCBzdGFydGluZyBmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0ge307XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBNZXJnZSBjb25maWcgaW50byBleGlzdGluZyBkYXRhIChwcmVzZXJ2aW5nIGV4aXN0aW5nIHNldHRpbmdzIG5vdCBpbiBjb25maWcpXHJcblx0XHRjb25zdCBtZXJnZWREYXRhID0ge1xyXG5cdFx0XHQuLi5leGlzdGluZ0RhdGEsXHJcblx0XHRcdC4uLmNvbmZpZ1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBUcnkgdG8gbW9kaWZ5IGZpcnN0LCBpZiBmaWxlIGRvZXNuJ3QgZXhpc3QgaXQgd2lsbCB0aHJvdywgdGhlbiB3ZSBjcmVhdGVcclxuXHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gRW5zdXJlIHBsdWdpbiBkaXJlY3RvcnkgZXhpc3RzXHJcblx0XHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdFx0aWYgKCFwbHVnaW5EaXJGaWxlKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0XHQvLyBJZ25vcmUgXCJhbHJlYWR5IGV4aXN0c1wiIGVycm9yc1xyXG5cdFx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG5cdFx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaWxlXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Ly8gSWYgZmlsZSB3YXMgY3JlYXRlZCBiZXR3ZWVuIGNoZWNrIGFuZCBjcmVhdGUsIHRyeSB0byBtb2RpZnkgaXRcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpIHx8IGVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcmV0cnlGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0XHRcdGlmIChyZXRyeUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkocmV0cnlGaWxlLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXNvbHZlcyB0aGUgaW1hZ2UgcHJvcGVydHkgZnJvbSB0aGUgd2l6YXJkIHN0YXRlIGFuZCBzeW5jcyBpdCB0byBJbWFnZSBNYW5hZ2VyIHNldHRpbmdzXHJcblx0ICovXHJcblx0YXN5bmMgcmVzb2x2ZUFuZFN5bmNJbWFnZVByb3BlcnR5KHN0YXRlOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IGNvbnRlbnRUeXBlcyA9IHN0YXRlLmNvbnRlbnRUeXBlcyB8fCBbXTtcclxuXHRcdGNvbnN0IGZyb250bWF0dGVyUHJvcGVydGllcyA9IHN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyB8fCB7fTtcclxuXHRcdGNvbnN0IGRlZmF1bHRUeXBlSWQgPSBzdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZDtcclxuXHJcblx0XHRsZXQgcmVzb2x2ZWRJbWFnZVByb3BlcnR5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0Ly8gMS4gQ2hlY2sgZGVmYXVsdCBjb250ZW50IHR5cGVcclxuXHRcdGlmIChkZWZhdWx0VHlwZUlkICYmIGZyb250bWF0dGVyUHJvcGVydGllc1tkZWZhdWx0VHlwZUlkXT8uaW1hZ2VQcm9wZXJ0eSkge1xyXG5cdFx0XHRyZXNvbHZlZEltYWdlUHJvcGVydHkgPSBmcm9udG1hdHRlclByb3BlcnRpZXNbZGVmYXVsdFR5cGVJZF0uaW1hZ2VQcm9wZXJ0eTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyAyLiBJZiBub3QgZm91bmQsIGNoZWNrIGFsbCBvdGhlciBjb250ZW50IHR5cGVzXHJcblx0XHRpZiAoIXJlc29sdmVkSW1hZ2VQcm9wZXJ0eSkge1xyXG5cdFx0XHRmb3IgKGNvbnN0IHR5cGUgb2YgY29udGVudFR5cGVzKSB7XHJcblx0XHRcdFx0aWYgKGZyb250bWF0dGVyUHJvcGVydGllc1t0eXBlLmlkXT8uaW1hZ2VQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdFx0cmVzb2x2ZWRJbWFnZVByb3BlcnR5ID0gZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW3R5cGUuaWRdLmltYWdlUHJvcGVydHk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyAzLiBVcGRhdGUgY29uZmlnIGlmIHByb3BlcnR5IHdhcyBmb3VuZFxyXG5cdFx0aWYgKHJlc29sdmVkSW1hZ2VQcm9wZXJ0eSkge1xyXG5cdFx0XHRjb25zdCBjb25maWcgPSBhd2FpdCB0aGlzLmxvYWRDb25maWcoKTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSByb290IGxldmVsIGRlZmF1bHRQcm9wZXJ0eU5hbWVcclxuXHRcdFx0Y29uZmlnLmRlZmF1bHRQcm9wZXJ0eU5hbWUgPSByZXNvbHZlZEltYWdlUHJvcGVydHk7XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgYmFubmVyIG5lc3RlZCBwcm9wZXJ0eVxyXG5cdFx0XHRpZiAoY29uZmlnLmJhbm5lcikge1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgY29uZmlnLmJhbm5lciA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRcdGlmICghKGNvbmZpZy5iYW5uZXIgYXMgYW55KS5wcm9wZXJ0aWVzKSB7XHJcblx0XHRcdFx0XHRcdChjb25maWcuYmFubmVyIGFzIGFueSkucHJvcGVydGllcyA9IHt9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0KGNvbmZpZy5iYW5uZXIgYXMgYW55KS5wcm9wZXJ0aWVzLmltYWdlUHJvcGVydHkgPSByZXNvbHZlZEltYWdlUHJvcGVydHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIENyZWF0ZSBiYW5uZXIgc3RydWN0dXJlIGlmIG1pc3NpbmdcclxuXHRcdFx0XHRjb25maWcuYmFubmVyID0ge1xyXG5cdFx0XHRcdFx0cHJvcGVydGllczoge1xyXG5cdFx0XHRcdFx0XHRpbWFnZVByb3BlcnR5OiByZXNvbHZlZEltYWdlUHJvcGVydHlcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWcoY29uZmlnKTtcclxuXHJcblx0XHRcdC8vIEFsc28gdXBkYXRlIHRoZSBzdGF0ZSBvYmplY3QgdG8gcHJldmVudCBvdmVyd3JpdGluZyB3aXRoIG9sZCB2YWx1ZXMgaW4gRmluYWxpemVTdGVwXHJcblx0XHRcdGlmIChzdGF0ZS5pbWFnZU1hbmFnZXIpIHtcclxuXHRcdFx0XHRzdGF0ZS5pbWFnZU1hbmFnZXIuZGVmYXVsdFByb3BlcnR5TmFtZSA9IHJlc29sdmVkSW1hZ2VQcm9wZXJ0eTtcclxuXHRcdFx0XHRpZiAoc3RhdGUuaW1hZ2VNYW5hZ2VyLmJhbm5lcikge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBzdGF0ZS5pbWFnZU1hbmFnZXIuYmFubmVyID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdFx0XHRpZiAoIXN0YXRlLmltYWdlTWFuYWdlci5iYW5uZXIucHJvcGVydGllcykge1xyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmltYWdlTWFuYWdlci5iYW5uZXIucHJvcGVydGllcyA9IHt9O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHN0YXRlLmltYWdlTWFuYWdlci5iYW5uZXIucHJvcGVydGllcy5pbWFnZVByb3BlcnR5ID0gcmVzb2x2ZWRJbWFnZVByb3BlcnR5O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGF0ZS5pbWFnZU1hbmFnZXIuYmFubmVyID0ge1xyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VQcm9wZXJ0eTogcmVzb2x2ZWRJbWFnZVByb3BlcnR5XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zb2xlLmRlYnVnKGBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3I6IFN5bmNlZCBpbWFnZSBwcm9wZXJ0eSBcIiR7cmVzb2x2ZWRJbWFnZVByb3BlcnR5fVwiIHRvIEltYWdlIE1hbmFnZXIgYW5kIHN0YXRlYCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBIb21lQmFzZUNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbnR5cGUgSG9tZUJhc2VQbHVnaW4gPSB7XHJcblx0c2V0dGluZ3M/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59O1xyXG5cclxudHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBIb21lQmFzZVBsdWdpbj47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgSG9tZUJhc2VDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRDb25maWcoKTogUHJvbWlzZTxIb21lQmFzZUNvbmZpZz4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzZXR0aW5ncyBBUEkgZmlyc3RcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IGhvbWVCYXNlUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChob21lQmFzZVBsdWdpbiAmJiBob21lQmFzZVBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdC8vIFJldHVybiBwbHVnaW4gc2V0dGluZ3MgYXMgY29uZmlnXHJcblx0XHRcdFx0cmV0dXJuIGhvbWVCYXNlUGx1Z2luLnNldHRpbmdzIGFzIEhvbWVCYXNlQ29uZmlnO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEhvbWUgQmFzZSBjb25maWcgZnJvbSBwbHVnaW4gQVBJOicsIGVycm9yKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdHJldHVybiBhd2FpdCB0aGlzLmxvYWRDb25maWdGYWxsYmFjaygpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBsb2FkQ29uZmlnRmFsbGJhY2soKTogUHJvbWlzZTxIb21lQmFzZUNvbmZpZz4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblx0XHRcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZ0RhdGEgYXMgSG9tZUJhc2VDb25maWc7XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZXhpc3RpbmcgSG9tZSBCYXNlIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdFx0cmV0dXJuIHt9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiB7fTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoY29uZmlnOiBIb21lQmFzZUNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyKVxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc3QgaG9tZUJhc2VQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGhvbWVCYXNlUGx1Z2luICYmIGhvbWVCYXNlUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Ly8gVXBkYXRlIHZpYSBwbHVnaW4gc2V0dGluZ3MgQVBJIChtYXRjaGluZyBhc3Ryby1tb2R1bGFyLXNldHRpbmdzIHBhdHRlcm4pXHJcblx0XHRcdFx0Y29uc3QgcGx1Z2luU2V0dGluZ3MgPSBob21lQmFzZVBsdWdpbi5zZXR0aW5ncztcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBNZXJnZSBjb25maWcgaW50byBwbHVnaW4gc2V0dGluZ3NcclxuXHRcdFx0XHRPYmplY3QuYXNzaWduKHBsdWdpblNldHRpbmdzLCBjb25maWcpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmICh0eXBlb2YgaG9tZUJhc2VQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBob21lQmFzZVBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0hvbWVCYXNlQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2QgKGxpa2UgQXN0cm8gQ29tcG9zZXIgZmFsbGJhY2spXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBIb21lIEJhc2UgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gVHJ5IGZhbGxiYWNrIGV2ZW4gaWYgcGx1Z2luIG1ldGhvZCBmYWlsc1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHRcdH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBIb21lIEJhc2UgY29uZmlnIHZpYSBmYWxsYmFjazonLCBmYWxsYmFja0Vycm9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnOiBIb21lQmFzZUNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblx0XHRcclxuXHRcdGxldCBleGlzdGluZ0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XHJcblx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcclxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgZGF0YSBpZiBmaWxlIGV4aXN0c1xyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBIb21lIEJhc2UgZGF0YS5qc29uLCBzdGFydGluZyBmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0ge307XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gTWVyZ2UgY29uZmlnIGludG8gZXhpc3RpbmcgZGF0YSAocHJlc2VydmluZyBleGlzdGluZyBzZXR0aW5ncyBub3QgaW4gY29uZmlnKVxyXG5cdFx0Y29uc3QgbWVyZ2VkRGF0YSA9IHtcclxuXHRcdFx0Li4uZXhpc3RpbmdEYXRhLFxyXG5cdFx0XHQuLi5jb25maWdcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdC8vIFRyeSB0byBtb2RpZnkgZmlyc3QsIGlmIGZpbGUgZG9lc24ndCBleGlzdCBpdCB3aWxsIHRocm93LCB0aGVuIHdlIGNyZWF0ZVxyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EaXIpO1xyXG5cdFx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKHBsdWdpbkRpcik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZSBcImFscmVhZHkgZXhpc3RzXCIgZXJyb3JzXHJcblx0XHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbGVcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHQvLyBJZiBmaWxlIHdhcyBjcmVhdGVkIGJldHdlZW4gY2hlY2sgYW5kIGNyZWF0ZSwgdHJ5IHRvIG1vZGlmeSBpdFxyXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgfHwgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpKSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRcdFx0aWYgKHJldHJ5RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShyZXRyeUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IEV4cGxvcmVyRm9jdXNDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG50eXBlIFBsdWdpbldpdGhTZXR0aW5ncyA9IHtcclxuXHRzZXR0aW5ncz86IEV4cGxvcmVyRm9jdXNDb25maWc7XHJcblx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufTtcclxuXHJcbnR5cGUgUGx1Z2luc0FQSSA9IHtcclxuXHRwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgUGx1Z2luV2l0aFNldHRpbmdzPjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBFeHBsb3JlckZvY3VzQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlQ29uZmlnKGNvbmZpZzogRXhwbG9yZXJGb2N1c0NvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnZXhwbG9yZXItZm9jdXMnO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIGxpdmUgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBleHBsb3JlckZvY3VzUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChleHBsb3JlckZvY3VzUGx1Z2luICYmIGV4cGxvcmVyRm9jdXNQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFeHBsb3JlckZvY3VzQ29uZmlnOiBVc2luZyBwbHVnaW4uc2V0dGluZ3MgQVBJJyk7XHJcblx0XHRcdFx0Y29uc3Qgc2V0dGluZ3MgPSBleHBsb3JlckZvY3VzUGx1Z2luLnNldHRpbmdzO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEFwcGx5IGNvbmZpZyB0byBsaXZlIHNldHRpbmdzXHJcblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnKSkge1xyXG5cdFx0XHRcdFx0KHNldHRpbmdzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXldID0gdmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFNhdmUgc2V0dGluZ3MgdmlhIHBsdWdpbiBBUElcclxuXHRcdFx0XHRpZiAodHlwZW9mIGV4cGxvcmVyRm9jdXNQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBleHBsb3JlckZvY3VzUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRXhwbG9yZXJGb2N1c0NvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kIGlmIHBsdWdpbiBub3QgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0V4cGxvcmVyRm9jdXNDb25maWc6IFBsdWdpbiBBUEkgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2sgZmlsZSBtZXRob2QnKTtcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEV4cGxvcmVyIEZvY3VzIGNvbmZpZzonLCBlcnJvcik7XHJcblx0XHRcdC8vIFRyeSBmYWxsYmFjayBhbnl3YXlcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRDb25maWcoKTogUHJvbWlzZTxFeHBsb3JlckZvY3VzQ29uZmlnIHwgbnVsbD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnZXhwbG9yZXItZm9jdXMnO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKTtcclxuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShjb250ZW50KSBhcyBFeHBsb3JlckZvY3VzQ29uZmlnO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEV4cGxvcmVyIEZvY3VzIGNvbmZpZzonLCBlcnJvcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogRXhwbG9yZXJGb2N1c0NvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnZXhwbG9yZXItZm9jdXMnO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBleHBsb3Jlci1mb2N1cyBkYXRhLmpzb246JywgZXJyb3IpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTWVyZ2Ugd2l0aCBvdXIgY29uZmlnXHJcblx0XHRjb25zdCBtZXJnZWREYXRhID0ge1xyXG5cdFx0XHQuLi5leGlzdGluZ0RhdGEsXHJcblx0XHRcdC4uLmNvbmZpZ1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRjb25zdCBwbHVnaW5EaXJGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcblx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGb2xkZXIgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2F2ZSB0byBmaWxlXHJcblx0XHRjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMik7XHJcblx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIGNvbnRlbnQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdGNvbnNvbGUuZGVidWcoJ0V4cGxvcmVyRm9jdXNDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCBleHBsb3Jlci1mb2N1cyBjb25maWcgdmlhIGZhbGxiYWNrJyk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxudHlwZSBFZGl0aW5nVG9vbGJhclBsdWdpbiA9IHtcclxuXHRlbmFibGVkPzogYm9vbGVhbjtcclxuXHRzZXR0aW5ncz86IHtcclxuXHRcdGNNZW51VmlzaWJpbGl0eT86IGJvb2xlYW47XHJcblx0XHRba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG5cdH07XHJcblx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuXHRsb2FkU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG5cdHJlZnJlc2g/OiAoKSA9PiB2b2lkO1xyXG59O1xyXG5cclxudHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBFZGl0aW5nVG9vbGJhclBsdWdpbj47XHJcblx0ZW5hYmxlUGx1Z2luPzogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcblx0ZGlzYWJsZVBsdWdpbj86IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbmFibGUvZGlzYWJsZSB0aGUgZWRpdGluZyB0b29sYmFyIHZpc2liaWxpdHlcclxuXHQgKi9cclxuXHRhc3luYyB0b2dnbGVWaXNpYmlsaXR5KGFwcDogQXBwLCBlbmFibGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnNvbGUuZGVidWcoYEVkaXRpbmdUb29sYmFyQ29uZmlnOiB0b2dnbGVWaXNpYmlsaXR5IGNhbGxlZCB3aXRoIGVuYWJsZT0ke2VuYWJsZX1gKTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAoYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0aWYgKCFwbHVnaW5zKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogUGx1Z2lucyBBUEkgbm90IGF2YWlsYWJsZScpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZWRpdGluZ1Rvb2xiYXJQbHVnaW4gPSBwbHVnaW5zLnBsdWdpbnM/LlsnZWRpdGluZy10b29sYmFyJ107XHJcblx0XHRcdGlmICghZWRpdGluZ1Rvb2xiYXJQbHVnaW4pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBFZGl0aW5nIFRvb2xiYXIgcGx1Z2luIG5vdCBmb3VuZCcpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhgRWRpdGluZ1Rvb2xiYXJDb25maWc6IEVkaXRpbmcgVG9vbGJhciBwbHVnaW4gZm91bmQsIGVuYWJsZWQ9JHtlZGl0aW5nVG9vbGJhclBsdWdpbi5lbmFibGVkfWApO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKGBFZGl0aW5nVG9vbGJhckNvbmZpZzogUGx1Z2luIHNldHRpbmdzIGF2YWlsYWJsZTpgLCAhIWVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzKTtcclxuXHJcblx0XHRcdGlmIChlZGl0aW5nVG9vbGJhclBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYEVkaXRpbmdUb29sYmFyQ29uZmlnOiBDdXJyZW50IGNNZW51VmlzaWJpbGl0eTpgLCBlZGl0aW5nVG9vbGJhclBsdWdpbi5zZXR0aW5ncy5jTWVudVZpc2liaWxpdHkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2QgZmlyc3RcclxuXHRcdFx0aWYgKGVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzICYmIHR5cGVvZiBlZGl0aW5nVG9vbGJhclBsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogVXNpbmcgcGx1Z2luLnNhdmVTZXR0aW5ncygpIG1ldGhvZCcpO1xyXG5cdFx0XHRcdGNvbnN0IG9sZFZhbHVlID0gZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MuY01lbnVWaXNpYmlsaXR5O1xyXG5cdFx0XHRcdGVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzLmNNZW51VmlzaWJpbGl0eSA9IGVuYWJsZTtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKGBFZGl0aW5nVG9vbGJhckNvbmZpZzogU2V0IGNNZW51VmlzaWJpbGl0eSBmcm9tICR7b2xkVmFsdWV9IHRvICR7ZW5hYmxlfWApO1xyXG5cclxuXHRcdFx0XHRhd2FpdCBlZGl0aW5nVG9vbGJhclBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIGVkaXRpbmctdG9vbGJhciB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XHJcblxyXG5cdFx0XHRcdC8vIERpc3BhdGNoIHRoZSBldmVudCB0aGF0IGVkaXRpbmctdG9vbGJhciBsaXN0ZW5zIGZvciB0byB0cmlnZ2VyIGEgcmVidWlsZFxyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBEaXNwYXRjaGluZyBlZGl0aW5nVG9vbGJhci1OZXdDb21tYW5kIGV2ZW50Jyk7XHJcblx0XHRcdFx0d2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZWRpdGluZ1Rvb2xiYXItTmV3Q29tbWFuZFwiKSk7XHJcblxyXG5cdFx0XHRcdGlmIChlbmFibGUpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBXYWl0aW5nIGZvciBzZXR0aW5ncyB0byBwZXJzaXN0Li4uJyk7XHJcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBlZGl0aW5nVG9vbGJhclBsdWdpbi5sb2FkU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRWRpdGluZ1Rvb2xiYXJDb25maWc6IFJlbG9hZGluZyBlZGl0aW5nIHRvb2xiYXIgcGx1Z2luIHNldHRpbmdzJyk7XHJcblx0XHRcdFx0XHRcdGF3YWl0IGVkaXRpbmdUb29sYmFyUGx1Z2luLmxvYWRTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZWRpdGluZ1Rvb2xiYXJQbHVnaW4ucmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogUmVmcmVzaGluZyBlZGl0aW5nIHRvb2xiYXIgcGx1Z2luJyk7XHJcblx0XHRcdFx0XHRcdGVkaXRpbmdUb29sYmFyUGx1Z2luLnJlZnJlc2goKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBQbHVnaW4gc2F2ZVNldHRpbmdzIG5vdCBhdmFpbGFibGUsIHVzaW5nIGZhbGxiYWNrJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXHJcblx0XHRcdGF3YWl0IHRoaXMudG9nZ2xlVmlzaWJpbGl0eUZhbGxiYWNrKGFwcCwgZW5hYmxlKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBGYWlsZWQgdG8gdG9nZ2xlIGVkaXRpbmcgdG9vbGJhciBwbHVnaW46JywgZXJyb3IpO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMudG9nZ2xlVmlzaWJpbGl0eUZhbGxiYWNrKGFwcCwgZW5hYmxlKTtcclxuXHRcdFx0fSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0VkaXRpbmdUb29sYmFyQ29uZmlnOiBGYWlsZWQgdG8gdG9nZ2xlIGVkaXRpbmcgdG9vbGJhciB2aWEgZmFsbGJhY2s6JywgZmFsbGJhY2tFcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgdG9nZ2xlVmlzaWJpbGl0eUZhbGxiYWNrKGFwcDogQXBwLCBlbmFibGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ2VkaXRpbmctdG9vbGJhcic7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSBhcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHJcblx0XHRsZXQgZXhpc3RpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xyXG5cdFx0Y29uc3QgZGF0YUZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHJcblx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBlZGl0aW5nLXRvb2xiYXIgZGF0YS5qc29uLCBzdGFydGluZyBmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0ge307XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRleGlzdGluZ0RhdGEuY01lbnVWaXNpYmlsaXR5ID0gZW5hYmxlO1xyXG5cclxuXHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdGF3YWl0IGFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIGVkaXRpbmctdG9vbGJhciB2aWEgZmlsZSBtb2RpZnknKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcblx0XHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRhd2FpdCBhcHAudmF1bHQuY3JlYXRlRm9sZGVyKHBsdWdpbkRpcik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRcdGlmIChlcnJvck1lc3NhZ2UgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRm9sZGVyIGFscmVhZHkgZXhpc3RzJykpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0YXdhaXQgYXBwLnZhdWx0LmNyZWF0ZShwbHVnaW5EYXRhUGF0aCwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRWRpdGluZ1Rvb2xiYXJDb25maWc6IFN1Y2Nlc3NmdWxseSBjcmVhdGVkIGVkaXRpbmctdG9vbGJhciBkYXRhLmpzb24nKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpIHx8IGVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcmV0cnlGaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcdFx0XHRpZiAocmV0cnlGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRcdFx0YXdhaXQgYXBwLnZhdWx0Lm1vZGlmeShyZXRyeUZpbGUsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIGVkaXRpbmctdG9vbGJhciB2aWEgcmV0cnkgbW9kaWZ5Jyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHJldHJ5RmlsZTIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJldHJ5RmlsZTIgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IGFwcC52YXVsdC5tb2RpZnkocmV0cnlGaWxlMiwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRWRpdGluZ1Rvb2xiYXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCBlZGl0aW5nLXRvb2xiYXIgdmlhIGRlbGF5ZWQgcmV0cnkgbW9kaWZ5Jyk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgdmlzaWJpbGl0eSBvZiB0aGUgZWRpdGluZyB0b29sYmFyXHJcblx0ICovXHJcblx0YXN5bmMgZ2V0VmlzaWJpbGl0eShhcHA6IEFwcCk6IFByb21pc2U8Ym9vbGVhbiB8IHVuZGVmaW5lZD4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9IChhcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBlZGl0aW5nVG9vbGJhclBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LlsnZWRpdGluZy10b29sYmFyJ107XHJcblxyXG5cdFx0XHRpZiAoZWRpdGluZ1Rvb2xiYXJQbHVnaW4/LnNldHRpbmdzKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzLmNNZW51VmlzaWJpbGl0eTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdFx0Y29uc3QgY29uZmlnRGlyID0gYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvZWRpdGluZy10b29sYmFyL2RhdGEuanNvbmA7XHJcblx0XHRcdGNvbnN0IGRhdGFGaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblxyXG5cdFx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyB7IGNNZW51VmlzaWJpbGl0eT86IGJvb2xlYW4gfTtcclxuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdEYXRhLmNNZW51VmlzaWJpbGl0eTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdFZGl0aW5nVG9vbGJhckNvbmZpZzogRmFpbGVkIHRvIGdldCBlZGl0aW5nIHRvb2xiYXIgdmlzaWJpbGl0eTonLCBlcnJvcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcclxuaW1wb3J0IHsgVmF1bHRDTVNTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3NldHRpbmdzJztcclxuaW1wb3J0IFZhdWx0Q01TUGx1Z2luIGZyb20gJy4uLy4uL21haW4nO1xyXG5pbXBvcnQgeyBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3IgfSBmcm9tICcuLi8uLi91dGlscy9JbWFnZU1hbmFnZXJDb25maWcnO1xyXG5pbXBvcnQgeyBIb21lQmFzZUNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0hvbWVCYXNlQ29uZmlnJztcclxuaW1wb3J0IHsgRXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0V4cGxvcmVyRm9jdXNDb25maWcnO1xyXG5pbXBvcnQgeyBFZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0VkaXRpbmdUb29sYmFyQ29uZmlnJztcclxuXHJcbmV4cG9ydCBjbGFzcyBXaXphcmRTdGF0ZU1hbmFnZXIge1xyXG5cdHByaXZhdGUgc3RhdGU6IFdpemFyZFN0YXRlO1xyXG5cdHByaXZhdGUgcGx1Z2luOiBQbHVnaW47XHJcblx0cHJpdmF0ZSBlZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvcjogRWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3I7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBsdWdpbjogUGx1Z2luKSB7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHRcdHRoaXMuZWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3IgPSBuZXcgRWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3IocGx1Z2luLmFwcCk7XHJcblx0XHRjb25zdCBzZXR0aW5ncyA9IChwbHVnaW4gYXMgVmF1bHRDTVNQbHVnaW4pLnNldHRpbmdzO1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuaW5pdGlhbGl6ZVN0YXRlKHNldHRpbmdzKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgaW5pdGlhbGl6ZVN0YXRlKHNldHRpbmdzOiBWYXVsdENNU1NldHRpbmdzKTogV2l6YXJkU3RhdGUge1xyXG5cdFx0Ly8gSW5pdGlhbGl6ZSBwcm9qZWN0IGRldGVjdGlvbiBmcm9tIHNhdmVkIHNldHRpbmdzIGlmIGF2YWlsYWJsZVxyXG5cdFx0Y29uc3Qgc2F2ZWRQcm9qZWN0RGV0ZWN0aW9uID0gc2V0dGluZ3MucHJvamVjdFJvb3QgJiYgc2V0dGluZ3MuY29uZmlnRmlsZVBhdGggPyB7XHJcblx0XHRcdHByb2plY3RSb290OiBzZXR0aW5ncy5wcm9qZWN0Um9vdCxcclxuXHRcdFx0Y29uZmlnRmlsZVBhdGg6IHNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoLFxyXG5cdFx0XHR2YXVsdExvY2F0aW9uOiAnY29udGVudCcgYXMgY29uc3RcclxuXHRcdH0gOiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0Ly8gVHJ5IHRvIGluZmVyIGF0dGFjaG1lbnQgc2V0dGluZ3MgZnJvbSBPYnNpZGlhbiBpZiBub3QgZXhwbGljaXRseSBzYXZlZCBpbiBvdXIgc2V0dGluZ3NcclxuXHRcdGxldCBhdHRhY2htZW50SGFuZGxpbmdNb2RlID0gc2V0dGluZ3MuYXR0YWNobWVudEhhbmRsaW5nTW9kZTtcclxuXHRcdGxldCBhdHRhY2htZW50Rm9sZGVyTmFtZSA9IHNldHRpbmdzLmF0dGFjaG1lbnRGb2xkZXJOYW1lO1xyXG5cclxuXHRcdGlmICghYXR0YWNobWVudEhhbmRsaW5nTW9kZSkge1xyXG5cdFx0XHRjb25zdCB2YXVsdCA9IHRoaXMucGx1Z2luLmFwcC52YXVsdCBhcyB7IGNvbmZpZz86IHsgbmV3RmlsZUxvY2F0aW9uPzogc3RyaW5nOyBuZXdGaWxlRm9sZGVyUGF0aD86IHN0cmluZzsgYXR0YWNobWVudEZvbGRlclBhdGg/OiBzdHJpbmc7IG5ld0xpbmtGb3JtYXQ/OiBzdHJpbmcgfSB9O1xyXG5cdFx0XHRjb25zdCBvYnNpZGlhbkNvbmZpZyA9IHZhdWx0LmNvbmZpZztcclxuXHJcblx0XHRcdGlmIChvYnNpZGlhbkNvbmZpZz8uYXR0YWNobWVudEZvbGRlclBhdGgpIHtcclxuXHRcdFx0XHRjb25zdCBmb2xkZXJQYXRoID0gb2JzaWRpYW5Db25maWcuYXR0YWNobWVudEZvbGRlclBhdGg7XHJcblx0XHRcdFx0aWYgKGZvbGRlclBhdGggPT09ICcuLycpIHtcclxuXHRcdFx0XHRcdGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc2FtZS1mb2xkZXInO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoZm9sZGVyUGF0aC5zdGFydHNXaXRoKCcuLycpKSB7XHJcblx0XHRcdFx0XHRhdHRhY2htZW50SGFuZGxpbmdNb2RlID0gJ3N1YmZvbGRlcic7XHJcblx0XHRcdFx0XHRhdHRhY2htZW50Rm9sZGVyTmFtZSA9IGZvbGRlclBhdGguc3Vic3RyaW5nKDIpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhdHRhY2htZW50SGFuZGxpbmdNb2RlID0gJ3NwZWNpZmllZC1mb2xkZXInO1xyXG5cdFx0XHRcdFx0YXR0YWNobWVudEZvbGRlck5hbWUgPSBmb2xkZXJQYXRoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGN1cnJlbnRTdGVwOiAwLFxyXG5cdFx0XHRwcm9qZWN0RGV0ZWN0aW9uOiBzYXZlZFByb2plY3REZXRlY3Rpb24sXHJcblx0XHRcdGNvbnRlbnRUeXBlczogc2V0dGluZ3MuY29udGVudFR5cGVzIHx8IFtdLFxyXG5cdFx0XHRmcm9udG1hdHRlclByb3BlcnRpZXM6IHNldHRpbmdzLmZyb250bWF0dGVyUHJvcGVydGllcyB8fCB7fSxcclxuXHRcdFx0ZGVmYXVsdENvbnRlbnRUeXBlSWQ6IHNldHRpbmdzLmRlZmF1bHRDb250ZW50VHlwZUlkLFxyXG5cdFx0XHRhdHRhY2htZW50SGFuZGxpbmdNb2RlOiBhdHRhY2htZW50SGFuZGxpbmdNb2RlIHx8ICdzdWJmb2xkZXInLFxyXG5cdFx0XHRhdHRhY2htZW50Rm9sZGVyTmFtZTogYXR0YWNobWVudEZvbGRlck5hbWUsXHJcblx0XHRcdHByZXNldDogc2V0dGluZ3MucHJlc2V0IHx8ICd2YW5pbGxhJyxcclxuXHRcdFx0cHJlc2V0TmFtZTogc2V0dGluZ3MucHJlc2V0TmFtZSB8fCAnJyxcclxuXHRcdFx0cHJlc2V0c1JlcG86IHNldHRpbmdzLnByZXNldHNSZXBvIHx8ICdkYXZpZHZraW1iYWxsL3ZhdWx0LWNtcy1wcmVzZXRzJyxcclxuXHRcdFx0ZW5hYmxlRWRpdGluZ1Rvb2xiYXI6IHNldHRpbmdzLmVuYWJsZUVkaXRpbmdUb29sYmFyID8/IChzZXR0aW5ncyBhcyBhbnkpLmVuYWJsZVdZU0lXWUcgPz8gZmFsc2UsXHJcblx0XHRcdGVuYWJsZU1keFN1cHBvcnQ6IHNldHRpbmdzLmVuYWJsZU1keFN1cHBvcnQsXHJcblx0XHRcdGVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzOiBzZXR0aW5ncy5lbmFibGVFeHRlbmRlZEZpbGVUeXBlcyxcclxuXHRcdFx0ZW5hYmxlZFBsdWdpbnM6IHNldHRpbmdzLmVuYWJsZWRQbHVnaW5zIHx8IFtdLFxyXG5cdFx0XHRkaXNhYmxlZFBsdWdpbnM6IHNldHRpbmdzLmRpc2FibGVkUGx1Z2lucyB8fCBbXSxcclxuXHRcdFx0dGhlbWU6IHNldHRpbmdzLnRoZW1lIHx8ICcnLFxyXG5cdFx0XHRiYXNlc0NNU0NvbmZpZzogc2V0dGluZ3MuYmFzZXNDTVNDb25maWcgfHwgeyB2aWV3czogW10gfSxcclxuXHRcdFx0YXN0cm9Db21wb3NlckNvbmZpZzogc2V0dGluZ3MuYXN0cm9Db21wb3NlckNvbmZpZyB8fCB7XHJcblx0XHRcdFx0Y3VzdG9tQ29udGVudFR5cGVzOiBbXSxcclxuXHRcdFx0XHRkZWZhdWx0VGVtcGxhdGU6ICcnLFxyXG5cdFx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiAnJyxcclxuXHRcdFx0XHR0ZXJtaW5hbFByb2plY3RSb290UGF0aDogJydcclxuXHRcdFx0fSxcclxuXHRcdFx0c2VvQ29uZmlnOiBzZXR0aW5ncy5zZW9Db25maWcgfHwge1xyXG5cdFx0XHRcdHRpdGxlUHJvcGVydHk6ICd0aXRsZScsXHJcblx0XHRcdFx0c2NhbkRpcmVjdG9yaWVzOiAnJyxcclxuXHRcdFx0XHR1c2VGaWxlbmFtZUFzVGl0bGU6IGZhbHNlLFxyXG5cdFx0XHRcdHVzZUZpbGVuYW1lQXNTbHVnOiB0cnVlLFxyXG5cdFx0XHRcdGVuYWJsZU1EWFN1cHBvcnQ6IHNldHRpbmdzLmVuYWJsZU1keFN1cHBvcnQgPz8gZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0cHJvcGVydHlPdmVyRmlsZU5hbWU6IHNldHRpbmdzLnByb3BlcnR5T3ZlckZpbGVOYW1lIHx8IHsgcHJvcGVydHlLZXk6ICd0aXRsZScgfSxcclxuXHRcdFx0aW1hZ2VNYW5hZ2VyOiBzZXR0aW5ncy5pbWFnZU1hbmFnZXIgfHwge30sXHJcblx0XHRcdGhvbWVCYXNlOiBzZXR0aW5ncy5ob21lQmFzZSB8fCB7fSxcclxuXHRcdFx0ZXhwbG9yZXJGb2N1czogc2V0dGluZ3MuZXhwbG9yZXJGb2N1cyB8fCB7fSxcclxuXHRcdFx0aWdub3JlQ29uZmlnOiBzZXR0aW5ncy5pZ25vcmVDb25maWcgfHwgeyBnaXRJZ25vcmVDb25maWd1cmVkOiBmYWxzZSwgdml0ZUlnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlIH0sXHJcblx0XHRcdGdpdENvbmZpZzogc2V0dGluZ3MuZ2l0Q29uZmlnIHx8IHsgZW5hYmxlZDogZmFsc2UsIGF1dG9Db25maWd1cmVPYnNpZGlhbkdpdDogdHJ1ZSB9XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Z2V0U3RhdGUoKTogV2l6YXJkU3RhdGUge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGU7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVTdGF0ZSh1cGRhdGVzOiBQYXJ0aWFsPFdpemFyZFN0YXRlPik6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHsgLi4udGhpcy5zdGF0ZSwgLi4udXBkYXRlcyB9O1xyXG5cdH1cclxuXHJcblx0c2V0U3RhdGUodXBkYXRlczogUGFydGlhbDxXaXphcmRTdGF0ZT4pOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUsIC4uLnVwZGF0ZXMgfTtcclxuXHR9XHJcblxyXG5cdG5leHRTdGVwKHRvdGFsU3RlcHM6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Ly8gY3VycmVudFN0ZXAgaXMgMC1pbmRleGVkLCBzbyB3ZSBpbmNyZW1lbnQgaXQgYnV0IGtlZXAgaXQgd2l0aGluIGJvdW5kc1xyXG5cdFx0aWYgKHRoaXMuc3RhdGUuY3VycmVudFN0ZXAgPCB0b3RhbFN0ZXBzIC0gMSkge1xyXG5cdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnRTdGVwKys7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcmV2aW91c1N0ZXAoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5zdGF0ZS5jdXJyZW50U3RlcCA+IDApIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50U3RlcC0tO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y2FuR29OZXh0KHRvdGFsU3RlcHM6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFN0ZXAgPCB0b3RhbFN0ZXBzIC0gMTtcclxuXHR9XHJcblxyXG5cdGNhbkdvUHJldmlvdXMoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50U3RlcCA+IDA7XHJcblx0fVxyXG5cclxuXHRnZXRQcm9ncmVzcyh0b3RhbFN0ZXBzOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRvdGFsU3RlcHMgPT09IDApIHJldHVybiAwO1xyXG5cdFx0cmV0dXJuICgodGhpcy5zdGF0ZS5jdXJyZW50U3RlcCArIDEpIC8gdG90YWxTdGVwcykgKiAxMDA7XHJcblx0fVxyXG5cclxuXHRhc3luYyByZWZyZXNoU3RhdGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHQvLyBSZWZyZXNoIHRoZSB3aXphcmQgc3RhdGUgd2l0aCBjdXJyZW50IHBsdWdpbiBzZXR0aW5nc1xyXG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSAodGhpcy5wbHVnaW4gYXMgVmF1bHRDTVNQbHVnaW4pLnNldHRpbmdzO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBwcm9qZWN0IGRldGVjdGlvblxyXG5cdFx0aWYgKHNldHRpbmdzLnByb2plY3RSb290ICYmIHNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiA9IHtcclxuXHRcdFx0XHRwcm9qZWN0Um9vdDogc2V0dGluZ3MucHJvamVjdFJvb3QsXHJcblx0XHRcdFx0Y29uZmlnRmlsZVBhdGg6IHNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoLFxyXG5cdFx0XHRcdHZhdWx0TG9jYXRpb246ICdjb250ZW50J1xyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSBhbGwgb3RoZXIgc2V0dGluZ3NcclxuXHRcdHRoaXMuc3RhdGUuY29udGVudFR5cGVzID0gc2V0dGluZ3MuY29udGVudFR5cGVzIHx8IFtdO1xyXG5cdFx0dGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXMgPSBzZXR0aW5ncy5mcm9udG1hdHRlclByb3BlcnRpZXMgfHwge307XHJcblx0XHR0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkID0gc2V0dGluZ3MuZGVmYXVsdENvbnRlbnRUeXBlSWQ7XHJcblxyXG5cdFx0Ly8gVXNlIHNhdmVkIHNldHRpbmdzIGZvciBhdHRhY2htZW50IGhhbmRsaW5nLCBvciBpbmZlciBmcm9tIE9ic2lkaWFuIGlmIG5vdCBzZXRcclxuXHRcdGlmIChzZXR0aW5ncy5hdHRhY2htZW50SGFuZGxpbmdNb2RlKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9IHNldHRpbmdzLmF0dGFjaG1lbnRIYW5kbGluZ01vZGU7XHJcblx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgPSBzZXR0aW5ncy5hdHRhY2htZW50Rm9sZGVyTmFtZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0IGFzIHsgY29uZmlnPzogeyBuZXdGaWxlTG9jYXRpb24/OiBzdHJpbmc7IG5ld0ZpbGVGb2xkZXJQYXRoPzogc3RyaW5nOyBhdHRhY2htZW50Rm9sZGVyUGF0aD86IHN0cmluZzsgbmV3TGlua0Zvcm1hdD86IHN0cmluZyB9IH07XHJcblx0XHRcdGNvbnN0IG9ic2lkaWFuQ29uZmlnID0gdmF1bHQuY29uZmlnO1xyXG5cclxuXHRcdFx0aWYgKG9ic2lkaWFuQ29uZmlnPy5hdHRhY2htZW50Rm9sZGVyUGF0aCkge1xyXG5cdFx0XHRcdGNvbnN0IGZvbGRlclBhdGggPSBvYnNpZGlhbkNvbmZpZy5hdHRhY2htZW50Rm9sZGVyUGF0aDtcclxuXHRcdFx0XHRpZiAoZm9sZGVyUGF0aCA9PT0gJy4vJykge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID0gJ3NhbWUtZm9sZGVyJztcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChmb2xkZXJQYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9ICdzdWJmb2xkZXInO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSA9IGZvbGRlclBhdGguc3Vic3RyaW5nKDIpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc3BlY2lmaWVkLWZvbGRlcic7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gZm9sZGVyUGF0aDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID0gJ3N1YmZvbGRlcic7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RhdGUucHJlc2V0ID0gc2V0dGluZ3MucHJlc2V0IHx8ICd2YW5pbGxhJztcclxuXHRcdHRoaXMuc3RhdGUucHJlc2V0TmFtZSA9IHNldHRpbmdzLnByZXNldE5hbWUgfHwgJyc7XHJcblx0XHR0aGlzLnN0YXRlLnByZXNldHNSZXBvID0gc2V0dGluZ3MucHJlc2V0c1JlcG8gfHwgJ3ZhdWx0Y21zL3ZhdWx0LWNtcy1wcmVzZXRzJztcclxuXHJcblx0XHQvLyBTeW5jIGVuYWJsZUVkaXRpbmdUb29sYmFyIHdpdGggYWN0dWFsIHBsdWdpbiBzdGF0ZVxyXG5cdFx0Y29uc3QgYWN0dWFsVmlzaWJpbGl0eSA9IGF3YWl0IHRoaXMuZWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3IuZ2V0VmlzaWJpbGl0eSh0aGlzLnBsdWdpbi5hcHApO1xyXG5cdFx0aWYgKGFjdHVhbFZpc2liaWxpdHkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0YXRlLmVuYWJsZUVkaXRpbmdUb29sYmFyID0gYWN0dWFsVmlzaWJpbGl0eTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXIgPSBzZXR0aW5ncy5lbmFibGVFZGl0aW5nVG9vbGJhciA/PyAoc2V0dGluZ3MgYXMgYW55KS5lbmFibGVXWVNJV1lHID8/IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9IHNldHRpbmdzLmVuYWJsZU1keFN1cHBvcnQ7XHJcblx0XHR0aGlzLnN0YXRlLmVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzID0gc2V0dGluZ3MuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXM7XHJcblx0XHR0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zID0gc2V0dGluZ3MuZW5hYmxlZFBsdWdpbnMgfHwgW107XHJcblx0XHR0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucyA9IHNldHRpbmdzLmRpc2FibGVkUGx1Z2lucyB8fCBbXTtcclxuXHRcdHRoaXMuc3RhdGUudGhlbWUgPSBzZXR0aW5ncy50aGVtZSB8fCAnJztcclxuXHRcdHRoaXMuc3RhdGUuYmFzZXNDTVNDb25maWcgPSBzZXR0aW5ncy5iYXNlc0NNU0NvbmZpZyB8fCB7IHZpZXdzOiBbXSB9O1xyXG5cdFx0dGhpcy5zdGF0ZS5hc3Ryb0NvbXBvc2VyQ29uZmlnID0gc2V0dGluZ3MuYXN0cm9Db21wb3NlckNvbmZpZyB8fCB7XHJcblx0XHRcdGN1c3RvbUNvbnRlbnRUeXBlczogW10sXHJcblx0XHRcdGRlZmF1bHRUZW1wbGF0ZTogJycsXHJcblx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiAnJyxcclxuXHRcdFx0dGVybWluYWxQcm9qZWN0Um9vdFBhdGg6ICcnXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5zdGF0ZS5zZW9Db25maWcgPSBzZXR0aW5ncy5zZW9Db25maWcgfHwge1xyXG5cdFx0XHR0aXRsZVByb3BlcnR5OiAndGl0bGUnLFxyXG5cdFx0XHRzY2FuRGlyZWN0b3JpZXM6ICcnLFxyXG5cdFx0XHR1c2VGaWxlbmFtZUFzVGl0bGU6IGZhbHNlLFxyXG5cdFx0XHR1c2VGaWxlbmFtZUFzU2x1ZzogdHJ1ZVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUgPSBzZXR0aW5ncy5wcm9wZXJ0eU92ZXJGaWxlTmFtZSB8fCB7IHByb3BlcnR5S2V5OiAndGl0bGUnIH07XHJcblx0XHR0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXMgPSBzZXR0aW5ncy5leHBsb3JlckZvY3VzIHx8IHt9O1xyXG5cclxuXHRcdC8vIExvYWQgY29uZmlncyBmcm9tIHBsdWdpbiBkYXRhLmpzb24gZmlsZXMgaWYgdGhleSdyZSBlbXB0eVxyXG5cdFx0aWYgKCF0aGlzLnN0YXRlLmltYWdlTWFuYWdlciB8fCBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLmltYWdlTWFuYWdlcikubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y29uc3QgaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yID0gbmV3IEltYWdlTWFuYWdlckNvbmZpZ3VyYXRvcih0aGlzLnBsdWdpbi5hcHApO1xyXG5cdFx0XHRcdGNvbnN0IGxvYWRlZENvbmZpZyA9IGF3YWl0IGltYWdlTWFuYWdlckNvbmZpZ3VyYXRvci5sb2FkQ29uZmlnKCk7XHJcblx0XHRcdFx0aWYgKGxvYWRlZENvbmZpZyAmJiBPYmplY3Qua2V5cyhsb2FkZWRDb25maWcpLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyID0gbG9hZGVkQ29uZmlnO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmltYWdlTWFuYWdlciA9IHNldHRpbmdzLmltYWdlTWFuYWdlciB8fCB7fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBJbWFnZSBNYW5hZ2VyIGNvbmZpZyBkdXJpbmcgcmVmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5pbWFnZU1hbmFnZXIgPSBzZXR0aW5ncy5pbWFnZU1hbmFnZXIgfHwge307XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyID0gc2V0dGluZ3MuaW1hZ2VNYW5hZ2VyIHx8IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5zdGF0ZS5ob21lQmFzZSB8fCBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLmhvbWVCYXNlKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjb25zdCBob21lQmFzZUNvbmZpZ3VyYXRvciA9IG5ldyBIb21lQmFzZUNvbmZpZ3VyYXRvcih0aGlzLnBsdWdpbi5hcHApO1xyXG5cdFx0XHRcdGNvbnN0IGxvYWRlZENvbmZpZyA9IGF3YWl0IGhvbWVCYXNlQ29uZmlndXJhdG9yLmxvYWRDb25maWcoKTtcclxuXHRcdFx0XHRpZiAobG9hZGVkQ29uZmlnICYmIE9iamVjdC5rZXlzKGxvYWRlZENvbmZpZykubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5ob21lQmFzZSA9IGxvYWRlZENvbmZpZztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5ob21lQmFzZSA9IHNldHRpbmdzLmhvbWVCYXNlIHx8IHt9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEhvbWUgQmFzZSBjb25maWcgZHVyaW5nIHJlZnJlc2g6JywgZXJyb3IpO1xyXG5cdFx0XHRcdHRoaXMuc3RhdGUuaG9tZUJhc2UgPSBzZXR0aW5ncy5ob21lQmFzZSB8fCB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5ob21lQmFzZSA9IHNldHRpbmdzLmhvbWVCYXNlIHx8IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzIHx8IE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cykubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y29uc3QgZXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvciA9IG5ldyBFeHBsb3JlckZvY3VzQ29uZmlndXJhdG9yKHRoaXMucGx1Z2luLmFwcCk7XHJcblx0XHRcdFx0Y29uc3QgbG9hZGVkQ29uZmlnID0gYXdhaXQgZXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvci5sb2FkQ29uZmlnKCk7XHJcblx0XHRcdFx0aWYgKGxvYWRlZENvbmZpZyAmJiBPYmplY3Qua2V5cyhsb2FkZWRDb25maWcpLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cyA9IGxvYWRlZENvbmZpZztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzID0gc2V0dGluZ3MuZXhwbG9yZXJGb2N1cyB8fCB7fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBFeHBsb3JlciBGb2N1cyBjb25maWcgZHVyaW5nIHJlZnJlc2g6JywgZXJyb3IpO1xyXG5cdFx0XHRcdHRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cyA9IHNldHRpbmdzLmV4cGxvcmVyRm9jdXMgfHwge307XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cyA9IHNldHRpbmdzLmV4cGxvcmVyRm9jdXMgfHwge307XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGF0ZS5naXRDb25maWcgPSBzZXR0aW5ncy5naXRDb25maWcgfHwgeyBlbmFibGVkOiBmYWxzZSwgYXV0b0NvbmZpZ3VyZU9ic2lkaWFuR2l0OiB0cnVlIH07XHJcblx0XHR0aGlzLnN0YXRlLmlnbm9yZUNvbmZpZyA9IHNldHRpbmdzLmlnbm9yZUNvbmZpZyB8fCB7IGdpdElnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlLCB2aXRlSWdub3JlQ29uZmlndXJlZDogZmFsc2UgfTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGJ1aWxkRmluYWxTZXR0aW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdC8vIFVwZGF0ZSBwbHVnaW4uc2V0dGluZ3MgZGlyZWN0bHkgZnJvbSB3aXphcmQgc3RhdGVcclxuXHRcdGNvbnN0IHNldHRpbmdzID0gKHRoaXMucGx1Z2luIGFzIFZhdWx0Q01TUGx1Z2luKS5zZXR0aW5ncztcclxuXHJcblx0XHRzZXR0aW5ncy5wcm9qZWN0Um9vdCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3QgfHwgJyc7XHJcblx0XHRzZXR0aW5ncy5jb25maWdGaWxlUGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8uY29uZmlnRmlsZVBhdGggfHwgJyc7XHJcblx0XHRzZXR0aW5ncy5jb250ZW50VHlwZXMgPSB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcztcclxuXHRcdHNldHRpbmdzLmZyb250bWF0dGVyUHJvcGVydGllcyA9IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzO1xyXG5cdFx0c2V0dGluZ3MuZGVmYXVsdENvbnRlbnRUeXBlSWQgPSB0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkO1xyXG5cdFx0c2V0dGluZ3MuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9IHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZTtcclxuXHRcdHNldHRpbmdzLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gdGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZTtcclxuXHRcdHNldHRpbmdzLnByZXNldCA9IHRoaXMuc3RhdGUucHJlc2V0O1xyXG5cdFx0c2V0dGluZ3MucHJlc2V0TmFtZSA9IHRoaXMuc3RhdGUucHJlc2V0TmFtZSB8fCAnJztcclxuXHRcdHNldHRpbmdzLnByZXNldHNSZXBvID0gdGhpcy5zdGF0ZS5wcmVzZXRzUmVwbyB8fCAnZGF2aWR2a2ltYmFsbC92YXVsdC1jbXMtcHJlc2V0cyc7XHJcblx0XHRzZXR0aW5ncy5lbmFibGVFZGl0aW5nVG9vbGJhciA9IHRoaXMuc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXI7XHJcblxyXG5cdFx0Ly8gQ2xlYW4gdXAgb2xkIFdZU0lXWUcgc2V0dGluZyBuYW1lXHJcblx0XHRpZiAoKHNldHRpbmdzIGFzIGFueSkuZW5hYmxlV1lTSVdZRyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGRlbGV0ZSAoc2V0dGluZ3MgYXMgYW55KS5lbmFibGVXWVNJV1lHO1xyXG5cdFx0fVxyXG5cdFx0c2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydCA9IHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZTtcclxuXHRcdHNldHRpbmdzLmVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzID0gdGhpcy5zdGF0ZS5lbmFibGVFeHRlbmRlZEZpbGVUeXBlcyA/PyBmYWxzZTtcclxuXHRcdHNldHRpbmdzLmVuYWJsZWRQbHVnaW5zID0gdGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucztcclxuXHRcdHNldHRpbmdzLmRpc2FibGVkUGx1Z2lucyA9IHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zO1xyXG5cdFx0c2V0dGluZ3MudGhlbWUgPSB0aGlzLnN0YXRlLnRoZW1lO1xyXG5cdFx0c2V0dGluZ3MuYmFzZXNDTVNDb25maWcgPSB0aGlzLnN0YXRlLmJhc2VzQ01TQ29uZmlnO1xyXG5cdFx0c2V0dGluZ3MuYXN0cm9Db21wb3NlckNvbmZpZyA9IHRoaXMuc3RhdGUuYXN0cm9Db21wb3NlckNvbmZpZztcclxuXHRcdHNldHRpbmdzLnNlb0NvbmZpZyA9IHRoaXMuc3RhdGUuc2VvQ29uZmlnO1xyXG5cdFx0c2V0dGluZ3MucHJvcGVydHlPdmVyRmlsZU5hbWUgPSB0aGlzLnN0YXRlLnByb3BlcnR5T3ZlckZpbGVOYW1lO1xyXG5cdFx0Ly8gQ2xlYW4gdXAgb2xkIHN0cnVjdHVyZSBpZiBpdCBleGlzdHNcclxuXHRcdGNvbnN0IHNldHRpbmdzUmVjb3JkID0gc2V0dGluZ3MgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdGlmIChzZXR0aW5nc1JlY29yZC51aVR3ZWFrZXIpIHtcclxuXHRcdFx0ZGVsZXRlIHNldHRpbmdzUmVjb3JkLnVpVHdlYWtlcjtcclxuXHRcdH1cclxuXHRcdGlmIChzZXR0aW5nc1JlY29yZC50YWJCYXJDb21tYW5kcykge1xyXG5cdFx0XHRkZWxldGUgc2V0dGluZ3NSZWNvcmQudGFiQmFyQ29tbWFuZHM7XHJcblx0XHR9XHJcblx0XHRpZiAoc2V0dGluZ3NSZWNvcmQuY29tbWFuZGVyQ29uZmlnKSB7XHJcblx0XHRcdGRlbGV0ZSBzZXR0aW5nc1JlY29yZC5jb21tYW5kZXJDb25maWc7XHJcblx0XHR9XHJcblx0XHRpZiAoc2V0dGluZ3NSZWNvcmQuaW1hZ2VJbnNlcnRlcikge1xyXG5cdFx0XHRkZWxldGUgc2V0dGluZ3NSZWNvcmQuaW1hZ2VJbnNlcnRlcjtcclxuXHRcdH1cclxuXHRcdHNldHRpbmdzLmltYWdlTWFuYWdlciA9IHRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyO1xyXG5cdFx0c2V0dGluZ3MuaG9tZUJhc2UgPSB0aGlzLnN0YXRlLmhvbWVCYXNlO1xyXG5cdFx0c2V0dGluZ3MuZXhwbG9yZXJGb2N1cyA9IHRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cztcclxuXHRcdHNldHRpbmdzLmlnbm9yZUNvbmZpZyA9IHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnO1xyXG5cdFx0c2V0dGluZ3MuZ2l0Q29uZmlnID0geyAuLi50aGlzLnN0YXRlLmdpdENvbmZpZyB9O1xyXG5cdFx0Ly8gQ0FVVElPTjogTmV2ZXIgcGVyc2lzdCB0aGUgUEFUIHRvIGRhdGEuanNvbiFcclxuXHRcdGRlbGV0ZSBzZXR0aW5ncy5naXRDb25maWcucGF0O1xyXG5cclxuXHRcdC8vIFN5bmMgaW1hZ2UgcHJvcGVydHkgd2l0aCBJbWFnZSBNYW5hZ2VyXHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCBpbWFnZU1hbmFnZXJDb25maWd1cmF0b3IgPSBuZXcgSW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yKHRoaXMucGx1Z2luLmFwcCk7XHJcblx0XHRcdGF3YWl0IGltYWdlTWFuYWdlckNvbmZpZ3VyYXRvci5yZXNvbHZlQW5kU3luY0ltYWdlUHJvcGVydHkodGhpcy5zdGF0ZSk7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ1dpemFyZFN0YXRlTWFuYWdlcjogRmFpbGVkIHRvIHN5bmMgaW1hZ2UgcHJvcGVydHkgd2l0aCBJbWFnZSBNYW5hZ2VyOicsIGVycm9yKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVdpemFyZFN0ZXAge1xyXG5cdHByb3RlY3RlZCBhcHA6IEFwcDtcclxuXHRwcm90ZWN0ZWQgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50O1xyXG5cdHByb3RlY3RlZCBzdGF0ZTogV2l6YXJkU3RhdGU7XHJcblx0cHJvdGVjdGVkIG9uTmV4dDogKCkgPT4gdm9pZDtcclxuXHRwcm90ZWN0ZWQgb25CYWNrOiAoKSA9PiB2b2lkO1xyXG5cdHByb3RlY3RlZCBvbkNhbmNlbDogKCkgPT4gdm9pZDtcclxuXHRwdWJsaWMgc2hvd05leHRCdXR0b246IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGFwcDogQXBwLFxyXG5cdFx0Y29udGFpbmVyRWw6IEhUTUxFbGVtZW50LFxyXG5cdFx0c3RhdGU6IFdpemFyZFN0YXRlLFxyXG5cdFx0b25OZXh0OiAoKSA9PiB2b2lkLFxyXG5cdFx0b25CYWNrOiAoKSA9PiB2b2lkLFxyXG5cdFx0b25DYW5jZWw6ICgpID0+IHZvaWRcclxuXHQpIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdFx0dGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cdFx0dGhpcy5vbk5leHQgPSBvbk5leHQ7XHJcblx0XHR0aGlzLm9uQmFjayA9IG9uQmFjaztcclxuXHRcdHRoaXMub25DYW5jZWwgPSBvbkNhbmNlbDtcclxuXHR9XHJcblxyXG5cdGFic3RyYWN0IGRpc3BsYXkoKTogdm9pZCB8IFByb21pc2U8dm9pZD47XHJcblx0YWJzdHJhY3QgdmFsaWRhdGUoKTogYm9vbGVhbjtcclxuXHRhYnN0cmFjdCBnZXRUaXRsZSgpOiBzdHJpbmc7XHJcblx0YWJzdHJhY3QgZ2V0RGVzY3JpcHRpb24oKTogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiB0aGlzIHN0ZXAgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgc2tpcHBlZFxyXG5cdCAqL1xyXG5cdGFzeW5jIHNob3VsZFNraXAoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IGFic29sdXRlIHBhdGggdG8gcmVsYXRpdmUgcGF0aCBmcm9tIHZhdWx0IHJvb3RcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgdG9SZWxhdGl2ZVBhdGgoYWJzb2x1dGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xyXG5cdFx0Y29uc3QgdmF1bHRQYXRoID0gYWRhcHRlci5iYXNlUGF0aCB8fCBhZGFwdGVyLnBhdGg7XHJcblx0XHRpZiAoIXZhdWx0UGF0aCkge1xyXG5cdFx0XHRyZXR1cm4gYWJzb2x1dGVQYXRoO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHZhdWx0Tm9ybWFsaXplZCA9IHZhdWx0UGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuXHRcdGNvbnN0IGFic29sdXRlTm9ybWFsaXplZCA9IGFic29sdXRlUGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuXHJcblx0XHQvLyBJZiB0aGUgYWJzb2x1dGUgcGF0aCBpcyB3aXRoaW4gdGhlIHZhdWx0LCByZXR1cm4gcmVsYXRpdmUgcGF0aFxyXG5cdFx0aWYgKGFic29sdXRlTm9ybWFsaXplZC5zdGFydHNXaXRoKHZhdWx0Tm9ybWFsaXplZCkpIHtcclxuXHRcdFx0Y29uc3QgcmVsYXRpdmUgPSBhYnNvbHV0ZU5vcm1hbGl6ZWQuc2xpY2UodmF1bHROb3JtYWxpemVkLmxlbmd0aCk7XHJcblx0XHRcdC8vIFJlbW92ZSBsZWFkaW5nIHBhdGggc2VwYXJhdG9yXHJcblx0XHRcdGNvbnN0IHRyaW1tZWRSZWxhdGl2ZSA9IHJlbGF0aXZlLnN0YXJ0c1dpdGgoJy8nKSA/IHJlbGF0aXZlLnNsaWNlKDEpIDogcmVsYXRpdmU7XHJcblx0XHRcdHJldHVybiB0cmltbWVkUmVsYXRpdmUgfHwgJy4nO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHBhdGggaXMgb3V0c2lkZSB2YXVsdCwgY2FsY3VsYXRlIHJlbGF0aXZlIHBhdGggbWFudWFsbHlcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIFNwbGl0IHBhdGhzIGludG8gcGFydHNcclxuXHRcdFx0Y29uc3QgdmF1bHRQYXJ0cyA9IHZhdWx0Tm9ybWFsaXplZC5zcGxpdCgnLycpLmZpbHRlcihwID0+IHApO1xyXG5cdFx0XHRjb25zdCBhYnNvbHV0ZVBhcnRzID0gYWJzb2x1dGVOb3JtYWxpemVkLnNwbGl0KCcvJykuZmlsdGVyKHAgPT4gcCk7XHJcblxyXG5cdFx0XHQvLyBGaW5kIGNvbW1vbiBwcmVmaXhcclxuXHRcdFx0bGV0IGNvbW1vbkxlbmd0aCA9IDA7XHJcblx0XHRcdHdoaWxlIChjb21tb25MZW5ndGggPCB2YXVsdFBhcnRzLmxlbmd0aCAmJiBjb21tb25MZW5ndGggPCBhYnNvbHV0ZVBhcnRzLmxlbmd0aCAmJiB2YXVsdFBhcnRzW2NvbW1vbkxlbmd0aF0gPT09IGFic29sdXRlUGFydHNbY29tbW9uTGVuZ3RoXSkge1xyXG5cdFx0XHRcdGNvbW1vbkxlbmd0aCsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDYWxjdWxhdGUgcmVsYXRpdmUgcGF0aFxyXG5cdFx0XHRjb25zdCB1cExldmVscyA9IHZhdWx0UGFydHMubGVuZ3RoIC0gY29tbW9uTGVuZ3RoO1xyXG5cdFx0XHRjb25zdCByZWxhdGl2ZVBhcnRzID0gYWJzb2x1dGVQYXJ0cy5zbGljZShjb21tb25MZW5ndGgpO1xyXG5cdFx0XHRjb25zdCByZWxhdGl2ZSA9ICh1cExldmVscyA+IDAgPyAnLi4vJy5yZXBlYXQodXBMZXZlbHMpIDogJycpICsgcmVsYXRpdmVQYXJ0cy5qb2luKCcvJyk7XHJcblx0XHRcdHJldHVybiByZWxhdGl2ZSB8fCBhYnNvbHV0ZVBhdGg7XHJcblx0XHR9IGNhdGNoIHtcclxuXHRcdFx0Ly8gSWYgcmVsYXRpdmUgcGF0aCBjYWxjdWxhdGlvbiBmYWlscywgcmV0dXJuIGFic29sdXRlIHBhdGhcclxuXHRcdFx0cmV0dXJuIGFic29sdXRlUGF0aDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3Igc2V0Q3NzUHJvcHNcbiAqL1xuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuXHRcdGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcblx0fVxufVxuXG5pbnRlcmZhY2UgT2JzaWRpYW5TZXR0aW5nIHtcblx0b3BlbigpOiB2b2lkO1xuXHRvcGVuVGFiQnlJZChpZDogc3RyaW5nKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIE9ic2lkaWFuQXBwV2l0aFNldHRpbmcge1xuXHRzZXR0aW5nOiBPYnNpZGlhblNldHRpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBXZWxjb21lU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdXZWxjb21lIHRvIFZhdWx0IENNUycgfSk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnVGhpcyB3aXphcmQgd2lsbCBoZWxwIHlvdSBjb25maWd1cmUgVmF1bHQgQ01TIGZvciB5b3VyIHByb2plY3QuIFdlXFwnbGwgZ3VpZGUgeW91IHRocm91Z2g6J1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgbGlzdCA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCd1bCcpO1xuXHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnRGV0ZWN0aW5nIHlvdXIgQXN0cm8gcHJvamVjdCBzdHJ1Y3R1cmUnIH0pO1xuXHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnSWRlbnRpZnlpbmcgeW91ciBjb250ZW50IHR5cGVzJyB9KTtcblx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ01hcHBpbmcgZnJvbnRtYXR0ZXIgcHJvcGVydGllcycgfSk7XG5cdFx0bGlzdC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdDb25maWd1cmluZyBwbHVnaW5zIGFuZCB0aGVtZXMnIH0pO1xuXHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnU2V0dGluZyB1cCBIb21lIEJhc2UgY29udGVudCB2aWV3cycgfSk7XG5cdFx0bGlzdC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdDb25maWd1cmluZyBBc3RybyBDb21wb3NlciBhbmQgU0VPIHBsdWdpbnMnIH0pO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxuXHRcdFx0dGV4dDogJ0Nob29zZSBhbiBvcHRpb24gdG8gY29udGludWU6JyBcblx0XHR9KTtcblxuXHRcdGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdignd2l6YXJkLXdlbGNvbWUtYnV0dG9ucycpO1xuXHRcdHNldENzc1Byb3BzKGJ1dHRvbkNvbnRhaW5lciwge1xuXHRcdFx0ZGlzcGxheTogJ2ZsZXgnLFxuXHRcdFx0Z2FwOiAnMTBweCcsXG5cdFx0XHRtYXJnaW5Ub3A6ICcyMHB4J1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgZ2V0U3RhcnRlZEJ0biA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywge1xuXHRcdFx0dGV4dDogJ0dldCBzdGFydGVkJyxcblx0XHRcdGNsczogJ21vZC1idXR0b24gbW9kLWN0YSdcblx0XHR9KTtcblx0XHRnZXRTdGFydGVkQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuXHRcdFx0dGhpcy5vbk5leHQoKTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IHNlbGVjdFByZXNldEJ0biA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywge1xuXHRcdFx0dGV4dDogJ1NlbGVjdCBwcmVzZXQnLFxuXHRcdFx0Y2xzOiAnbW9kLWJ1dHRvbidcblx0XHR9KTtcblx0XHRzZWxlY3RQcmVzZXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG5cdFx0XHQvLyBDbG9zZSBtb2RhbCBhbmQgb3BlbiBzZXR0aW5ncyB0YWJcblx0XHRcdHRoaXMub25DYW5jZWwoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYXBwV2l0aFNldHRpbmcgPSB0aGlzLmFwcCBhcyB1bmtub3duIGFzIE9ic2lkaWFuQXBwV2l0aFNldHRpbmc7XG5cdFx0XHRpZiAoYXBwV2l0aFNldHRpbmcuc2V0dGluZyAmJiB0eXBlb2YgYXBwV2l0aFNldHRpbmcuc2V0dGluZy5vcGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlbigpO1xuXHRcdFx0XHRpZiAodHlwZW9mIGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlblRhYkJ5SWQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRhcHBXaXRoU2V0dGluZy5zZXR0aW5nLm9wZW5UYWJCeUlkKCd2YXVsdC1jbXMnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0dmFsaWRhdGUoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnV2VsY29tZSc7XG5cdH1cblxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnSW50cm9kdWN0aW9uIHRvIFZhdWx0IENNUyBzZXR1cCc7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wcyAobWF5IG5vdCBiZSBpbiB0eXBlcyB5ZXQpXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuXHR9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzIC0tIE5vZGUuanMgbW9kdWxlIG5lZWRlZCBmb3IgcGF0aCBvcGVyYXRpb25zXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlcyAtLSBOb2RlLmpzIG1vZHVsZSBuZWVkZWQgZm9yIGZpbGUgb3BlcmF0aW9uc1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgUHJvamVjdERldGVjdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvUHJvamVjdERldGVjdG9yJztcbmltcG9ydCB7IE1keERldGVjdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvTWR4RGV0ZWN0b3InO1xuaW1wb3J0IHsgQ29udGVudFR5cGVEZXRlY3RvciB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbnRlbnRUeXBlRGV0ZWN0b3InO1xuXG5leHBvcnQgY2xhc3MgUHJvamVjdERldGVjdGlvblN0ZXAgZXh0ZW5kcyBCYXNlV2l6YXJkU3RlcCB7XG5cdHByaXZhdGUgcHJvamVjdERldGVjdG9yOiBQcm9qZWN0RGV0ZWN0b3I7XG5cdHByaXZhdGUgbWR4RGV0ZWN0b3I6IE1keERldGVjdG9yO1xuXHRwcml2YXRlIGNvbnRlbnRUeXBlRGV0ZWN0b3I6IENvbnRlbnRUeXBlRGV0ZWN0b3I7XG5cdHByaXZhdGUgZGV0ZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSBwcm9qZWN0Um9vdERpc3BsYXk6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgY29uZmlnRmlsZURpc3BsYXk6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHAsIGNvbnRhaW5lckVsLCBzdGF0ZSwgb25OZXh0LCBvbkJhY2ssIG9uQ2FuY2VsKTtcblx0XHR0aGlzLnByb2plY3REZXRlY3RvciA9IG5ldyBQcm9qZWN0RGV0ZWN0b3IoYXBwKTtcblx0XHR0aGlzLm1keERldGVjdG9yID0gbmV3IE1keERldGVjdG9yKGFwcCk7XG5cdFx0dGhpcy5jb250ZW50VHlwZURldGVjdG9yID0gbmV3IENvbnRlbnRUeXBlRGV0ZWN0b3IoYXBwKTtcblx0fVxuXG5cdGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAuZGlzcGxheTogY2FsbGVkJyk7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgaGF2ZSBzYXZlZCBwcm9qZWN0IGRldGVjdGlvbiB2YWx1ZXNcblx0XHRjb25zdCBoYXNTYXZlZFZhbHVlcyA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3QgJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aDtcblx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcC5kaXNwbGF5OiBoYXNTYXZlZFZhbHVlcyA9JywgaGFzU2F2ZWRWYWx1ZXMpO1xuXHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwLmRpc3BsYXk6IGN1cnJlbnQgZW5hYmxlTWR4U3VwcG9ydCA9JywgdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0KTtcblxuXHRcdGlmICghaGFzU2F2ZWRWYWx1ZXMpIHtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3QgZGV0ZWN0aW9uJyB9KTtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0XHR0ZXh0OiAnRGV0ZWN0aW5nIHlvdXIgQXN0cm8gcHJvamVjdCBzdHJ1Y3R1cmUuLi4nXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5wcm9qZWN0RGV0ZWN0b3IuZGV0ZWN0UHJvamVjdCgpO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAuZGlzcGxheTogZGV0ZWN0aW9uIHJlc3VsdCA9JywgcmVzdWx0KTtcblxuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHQvLyBTdG9yZSBhYnNvbHV0ZSBwYXRocyBmb3IgcmVsaWFiaWxpdHkgd2l0aGluIGludGVybmFsIGxvZ2ljXG5cdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiA9IHtcblx0XHRcdFx0XHRwcm9qZWN0Um9vdDogcmVzdWx0LnByb2plY3RSb290LFxuXHRcdFx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiByZXN1bHQuY29uZmlnRmlsZVBhdGgsXG5cdFx0XHRcdFx0dmF1bHRMb2NhdGlvbjogcmVzdWx0LnZhdWx0TG9jYXRpb25cblx0XHRcdFx0fTtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAuZGlzcGxheTogc2V0IHByb2plY3REZXRlY3Rpb24gPScsIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbik7XG5cdFx0XHRcdHRoaXMuZGV0ZWN0ZWQgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTm8gZGV0ZWN0aW9uLCBzaG93IG1hbnVhbCBzZWxlY3Rpb25cblx0XHRcdFx0dGhpcy5kZXRlY3RlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVc2Ugc2F2ZWQgdmFsdWVzXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcC5kaXNwbGF5OiB1c2luZyBzYXZlZCBwcm9qZWN0RGV0ZWN0aW9uID0nLCB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0dGhpcy5kZXRlY3RlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiAmJiAodGhpcy5kZXRlY3RlZCB8fCBoYXNTYXZlZFZhbHVlcykpIHtcblxuXHRcdFx0Ly8gQWRkIHNsaWdodCBkZWxheSBiZWZvcmUgc2hvd2luZyBkZXRlY3RlZCBjb250ZW50IChsaWtlIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MpXG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cblx0XHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdQcm9qZWN0IGRldGVjdGVkJyB9KTtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0XHR0ZXh0OiAnUHJvamVjdCBzdHJ1Y3R1cmUgZGV0ZWN0ZWQgc3VjY2Vzc2Z1bGx5LiBZb3UgY2FuIG1vZGlmeSB0aGUgcGF0aHMgYmVsb3cgaWYgbmVlZGVkLCB0aGVuIGNsaWNrIFwiTmV4dFwiIHRvIGNvbnRpbnVlLidcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBQcm9qZWN0IFJvb3QgcGlja2VyICh3aXRoIGJyb3dzZSBidXR0b24gZXZlbiB3aGVuIGRldGVjdGVkKVxuXHRcdFx0Y29uc3QgcHJvamVjdFJvb3RTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdQcm9qZWN0IHJvb3QnKVxuXHRcdFx0XHQuc2V0RGVzYygnU2VsZWN0IHRoZSBmb2xkZXIgY29udGFpbmluZyB5b3VyIEFzdHJvIHByb2plY3Qgcm9vdCcpO1xuXG5cdFx0XHQvLyBEaXNwbGF5IGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHR0aGlzLnByb2plY3RSb290RGlzcGxheSA9IHByb2plY3RSb290U2V0dGluZy5kZXNjRWwuY3JlYXRlRGl2KHtcblx0XHRcdFx0dGV4dDogdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290ID8gdGhpcy50b1JlbGF0aXZlUGF0aCh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpIDogJ05vIGZvbGRlciBzZWxlY3RlZCcsXG5cdFx0XHRcdGNsczogJ3ZhdWx0LWNtcy1wYXRoLWRpc3BsYXknXG5cdFx0XHR9KTtcblx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblxuXHRcdFx0cHJvamVjdFJvb3RTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdCcm93c2UuLi4nKVxuXHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZFBhdGggPSB0aGlzLnNlbGVjdEZvbGRlcigpO1xuXHRcdFx0XHRcdFx0aWYgKHNlbGVjdGVkUGF0aCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24hLnByb2plY3RSb290ID0gc2VsZWN0ZWRQYXRoO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5wcm9qZWN0Um9vdERpc3BsYXkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnByb2plY3RSb290RGlzcGxheS50ZXh0Q29udGVudCA9IHRoaXMudG9SZWxhdGl2ZVBhdGgoc2VsZWN0ZWRQYXRoKTtcblx0XHRcdFx0XHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLnByb2plY3RSb290RGlzcGxheSwgeyBjb2xvcjogJ3ZhcigtLXRleHQtbm9ybWFsKScgfSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gVXBkYXRlIGRldGVjdGVkIGZsYWcgaWYgdXNlciBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRcdHRoaXMuZGV0ZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRcdC8vIENvbmZpZyBGaWxlIHBpY2tlciAod2l0aCBicm93c2UgYnV0dG9uIGV2ZW4gd2hlbiBkZXRlY3RlZClcblx0XHRcdGNvbnN0IGNvbmZpZ0ZpbGVTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdDb25maWcgZmlsZScpXG5cdFx0XHRcdC5zZXREZXNjKCdTZWxlY3QgeW91ciBBc3RybyBjb25maWcgZmlsZSAoYXN0cm8uY29uZmlnLm1qcywgYXN0cm8uY29uZmlnLmpzLCBzcmMvY29uZmlnLnRzLCBldGMuKScpO1xuXG5cdFx0XHQvLyBEaXNwbGF5IGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHR0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5ID0gY29uZmlnRmlsZVNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdih7XG5cdFx0XHRcdHRleHQ6IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aCA/IHRoaXMudG9SZWxhdGl2ZVBhdGgodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoKSA6ICdObyBmaWxlIHNlbGVjdGVkJyxcblx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLXBhdGgtZGlzcGxheSdcblx0XHRcdH0pO1xuXHRcdFx0c2V0Q3NzUHJvcHModGhpcy5jb25maWdGaWxlRGlzcGxheSwgeyBjb2xvcjogJ3ZhcigtLXRleHQtbm9ybWFsKScgfSk7XG5cblx0XHRcdGNvbmZpZ0ZpbGVTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdCcm93c2UuLi4nKVxuXHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWZhdWx0UGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3QgfHwgdGhpcy5nZXRWYXVsdFBhdGgoKTtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGVkUGF0aCA9IHRoaXMuc2VsZWN0Q29uZmlnRmlsZShkZWZhdWx0UGF0aCk7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0ZWRQYXRoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiEuY29uZmlnRmlsZVBhdGggPSBzZWxlY3RlZFBhdGg7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jb25maWdGaWxlRGlzcGxheS50ZXh0Q29udGVudCA9IHRoaXMudG9SZWxhdGl2ZVBhdGgoc2VsZWN0ZWRQYXRoKTtcblx0XHRcdFx0XHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgZGV0ZWN0ZWQgZmxhZyBpZiB1c2VyIGNoYW5nZXNcblx0XHRcdFx0XHRcdFx0dGhpcy5kZXRlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gTURYIFN1cHBvcnQgY2hlY2tib3hcblx0XHRcdC8vIEF1dG8tZGV0ZWN0IE1EWCBmaWxlcyBpZiBwcm9qZWN0IGlzIGRldGVjdGVkXG5cdFx0XHRsZXQgYXV0b0RldGVjdGVkTWR4ID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IFN0YXJ0aW5nIE1EWCBkZXRlY3Rpb24nKTtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogcHJvamVjdERldGVjdGlvbiA9JywgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogZXhpc3RpbmcgY29udGVudFR5cGVzID0nLCB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5sZW5ndGgpO1xuXG5cdFx0XHRcdFx0Ly8gR2V0IGNvbnRlbnQgdHlwZXMgLSB1c2UgZXhpc3Rpbmcgb25lcyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBkZXRlY3QgdGhlbVxuXHRcdFx0XHRcdGxldCBjb250ZW50VHlwZXNUb1VzZSA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzO1xuXHRcdFx0XHRcdGlmIChjb250ZW50VHlwZXNUb1VzZS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBObyBjb250ZW50IHR5cGVzIGluIHN0YXRlLCBkZXRlY3Rpbmcgbm93Li4uJyk7XG5cdFx0XHRcdFx0XHQvLyBDb250ZW50IHR5cGVzIG5vdCBkZXRlY3RlZCB5ZXQsIGRldGVjdCB0aGVtIG5vdyBmb3IgTURYIHNjYW5uaW5nXG5cdFx0XHRcdFx0XHRjb250ZW50VHlwZXNUb1VzZSA9IHRoaXMuY29udGVudFR5cGVEZXRlY3Rvci5kZXRlY3RDb250ZW50VHlwZXModGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBEZXRlY3RlZCBjb250ZW50IHR5cGVzID0nLCBjb250ZW50VHlwZXNUb1VzZS5sZW5ndGgsIGNvbnRlbnRUeXBlc1RvVXNlLm1hcChjdCA9PiBgJHtjdC5uYW1lfSAoJHtjdC5mb2xkZXJ9LCBlbmFibGVkOiAke2N0LmVuYWJsZWR9KWApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IFVzaW5nIGV4aXN0aW5nIGNvbnRlbnQgdHlwZXMgPScsIGNvbnRlbnRUeXBlc1RvVXNlLm1hcChjdCA9PiBgJHtjdC5uYW1lfSAoJHtjdC5mb2xkZXJ9LCBlbmFibGVkOiAke2N0LmVuYWJsZWR9KWApKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoY29udGVudFR5cGVzVG9Vc2UubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IENhbGxpbmcgbWR4RGV0ZWN0b3IuZGV0ZWN0TWR4VXNhZ2UuLi4nKTtcblx0XHRcdFx0XHRcdGF1dG9EZXRlY3RlZE1keCA9IHRoaXMubWR4RGV0ZWN0b3IuZGV0ZWN0TWR4VXNhZ2UoXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbixcblx0XHRcdFx0XHRcdFx0Y29udGVudFR5cGVzVG9Vc2Vcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogTURYIGRldGVjdGlvbiByZXN1bHQgPScsIGF1dG9EZXRlY3RlZE1keCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBObyBjb250ZW50IHR5cGVzIHRvIHNjYW4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gSWYgZGV0ZWN0aW9uIGZhaWxzLCBkZWZhdWx0IHRvIGZhbHNlXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignUHJvamVjdERldGVjdGlvblN0ZXA6IE1EWCBkZXRlY3Rpb24gZmFpbGVkOicsIGVycm9yKTtcblx0XHRcdFx0XHRhdXRvRGV0ZWN0ZWRNZHggPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IE5vIHByb2plY3REZXRlY3Rpb24sIHNraXBwaW5nIE1EWCBkZXRlY3Rpb24nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWx3YXlzIHVwZGF0ZSBlbmFibGVNZHhTdXBwb3J0IHdpdGggYXV0by1kZXRlY3Rpb24gcmVzdWx0IGlmIGl0IGhhc24ndCBiZWVuIHNldC9kZXRlY3RlZCB5ZXRcblx0XHRcdC8vIFRoaXMgZW5zdXJlcyBkZXRlY3Rpb24gcnVucyBvbiBmaXJzdCBydW4gYnV0IHJlbWVtYmVycyB1c2VyJ3MgbWFudWFsIGNob2ljZSB0aGVyZWFmdGVyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID0gYXV0b0RldGVjdGVkTWR4O1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogU2V0IGVuYWJsZU1keFN1cHBvcnQgdG8nLCBhdXRvRGV0ZWN0ZWRNZHgsICdiYXNlZCBvbiBhdXRvLWRldGVjdGlvbicpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IGVuYWJsZU1keFN1cHBvcnQgYWxyZWFkeSBzZXQgdG8nLCB0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQsICcsIHNraXBwaW5nIGF1dG8tZGV0ZWN0aW9uIG92ZXJ3cml0ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtZHhTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdNRFggZmlsZSBzdXBwb3J0Jylcblx0XHRcdFx0LnNldERlc2MoJ0VuYWJsZSBNRFggZmlsZSBzdXBwb3J0IGZvciBBc3RybyBDb21wb3NlciwgUHJvcGVydHkgT3ZlciBGaWxlIE5hbWUsIFNFTywgYW5kIFVJIFR3ZWFrZXIgcGx1Z2lucy4nKTtcblxuXHRcdFx0bWR4U2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHtcblx0XHRcdFx0dG9nZ2xlXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZSlcblx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID0gdmFsdWU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gU2hvdyBhdXRvLWRldGVjdGlvbiBtZXNzYWdlIGlmIE1EWCB3YXMgZGV0ZWN0ZWRcblx0XHRcdFx0aWYgKGF1dG9EZXRlY3RlZE1keCAmJiB0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQpIHtcblx0XHRcdFx0XHRjb25zdCBhdXRvRGV0ZWN0TXNnID0gbWR4U2V0dGluZy5kZXNjRWwuY3JlYXRlRGl2KHtcblx0XHRcdFx0XHRcdHRleHQ6ICdNRFggZmlsZXMgZGV0ZWN0ZWQgaW4gY29udGVudCBmb2xkZXJzJyxcblx0XHRcdFx0XHRcdGNsczogJ3ZhdWx0LWNtcy1hdXRvLWRldGVjdC1tc2cnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoYXV0b0RldGVjdE1zZywge1xuXHRcdFx0XHRcdFx0Y29sb3I6ICd2YXIoLS10ZXh0LW11dGVkKScsXG5cdFx0XHRcdFx0XHRmb250U2l6ZTogJzAuOWVtJyxcblx0XHRcdFx0XHRcdG1hcmdpblRvcDogJzRweCdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEV4dGVuZGVkIEZpbGUgVHlwZXMgc3VwcG9ydCAoSlNPTiwgQXN0cm8pXG5cdFx0XHRjb25zdCBleHRlbmRlZEZpbGVUeXBlc1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ0V4dGVuZGVkIGZpbGUgdHlwZXMnKVxuXHRcdFx0XHQuc2V0RGVzYygnRW5hYmxlIHN1cHBvcnQgdG8gdmlldywgZWRpdCwgYW5kIGNyZWF0ZSAuanNvbiBhbmQgLmFzdHJvIGZpbGVzIHZpYSB0aGUgRGF0YSBGaWxlcyBFZGl0b3IgcGx1Z2luLicpO1xuXG5cdFx0XHRleHRlbmRlZEZpbGVUeXBlc1NldHRpbmcuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB7XG5cdFx0XHRcdHRvZ2dsZVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnN0YXRlLmVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzID8/IGZhbHNlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZUV4dGVuZGVkRmlsZVR5cGVzID0gdmFsdWU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3QgZGV0ZWN0aW9uIGZhaWxlZCcgfSk7XG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcblx0XHRcdFx0dGV4dDogJ0NvdWxkIG5vdCBkZXRlY3QgQXN0cm8gcHJvamVjdCBzdHJ1Y3R1cmUuIFBsZWFzZSBzZWxlY3QgeW91ciBBc3RybyBwcm9qZWN0IHJvb3QgYW5kIGNvbmZpZyBmaWxlIG1hbnVhbGx5Lidcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHN0YXRlIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCF0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pIHtcblx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uID0ge1xuXHRcdFx0XHRcdHByb2plY3RSb290OiAnJyxcblx0XHRcdFx0XHRjb25maWdGaWxlUGF0aDogJycsXG5cdFx0XHRcdFx0dmF1bHRMb2NhdGlvbjogJ3Jvb3QnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByb2plY3QgUm9vdCBwaWNrZXJcblx0XHRcdGNvbnN0IHByb2plY3RSb290U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnUHJvamVjdCByb290Jylcblx0XHRcdFx0LnNldERlc2MoJ1NlbGVjdCB0aGUgZm9sZGVyIGNvbnRhaW5pbmcgeW91ciBBc3RybyBwcm9qZWN0IHJvb3QnKTtcblxuXHRcdFx0Ly8gRGlzcGxheSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0dGhpcy5wcm9qZWN0Um9vdERpc3BsYXkgPSBwcm9qZWN0Um9vdFNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdih7XG5cdFx0XHRcdHRleHQ6IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCA/IHRoaXMudG9SZWxhdGl2ZVBhdGgodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KSA6ICdObyBmb2xkZXIgc2VsZWN0ZWQnLFxuXHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtcGF0aC1kaXNwbGF5J1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KSB7XG5cdFx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1tdXRlZCknIH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwcm9qZWN0Um9vdFNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0Jyb3dzZS4uLicpXG5cdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0KCgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGVkUGF0aCA9IHRoaXMuc2VsZWN0Rm9sZGVyKCk7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0ZWRQYXRoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiEucHJvamVjdFJvb3QgPSBzZWxlY3RlZFBhdGg7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnByb2plY3RSb290RGlzcGxheSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvamVjdFJvb3REaXNwbGF5LnRleHRDb250ZW50ID0gdGhpcy50b1JlbGF0aXZlUGF0aChzZWxlY3RlZFBhdGgpO1xuXHRcdFx0XHRcdFx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gQ29uZmlnIEZpbGUgcGlja2VyXG5cdFx0XHRjb25zdCBjb25maWdGaWxlU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnQ29uZmlnIGZpbGUnKVxuXHRcdFx0XHQuc2V0RGVzYygnU2VsZWN0IHlvdXIgQXN0cm8gY29uZmlnIGZpbGUgKGFzdHJvLmNvbmZpZy5tanMsIGFzdHJvLmNvbmZpZy5qcywgc3JjL2NvbmZpZy50cywgZXRjLiknKTtcblxuXHRcdFx0Ly8gRGlzcGxheSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0dGhpcy5jb25maWdGaWxlRGlzcGxheSA9IGNvbmZpZ0ZpbGVTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoe1xuXHRcdFx0XHR0ZXh0OiB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGggPyB0aGlzLnRvUmVsYXRpdmVQYXRoKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aCkgOiAnTm8gZmlsZSBzZWxlY3RlZCcsXG5cdFx0XHRcdGNsczogJ3ZhdWx0LWNtcy1wYXRoLWRpc3BsYXknXG5cdFx0XHR9KTtcblx0XHRcdGlmICh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGgpIHtcblx0XHRcdFx0c2V0Q3NzUHJvcHModGhpcy5jb25maWdGaWxlRGlzcGxheSwgeyBjb2xvcjogJ3ZhcigtLXRleHQtbm9ybWFsKScgfSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1tdXRlZCknIH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25maWdGaWxlU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnQnJvd3NlLi4uJylcblx0XHRcdFx0LnNldEN0YSgpXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVmYXVsdFBhdGggPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290IHx8IHRoaXMuZ2V0VmF1bHRQYXRoKCk7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZFBhdGggPSB0aGlzLnNlbGVjdENvbmZpZ0ZpbGUoZGVmYXVsdFBhdGgpO1xuXHRcdFx0XHRcdFx0aWYgKHNlbGVjdGVkUGF0aCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24hLmNvbmZpZ0ZpbGVQYXRoID0gc2VsZWN0ZWRQYXRoO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5jb25maWdGaWxlRGlzcGxheSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY29uZmlnRmlsZURpc3BsYXkudGV4dENvbnRlbnQgPSB0aGlzLnRvUmVsYXRpdmVQYXRoKHNlbGVjdGVkUGF0aCk7XG5cdFx0XHRcdFx0XHRcdFx0c2V0Q3NzUHJvcHModGhpcy5jb25maWdGaWxlRGlzcGxheSwgeyBjb2xvcjogJ3ZhcigtLXRleHQtbm9ybWFsKScgfSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRcdC8vIE1EWCBTdXBwb3J0IGNoZWNrYm94IChmb3IgbWFudWFsIHByb2plY3Qgc2VsZWN0aW9uKVxuXHRcdFx0Ly8gVHJ5IHRvIGF1dG8tZGV0ZWN0IE1EWCBpZiB3ZSBoYXZlIHByb2plY3QgZGV0ZWN0aW9uXG5cdFx0XHRsZXQgYXV0b0RldGVjdGVkTWR4ID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uICYmIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCAmJiB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGgpIHtcblx0XHRcdFx0Ly8gVHJ5IHRvIGRldGVjdCBjb250ZW50IHR5cGVzIGZpcnN0XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWRDb250ZW50VHlwZXMgPSB0aGlzLmNvbnRlbnRUeXBlRGV0ZWN0b3IuZGV0ZWN0Q29udGVudFR5cGVzKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbik7XG5cdFx0XHRcdFx0aWYgKGRldGVjdGVkQ29udGVudFR5cGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdGF1dG9EZXRlY3RlZE1keCA9IHRoaXMubWR4RGV0ZWN0b3IuZGV0ZWN0TWR4VXNhZ2UoXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbixcblx0XHRcdFx0XHRcdFx0ZGV0ZWN0ZWRDb250ZW50VHlwZXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0XHQvLyBJZiBkZXRlY3Rpb24gZmFpbHMsIGRlZmF1bHQgdG8gZmFsc2Vcblx0XHRcdFx0XHRhdXRvRGV0ZWN0ZWRNZHggPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbHdheXMgdXBkYXRlIGVuYWJsZU1keFN1cHBvcnQgd2l0aCBhdXRvLWRldGVjdGlvbiByZXN1bHQgaWYgaXQgaGFzbid0IGJlZW4gc2V0L2RldGVjdGVkIHlldFxuXHRcdFx0Ly8gVGhpcyBlbnN1cmVzIGRldGVjdGlvbiBydW5zIG9uIGZpcnN0IHJ1biBidXQgcmVtZW1iZXJzIHVzZXIncyBtYW51YWwgY2hvaWNlIHRoZXJlYWZ0ZXJcblx0XHRcdGlmICh0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPSBhdXRvRGV0ZWN0ZWRNZHg7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwIChtYW51YWwpOiBTZXQgZW5hYmxlTWR4U3VwcG9ydCB0bycsIGF1dG9EZXRlY3RlZE1keCwgJ2Jhc2VkIG9uIGF1dG8tZGV0ZWN0aW9uJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcCAobWFudWFsKTogZW5hYmxlTWR4U3VwcG9ydCBhbHJlYWR5IHNldCB0bycsIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCwgJywgc2tpcHBpbmcgYXV0by1kZXRlY3Rpb24gb3ZlcndyaXRlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1keFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ01EWCBmaWxlIHN1cHBvcnQnKVxuXHRcdFx0XHQuc2V0RGVzYygnRW5hYmxlIE1EWCBmaWxlIHN1cHBvcnQgZm9yIEFzdHJvIENvbXBvc2VyLCBQcm9wZXJ0eSBPdmVyIEZpbGUgTmFtZSwgU0VPLCBhbmQgVUkgVHdlYWtlciBwbHVnaW5zLicpO1xuXG5cdFx0XHRtZHhTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xuXHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID8/IGZhbHNlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBTaG93IGF1dG8tZGV0ZWN0aW9uIG1lc3NhZ2UgaWYgTURYIHdhcyBkZXRlY3RlZFxuXHRcdFx0XHRpZiAoYXV0b0RldGVjdGVkTWR4ICYmIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCkge1xuXHRcdFx0XHRcdGNvbnN0IGF1dG9EZXRlY3RNc2cgPSBtZHhTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoe1xuXHRcdFx0XHRcdFx0dGV4dDogJ01EWCBmaWxlcyBkZXRlY3RlZCBpbiBjb250ZW50IGZvbGRlcnMnLFxuXHRcdFx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLWF1dG8tZGV0ZWN0LW1zZydcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRDc3NQcm9wcyhhdXRvRGV0ZWN0TXNnLCB7XG5cdFx0XHRcdFx0XHRjb2xvcjogJ3ZhcigtLXRleHQtbXV0ZWQpJyxcblx0XHRcdFx0XHRcdGZvbnRTaXplOiAnMC45ZW0nLFxuXHRcdFx0XHRcdFx0bWFyZ2luVG9wOiAnNHB4J1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRXh0ZW5kZWQgRmlsZSBUeXBlcyBzdXBwb3J0IChKU09OLCBBc3Rybylcblx0XHRcdGNvbnN0IGV4dGVuZGVkRmlsZVR5cGVzU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnRXh0ZW5kZWQgZmlsZSB0eXBlcycpXG5cdFx0XHRcdC5zZXREZXNjKCdFbmFibGUgc3VwcG9ydCB0byB2aWV3LCBlZGl0LCBhbmQgY3JlYXRlIC5qc29uIGFuZCAuYXN0cm8gZmlsZXMgdmlhIHRoZSBEYXRhIEZpbGVzIEVkaXRvciBwbHVnaW4uJyk7XG5cblx0XHRcdGV4dGVuZGVkRmlsZVR5cGVzU2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHtcblx0XHRcdFx0dG9nZ2xlXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMgPz8gZmFsc2UpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlRXh0ZW5kZWRGaWxlVHlwZXMgPSB2YWx1ZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBPcGVuIG5hdGl2ZSBmb2xkZXIgcGlja2VyIGRpYWxvZ1xuXHQgKi9cblx0cHJpdmF0ZSBzZWxlY3RGb2xkZXIoKTogc3RyaW5nIHwgbnVsbCB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSBtdWx0aXBsZSB3YXlzIHRvIGFjY2VzcyBFbGVjdHJvbiBkaWFsb2cgQVBJXG5cdFx0XHRsZXQgZGlhbG9nOiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfCBudWxsID0gbnVsbDtcblxuXHRcdFx0Ly8gTWV0aG9kIDE6IFRyeSBAZWxlY3Ryb24vcmVtb3RlIChuZXdlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZiAtLSBkeW5hbWljIHJlcXVpcmUgZm9yIEVsZWN0cm9uXG5cdFx0XHRcdGNvbnN0IGVsZWN0cm9uUmVtb3RlID0gcmVxdWlyZSgnQGVsZWN0cm9uL3JlbW90ZScpIGFzIHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH07XG5cdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uUmVtb3RlPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlLCB0cnkgbmV4dCBtZXRob2Rcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0aG9kIDI6IFRyeSBlbGVjdHJvbi5yZW1vdGUuZGlhbG9nIChvbGRlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9ICgod2luZG93IGFzIHsgcmVxdWlyZT86IChtb2R1bGU6IHN0cmluZykgPT4gdW5rbm93biB9KS5yZXF1aXJlPy4oJ2VsZWN0cm9uJykgfHwgcmVxdWlyZSgnZWxlY3Ryb24nKSkgYXMgeyByZW1vdGU/OiB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9IH07XG5cdFx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb24/LnJlbW90ZT8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ldGhvZCAzOiBUcnkgZWxlY3Ryb24uZGlhbG9nIGRpcmVjdGx5IChtYWluIHByb2Nlc3MsIG1heSBub3Qgd29yaylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJykgYXMgeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfTtcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRpYWxvZyB8fCB0eXBlb2YgZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIGRpYWxvZyBBUEkgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSB0aGlzLmdldFZhdWx0UGF0aCgpO1xuXHRcdFx0bGV0IGRlZmF1bHRQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdCB8fCB2YXVsdFBhdGg7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVsYXRpdmUgcGF0aCB0byBhYnNvbHV0ZSBpZiBuZWVkZWRcblx0XHRcdGlmIChkZWZhdWx0UGF0aCAmJiAhcGF0aC5pc0Fic29sdXRlKGRlZmF1bHRQYXRoKSkge1xuXHRcdFx0XHRkZWZhdWx0UGF0aCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIGRlZmF1bHRQYXRoKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyh7XG5cdFx0XHRcdHRpdGxlOiAnU2VsZWN0IEFzdHJvIFByb2plY3QgUm9vdCBGb2xkZXInLFxuXHRcdFx0XHRkZWZhdWx0UGF0aDogZGVmYXVsdFBhdGgsXG5cdFx0XHRcdHByb3BlcnRpZXM6IFsnb3BlbkRpcmVjdG9yeSddXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRyZXR1cm4gcGF0aC5ub3JtYWxpemUocmVzdWx0WzBdKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3Igb3BlbmluZyBmb2xkZXIgcGlja2VyOicsIGVycm9yKTtcblx0XHRcdC8vIFNob3cgdXNlci1mcmllbmRseSBlcnJvclxuXHRcdFx0bmV3IE5vdGljZSgnVW5hYmxlIHRvIG9wZW4gZm9sZGVyIHBpY2tlci4gUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIE9ic2lkaWFuIG9uIGRlc2t0b3AuJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogT3BlbiBuYXRpdmUgZmlsZSBwaWNrZXIgZGlhbG9nIGZvciBjb25maWcgZmlsZVxuXHQgKi9cblx0cHJpdmF0ZSBzZWxlY3RDb25maWdGaWxlKGRlZmF1bHRQYXRoPzogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSBtdWx0aXBsZSB3YXlzIHRvIGFjY2VzcyBFbGVjdHJvbiBkaWFsb2cgQVBJXG5cdFx0XHRsZXQgZGlhbG9nOiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IGZpbHRlcnM/OiBBcnJheTx7IG5hbWU6IHN0cmluZzsgZXh0ZW5zaW9uczogc3RyaW5nW10gfT47IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfCBudWxsID0gbnVsbDtcblxuXHRcdFx0Ly8gTWV0aG9kIDE6IFRyeSBAZWxlY3Ryb24vcmVtb3RlIChuZXdlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZiAtLSBkeW5hbWljIHJlcXVpcmUgZm9yIEVsZWN0cm9uXG5cdFx0XHRcdGNvbnN0IGVsZWN0cm9uUmVtb3RlID0gcmVxdWlyZSgnQGVsZWN0cm9uL3JlbW90ZScpIGFzIHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBmaWx0ZXJzPzogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IGV4dGVuc2lvbnM6IHN0cmluZ1tdIH0+OyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH07XG5cdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uUmVtb3RlPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlLCB0cnkgbmV4dCBtZXRob2Rcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0aG9kIDI6IFRyeSBlbGVjdHJvbi5yZW1vdGUuZGlhbG9nIChvbGRlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9ICgod2luZG93IGFzIHsgcmVxdWlyZT86IChtb2R1bGU6IHN0cmluZykgPT4gdW5rbm93biB9KS5yZXF1aXJlPy4oJ2VsZWN0cm9uJykgfHwgcmVxdWlyZSgnZWxlY3Ryb24nKSkgYXMgeyByZW1vdGU/OiB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgZmlsdGVycz86IEFycmF5PHsgbmFtZTogc3RyaW5nOyBleHRlbnNpb25zOiBzdHJpbmdbXSB9PjsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9IH07XG5cdFx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb24/LnJlbW90ZT8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ldGhvZCAzOiBUcnkgZWxlY3Ryb24uZGlhbG9nIGRpcmVjdGx5IChtYWluIHByb2Nlc3MsIG1heSBub3Qgd29yaylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJykgYXMgeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IGZpbHRlcnM/OiBBcnJheTx7IG5hbWU6IHN0cmluZzsgZXh0ZW5zaW9uczogc3RyaW5nW10gfT47IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfTtcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRpYWxvZyB8fCB0eXBlb2YgZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIGRpYWxvZyBBUEkgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSB0aGlzLmdldFZhdWx0UGF0aCgpO1xuXHRcdFx0bGV0IHN0YXJ0UGF0aCA9IGRlZmF1bHRQYXRoIHx8IHZhdWx0UGF0aDtcblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIGRldGVjdGVkIGNvbmZpZyBmaWxlIHBhdGgsIHVzZSBpdHMgZGlyZWN0b3J5XG5cdFx0XHRpZiAoIWRlZmF1bHRQYXRoICYmIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8uY29uZmlnRmlsZVBhdGgpIHtcblx0XHRcdFx0Y29uc3QgY29uZmlnUGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aDtcblx0XHRcdFx0aWYgKHBhdGguaXNBYnNvbHV0ZShjb25maWdQYXRoKSkge1xuXHRcdFx0XHRcdHN0YXJ0UGF0aCA9IHBhdGguZGlybmFtZShjb25maWdQYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGFydFBhdGggPSBwYXRoLmRpcm5hbWUocGF0aC5yZXNvbHZlKHZhdWx0UGF0aCwgY29uZmlnUGF0aCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGRlZmF1bHRQYXRoICYmICFwYXRoLmlzQWJzb2x1dGUoZGVmYXVsdFBhdGgpKSB7XG5cdFx0XHRcdC8vIENvbnZlcnQgcmVsYXRpdmUgcGF0aCB0byBhYnNvbHV0ZSBpZiBuZWVkZWRcblx0XHRcdFx0c3RhcnRQYXRoID0gcGF0aC5yZXNvbHZlKHZhdWx0UGF0aCwgZGVmYXVsdFBhdGgpO1xuXHRcdFx0XHQvLyBJZiBpdCdzIGEgZmlsZSBwYXRoLCB1c2UgaXRzIGRpcmVjdG9yeVxuXHRcdFx0XHRpZiAocGF0aC5leHRuYW1lKHN0YXJ0UGF0aCkpIHtcblx0XHRcdFx0XHRzdGFydFBhdGggPSBwYXRoLmRpcm5hbWUoc3RhcnRQYXRoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChkZWZhdWx0UGF0aCAmJiBwYXRoLmlzQWJzb2x1dGUoZGVmYXVsdFBhdGgpKSB7XG5cdFx0XHRcdC8vIElmIGl0J3MgYSBmaWxlIHBhdGgsIHVzZSBpdHMgZGlyZWN0b3J5XG5cdFx0XHRcdGlmIChwYXRoLmV4dG5hbWUoZGVmYXVsdFBhdGgpKSB7XG5cdFx0XHRcdFx0c3RhcnRQYXRoID0gcGF0aC5kaXJuYW1lKGRlZmF1bHRQYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGFydFBhdGggPSBkZWZhdWx0UGF0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBkaWFsb2cuc2hvd09wZW5EaWFsb2dTeW5jKHtcblx0XHRcdFx0dGl0bGU6ICdTZWxlY3QgQXN0cm8gQ29uZmlnIEZpbGUnLFxuXHRcdFx0XHRkZWZhdWx0UGF0aDogc3RhcnRQYXRoLFxuXHRcdFx0XHRmaWx0ZXJzOiBbXG5cdFx0XHRcdFx0eyBuYW1lOiAnQXN0cm8gQ29uZmlnIEZpbGVzJywgZXh0ZW5zaW9uczogWyd0cycsICdtanMnLCAnanMnLCAnbXRzJywgJ2NqcycsICd5bWwnLCAneWFtbCddIH0sXG5cdFx0XHRcdFx0eyBuYW1lOiAnQWxsIEZpbGVzJywgZXh0ZW5zaW9uczogWycqJ10gfVxuXHRcdFx0XHRdLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBbJ29wZW5GaWxlJ11cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldHVybiBwYXRoLm5vcm1hbGl6ZShyZXN1bHRbMF0pO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBvcGVuaW5nIGZpbGUgcGlja2VyOicsIGVycm9yKTtcblx0XHRcdC8vIFNob3cgdXNlci1mcmllbmRseSBlcnJvclxuXHRcdFx0bmV3IE5vdGljZSgnVW5hYmxlIHRvIG9wZW4gZmlsZSBwaWNrZXIuIFBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyBPYnNpZGlhbiBvbiBkZXNrdG9wLicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdmF1bHQgcGF0aFxuXHQgKi9cblx0cHJpdmF0ZSBnZXRWYXVsdFBhdGgoKTogc3RyaW5nIHtcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XG5cdFx0Y29uc3QgdmF1bHRQYXRoID0gYWRhcHRlci5iYXNlUGF0aCB8fCBhZGFwdGVyLnBhdGg7XG5cdFx0Ly8gUmVzb2x2ZSBwYXRoIChjb252ZXJ0IHJlbGF0aXZlIHRvIGFic29sdXRlLCBub3JtYWxpemUgc2VwYXJhdG9ycylcblx0XHRpZiAodmF1bHRQYXRoKSB7XG5cdFx0XHQvLyBJZiBhbHJlYWR5IGFic29sdXRlLCByZXR1cm4gYXMtaXMgKG5vcm1hbGl6ZWQpXG5cdFx0XHRpZiAodmF1bHRQYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCAvXltBLVpdOi8udGVzdCh2YXVsdFBhdGgpKSB7XG5cdFx0XHRcdHJldHVybiB2YXVsdFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRm9yIHJlbGF0aXZlIHBhdGhzLCB3ZSdkIG5lZWQgdG8gcmVzb2x2ZSwgYnV0IGluIE9ic2lkaWFuIGNvbnRleHQsIGJhc2VQYXRoIHNob3VsZCBiZSBhYnNvbHV0ZVxuXHRcdFx0cmV0dXJuIHZhdWx0UGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cdFx0fVxuXHRcdC8vIEZhbGxiYWNrIC0gaW4gT2JzaWRpYW4gY29udGV4dCB0aGlzIHNob3VsZG4ndCBoYXBwZW5cblx0XHRyZXR1cm4gJy8nO1xuXHR9XG5cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRpZiAodGhpcy5kZXRlY3RlZCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVmFsaWRhdGUgdGhhdCBib3RoIHBhdGhzIGFyZSBzZXQgYW5kIGV4aXN0XG5cdFx0Y29uc3QgcHJvamVjdFJvb3QgPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290O1xuXHRcdGNvbnN0IGNvbmZpZ0ZpbGVQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aDtcblxuXHRcdGlmICghcHJvamVjdFJvb3QgfHwgIWNvbmZpZ0ZpbGVQYXRoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgcGF0aHMgZXhpc3QgKHJlc29sdmUgcmVsYXRpdmUgcGF0aHMgdG8gYWJzb2x1dGUpXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuZ2V0VmF1bHRQYXRoKCk7XG5cdFx0XHRjb25zdCByZXNvbHZlZFByb2plY3RSb290ID0gcGF0aC5pc0Fic29sdXRlKHByb2plY3RSb290KSA/IHByb2plY3RSb290IDogcGF0aC5qb2luKHZhdWx0UGF0aCwgcHJvamVjdFJvb3QpO1xuXHRcdFx0Y29uc3QgcmVzb2x2ZWRDb25maWdGaWxlUGF0aCA9IHBhdGguaXNBYnNvbHV0ZShjb25maWdGaWxlUGF0aCkgPyBjb25maWdGaWxlUGF0aCA6IHBhdGguam9pbih2YXVsdFBhdGgsIGNvbmZpZ0ZpbGVQYXRoKTtcblxuXHRcdFx0aWYgKCFmcy5leGlzdHNTeW5jKHJlc29sdmVkUHJvamVjdFJvb3QpIHx8ICFmcy5zdGF0U3luYyhyZXNvbHZlZFByb2plY3RSb290KS5pc0RpcmVjdG9yeSgpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICghZnMuZXhpc3RzU3luYyhyZXNvbHZlZENvbmZpZ0ZpbGVQYXRoKSB8fCAhZnMuc3RhdFN5bmMocmVzb2x2ZWRDb25maWdGaWxlUGF0aCkuaXNGaWxlKCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ1Byb2plY3QgZGV0ZWN0aW9uJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdEZXRlY3QgQXN0cm8gcHJvamVjdCBzdHJ1Y3R1cmUnO1xuXHR9XG59XG5cbiIsICJpbXBvcnQgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBwYXRoIG9wZXJhdGlvbnNcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlcyAtLSBOb2RlLmpzIG1vZHVsZSBuZWVkZWQgZm9yIGZpbGUgb3BlcmF0aW9uc1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCB7IFByb2plY3REZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvamVjdERldGVjdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRkZXRlY3RQcm9qZWN0KCk6IFByb2plY3REZXRlY3Rpb25SZXN1bHQgfCBudWxsIHtcclxuXHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XHJcblx0XHRjb25zdCBhZGFwdGVyID0gdmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XHJcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHJcblx0XHRpZiAoIXZhdWx0UGF0aCkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZWFyY2ggdXB3YXJkIGZyb20gdmF1bHQgcGF0aCBmb3IgYXN0cm8uY29uZmlnIGZpbGVzXHJcblx0XHRjb25zdCBjb25maWdSZXN1bHQgPSB0aGlzLnNlYXJjaFVwd2FyZEZvckNvbmZpZyh2YXVsdFBhdGgpO1xyXG5cclxuXHRcdGlmICghY29uZmlnUmVzdWx0KSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERldGVybWluZSB2YXVsdCBsb2NhdGlvbiByZWxhdGl2ZSB0byBwcm9qZWN0XHJcblx0XHRjb25zdCB2YXVsdExvY2F0aW9uID0gdGhpcy5kZXRlY3RWYXVsdExvY2F0aW9uKHZhdWx0UGF0aCwgY29uZmlnUmVzdWx0LnByb2plY3RSb290KTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRwcm9qZWN0Um9vdDogY29uZmlnUmVzdWx0LnByb2plY3RSb290LFxyXG5cdFx0XHRjb25maWdGaWxlUGF0aDogY29uZmlnUmVzdWx0LmNvbmZpZ0ZpbGVQYXRoLFxyXG5cdFx0XHR2YXVsdExvY2F0aW9uXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2VhcmNoIHVwd2FyZCBmcm9tIHRoZSB2YXVsdCBwYXRoIHRvIGZpbmQgYW4gQXN0cm8gY29uZmlnIGZpbGUuXHJcblx0ICogVGhpcyBhbGxvd3MgdGhlIHZhdWx0IHRvIGJlIGFueXdoZXJlIHdpdGhpbiB0aGUgQXN0cm8gcHJvamVjdCBzdHJ1Y3R1cmUuXHJcblx0ICogQmlhcyB0b3dhcmRzIHNyYy9jb25maWcudHMgaWYgaXQgZXhpc3RzIGFsb25nc2lkZSBhIHJvb3QgY29uZmlnIGZpbGUuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzZWFyY2hVcHdhcmRGb3JDb25maWcoc3RhcnRQYXRoOiBzdHJpbmcpOiB7IHByb2plY3RSb290OiBzdHJpbmc7IGNvbmZpZ0ZpbGVQYXRoOiBzdHJpbmcgfSB8IG51bGwge1xyXG5cdFx0Y29uc3Qgcm9vdENvbmZpZ0ZpbGVOYW1lcyA9IFtcclxuXHRcdFx0J2FzdHJvLmNvbmZpZy5tanMnLFxyXG5cdFx0XHQnYXN0cm8uY29uZmlnLnRzJyxcclxuXHRcdFx0J2FzdHJvLmNvbmZpZy5qcycsXHJcblx0XHRcdCdhc3Ryby5jb25maWcubXRzJyxcclxuXHRcdFx0J2FzdHJvLmNvbmZpZy5janMnLFxyXG5cdFx0XHQnYXN0cm8uY29uZmlnLnltbCcsXHJcblx0XHRcdCdhc3Ryby5jb25maWcueWFtbCdcclxuXHRcdF07XHJcblx0XHRjb25zdCBzcmNDb25maWdGaWxlTmFtZSA9ICdzcmMvY29uZmlnLnRzJztcclxuXHJcblx0XHRsZXQgY3VycmVudERpciA9IHBhdGgucmVzb2x2ZShzdGFydFBhdGgpO1xyXG5cdFx0Y29uc3Qgcm9vdCA9IHBhdGgucGFyc2UoY3VycmVudERpcikucm9vdDtcclxuXHJcblx0XHQvLyBXYWxrIHVwIHRoZSBkaXJlY3RvcnkgdHJlZVxyXG5cdFx0d2hpbGUgKGN1cnJlbnREaXIgIT09IHJvb3QpIHtcclxuXHRcdFx0Ly8gMS4gQ2hlY2sgZm9yIHNyYy9jb25maWcudHMgZmlyc3QgKHRoZSBwcmlvcml0aXplZCBjaG9pY2UpXHJcblx0XHRcdGNvbnN0IHNyY0NvbmZpZ1BhdGggPSBwYXRoLmpvaW4oY3VycmVudERpciwgc3JjQ29uZmlnRmlsZU5hbWUpO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGlmIChmcy5leGlzdHNTeW5jKHNyY0NvbmZpZ1BhdGgpICYmIGZzLnN0YXRTeW5jKHNyY0NvbmZpZ1BhdGgpLmlzRmlsZSgpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRwcm9qZWN0Um9vdDogY3VycmVudERpcixcclxuXHRcdFx0XHRcdFx0Y29uZmlnRmlsZVBhdGg6IHNyY0NvbmZpZ1BhdGhcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoIHtcclxuXHRcdFx0XHQvLyBDb250aW51ZSB0byBjaGVjayByb290IGNvbmZpZ3MgaWYgc3JjIGNoZWNrIGZhaWxzXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDIuIENoZWNrIGZvciByb290LWxldmVsIGNvbmZpZyBmaWxlcyAocHJpb3JpdGl6aW5nIC5tanMpXHJcblx0XHRcdGZvciAoY29uc3QgZmlsZU5hbWUgb2Ygcm9vdENvbmZpZ0ZpbGVOYW1lcykge1xyXG5cdFx0XHRcdGNvbnN0IGNvbmZpZ1BhdGggPSBwYXRoLmpvaW4oY3VycmVudERpciwgZmlsZU5hbWUpO1xyXG5cclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0aWYgKGZzLmV4aXN0c1N5bmMoY29uZmlnUGF0aCkgJiYgZnMuc3RhdFN5bmMoY29uZmlnUGF0aCkuaXNGaWxlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHRwcm9qZWN0Um9vdDogY3VycmVudERpcixcclxuXHRcdFx0XHRcdFx0XHRjb25maWdGaWxlUGF0aDogY29uZmlnUGF0aFxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gY2F0Y2gge1xyXG5cdFx0XHRcdFx0Ly8gQ29udGludWUgc2VhcmNoaW5nXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNb3ZlIHVwIG9uZSBkaXJlY3RvcnlcclxuXHRcdFx0Y29uc3QgcGFyZW50RGlyID0gcGF0aC5kaXJuYW1lKGN1cnJlbnREaXIpO1xyXG5cdFx0XHRpZiAocGFyZW50RGlyID09PSBjdXJyZW50RGlyKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0Y3VycmVudERpciA9IHBhcmVudERpcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZSB2YXVsdCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgZGV0ZWN0ZWQgcHJvamVjdCByb290LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgZGV0ZWN0VmF1bHRMb2NhdGlvbih2YXVsdFBhdGg6IHN0cmluZywgcHJvamVjdFJvb3Q6IHN0cmluZyk6ICdjb250ZW50JyB8ICduZXN0ZWQtY29udGVudCcgfCAncm9vdCcge1xyXG5cdFx0Y29uc3Qgbm9ybWFsaXplZFZhdWx0UGF0aCA9IHBhdGgubm9ybWFsaXplKHZhdWx0UGF0aCk7XHJcblx0XHRjb25zdCBub3JtYWxpemVkUHJvamVjdFJvb3QgPSBwYXRoLm5vcm1hbGl6ZShwcm9qZWN0Um9vdCk7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgdmF1bHQgaXMgd2l0aGluIHByb2plY3Qgcm9vdFxyXG5cdFx0aWYgKCFub3JtYWxpemVkVmF1bHRQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZFByb2plY3RSb290KSkge1xyXG5cdFx0XHRyZXR1cm4gJ3Jvb3QnO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEdldCByZWxhdGl2ZSBwYXRoIGZyb20gcHJvamVjdCByb290IHRvIHZhdWx0XHJcblx0XHRjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKG5vcm1hbGl6ZWRQcm9qZWN0Um9vdCwgbm9ybWFsaXplZFZhdWx0UGF0aCk7XHJcblx0XHRjb25zdCBwYXRoUGFydHMgPSByZWxhdGl2ZVBhdGguc3BsaXQocGF0aC5zZXApLmZpbHRlcihwYXJ0ID0+IHBhcnQubGVuZ3RoID4gMCk7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgdmF1bHQgaXMgaW4gYSBmb2xkZXIgbmFtZWQgXCJjb250ZW50XCIgd2l0aCBwYXJlbnQgXCJzcmNcIlxyXG5cdFx0Y29uc3QgY29udGVudEluZGV4ID0gcGF0aFBhcnRzLmZpbmRJbmRleChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQnKTtcclxuXHRcdGlmIChjb250ZW50SW5kZXggPiAwKSB7XHJcblx0XHRcdGNvbnN0IHBhcmVudEluZGV4ID0gY29udGVudEluZGV4IC0gMTtcclxuXHRcdFx0aWYgKHBhcmVudEluZGV4ID49IDAgJiYgcGF0aFBhcnRzW3BhcmVudEluZGV4XS50b0xvd2VyQ2FzZSgpID09PSAnc3JjJykge1xyXG5cdFx0XHRcdHJldHVybiAnY29udGVudCc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGVjayBmb3IgbmVzdGVkIGNvbnRlbnQgZm9sZGVycyAoc3JjL2NvbnRlbnQvcG9zdHMsIGV0Yy4pXHJcblx0XHRjb25zdCBzcmNJbmRleCA9IHBhdGhQYXJ0cy5maW5kSW5kZXgocGFydCA9PiBwYXJ0LnRvTG93ZXJDYXNlKCkgPT09ICdzcmMnKTtcclxuXHRcdGlmIChzcmNJbmRleCA+PSAwICYmIHNyY0luZGV4IDwgcGF0aFBhcnRzLmxlbmd0aCAtIDEpIHtcclxuXHRcdFx0Y29uc3QgbmV4dFBhcnQgPSBwYXRoUGFydHNbc3JjSW5kZXggKyAxXTtcclxuXHRcdFx0aWYgKG5leHRQYXJ0LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50Jykge1xyXG5cdFx0XHRcdHJldHVybiAnbmVzdGVkLWNvbnRlbnQnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICdyb290JztcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBwYXRoIG9wZXJhdGlvbnNcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlcyAtLSBOb2RlLmpzIG1vZHVsZSBuZWVkZWQgZm9yIGZpbGUgb3BlcmF0aW9uc1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCB7IFByb2plY3REZXRlY3Rpb25SZXN1bHQsIENvbnRlbnRUeXBlQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1keERldGVjdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlY3QgaWYgTURYIGZpbGVzIGFyZSBwcmVzZW50IGluIHRoZSBjb250ZW50IGZvbGRlcnNcclxuXHQgKiBTY2FucyBhbGwgY29udGVudCB0eXBlIGZvbGRlcnMgKHBvc3RzLCBwYWdlcywgZXRjLikgZm9yIC5tZHggZmlsZXNcclxuXHQgKi9cclxuXHRkZXRlY3RNZHhVc2FnZShcclxuXHRcdHByb2plY3REZXRlY3Rpb246IFByb2plY3REZXRlY3Rpb25SZXN1bHQsXHJcblx0XHRjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW11cclxuXHQpOiBib29sZWFuIHtcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yLmRldGVjdE1keFVzYWdlOiBjYWxsZWQgd2l0aCcsIHtcclxuXHRcdFx0cHJvamVjdFJvb3Q6IHByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290LFxyXG5cdFx0XHR2YXVsdExvY2F0aW9uOiBwcm9qZWN0RGV0ZWN0aW9uPy52YXVsdExvY2F0aW9uLFxyXG5cdFx0XHRjb250ZW50VHlwZXNDb3VudDogY29udGVudFR5cGVzPy5sZW5ndGhcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICghcHJvamVjdERldGVjdGlvbikge1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogTm8gcHJvamVjdERldGVjdGlvbiwgcmV0dXJuaW5nIGZhbHNlJyk7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB2YXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xyXG5cdFx0Y29uc3QgYWRhcHRlciA9IHZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xyXG5cdFx0Y29uc3QgdmF1bHRQYXRoID0gYWRhcHRlci5iYXNlUGF0aCB8fCBhZGFwdGVyLnBhdGg7XHJcblx0XHRcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiB2YXVsdFBhdGggPScsIHZhdWx0UGF0aCk7XHJcblx0XHRcclxuXHRcdGlmICghdmF1bHRQYXRoKSB7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBObyB2YXVsdFBhdGgsIHJldHVybmluZyBmYWxzZScpO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gR2V0IHByb2plY3Qgcm9vdCBwYXRoXHJcblx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3Q7XHJcblx0XHRsZXQgcHJvamVjdFJvb3RQYXRoOiBzdHJpbmc7XHJcblx0XHRcclxuXHRcdGlmIChwYXRoLmlzQWJzb2x1dGUocHJvamVjdFJvb3QpKSB7XHJcblx0XHRcdHByb2plY3RSb290UGF0aCA9IHByb2plY3RSb290O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gUmVzb2x2ZSByZWxhdGl2ZSBwYXRoIGZyb20gdmF1bHQgcm9vdFxyXG5cdFx0XHRwcm9qZWN0Um9vdFBhdGggPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCBwcm9qZWN0Um9vdCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBwcm9qZWN0Um9vdFBhdGggPScsIHByb2plY3RSb290UGF0aCk7XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIGNvbnRlbnQgZGlyZWN0b3J5IGJhc2VkIG9uIHZhdWx0IGxvY2F0aW9uXHJcblx0XHRsZXQgY29udGVudEJhc2VQYXRoOiBzdHJpbmc7XHJcblx0XHRpZiAocHJvamVjdERldGVjdGlvbi52YXVsdExvY2F0aW9uID09PSAnY29udGVudCcpIHtcclxuXHRcdFx0Ly8gVmF1bHQgaXMgYXQgc3JjL2NvbnRlbnQsIHNvIGNvbnRlbnQgaXMgYXQgdmF1bHQgcm9vdFxyXG5cdFx0XHRjb250ZW50QmFzZVBhdGggPSB2YXVsdFBhdGg7XHJcblx0XHR9IGVsc2UgaWYgKHByb2plY3REZXRlY3Rpb24udmF1bHRMb2NhdGlvbiA9PT0gJ25lc3RlZC1jb250ZW50Jykge1xyXG5cdFx0XHQvLyBWYXVsdCBpcyBuZXN0ZWQgaW4gc3JjL2NvbnRlbnQvc29tZXRoaW5nLCBnbyB1cCB0byBzcmMvY29udGVudFxyXG5cdFx0XHRjb250ZW50QmFzZVBhdGggPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCAnLi4nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFZhdWx0IGlzIGF0IHJvb3QsIGNvbnRlbnQgc2hvdWxkIGJlIGF0IHByb2plY3RSb290L3NyYy9jb250ZW50XHJcblx0XHRcdGNvbnRlbnRCYXNlUGF0aCA9IHBhdGguam9pbihwcm9qZWN0Um9vdFBhdGgsICdzcmMnLCAnY29udGVudCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBjb250ZW50QmFzZVBhdGggPScsIGNvbnRlbnRCYXNlUGF0aCk7XHJcblx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogdmF1bHRMb2NhdGlvbiA9JywgcHJvamVjdERldGVjdGlvbi52YXVsdExvY2F0aW9uKTtcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBjb250ZW50VHlwZXMgdG8gc2NhbiA9JywgY29udGVudFR5cGVzLm1hcChjdCA9PiBgJHtjdC5uYW1lfSAoJHtjdC5mb2xkZXJ9KWApKTtcclxuXHJcblx0XHQvLyBTY2FuIGVhY2ggY29udGVudCB0eXBlIGZvbGRlciBmb3IgLm1keCBmaWxlcyAoY2hlY2sgYm90aCBlbmFibGVkIGFuZCBkaXNhYmxlZClcclxuXHRcdC8vIFdlIHNjYW4gYWxsIGNvbnRlbnQgdHlwZXMgYmVjYXVzZSBNRFggZmlsZXMgbWlnaHQgZXhpc3QgZXZlbiBpZiB0aGUgdHlwZSBpcyBkaXNhYmxlZFxyXG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBjb250ZW50VHlwZXMpIHtcclxuXHRcdFx0bGV0IGNvbnRlbnRUeXBlUGF0aDogc3RyaW5nO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSWYgY29udGVudFR5cGUuZm9sZGVyIGFscmVhZHkgY29udGFpbnMgc3JjL2NvbnRlbnQgKHZhdWx0IGF0IHByb2plY3Qgcm9vdCksXHJcblx0XHRcdC8vIHVzZSBpdCByZWxhdGl2ZSB0byBwcm9qZWN0IHJvb3QuIE90aGVyd2lzZSwgdXNlIGl0IHJlbGF0aXZlIHRvIGNvbnRlbnRCYXNlUGF0aC5cclxuXHRcdFx0aWYgKGNvbnRlbnRUeXBlLmZvbGRlci5zdGFydHNXaXRoKCdzcmMvY29udGVudC8nKSkge1xyXG5cdFx0XHRcdGNvbnRlbnRUeXBlUGF0aCA9IHBhdGguam9pbihwcm9qZWN0Um9vdFBhdGgsIGNvbnRlbnRUeXBlLmZvbGRlcik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29udGVudFR5cGVQYXRoID0gcGF0aC5qb2luKGNvbnRlbnRCYXNlUGF0aCwgY29udGVudFR5cGUuZm9sZGVyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IHNjYW5uaW5nJywgY29udGVudFR5cGVQYXRoLCAnKGVuYWJsZWQ6JywgY29udGVudFR5cGUuZW5hYmxlZCwgJyknKTtcclxuXHRcdFx0XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0aWYgKGZzLmV4aXN0c1N5bmMoY29udGVudFR5cGVQYXRoKSAmJiBmcy5zdGF0U3luYyhjb250ZW50VHlwZVBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGZvdW5kTWR4ID0gdGhpcy5zY2FuRGlyZWN0b3J5Rm9yTWR4KGNvbnRlbnRUeXBlUGF0aCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogZm91bmQgTURYIGluJywgY29udGVudFR5cGVQYXRoLCAnPScsIGZvdW5kTWR4KTtcclxuXHRcdFx0XHRcdGlmIChmb3VuZE1keCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gRm91bmQgYXQgbGVhc3Qgb25lIC5tZHggZmlsZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogcGF0aCBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYSBkaXJlY3Rvcnk6JywgY29udGVudFR5cGVQYXRoLCAnZXhpc3RzOicsIGZzLmV4aXN0c1N5bmMoY29udGVudFR5cGVQYXRoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRcdC8vIENvbnRpbnVlIHRvIG5leHQgZm9sZGVyIGlmIHRoaXMgb25lIGZhaWxzXHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IGVycm9yIHNjYW5uaW5nJywgY29udGVudFR5cGVQYXRoLCBlcnJvcik7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3Rvcjogbm8gTURYIGZpbGVzIGZvdW5kJyk7XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVjdXJzaXZlbHkgc2NhbiBhIGRpcmVjdG9yeSBmb3IgLm1keCBmaWxlc1xyXG5cdCAqL1xyXG5cdHByaXZhdGUgc2NhbkRpcmVjdG9yeUZvck1keChkaXJQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IGVudHJpZXMgPSBmcy5yZWFkZGlyU3luYyhkaXJQYXRoLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuXHRcdFx0XHRjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJQYXRoLCBlbnRyeS5uYW1lKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoZW50cnkuaXNGaWxlKCkgJiYgZW50cnkubmFtZS5lbmRzV2l0aCgnLm1keCcpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gRm91bmQgYW4gLm1keCBmaWxlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0XHQvLyBSZWN1cnNpdmVseSBzY2FuIHN1YmRpcmVjdG9yaWVzXHJcblx0XHRcdFx0XHRpZiAodGhpcy5zY2FuRGlyZWN0b3J5Rm9yTWR4KGZ1bGxQYXRoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2gge1xyXG5cdFx0XHQvLyBJZiB3ZSBjYW4ndCByZWFkIHRoZSBkaXJlY3RvcnksIHJldHVybiBmYWxzZVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZvbGRlciB9IGZyb20gJ29ic2lkaWFuJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBwYXRoIG9wZXJhdGlvbnNcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzIC0tIE5vZGUuanMgbW9kdWxlIG5lZWRlZCBmb3IgZmlsZSBvcGVyYXRpb25zXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBDb250ZW50VHlwZUNvbmZpZywgUHJvamVjdERldGVjdGlvblJlc3VsdCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIENvbnRlbnRUeXBlRGV0ZWN0b3Ige1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdH1cblxuXHRkZXRlY3RDb250ZW50VHlwZXMocHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQpOiBDb250ZW50VHlwZUNvbmZpZ1tdIHtcblx0XHQvLyBGaW5kIHRoZSBjb3JyZWN0IHNyYy9jb250ZW50IGRpcmVjdG9yeVxuXHRcdGNvbnN0IGNvbnRlbnRGb2xkZXIgPSB0aGlzLmZpbmRDb250ZW50RGlyZWN0b3J5KHByb2plY3REZXRlY3Rpb24pO1xuXG5cdFx0aWYgKCFjb250ZW50Rm9sZGVyKSB7XG5cdFx0XHQvLyBGYWxsYmFjayB0byBvbGQgYmVoYXZpb3IgaWYgd2UgY2FuJ3QgZmluZCBzcmMvY29udGVudFxuXHRcdFx0cmV0dXJuIHRoaXMuZGV0ZWN0Q29udGVudFR5cGVzRnJvbUZvbGRlcih0aGlzLmFwcC52YXVsdC5nZXRSb290KCkgYXMgVEZvbGRlcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZGV0ZWN0Q29udGVudFR5cGVzRnJvbUZvbGRlcihjb250ZW50Rm9sZGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlY3QgY29udGVudCB0eXBlcyBiYXNlZCBvbiBpbW1lZGlhdGUgc3ViZm9sZGVycyBvZiB0aGUgZ2l2ZW4gcm9vdC5cblx0ICovXG5cdHByaXZhdGUgZGV0ZWN0Q29udGVudFR5cGVzRnJvbUZvbGRlcihyb290Rm9sZGVyOiBURm9sZGVyKTogQ29udGVudFR5cGVDb25maWdbXSB7XG5cdFx0Y29uc3QgY29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gW107XG5cdFx0Y29uc3Qgc3ViZm9sZGVycyA9IHRoaXMuZ2V0VG9wTGV2ZWxGb2xkZXJzKHJvb3RGb2xkZXIpO1xuXG5cdFx0aWYgKHN1YmZvbGRlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Ly8gVHJhZGl0aW9uYWwgYmVoYXZpb3I6IGRldGVjdCBpbW1lZGlhdGUgc3ViZm9sZGVycyBhcyBjb250ZW50IHR5cGVzXG5cdFx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBzdWJmb2xkZXJzKSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5kZXRlY3RDb250ZW50VHlwZShmb2xkZXIpO1xuXHRcdFx0XHRpZiAoY29udGVudFR5cGUpIHtcblx0XHRcdFx0XHRjb250ZW50VHlwZXMucHVzaChjb250ZW50VHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRmFsbGJhY2s6IElmIG5vIHN1YmZvbGRlcnMgYXJlIGZvdW5kLCB0cmVhdCB0aGUgcm9vdCBmb2xkZXIgaXRzZWxmIGFzIGEgY29udGVudCB0eXBlXG5cdFx0XHQvLyAoaGFuZGxlcyBjYXNlcyB3aGVyZSB0aGUgdmF1bHQgaXMgcG9pbnRlZCBkaXJlY3RseSBhdCBhIGNvbnRlbnQgZm9sZGVyKVxuXHRcdFx0Ly8gU2tpcCBpZiBpdCdzIHN0cmljdGx5IHRoZSB2YXVsdCByb290IHdpdGggbm8gY2hpbGRyZW5cblx0XHRcdGlmIChyb290Rm9sZGVyLm5hbWUgPT09ICcvJyAmJiByb290Rm9sZGVyLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5kZXRlY3RDb250ZW50VHlwZShyb290Rm9sZGVyKTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRjb250ZW50VHlwZXMucHVzaChjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnRlbnRUeXBlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBGaW5kIHRoZSBzcmMvY29udGVudCBkaXJlY3RvcnkgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgdmF1bHQgaXMgbG9jYXRlZC5cblx0ICogSGFuZGxlcyBjYXNlcyB3aGVyZSB2YXVsdCBpcyBhdDpcblx0ICogLSBzcmMgbGV2ZWwgKG5lZWQgdG8gZ28gaW50byBzcmMvY29udGVudClcblx0ICogLSBzcmMvY29udGVudCBsZXZlbCAoYWxyZWFkeSB0aGVyZSlcblx0ICogLSBzcmMvY29udGVudC9wb3N0IGxldmVsICh2YXVsdCBpcyBpbnNpZGUgYSBjb250ZW50IHR5cGUsIGNhbid0IGFjY2VzcyBwYXJlbnQsIHJldHVybiBudWxsIHRvIHVzZSBmYWxsYmFjaylcblx0ICovXG5cdHByaXZhdGUgZmluZENvbnRlbnREaXJlY3RvcnkocHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQpOiBURm9sZGVyIHwgbnVsbCB7XG5cdFx0aWYgKCFwcm9qZWN0RGV0ZWN0aW9uIHx8ICFwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCB2YXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB2YXVsdC5hZGFwdGVyIGFzIHsgYmFzZVBhdGg/OiBzdHJpbmc7IHBhdGg/OiBzdHJpbmcgfTtcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcblxuXHRcdGlmICghdmF1bHRQYXRoKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBSZXNvbHZlIHByb2plY3Qgcm9vdCB0byBhYnNvbHV0ZSBwYXRoXG5cdFx0Ly8gSGFuZGxlIGJvdGggYWJzb2x1dGUgYW5kIHJlbGF0aXZlIHBhdGhzXG5cdFx0bGV0IHByb2plY3RSb290OiBzdHJpbmc7XG5cdFx0aWYgKHBhdGguaXNBYnNvbHV0ZShwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KSkge1xuXHRcdFx0cHJvamVjdFJvb3QgPSBwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBSZWxhdGl2ZSBwYXRoIC0gcmVzb2x2ZSByZWxhdGl2ZSB0byB2YXVsdFxuXHRcdFx0cHJvamVjdFJvb3QgPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCBwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNyYy9jb250ZW50IHBhdGhcblx0XHRjb25zdCBleHBlY3RlZENvbnRlbnRQYXRoID0gcGF0aC5qb2luKHByb2plY3RSb290LCAnc3JjJywgJ2NvbnRlbnQnKTtcblxuXHRcdC8vIENoZWNrIGlmIHNyYy9jb250ZW50IGV4aXN0cyBpbiB0aGUgZmlsZSBzeXN0ZW1cblx0XHRpZiAoIWZzLmV4aXN0c1N5bmMoZXhwZWN0ZWRDb250ZW50UGF0aCkgfHwgIWZzLnN0YXRTeW5jKGV4cGVjdGVkQ29udGVudFBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcblx0XHRcdC8vIHNyYy9jb250ZW50IGRvZXNuJ3QgZXhpc3QsIGNhbid0IGZpbmQgaXRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIE5vdyBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIFRGb2xkZXIgaW4gT2JzaWRpYW4ncyB2YXVsdCBzdHJ1Y3R1cmVcblx0XHQvLyBXZSBuZWVkIHRvIG5hdmlnYXRlIGZyb20gdmF1bHQgcm9vdCB0byBzcmMvY29udGVudFxuXHRcdGNvbnN0IHZhdWx0Um9vdCA9IHZhdWx0LmdldFJvb3QoKTtcblx0XHRpZiAoISh2YXVsdFJvb3QgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHJlbGF0aXZlIHBhdGggZnJvbSB2YXVsdCB0byBzcmMvY29udGVudFxuXHRcdGNvbnN0IHZhdWx0Tm9ybWFsaXplZCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0Y29uc3QgY29udGVudE5vcm1hbGl6ZWQgPSBwYXRoLnJlc29sdmUoZXhwZWN0ZWRDb250ZW50UGF0aCkudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIElmIHNyYy9jb250ZW50IGlzIHdpdGhpbiB0aGUgdmF1bHQsIGZpbmQgaXQgYnkgcGF0aFxuXHRcdGlmIChjb250ZW50Tm9ybWFsaXplZC5zdGFydHNXaXRoKHZhdWx0Tm9ybWFsaXplZCkpIHtcblx0XHRcdGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUocGF0aC5yZXNvbHZlKHZhdWx0UGF0aCksIHBhdGgucmVzb2x2ZShleHBlY3RlZENvbnRlbnRQYXRoKSk7XG5cdFx0XHQvLyBOb3JtYWxpemUgdG8gdXNlIGZvcndhcmQgc2xhc2hlcyBmb3IgT2JzaWRpYW5cblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRSZWxhdGl2ZVBhdGggPSByZWxhdGl2ZVBhdGguc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKTtcblx0XHRcdGNvbnN0IHBhdGhQYXJ0cyA9IG5vcm1hbGl6ZWRSZWxhdGl2ZVBhdGguc3BsaXQoJy8nKS5maWx0ZXIocGFydCA9PiBwYXJ0Lmxlbmd0aCA+IDApO1xuXG5cdFx0XHQvLyBJZiByZWxhdGl2ZSBwYXRoIGlzIGVtcHR5LCB2YXVsdCByb290IElTIHNyYy9jb250ZW50XG5cdFx0XHRpZiAocGF0aFBhcnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gdmF1bHRSb290O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXZpZ2F0ZSBmcm9tIHZhdWx0IHJvb3QgdG8gc3JjL2NvbnRlbnRcblx0XHRcdGxldCBjdXJyZW50Rm9sZGVyOiBURm9sZGVyID0gdmF1bHRSb290O1xuXHRcdFx0Zm9yIChjb25zdCBwYXJ0IG9mIHBhdGhQYXJ0cykge1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRGb2xkZXIuY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY3VycmVudEZvbGRlci5jaGlsZHJlbi5maW5kKGMgPT4gYyBpbnN0YW5jZW9mIFRGb2xkZXIgJiYgYy5uYW1lID09PSBwYXJ0KTtcblx0XHRcdFx0aWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudEZvbGRlciA9IGNoaWxkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY3VycmVudEZvbGRlcjtcblx0XHR9XG5cblx0XHQvLyBJZiBzcmMvY29udGVudCBpcyBvdXRzaWRlL2Fib3ZlIHRoZSB2YXVsdCAoZS5nLiwgdmF1bHQgaXMgYXQgc3JjL2NvbnRlbnQvcG9zdCksXG5cdFx0Ly8gd2UgY2FuJ3QgYWNjZXNzIGl0IHZpYSBPYnNpZGlhbidzIEFQSS4gUmV0dXJuIG51bGwgdG8gdXNlIGZhbGxiYWNrIGJlaGF2aW9yLlxuXHRcdC8vIFRoZSBmYWxsYmFjayB3aWxsIHNjYW4gdGhlIHZhdWx0IHJvb3QsIHdoaWNoIGluIHRoaXMgY2FzZSB3b3VsZCBiZSBhIGNvbnRlbnQgdHlwZSBmb2xkZXIuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRwcml2YXRlIGdldFRvcExldmVsRm9sZGVycyhmb2xkZXI6IFRGb2xkZXIpOiBURm9sZGVyW10ge1xuXHRcdGNvbnN0IGZvbGRlcnM6IFRGb2xkZXJbXSA9IFtdO1xuXG5cdFx0aWYgKCFmb2xkZXIuY2hpbGRyZW4pIHtcblx0XHRcdHJldHVybiBmb2xkZXJzO1xuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgY2hpbGQgb2YgZm9sZGVyLmNoaWxkcmVuKSB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdC8vIFNraXAgc3BlY2lhbCBmb2xkZXJzXG5cdFx0XHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcjtcblx0XHRcdFx0aWYgKCFjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJy4nKSAmJlxuXHRcdFx0XHRcdGNoaWxkLm5hbWUgIT09ICdiYXNlcycgJiZcblx0XHRcdFx0XHRjaGlsZC5uYW1lICE9PSAnX2Jhc2VzJyAmJlxuXHRcdFx0XHRcdGNoaWxkLm5hbWUgIT09ICdob21lJyAmJlxuXHRcdFx0XHRcdGNoaWxkLm5hbWUgIT09ICdfaG9tZScgJiZcblx0XHRcdFx0XHRjaGlsZC5uYW1lICE9PSAnYmFzZScgJiZcblx0XHRcdFx0XHRjaGlsZC5uYW1lICE9PSAnX2Jhc2UnICYmXG5cdFx0XHRcdFx0Y2hpbGQubmFtZSAhPT0gJ25vZGVfbW9kdWxlcycgJiZcblx0XHRcdFx0XHRjaGlsZC5uYW1lICE9PSBjb25maWdEaXIpIHtcblx0XHRcdFx0XHRmb2xkZXJzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvbGRlcnM7XG5cdH1cblxuXHRwcml2YXRlIGRldGVjdENvbnRlbnRUeXBlKGZvbGRlcjogVEZvbGRlcik6IENvbnRlbnRUeXBlQ29uZmlnIHwgbnVsbCB7XG5cdFx0Y29uc3QgbmFtZSA9IHRoaXMuY2FwaXRhbGl6ZUZpcnN0KGZvbGRlci5uYW1lKTtcblxuXHRcdC8vIEFsbCBkaXNjb3ZlcmVkIGNvbnRlbnQgZm9sZGVycyBhcmUgZW5hYmxlZCBieSBkZWZhdWx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiBgY29udGVudC10eXBlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTEpfWAsXG5cdFx0XHRuYW1lLFxuXHRcdFx0Zm9sZGVyOiBmb2xkZXIucGF0aCwgLy8gVXNlIHZhdWx0LXJlbGF0aXZlIHBhdGggaW5zdGVhZCBvZiBqdXN0IHRoZSBmb2xkZXIgbmFtZVxuXHRcdFx0ZmlsZU9yZ2FuaXphdGlvbjogJ2ZpbGUnLFxuXHRcdFx0ZW5hYmxlZDogdHJ1ZSwgLy8gRW5hYmxlIGFsbCBkaXNjb3ZlcmVkIGNvbnRlbnQgdHlwZXMgYnkgZGVmYXVsdFxuXHRcdFx0aW5kZXhGaWxlTmFtZTogJ2luZGV4J1xuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIGNhcGl0YWxpemVGaXJzdChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBOb3RpY2UsIFRGb2xkZXIsIFRGaWxlLCBBYnN0cmFjdElucHV0U3VnZ2VzdCwgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wcyAobWF5IG5vdCBiZSBpbiB0eXBlcyB5ZXQpXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuXHR9XG59XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUsIENvbnRlbnRUeXBlQ29uZmlnIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgQ29udGVudFR5cGVEZXRlY3RvciB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbnRlbnRUeXBlRGV0ZWN0b3InO1xuaW1wb3J0IHsgQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0FzdHJvQ29tcG9zZXJDb25maWcnO1xuXG4vLyBGb2xkZXIgbmFtZSBzdWdnZXN0ZXIgZm9yIGF0dGFjaG1lbnQgZm9sZGVyXG5jbGFzcyBGb2xkZXJOYW1lU3VnZ2VzdCBleHRlbmRzIEFic3RyYWN0SW5wdXRTdWdnZXN0PHN0cmluZz4ge1xuXHRwcml2YXRlIGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cdHByaXZhdGUgbW9kZTogJ3NwZWNpZmllZC1mb2xkZXInIHwgJ3N1YmZvbGRlcic7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQsIG1vZGU6ICdzcGVjaWZpZWQtZm9sZGVyJyB8ICdzdWJmb2xkZXInKSB7XG5cdFx0c3VwZXIoYXBwLCBpbnB1dEVsKTtcblx0XHR0aGlzLmlucHV0RWwgPSBpbnB1dEVsO1xuXHRcdHRoaXMubW9kZSA9IG1vZGU7XG5cdH1cblxuXHRnZXRTdWdnZXN0aW9ucyhpbnB1dFN0cjogc3RyaW5nKTogc3RyaW5nW10ge1xuXHRcdGNvbnN0IHN1Z2dlc3Rpb25zOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGNvbnN0IGxvd2VySW5wdXQgPSBpbnB1dFN0ci50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKHRoaXMubW9kZSA9PT0gJ3N1YmZvbGRlcicpIHtcblx0XHRcdC8vIEZvciBzdWJmb2xkZXIgbW9kZSwgc3VnZ2VzdCBmb2xkZXIgbmFtZXMgb25seVxuXHRcdFx0Ly8gQWx3YXlzIHN1Z2dlc3QgXCJhdHRhY2htZW50c1wiIGlmIGl0IG1hdGNoZXNcblx0XHRcdGlmICgnYXR0YWNobWVudHMnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobG93ZXJJbnB1dCkpIHtcblx0XHRcdFx0c3VnZ2VzdGlvbnMucHVzaCgnYXR0YWNobWVudHMnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGZvbGRlciBuYW1lcyBmcm9tIHZhdWx0XG5cdFx0XHRjb25zdCBhbGxGaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEFsbExvYWRlZEZpbGVzKCk7XG5cdFx0XHRjb25zdCBmb2xkZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgYWxsRmlsZXMpIHtcblx0XHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IGZpbGUubmFtZTtcblx0XHRcdFx0XHRpZiAoZm9sZGVyTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGxvd2VySW5wdXQpICYmIGZvbGRlck5hbWUgIT09ICdhdHRhY2htZW50cycpIHtcblx0XHRcdFx0XHRcdGZvbGRlck5hbWVzLmFkZChmb2xkZXJOYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c3VnZ2VzdGlvbnMucHVzaCguLi5BcnJheS5mcm9tKGZvbGRlck5hbWVzKS5zbGljZSgwLCAxMCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBGb3Igc3BlY2lmaWVkLWZvbGRlciBtb2RlLCBzdWdnZXN0IGZ1bGwgcGF0aHNcblx0XHRcdGNvbnN0IGFsbEZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0QWxsTG9hZGVkRmlsZXMoKTtcblx0XHRcdGNvbnN0IHBhdGhzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cblx0XHRcdGZvciAoY29uc3QgZmlsZSBvZiBhbGxGaWxlcykge1xuXHRcdFx0XHRpZiAoZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xuXHRcdFx0XHRcdGlmIChwYXRoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobG93ZXJJbnB1dCkpIHtcblx0XHRcdFx0XHRcdHBhdGhzLmFkZChwYXRoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c3VnZ2VzdGlvbnMucHVzaCguLi5BcnJheS5mcm9tKHBhdGhzKS5zbGljZSgwLCAxMCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdWdnZXN0aW9ucztcblx0fVxuXG5cdHJlbmRlclN1Z2dlc3Rpb24oc3VnZ2VzdGlvbjogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcblx0XHRlbC5zZXRUZXh0KHN1Z2dlc3Rpb24pO1xuXHR9XG5cblx0c2VsZWN0U3VnZ2VzdGlvbihzdWdnZXN0aW9uOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLmlucHV0RWwudmFsdWUgPSBzdWdnZXN0aW9uO1xuXHRcdHRoaXMuaW5wdXRFbC50cmlnZ2VyKCdpbnB1dCcpO1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGVTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRwcml2YXRlIGNvbnRlbnRUeXBlRGV0ZWN0b3I6IENvbnRlbnRUeXBlRGV0ZWN0b3I7XG5cdHByaXZhdGUgYXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvcjogQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvcjtcblx0cHJpdmF0ZSBkZXRlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHN0YXRlOiBXaXphcmRTdGF0ZSwgb25OZXh0OiAoKSA9PiB2b2lkLCBvbkJhY2s6ICgpID0+IHZvaWQsIG9uQ2FuY2VsOiAoKSA9PiB2b2lkKSB7XG5cdFx0c3VwZXIoYXBwLCBjb250YWluZXJFbCwgc3RhdGUsIG9uTmV4dCwgb25CYWNrLCBvbkNhbmNlbCk7XG5cdFx0dGhpcy5jb250ZW50VHlwZURldGVjdG9yID0gbmV3IENvbnRlbnRUeXBlRGV0ZWN0b3IoYXBwKTtcblx0XHR0aGlzLmFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IgPSBuZXcgQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvcihhcHApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEltcG9ydCBjb250ZW50IHR5cGVzIGZyb20gQXN0cm8gQ29tcG9zZXIgZGF0YS5qc29uIGlmIGl0IGV4aXN0c1xuXHQgKiBGaXJzdCB0cmllcyBwbHVnaW4gQVBJLCB0aGVuIGZhbGxzIGJhY2sgdG8gZmlsZSByZWFkaW5nXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIGltcG9ydEZyb21Bc3Ryb0NvbXBvc2VyKCk6IFByb21pc2U8Q29udGVudFR5cGVDb25maWdbXT4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBGaXJzdCB0cnkgdG8gdXNlIHBsdWdpbiBBUEkgKGxpa2UgaG93IHdlIHNhdmUpXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHsgc2V0dGluZ3M/OiB7IGNvbnRlbnRUeXBlcz86IHVua25vd25bXSB9IH0+IH0gfSkucGx1Z2lucztcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogQ2hlY2tpbmcgcGx1Z2lucyBBUEk6JywgISFwbHVnaW5zKTtcblxuXHRcdFx0aWYgKHBsdWdpbnMpIHtcblx0XHRcdFx0Y29uc3QgYXN0cm9Db21wb3NlclBsdWdpbiA9IHBsdWdpbnMucGx1Z2lucz8uWydhc3Ryby1jb21wb3NlciddO1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IEFzdHJvIENvbXBvc2VyIHBsdWdpbiBmb3VuZDonLCAhIWFzdHJvQ29tcG9zZXJQbHVnaW4pO1xuXG5cdFx0XHRcdGlmIChhc3Ryb0NvbXBvc2VyUGx1Z2luKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBQbHVnaW4gc2V0dGluZ3MgYXZhaWxhYmxlOicsICEhYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncyk7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBQbHVnaW4gc2V0dGluZ3Mga2V5czonLCBhc3Ryb0NvbXBvc2VyUGx1Z2luLnNldHRpbmdzID8gT2JqZWN0LmtleXMoYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncykgOiAnbm9uZScpO1xuXG5cdFx0XHRcdFx0aWYgKGFzdHJvQ29tcG9zZXJQbHVnaW4uc2V0dGluZ3MpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlcyA9IGFzdHJvQ29tcG9zZXJQbHVnaW4uc2V0dGluZ3MuY29udGVudFR5cGVzO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBjb250ZW50VHlwZXMgZnJvbSBwbHVnaW46JywgY29udGVudFR5cGVzID8gYEFycmF5IHdpdGggJHtjb250ZW50VHlwZXMubGVuZ3RofSBpdGVtc2AgOiAnbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlcykgJiYgY29udGVudFR5cGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBJbXBvcnRpbmcnLCBjb250ZW50VHlwZXMubGVuZ3RoLCAnY29udGVudCB0eXBlcyBmcm9tIEFzdHJvIENvbXBvc2VyICh2aWEgcGx1Z2luIEFQSSknKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBDb252ZXJ0IEFzdHJvIENvbXBvc2VyIGNvbnRlbnQgdHlwZXMgdG8gb3VyIGZvcm1hdFxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbXBvcnRlZFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gY29udGVudFR5cGVzLm1hcCgoY3Q6IHsgaWQ/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGZvbGRlcjogc3RyaW5nOyBjcmVhdGlvbk1vZGU/OiBzdHJpbmc7IGluZGV4RmlsZU5hbWU/OiBzdHJpbmc7IGxpbmtCYXNlUGF0aD86IHN0cmluZzsgZW5hYmxlZD86IGJvb2xlYW4gfSkgPT4gKHtcblx0XHRcdFx0XHRcdFx0XHRpZDogY3QuaWQgfHwgYGNvbnRlbnQtdHlwZS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDExKX1gLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGN0Lm5hbWUgfHwgdGhpcy5jYXBpdGFsaXplRmlyc3QoY3QuZm9sZGVyKSxcblx0XHRcdFx0XHRcdFx0XHRmb2xkZXI6IGN0LmZvbGRlcixcblx0XHRcdFx0XHRcdFx0XHRmaWxlT3JnYW5pemF0aW9uOiBjdC5jcmVhdGlvbk1vZGUgPT09ICdmb2xkZXInID8gJ2ZvbGRlcicgOiAnZmlsZScsXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXhGaWxlTmFtZTogY3QuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnLFxuXHRcdFx0XHRcdFx0XHRcdGxpbmtCYXNlUGF0aDogY3QubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZWQ6IGN0LmVuYWJsZWQgIT09IGZhbHNlIC8vIERlZmF1bHQgdG8gZW5hYmxlZCBpZiBub3Qgc3BlY2lmaWVkXG5cdFx0XHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaW1wb3J0ZWRUeXBlcztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSByZWFkaW5nXG5cdFx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XG5cdFx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy9hc3Ryby1jb21wb3Nlci9kYXRhLmpzb25gO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBUcnlpbmcgdG8gcmVhZCBmaWxlOicsIHBsdWdpbkRhdGFQYXRoKTtcblx0XHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogRmlsZSBmb3VuZDonLCAhIWRhdGFGaWxlLCBkYXRhRmlsZSA/IGBUeXBlOiAke2RhdGFGaWxlLmNvbnN0cnVjdG9yLm5hbWV9YCA6ICdub3QgZm91bmQnKTtcblxuXHRcdFx0aWYgKCFkYXRhRmlsZSB8fCAhKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRcdC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXRoc1xuXHRcdFx0XHRjb25zdCBhbHRQYXRocyA9IFtcblx0XHRcdFx0XHRgJHtjb25maWdEaXJ9L3BsdWdpbnMvYXN0cm8tY29tcG9zZXIvZGF0YS5qc29uYCxcblx0XHRcdFx0XHRgb2JzaWRpYW4vcGx1Z2lucy9hc3Ryby1jb21wb3Nlci9kYXRhLmpzb25gXG5cdFx0XHRcdF07XG5cblx0XHRcdFx0Zm9yIChjb25zdCBhbHRQYXRoIG9mIGFsdFBhdGhzKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWx0RmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChhbHRQYXRoKTtcblx0XHRcdFx0XHRpZiAoYWx0RmlsZSAmJiBhbHRGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogRm91bmQgZmlsZSBhdCBhbHRlcm5hdGl2ZSBwYXRoOicsIGFsdFBhdGgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoYWx0RmlsZSk7XG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyB7IGNvbnRlbnRUeXBlcz86IHVua25vd25bXSB9O1xuXG5cdFx0XHRcdFx0XHRpZiAoZGF0YS5jb250ZW50VHlwZXMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmNvbnRlbnRUeXBlcykpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBJbXBvcnRpbmcnLCBkYXRhLmNvbnRlbnRUeXBlcy5sZW5ndGgsICdjb250ZW50IHR5cGVzIGZyb20gQXN0cm8gQ29tcG9zZXIgKHZpYSBmaWxlIGF0JywgYWx0UGF0aCwgJyknKTtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbXBvcnRlZFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gZGF0YS5jb250ZW50VHlwZXMubWFwKChjdDogeyBpZD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgZm9sZGVyOiBzdHJpbmc7IGNyZWF0aW9uTW9kZT86IHN0cmluZzsgaW5kZXhGaWxlTmFtZT86IHN0cmluZzsgbGlua0Jhc2VQYXRoPzogc3RyaW5nOyBlbmFibGVkPzogYm9vbGVhbiB9KSA9PiAoe1xuXHRcdFx0XHRcdFx0XHRcdGlkOiBjdC5pZCB8fCBgY29udGVudC10eXBlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTEpfWAsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogY3QubmFtZSB8fCB0aGlzLmNhcGl0YWxpemVGaXJzdChjdC5mb2xkZXIpLFxuXHRcdFx0XHRcdFx0XHRcdGZvbGRlcjogY3QuZm9sZGVyLFxuXHRcdFx0XHRcdFx0XHRcdGZpbGVPcmdhbml6YXRpb246IGN0LmNyZWF0aW9uTW9kZSA9PT0gJ2ZvbGRlcicgPyAnZm9sZGVyJyA6ICdmaWxlJyxcblx0XHRcdFx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBjdC5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCcsXG5cdFx0XHRcdFx0XHRcdFx0bGlua0Jhc2VQYXRoOiBjdC5saW5rQmFzZVBhdGgsXG5cdFx0XHRcdFx0XHRcdFx0ZW5hYmxlZDogY3QuZW5hYmxlZCAhPT0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbXBvcnRlZFR5cGVzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogTm8gQXN0cm8gQ29tcG9zZXIgZGF0YS5qc29uIGZvdW5kLCB3aWxsIHNjYW4gZm9sZGVycycpO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIHsgY29udGVudFR5cGVzPzogdW5rbm93bltdIH07XG5cblx0XHRcdGlmICghZGF0YS5jb250ZW50VHlwZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5jb250ZW50VHlwZXMpKSB7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogQXN0cm8gQ29tcG9zZXIgZGF0YS5qc29uIGhhcyBubyBjb250ZW50VHlwZXMgYXJyYXkuIERhdGEga2V5czonLCBPYmplY3Qua2V5cyhkYXRhKSk7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBJbXBvcnRpbmcnLCBkYXRhLmNvbnRlbnRUeXBlcy5sZW5ndGgsICdjb250ZW50IHR5cGVzIGZyb20gQXN0cm8gQ29tcG9zZXIgKHZpYSBmaWxlKScpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IEFzdHJvIENvbXBvc2VyIGNvbnRlbnQgdHlwZXMgdG8gb3VyIGZvcm1hdFxuXHRcdFx0Y29uc3QgaW1wb3J0ZWRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IGRhdGEuY29udGVudFR5cGVzLm1hcCgoY3Q6IHsgaWQ/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGZvbGRlcjogc3RyaW5nOyBjcmVhdGlvbk1vZGU/OiBzdHJpbmc7IGluZGV4RmlsZU5hbWU/OiBzdHJpbmc7IGxpbmtCYXNlUGF0aD86IHN0cmluZzsgZW5hYmxlZD86IGJvb2xlYW4gfSkgPT4gKHtcblx0XHRcdFx0aWQ6IGN0LmlkIHx8IGBjb250ZW50LXR5cGUtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMSl9YCxcblx0XHRcdFx0bmFtZTogY3QubmFtZSB8fCB0aGlzLmNhcGl0YWxpemVGaXJzdChjdC5mb2xkZXIpLFxuXHRcdFx0XHRmb2xkZXI6IGN0LmZvbGRlcixcblx0XHRcdFx0ZmlsZU9yZ2FuaXphdGlvbjogY3QuY3JlYXRpb25Nb2RlID09PSAnZm9sZGVyJyA/ICdmb2xkZXInIDogJ2ZpbGUnLFxuXHRcdFx0XHRpbmRleEZpbGVOYW1lOiBjdC5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCcsXG5cdFx0XHRcdGxpbmtCYXNlUGF0aDogY3QubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRlbmFibGVkOiBjdC5lbmFibGVkICE9PSBmYWxzZSAvLyBEZWZhdWx0IHRvIGVuYWJsZWQgaWYgbm90IHNwZWNpZmllZFxuXHRcdFx0fSkpO1xuXG5cdFx0XHRyZXR1cm4gaW1wb3J0ZWRUeXBlcztcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignQ29udGVudFR5cGVTdGVwOiBGYWlsZWQgdG8gaW1wb3J0IGZyb20gQXN0cm8gQ29tcG9zZXI6JywgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuXHRcdC8vIFByZXNlcnZlIHNjcm9sbCBwb3NpdGlvbiB0byBwcmV2ZW50IGp1bXBpbmdcblx0XHRjb25zdCBzY3JvbGxhYmxlUGFyZW50ID0gY29udGFpbmVyRWwuY2xvc2VzdCgnLm1vZGFsLWNvbnRlbnQnKSB8fCBjb250YWluZXJFbC5wYXJlbnRFbGVtZW50O1xuXHRcdGNvbnN0IGN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxhYmxlUGFyZW50ID8gc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0Ly8gRmluZCBvciBjcmVhdGUgY29udGVudCB3cmFwcGVyIChwcmVzZXJ2ZSBmb290ZXIgaWYgaXQgZXhpc3RzKVxuXHRcdGxldCBzdGVwQ29udGVudFdyYXBwZXIgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcuY29udGVudC10eXBlLXN0ZXAtY29udGVudCcpIGFzIEhUTUxFbGVtZW50O1xuXG5cdFx0aWYgKCFzdGVwQ29udGVudFdyYXBwZXIpIHtcblx0XHRcdC8vIEZpcnN0IHRpbWUgLSBjbGVhciBldmVyeXRoaW5nIGFuZCBjcmVhdGUgd3JhcHBlclxuXHRcdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblx0XHRcdHN0ZXBDb250ZW50V3JhcHBlciA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ2NvbnRlbnQtdHlwZS1zdGVwLWNvbnRlbnQnIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBSZS1yZW5kZXJpbmcgLSBqdXN0IGNsZWFyIHRoZSB3cmFwcGVyIGNvbnRlbnQsIHByZXNlcnZlIGZvb3RlclxuXHRcdFx0c3RlcENvbnRlbnRXcmFwcGVyLmVtcHR5KCk7XG5cdFx0fVxuXG5cdFx0Ly8gRnVuY3Rpb24gdG8gcmVzdG9yZSBzY3JvbGwgYWZ0ZXIgcmVuZGVyXG5cdFx0Y29uc3QgcmVzdG9yZVNjcm9sbCA9ICgpID0+IHtcblx0XHRcdGlmIChzY3JvbGxhYmxlUGFyZW50ICYmIGN1cnJlbnRTY3JvbGxUb3AgPiAwKSB7XG5cdFx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG5cdFx0XHRcdFx0c2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgPSBjdXJyZW50U2Nyb2xsVG9wO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0NvbnRlbnQgdHlwZXMnIH0pO1xuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgncCcsIHtcblx0XHRcdHRleHQ6ICdEZXRlY3RpbmcgY29udGVudCB0eXBlcyBpbiB5b3VyIHZhdWx0Li4uJ1xuXHRcdH0pO1xuXG5cdFx0aWYgKCF0aGlzLmRldGVjdGVkKSB7XG5cdFx0XHQvLyBHZXQgc2F2ZWQgY29udGVudCB0eXBlcyBmcm9tIHN0YXRlIChwcmVzZXJ2ZXMgZW5hYmxlZCBzdGF0ZSBmcm9tIHByZXZpb3VzIHdpemFyZCBydW5zKVxuXHRcdFx0Y29uc3Qgc2F2ZWRDb250ZW50VHlwZXMgPSB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcyB8fCBbXTtcblx0XHRcdGNvbnN0IHNhdmVkQ29udGVudFR5cGVzTWFwID0gbmV3IE1hcChzYXZlZENvbnRlbnRUeXBlcy5tYXAoY3QgPT4gW2N0LmZvbGRlciwgY3RdKSk7XG5cblx0XHRcdC8vIEZpcnN0LCB0cnkgdG8gaW1wb3J0IGZyb20gQXN0cm8gQ29tcG9zZXIgaWYgaXQgZXhpc3RzXG5cdFx0XHRjb25zdCBpbXBvcnRlZFR5cGVzID0gYXdhaXQgdGhpcy5pbXBvcnRGcm9tQXN0cm9Db21wb3NlcigpO1xuXG5cdFx0XHQvLyBUaGVuIHNjYW4gZm9yIG5ldyBmb2xkZXJzIHRoYXQgYXJlbid0IGFscmVhZHkgbWFwcGVkXG5cdFx0XHQvLyBQYXNzIHByb2plY3QgZGV0ZWN0aW9uIGluZm8gc28gaXQgY2FuIGZpbmQgc3JjL2NvbnRlbnQgZGlyZWN0b3J5IGNvcnJlY3RseVxuXHRcdFx0Y29uc3Qgc2Nhbm5lZFR5cGVzID0gdGhpcy5jb250ZW50VHlwZURldGVjdG9yLmRldGVjdENvbnRlbnRUeXBlcyh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xuXG5cdFx0XHQvLyBDb21iaW5lIGltcG9ydGVkIGFuZCBzY2FubmVkIHR5cGVzXG5cdFx0XHQvLyBSZWNvbmNpbGU6IGlmIHdlIGhhdmUgYm90aCBhIHNob3J0IHBhdGggYW5kIGEgbG9uZyBwYXRoIHRoYXQgZW5kcyB3aXRoIGl0LCBwcmVmZXIgdGhlIGxvbmcgcGF0aFxuXHRcdFx0Y29uc3QgYWxsRGV0ZWN0ZWRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IFtdO1xuXG5cdFx0XHQvLyAxLiBTdGFydCB3aXRoIGFsbCBpbXBvcnRlZCB0eXBlc1xuXHRcdFx0Y29uc3QgaW1wb3J0ZWQgPSBbLi4uaW1wb3J0ZWRUeXBlc107XG5cblx0XHRcdC8vIDIuIENoZWNrIGVhY2ggc2Nhbm5lZCB0eXBlXG5cdFx0XHRmb3IgKGNvbnN0IHNjYW5uZWQgb2Ygc2Nhbm5lZFR5cGVzKSB7XG5cdFx0XHRcdGNvbnN0IG1hdGNoaW5nSW1wb3J0ZWRJbmRleCA9IGltcG9ydGVkLmZpbmRJbmRleChpdCA9PlxuXHRcdFx0XHRcdHNjYW5uZWQuZm9sZGVyID09PSBpdC5mb2xkZXIgfHxcblx0XHRcdFx0XHRzY2FubmVkLmZvbGRlci5lbmRzV2l0aChgLyR7aXQuZm9sZGVyfWApIHx8XG5cdFx0XHRcdFx0aXQuZm9sZGVyLmVuZHNXaXRoKGAvJHtzY2FubmVkLmZvbGRlcn1gKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChtYXRjaGluZ0ltcG9ydGVkSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdC8vIFJlY29uY2lsZTogdXBkYXRlIHRoZSBpbXBvcnRlZCBvbmUgd2l0aCB0aGUgbG9uZ2VyIGZvbGRlciBwYXRoIGlmIGl0J3MgYSBtYXRjaFxuXHRcdFx0XHRcdGNvbnN0IGltcG9ydGVkVHlwZSA9IGltcG9ydGVkW21hdGNoaW5nSW1wb3J0ZWRJbmRleF07XG5cdFx0XHRcdFx0aWYgKHNjYW5uZWQuZm9sZGVyLmxlbmd0aCA+IGltcG9ydGVkVHlwZS5mb2xkZXIubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBDb250ZW50VHlwZVN0ZXA6IFVwZGF0aW5nIGltcG9ydGVkIHR5cGUgXCIke2ltcG9ydGVkVHlwZS5uYW1lfVwiIGZvbGRlciBmcm9tIFwiJHtpbXBvcnRlZFR5cGUuZm9sZGVyfVwiIHRvIFwiJHtzY2FubmVkLmZvbGRlcn1cImApO1xuXHRcdFx0XHRcdFx0aW1wb3J0ZWRbbWF0Y2hpbmdJbXBvcnRlZEluZGV4XSA9IHtcblx0XHRcdFx0XHRcdFx0Li4uaW1wb3J0ZWRUeXBlLFxuXHRcdFx0XHRcdFx0XHRmb2xkZXI6IHNjYW5uZWQuZm9sZGVyXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBOb3QgZm91bmQgaW4gaW1wb3J0ZWQsIGFkZCBhcyBuZXcgZGV0ZWN0ZWQgdHlwZVxuXHRcdFx0XHRcdGFsbERldGVjdGVkVHlwZXMucHVzaChzY2FubmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21iaW5lIHJlY29uY2lsZWQgaW1wb3J0ZWQgdHlwZXMgd2l0aCBuZXcgZGV0ZWN0ZWQgdHlwZXNcblx0XHRcdGFsbERldGVjdGVkVHlwZXMucHVzaCguLi5pbXBvcnRlZCk7XG5cblx0XHRcdGNvbnN0IGRldGVjdGVkVHlwZXNNYXAgPSBuZXcgTWFwKGFsbERldGVjdGVkVHlwZXMubWFwKGN0ID0+IFtjdC5mb2xkZXIsIGN0XSkpO1xuXG5cdFx0XHQvLyBNZXJnZSB3aXRoIHNhdmVkIGNvbnRlbnQgdHlwZXMsIHByZXNlcnZpbmcgZW5hYmxlZCBzdGF0ZSBmcm9tIHNhdmVkIHNldHRpbmdzXG5cdFx0XHRjb25zdCBtZXJnZWRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IFtdO1xuXHRcdFx0Y29uc3QgcHJvY2Vzc2VkRm9sZGVycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5cdFx0XHQvLyBQcm9jZXNzIGFsbCBmb2xkZXJzIChib3RoIHNhdmVkIGFuZCBkZXRlY3RlZClcblx0XHRcdGNvbnN0IGFsbEZvbGRlcnMgPSBuZXcgU2V0KFtcblx0XHRcdFx0Li4uc2F2ZWRDb250ZW50VHlwZXMubWFwKGN0ID0+IGN0LmZvbGRlciksXG5cdFx0XHRcdC4uLmFsbERldGVjdGVkVHlwZXMubWFwKGN0ID0+IGN0LmZvbGRlcilcblx0XHRcdF0pO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBhbGxGb2xkZXJzKSB7XG5cdFx0XHRcdGlmIChwcm9jZXNzZWRGb2xkZXJzLmhhcyhmb2xkZXIpKSBjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgc2F2ZWRUeXBlID0gc2F2ZWRDb250ZW50VHlwZXNNYXAuZ2V0KGZvbGRlcik7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGVkVHlwZSA9IGRldGVjdGVkVHlwZXNNYXAuZ2V0KGZvbGRlcik7XG5cblx0XHRcdFx0Ly8gUkVDT05DSUxJQVRJT046IElmIHdlIGhhdmUgYSBzYXZlZCB0eXBlIHRoYXQgd2Fzbid0IGRldGVjdGVkLCBjaGVjayBpZiBpdCdzIGJlY2F1c2Vcblx0XHRcdFx0Ly8gaXQgd2FzIHNhdmVkIHdpdGggYSBzaG9ydCBwYXRoIChlLmcuIFwicG9zdHNcIikgYnV0IG5vdyBkZXRlY3RlZCB3aXRoIGEgZnVsbCBwYXRoIChlLmcuIFwic3JjL2NvbnRlbnQvcG9zdHNcIilcblx0XHRcdFx0aWYgKHNhdmVkVHlwZSAmJiAhZGV0ZWN0ZWRUeXBlKSB7XG5cdFx0XHRcdFx0Ly8gVHJ5IHRvIGZpbmQgaWYgdGhpcyBzYXZlZCB0eXBlJ3MgZm9sZGVyIG5hbWUgbWF0Y2hlcyB0aGUgZW5kIG9mIGFueSBkZXRlY3RlZCBmb2xkZXJcblx0XHRcdFx0XHRjb25zdCBtYXRjaGluZ0RldGVjdGVkID0gYWxsRGV0ZWN0ZWRUeXBlcy5maW5kKGR0ID0+XG5cdFx0XHRcdFx0XHRkdC5mb2xkZXIuZW5kc1dpdGgoYC8ke2ZvbGRlcn1gKSB8fCBkdC5mb2xkZXIgPT09IGZvbGRlclxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAobWF0Y2hpbmdEZXRlY3RlZCAmJiAhcHJvY2Vzc2VkRm9sZGVycy5oYXMobWF0Y2hpbmdEZXRlY3RlZC5mb2xkZXIpKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBDb250ZW50VHlwZVN0ZXA6IFJlY29uY2lsaW5nIHNhdmVkIGZvbGRlciBcIiR7Zm9sZGVyfVwiIHdpdGggZGV0ZWN0ZWQgZm9sZGVyIFwiJHttYXRjaGluZ0RldGVjdGVkLmZvbGRlcn1cImApO1xuXHRcdFx0XHRcdFx0Ly8gTWlncmF0ZSBzYXZlZCBzZXR0aW5ncyB0byB0aGUgY29ycmVjdCBkZXRlY3RlZCBmb2xkZXIgcGF0aFxuXHRcdFx0XHRcdFx0bWVyZ2VkVHlwZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdC4uLnNhdmVkVHlwZSxcblx0XHRcdFx0XHRcdFx0Zm9sZGVyOiBtYXRjaGluZ0RldGVjdGVkLmZvbGRlclxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRwcm9jZXNzZWRGb2xkZXJzLmFkZChmb2xkZXIpO1xuXHRcdFx0XHRcdFx0cHJvY2Vzc2VkRm9sZGVycy5hZGQobWF0Y2hpbmdEZXRlY3RlZC5mb2xkZXIpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNhdmVkVHlwZSkge1xuXHRcdFx0XHRcdC8vIFVzZSBzYXZlZCB0eXBlIHRvIHByZXNlcnZlIGVuYWJsZWQgc3RhdGUsIGN1c3RvbSBuYW1lLCBhbmQgYWxsIG90aGVyIHNldHRpbmdzXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhbHNvIGEgZGV0ZWN0ZWQgdHlwZSwgbWVyZ2UgaW4gYW55IG5ldyBpbmZvIHdoaWxlIHByZXNlcnZpbmcgc2F2ZWQgc2V0dGluZ3Ncblx0XHRcdFx0XHRpZiAoZGV0ZWN0ZWRUeXBlKSB7XG5cdFx0XHRcdFx0XHRtZXJnZWRUeXBlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0Li4uc2F2ZWRUeXBlLCAvLyBQcmVzZXJ2ZSBhbGwgc2F2ZWQgc2V0dGluZ3MgKGVuYWJsZWQsIGN1c3RvbSBuYW1lLCBsaW5rQmFzZVBhdGgsIGV0Yy4pXG5cdFx0XHRcdFx0XHRcdC8vIEFsd2F5cyBwcmVzZXJ2ZSBzYXZlZCBmb2xkZXIgYW5kIG5hbWUgKHVzZXIgbWF5IGhhdmUgY3VzdG9taXplZCB0aGUgbmFtZSlcblx0XHRcdFx0XHRcdFx0Zm9sZGVyOiBzYXZlZFR5cGUuZm9sZGVyLFxuXHRcdFx0XHRcdFx0XHRuYW1lOiBzYXZlZFR5cGUubmFtZSAvLyBBbHdheXMgdXNlIHNhdmVkIG5hbWUgKG1heSBiZSBjdXN0b21pemVkKVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFNhdmVkIHR5cGUgbm90IGRldGVjdGVkIC0ga2VlcCBpdCBhcyBpcyAodXNlciBtaWdodCBoYXZlIGRlbGV0ZWQgdGhlIGZvbGRlcilcblx0XHRcdFx0XHRcdG1lcmdlZFR5cGVzLnB1c2goc2F2ZWRUeXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGV0ZWN0ZWRUeXBlKSB7XG5cdFx0XHRcdFx0Ly8gTmV3IHR5cGUgbm90IGluIHNhdmVkIHNldHRpbmdzIC0gYWRkIGl0IChkZWZhdWx0IHRvIGVuYWJsZWQgZm9yIG5ldyB0eXBlcylcblx0XHRcdFx0XHQvLyBVc2UgYXV0by1kZXRlY3RlZCBuYW1lIGFzIHN0YXJ0aW5nIHBvaW50ICh1c2VyIGNhbiBjdXN0b21pemUgaXQpXG5cdFx0XHRcdFx0bWVyZ2VkVHlwZXMucHVzaChkZXRlY3RlZFR5cGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJvY2Vzc2VkRm9sZGVycy5hZGQoZm9sZGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU29ydCBhbHBoYWJldGljYWxseSBieSBuYW1lXG5cdFx0XHRtZXJnZWRUeXBlcy5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcblxuXHRcdFx0dGhpcy5zdGF0ZS5jb250ZW50VHlwZXMgPSBtZXJnZWRUeXBlcztcblx0XHRcdHRoaXMuZGV0ZWN0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5lbXB0eSgpO1xuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdDb250ZW50IHR5cGVzJyB9KTtcblx0XHRzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnU2VsZWN0IGFuZCBjb25maWd1cmUgeW91ciBjb250ZW50IHR5cGVzOidcblx0XHR9KTtcblxuXHRcdC8vIEdsb2JhbCBhdHRhY2htZW50IGhhbmRsaW5nIGF0IHRoZSB0b3Bcblx0XHRzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnQXR0YWNobWVudCBoYW5kbGluZycsIGNsczogJ3ZhdWx0LWNtcy1zZWN0aW9uLWhlYWRlcicgfSk7XG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0dGV4dDogJ0hvdyBzaG91bGQgYXR0YWNobWVudHMgYmUgc3RvcmVkIGdsb2JhbGx5PycsXG5cdFx0XHRjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1kZXNjJ1xuXHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoc3RlcENvbnRlbnRXcmFwcGVyKVxuXHRcdFx0LnNldE5hbWUoJ0hvdyBhcmUgYXR0YWNobWVudHMgaGFuZGxlZD8nKVxuXHRcdFx0LnNldERlc2MoJ0Nob29zZSBob3cgYXR0YWNobWVudHMgYXJlIHN0b3JlZCBmb3IgYWxsIGNvbnRlbnQgdHlwZXMnKVxuXHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdC5hZGRPcHRpb24oJ3NhbWUtZm9sZGVyJywgJ1NhbWUgZm9sZGVyIGFzIGN1cnJlbnQgZmlsZScpXG5cdFx0XHRcdC5hZGRPcHRpb24oJ3NwZWNpZmllZC1mb2xkZXInLCAnSW4gdGhlIHNwZWNpZmllZCBmb2xkZXInKVxuXHRcdFx0XHQuYWRkT3B0aW9uKCdzdWJmb2xkZXInLCAnSW4gc3ViZm9sZGVyIHVuZGVyIGN1cnJlbnQgZm9sZGVyJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSB8fCAnc3ViZm9sZGVyJylcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSB2YWx1ZSBhcyAnc3BlY2lmaWVkLWZvbGRlcicgfCAnc2FtZS1mb2xkZXInIHwgJ3N1YmZvbGRlcic7XG5cdFx0XHRcdFx0Ly8gQ2xlYXIgZm9sZGVyIG5hbWUgaWYgc3dpdGNoaW5nIHRvIHNhbWUtZm9sZGVyXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSAnc2FtZS1mb2xkZXInKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBSZS1yZW5kZXIgdG8gc2hvdy9oaWRlIGZvbGRlciBuYW1lIGlucHV0XG5cdFx0XHRcdFx0dm9pZCB0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0Ly8gU2hvdyBmb2xkZXIgbmFtZSBpbnB1dCBmb3Igc3BlY2lmaWVkLWZvbGRlciBvciBzdWJmb2xkZXIgbW9kZXNcblx0XHRpZiAodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc3BlY2lmaWVkLWZvbGRlcicgfHwgdGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc3ViZm9sZGVyJykge1xuXHRcdFx0Y29uc3QgZGVzY1RleHQgPSB0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzcGVjaWZpZWQtZm9sZGVyJ1xuXHRcdFx0XHQ/ICdFbnRlciB0aGUgZXhhY3QgcGF0aCB0byB0aGUgZm9sZGVyIGZvciBhdHRhY2htZW50cyAoZS5nLiwgXCJhdHRhY2htZW50c1wiIG9yIFwiaW1hZ2VzL2F0dGFjaG1lbnRzXCIpLiBMZWF2ZSBibGFuayB0byB1c2UgXCJhdHRhY2htZW50c1wiIGFzIGRlZmF1bHQuJ1xuXHRcdFx0XHQ6ICdFbnRlciB0aGUgbmFtZSBvZiB0aGUgc3ViZm9sZGVyIGZvciBhdHRhY2htZW50cyAoZS5nLiwgXCJhdHRhY2htZW50c1wiKS4gTGVhdmUgYmxhbmsgdG8gdXNlIFwiYXR0YWNobWVudHNcIiBhcyBkZWZhdWx0Lic7XG5cblx0XHRcdGNvbnN0IGZvbGRlck5hbWVTZXR0aW5nID0gbmV3IFNldHRpbmcoc3RlcENvbnRlbnRXcmFwcGVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnQXR0YWNobWVudCBmb2xkZXInKVxuXHRcdFx0XHQuc2V0RGVzYyhkZXNjVGV4dCk7XG5cblx0XHRcdGZvbGRlck5hbWVTZXR0aW5nLmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoJ2F0dGFjaG1lbnRzJylcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSB8fCAnJylcblx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBBZGQgYXV0b2NvbXBsZXRlIHN1Z2dlc3RlciB3aXRoIG1vZGUgKG9ubHkgaWYgbm90IHNhbWUtZm9sZGVyKVxuXHRcdFx0XHRpZiAodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlICE9PSAnc2FtZS1mb2xkZXInKSB7XG5cdFx0XHRcdFx0bmV3IEZvbGRlck5hbWVTdWdnZXN0KHRoaXMuYXBwLCB0ZXh0LmlucHV0RWwsIHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaHInLCB7IGNsczogJ3ZhdWx0LWNtcy1kaXZpZGVyJyB9KTtcblxuXHRcdC8vIENvbnRlbnQgdHlwZXMgc2VjdGlvblxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdDb250ZW50IHR5cGVzJywgY2xzOiAndmF1bHQtY21zLXNlY3Rpb24taGVhZGVyJyB9KTtcblxuXHRcdGZvciAoY29uc3QgY29udGVudFR5cGUgb2YgdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMpIHtcblx0XHRcdGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhzdGVwQ29udGVudFdyYXBwZXIpO1xuXG5cdFx0XHQvLyBDcmVhdGUgY2xpY2stdG8tZWRpdCBuYW1lIGVsZW1lbnQgd2l0aCBpY29uXG5cdFx0XHRjb25zdCBuYW1lQ29udGFpbmVyID0gc2V0dGluZy5uYW1lRWwuY3JlYXRlRGl2KHsgY2xzOiAndmF1bHQtY21zLWVkaXRhYmxlLW5hbWUnIH0pO1xuXHRcdFx0c2V0Q3NzUHJvcHMobmFtZUNvbnRhaW5lciwgeyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBnYXA6ICcwLjVyZW0nIH0pO1xuXG5cdFx0XHQvLyBGdW5jdGlvbiB0byBjcmVhdGUgdGhlIGRpc3BsYXkgZWxlbWVudCB3aXRoIGNsaWNrIGhhbmRsZXJcblx0XHRcdGNvbnN0IGNyZWF0ZU5hbWVEaXNwbGF5ID0gKG5hbWU6IHN0cmluZykgPT4ge1xuXHRcdFx0XHQvLyBDbGVhciBjb250YWluZXIgZmlyc3Rcblx0XHRcdFx0bmFtZUNvbnRhaW5lci5lbXB0eSgpO1xuXG5cdFx0XHRcdGNvbnN0IGRpc3BsYXkgPSBuYW1lQ29udGFpbmVyLmNyZWF0ZVNwYW4oe1xuXHRcdFx0XHRcdHRleHQ6IG5hbWUsXG5cdFx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLW5hbWUtZGlzcGxheSdcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gQWRkIHBlbmNpbCBpY29uXG5cdFx0XHRcdGNvbnN0IGljb25Db250YWluZXIgPSBuYW1lQ29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy1lZGl0LWljb24nIH0pO1xuXHRcdFx0XHRzZXRDc3NQcm9wcyhpY29uQ29udGFpbmVyLCB7IG9wYWNpdHk6ICcwLjYnIH0pO1xuXHRcdFx0XHRzZXRJY29uKGljb25Db250YWluZXIsICdsdWNpZGUtcGVuY2lsLWxpbmUnKTtcblxuXHRcdFx0XHQvLyBNYWtlIG5hbWUgYW5kIGljb24gZWRpdGFibGUgb24gY2xpY2tcblx0XHRcdFx0Y29uc3Qgc3RhcnRFZGl0ID0gKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnROYW1lID0gY29udGVudFR5cGUubmFtZTtcblxuXHRcdFx0XHRcdC8vIENsZWFyIGNvbnRhaW5lclxuXHRcdFx0XHRcdG5hbWVDb250YWluZXIuZW1wdHkoKTtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBpbnB1dCB1c2luZyBuYXRpdmUgT2JzaWRpYW4gc3R5bGluZ1xuXHRcdFx0XHRcdGNvbnN0IG5hbWVJbnB1dCA9IG5hbWVDb250YWluZXIuY3JlYXRlRWwoJ2lucHV0Jywge1xuXHRcdFx0XHRcdFx0dHlwZTogJ3RleHQnLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGN1cnJlbnROYW1lXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBPYnNpZGlhbiBpbnB1dCBzdHlsaW5nIGNsYXNzIChzYW1lIGFzIFNldHRpbmcuYWRkVGV4dCB1c2VzKVxuXHRcdFx0XHRcdG5hbWVJbnB1dC5hZGRDbGFzcygnbW9kLXRleHQtaW5wdXQnKTtcblxuXHRcdFx0XHRcdC8vIEZvY3VzIGFuZCBzZWxlY3QgdGV4dFxuXHRcdFx0XHRcdG5hbWVJbnB1dC5mb2N1cygpO1xuXHRcdFx0XHRcdG5hbWVJbnB1dC5zZWxlY3QoKTtcblxuXHRcdFx0XHRcdC8vIFNhdmUgb24gYmx1clxuXHRcdFx0XHRcdGNvbnN0IHNhdmVOYW1lID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGJsdXIgbGlzdGVuZXIgdG8gcHJldmVudCBkb3VibGUgZXhlY3V0aW9uXG5cdFx0XHRcdFx0XHRuYW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHNhdmVOYW1lKTtcblxuXHRcdFx0XHRcdFx0bGV0IG5ld05hbWUgPSBuYW1lSW5wdXQudmFsdWUudHJpbSgpO1xuXHRcdFx0XHRcdFx0Ly8gVmFsaWRhdGU6IGVuc3VyZSBuYW1lIGlzIG5vdCBlbXB0eVxuXHRcdFx0XHRcdFx0aWYgKCFuZXdOYW1lKSB7XG5cdFx0XHRcdFx0XHRcdG5ld05hbWUgPSBjdXJyZW50TmFtZTsgLy8gUmV2ZXJ0IHRvIG9yaWdpbmFsIGlmIGVtcHR5XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBWYWxpZGF0ZTogcmVtb3ZlIGFueSBwcm9ibGVtYXRpYyBjaGFyYWN0ZXJzIHRoYXQgbWlnaHQgYnJlYWsgQXN0cm8gQ29tcG9zZXJcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4IC0tIGludGVudGlvbmFsbHkgbWF0Y2hpbmcgY29udHJvbCBjaGFyc1xuXHRcdFx0XHRcdFx0bmV3TmFtZSA9IG5ld05hbWUucmVwbGFjZSgvWzw+OlwiL1xcXFx8PypcXHgwMC1cXHgxRl0vZywgJycpO1xuXHRcdFx0XHRcdFx0Ly8gRW5zdXJlIGl0J3Mgc3RpbGwgbm90IGVtcHR5IGFmdGVyIGNsZWFuaW5nXG5cdFx0XHRcdFx0XHRpZiAoIW5ld05hbWUudHJpbSgpKSB7XG5cdFx0XHRcdFx0XHRcdG5ld05hbWUgPSBjdXJyZW50TmFtZTsgLy8gUmV2ZXJ0IHRvIG9yaWdpbmFsIGlmIGVtcHR5IGFmdGVyIGNsZWFuaW5nXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRuZXdOYW1lID0gbmV3TmFtZS50cmltKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb250ZW50VHlwZS5uYW1lID0gbmV3TmFtZTtcblxuXHRcdFx0XHRcdFx0Ly8gUmUtcmVuZGVyIHRvIHVwZGF0ZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgbmFtZVxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBjcmVhdGVOYW1lRGlzcGxheSBoZXJlIGFzIGRpc3BsYXkoKSB3aWxsIHJlY3JlYXRlIGV2ZXJ5dGhpbmdcblx0XHRcdFx0XHRcdHZvaWQgdGhpcy5kaXNwbGF5KCk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIFNhdmUgb24gRW50ZXJcblx0XHRcdFx0XHRuYW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRzYXZlTmFtZSgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHQvLyBDYW5jZWw6IHJldmVydCB0byBvcmlnaW5hbFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVOYW1lRGlzcGxheShjdXJyZW50TmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBTYXZlIG9uIGJsdXJcblx0XHRcdFx0XHRuYW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHNhdmVOYW1lKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBBZGQgY2xpY2sgaGFuZGxlcnMgdG8gYm90aCBuYW1lIGFuZCBpY29uXG5cdFx0XHRcdGRpc3BsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdGFydEVkaXQpO1xuXHRcdFx0XHRpY29uQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3RhcnRFZGl0KTtcblxuXHRcdFx0XHQvLyBBZGQgaG92ZXIgZWZmZWN0IHRvIGljb25cblx0XHRcdFx0aWNvbkNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuXHRcdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgb3BhY2l0eTogJzEnIH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWNvbkNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuXHRcdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgb3BhY2l0eTogJzAuNicgfSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiBkaXNwbGF5O1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGluaXRpYWwgZGlzcGxheVxuXHRcdFx0Y3JlYXRlTmFtZURpc3BsYXkoY29udGVudFR5cGUubmFtZSk7XG5cblx0XHRcdHNldHRpbmcuc2V0RGVzYyhgRm9sZGVyOiAke2NvbnRlbnRUeXBlLmZvbGRlcn1gKVxuXHRcdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUoY29udGVudFR5cGUuZW5hYmxlZClcblx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0Y29udGVudFR5cGUuZW5hYmxlZCA9IHZhbHVlO1xuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gRmlsZSBvcmdhbml6YXRpb24gZHJvcGRvd25cblx0XHRcdG5ldyBTZXR0aW5nKHN0ZXBDb250ZW50V3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoYCR7Y29udGVudFR5cGUubmFtZX0gLSBGaWxlIG9yZ2FuaXphdGlvbmApXG5cdFx0XHRcdC5zZXREZXNjKCdDaG9vc2UgaG93IGNvbnRlbnQgaXMgb3JnYW5pemVkIGZvciB0aGlzIGNvbnRlbnQgdHlwZScpXG5cdFx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuXHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZpbGUnLCAnRmlsZS1iYXNlZCcpXG5cdFx0XHRcdFx0LmFkZE9wdGlvbignZm9sZGVyJywgJ0ZvbGRlci1iYXNlZCcpXG5cdFx0XHRcdFx0LnNldFZhbHVlKGNvbnRlbnRUeXBlLmZpbGVPcmdhbml6YXRpb24gfHwgJ2ZpbGUnKVxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRjb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uID0gdmFsdWUgYXMgJ2ZpbGUnIHwgJ2ZvbGRlcic7XG5cdFx0XHRcdFx0XHQvLyBSZS1yZW5kZXIgdG8gc2hvdy9oaWRlIGluZGV4IGZpbGUgbmFtZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHR2b2lkIHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gU2hvdyBpbmRleCBmaWxlIG5hbWUgZm9yIGZvbGRlci1iYXNlZCBvcmdhbml6YXRpb25cblx0XHRcdGlmIChjb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uID09PSAnZm9sZGVyJykge1xuXHRcdFx0XHRuZXcgU2V0dGluZyhzdGVwQ29udGVudFdyYXBwZXIpXG5cdFx0XHRcdFx0LnNldE5hbWUoYCR7Y29udGVudFR5cGUubmFtZX0gLSBJbmRleCBmaWxlIG5hbWVgKVxuXHRcdFx0XHRcdC5zZXREZXNjKCdOYW1lIG9mIHRoZSBpbmRleCBmaWxlIGluIGZvbGRlci1iYXNlZCBvcmdhbml6YXRpb24nKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKGNvbnRlbnRUeXBlLmluZGV4RmlsZU5hbWUgfHwgJ2luZGV4Jylcblx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlLmluZGV4RmlsZU5hbWUgPSB2YWx1ZSB8fCAnaW5kZXgnO1xuXHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMaW5rIGJhc2UgcGF0aCBmb3IgQXN0cm8gQ29tcG9zZXJcblx0XHRcdC8vIEV4dHJhY3QgZm9sZGVyIG5hbWUgZnJvbSBwYXRoIChlLmcuLCBcInNyYy9jb250ZW50L3Bvc3RzXCIgLT4gXCJwb3N0c1wiKVxuXHRcdFx0Y29uc3QgcGF0aFBhcnRzID0gY29udGVudFR5cGUuZm9sZGVyLnNwbGl0KCcvJykuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcblx0XHRcdGNvbnN0IGZvbGRlck5hbWUgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdIHx8IGNvbnRlbnRUeXBlLmZvbGRlcjtcblx0XHRcdGNvbnN0IGRlZmF1bHRMaW5rQmFzZVBhdGggPSBgLyR7Zm9sZGVyTmFtZX0vYDtcblx0XHRcdG5ldyBTZXR0aW5nKHN0ZXBDb250ZW50V3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoYCR7Y29udGVudFR5cGUubmFtZX0gLSBMaW5rIGJhc2UgcGF0aGApXG5cdFx0XHRcdC5zZXREZXNjKGBVUkwgcGF0aCBmb3IgdGhpcyBjb250ZW50IHR5cGUgKGUuZy4sIFwiL3Bvc3RzL1wiIG9yIFwiL1wiIGZvciByb290KS4gTGVhdmUgYmxhbmsgdG8gdXNlIGRlZmF1bHQ6ICR7ZGVmYXVsdExpbmtCYXNlUGF0aH1gKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoZGVmYXVsdExpbmtCYXNlUGF0aClcblx0XHRcdFx0XHQuc2V0VmFsdWUoY29udGVudFR5cGUubGlua0Jhc2VQYXRoIHx8ICcnKVxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRjb250ZW50VHlwZS5saW5rQmFzZVBhdGggPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0fSkpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBBZGRpdGlvbmFsIENvbnRlbnQgVHlwZSBidXR0b25cblx0XHRjb25zdCBhZGRCdXR0b24gPSBzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHtcblx0XHRcdHRleHQ6ICdBZGQgYWRkaXRpb25hbCBjb250ZW50IHR5cGUnLFxuXHRcdFx0Y2xzOiAnbW9kLWN0YSdcblx0XHR9KTtcblx0XHRzZXRDc3NQcm9wcyhhZGRCdXR0b24sIHsgbWFyZ2luVG9wOiAnMjBweCcsIG1hcmdpbkJvdHRvbTogJzMwcHgnIH0pO1xuXHRcdGFkZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcblx0XHRcdHZvaWQgKGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRGb2xkZXIgPSB0aGlzLnNlbGVjdENvbnRlbnRUeXBlRm9sZGVyKCk7XG5cdFx0XHRcdGlmIChzZWxlY3RlZEZvbGRlcikge1xuXHRcdFx0XHRcdC8vIENhbGN1bGF0ZSByZWxhdGl2ZSBwYXRoIGZyb20gdmF1bHQgcm9vdFxuXHRcdFx0XHRcdGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuZ2V0VmF1bHRQYXRoKCk7XG5cdFx0XHRcdFx0bGV0IGZvbGRlclBhdGggPSBzZWxlY3RlZEZvbGRlcjtcblxuXHRcdFx0XHRcdC8vIElmIHNlbGVjdGVkIGZvbGRlciBpcyBpbnNpZGUgdGhlIHZhdWx0LCBtYWtlIGl0IHJlbGF0aXZlXG5cdFx0XHRcdFx0aWYgKHNlbGVjdGVkRm9sZGVyLnN0YXJ0c1dpdGgodmF1bHRQYXRoKSkge1xuXHRcdFx0XHRcdFx0Zm9sZGVyUGF0aCA9IHNlbGVjdGVkRm9sZGVyLnN1YnN0cmluZyh2YXVsdFBhdGgubGVuZ3RoKS5yZXBsYWNlKC9eWy9cXFxcXSsvLCAnJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCBmb2xkZXIgbmFtZSBmcm9tIHBhdGggKGxhc3Qgc2VnbWVudCkgZm9yIHRoZSBkaXNwbGF5IG5hbWVcblx0XHRcdFx0XHRjb25zdCBwYXRoUGFydHMgPSBmb2xkZXJQYXRoLnNwbGl0KC9bL1xcXFxdLykuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcblx0XHRcdFx0XHRjb25zdCBsZWFmRm9sZGVyTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV0gfHwgZm9sZGVyUGF0aDtcblxuXHRcdFx0XHRcdGNvbnN0IG5ld1R5cGU6IENvbnRlbnRUeXBlQ29uZmlnID0ge1xuXHRcdFx0XHRcdFx0aWQ6IGBjb250ZW50LXR5cGUtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMSl9YCxcblx0XHRcdFx0XHRcdG5hbWU6IHRoaXMuY2FwaXRhbGl6ZUZpcnN0KGxlYWZGb2xkZXJOYW1lKSxcblx0XHRcdFx0XHRcdGZvbGRlcjogZm9sZGVyUGF0aCxcblx0XHRcdFx0XHRcdGZpbGVPcmdhbml6YXRpb246ICdmaWxlJyxcblx0XHRcdFx0XHRcdGVuYWJsZWQ6IHRydWUsIC8vIEVuYWJsZSBieSBkZWZhdWx0IHNvIGl0IHNob3dzIHVwIGluIFN0ZXAgNVxuXHRcdFx0XHRcdFx0aW5kZXhGaWxlTmFtZTogJ2luZGV4J1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5jb250ZW50VHlwZXMucHVzaChuZXdUeXBlKTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkoKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uIGFmdGVyIGFsbCByZW5kZXJpbmcgaXMgY29tcGxldGVcblx0XHRyZXN0b3JlU2Nyb2xsKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0IGZvbGRlciBmb3IgYWRkaXRpb25hbCBjb250ZW50IHR5cGVcblx0ICovXG5cdHByaXZhdGUgc2VsZWN0Q29udGVudFR5cGVGb2xkZXIoKTogc3RyaW5nIHwgbnVsbCB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSBtdWx0aXBsZSB3YXlzIHRvIGFjY2VzcyBFbGVjdHJvbiBkaWFsb2cgQVBJXG5cdFx0XHRsZXQgZGlhbG9nOiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfCBudWxsID0gbnVsbDtcblxuXHRcdFx0Ly8gTWV0aG9kIDE6IFRyeSBAZWxlY3Ryb24vcmVtb3RlIChuZXdlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZiAtLSBkeW5hbWljIHJlcXVpcmUgZm9yIEVsZWN0cm9uXG5cdFx0XHRcdGNvbnN0IGVsZWN0cm9uUmVtb3RlID0gcmVxdWlyZSgnQGVsZWN0cm9uL3JlbW90ZScpIGFzIHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH07XG5cdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uUmVtb3RlPy5kaWFsb2cgfHwgbnVsbDtcblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlLCB0cnkgbmV4dCBtZXRob2Rcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0aG9kIDI6IFRyeSBlbGVjdHJvbi5yZW1vdGUuZGlhbG9nIChvbGRlciBFbGVjdHJvbiB2ZXJzaW9ucylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9ICgod2luZG93IGFzIHsgcmVxdWlyZT86IChtb2R1bGU6IHN0cmluZykgPT4gdW5rbm93biB9KS5yZXF1aXJlPy4oJ2VsZWN0cm9uJykgfHwgcmVxdWlyZSgnZWxlY3Ryb24nKSkgYXMgeyByZW1vdGU/OiB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9IH07XG5cdFx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb24/LnJlbW90ZT8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ldGhvZCAzOiBUcnkgZWxlY3Ryb24uZGlhbG9nIGRpcmVjdGx5IChtYWluIHByb2Nlc3MsIG1heSBub3Qgd29yaylcblx0XHRcdGlmICghZGlhbG9nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmIC0tIGR5bmFtaWMgcmVxdWlyZSBmb3IgRWxlY3Ryb25cblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJykgYXMgeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfTtcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8uZGlhbG9nIHx8IG51bGw7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRpYWxvZyB8fCB0eXBlb2YgZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIGRpYWxvZyBBUEkgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSB0aGlzLmdldFZhdWx0UGF0aCgpO1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBkaWFsb2cuc2hvd09wZW5EaWFsb2dTeW5jKHtcblx0XHRcdFx0dGl0bGU6ICdTZWxlY3QgQ29udGVudCBUeXBlIEZvbGRlcicsXG5cdFx0XHRcdGRlZmF1bHRQYXRoOiB2YXVsdFBhdGgsXG5cdFx0XHRcdHByb3BlcnRpZXM6IFsnb3BlbkRpcmVjdG9yeSddXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBOb3JtYWxpemUgcGF0aCAocmVwbGFjZSBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmQgc2xhc2hlcywgcmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMpXG5cdFx0XHRcdHJldHVybiByZXN1bHRbMF0ucmVwbGFjZSgvXFxcXC9nLCAnLycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9wZW5pbmcgZm9sZGVyIHBpY2tlcjonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKCdVbmFibGUgdG8gb3BlbiBmb2xkZXIgcGlja2VyLiBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgT2JzaWRpYW4gb24gZGVza3RvcC4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHZhdWx0IHBhdGhcblx0ICovXG5cdHByaXZhdGUgZ2V0VmF1bHRQYXRoKCk6IHN0cmluZyB7XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xuXHRcdC8vIFJlc29sdmUgcGF0aCAoY29udmVydCByZWxhdGl2ZSB0byBhYnNvbHV0ZSwgbm9ybWFsaXplIHNlcGFyYXRvcnMpXG5cdFx0aWYgKHZhdWx0UGF0aCkge1xuXHRcdFx0Ly8gSWYgYWxyZWFkeSBhYnNvbHV0ZSwgcmV0dXJuIGFzLWlzIChub3JtYWxpemVkKVxuXHRcdFx0aWYgKHZhdWx0UGF0aC5zdGFydHNXaXRoKCcvJykgfHwgL15bQS1aXTovLnRlc3QodmF1bHRQYXRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdmF1bHRQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblx0XHRcdH1cblx0XHRcdC8vIEZvciByZWxhdGl2ZSBwYXRocywgd2UnZCBuZWVkIHRvIHJlc29sdmUsIGJ1dCBpbiBPYnNpZGlhbiBjb250ZXh0LCBiYXNlUGF0aCBzaG91bGQgYmUgYWJzb2x1dGVcblx0XHRcdHJldHVybiB2YXVsdFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXHRcdH1cblx0XHQvLyBGYWxsYmFjayAtIGluIE9ic2lkaWFuIGNvbnRleHQgdGhpcyBzaG91bGRuJ3QgaGFwcGVuXG5cdFx0cmV0dXJuICcvJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYXBpdGFsaXplIGZpcnN0IGxldHRlclxuXHQgKi9cblx0cHJpdmF0ZSBjYXBpdGFsaXplRmlyc3Qoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuc29tZShjdCA9PiBjdC5lbmFibGVkKTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb250ZW50IHR5cGVzJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb25maWd1cmUgY29udGVudCB0eXBlcyc7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBwYXRoIG9wZXJhdGlvbnNcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgUHJvamVjdERldGVjdGlvblJlc3VsdCB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGNsYXNzIHRvIHJlc29sdmUgY29udGVudCB0eXBlIGZvbGRlciBwYXRocyByZWxhdGl2ZSB0byB2YXVsdCByb290XHJcbiAqIGFuZCBwcm9qZWN0IHJvb3QsIGFjY291bnRpbmcgZm9yIGRpZmZlcmVudCB2YXVsdCBsb2NhdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGF0aFJlc29sdmVyIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGZvbGRlciBwYXRoIGZyb20gdmF1bHQgcm9vdCB0byB0aGUgY29udGVudCB0eXBlIGZvbGRlci5cclxuXHQgKiBUaGlzIGlzIHVzZWQgYnkgQmFzZXMgQ01TIGZpbHRlcnMgYW5kIEFzdHJvIENvbXBvc2VyIGZvbGRlciBzZXR0aW5ncy5cclxuXHQgKiBcclxuXHQgKiBFeGFtcGxlczpcclxuXHQgKiAtIFZhdWx0IGF0IHNyYyBsZXZlbCwgY29udGVudCB0eXBlIFwiZG9jc1wiOiByZXR1cm5zIFwiY29udGVudC9kb2NzXCJcclxuXHQgKiAtIFZhdWx0IGF0IHNyYy9jb250ZW50IGxldmVsLCBjb250ZW50IHR5cGUgXCJkb2NzXCI6IHJldHVybnMgXCJkb2NzXCJcclxuXHQgKiAtIFZhdWx0IGF0IHNyYy9jb250ZW50L3Bvc3QgbGV2ZWwsIGNvbnRlbnQgdHlwZSBcImRvY3NcIjogcmV0dXJucyBcIi4uL2RvY3NcIiAoaWYgYWNjZXNzaWJsZSkgb3IgXCJkb2NzXCIgKGlmIHZhdWx0IGlzIHRoZSBjb250ZW50IHR5cGUgZm9sZGVyKVxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBmb2xkZXJOYW1lIFRoZSBjb250ZW50IHR5cGUgZm9sZGVyIG5hbWUgKGUuZy4sIFwiZG9jc1wiLCBcInBvc3RzXCIpXHJcblx0ICogQHBhcmFtIHByb2plY3REZXRlY3Rpb24gUHJvamVjdCBkZXRlY3Rpb24gcmVzdWx0IHdpdGggcHJvamVjdCByb290IGFuZCB2YXVsdCBsb2NhdGlvblxyXG5cdCAqIEByZXR1cm5zIFBhdGggZnJvbSB2YXVsdCByb290IHRvIGNvbnRlbnQgdHlwZSBmb2xkZXIsIG9yIG51bGwgaWYgY2Fubm90IGJlIGRldGVybWluZWRcclxuXHQgKi9cclxuXHRnZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChmb2xkZXJOYW1lOiBzdHJpbmcsIHByb2plY3REZXRlY3Rpb24/OiBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0KTogc3RyaW5nIHtcclxuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIHsgYmFzZVBhdGg/OiBzdHJpbmc7IHBhdGg/OiBzdHJpbmcgfTtcclxuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xyXG5cclxuXHRcdC8vIDEuIENoZWNrIGlmIGZvbGRlck5hbWUgaXMgYWxyZWFkeSBhIHZhbGlkIHBhdGggaW4gdGhlIHZhdWx0LlxyXG5cdFx0Ly8gVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIGZvbGRlck5hbWUgaXMgYWxyZWFkeSBhIHZhdWx0LXJlbGF0aXZlIHBhdGggKGUuZy4sIFwic3JjL2NvbnRlbnQvcG9zdHNcIlxyXG5cdFx0Ly8gb3IgYSBtYW51YWxseSBzZWxlY3RlZCBmb2xkZXIgbGlrZSBcImJsb2ctcG9zdHNcIikgYW5kIHByb2plY3QgZGV0ZWN0aW9uIG1pZ2h0IG5vdCBiZSBuZWVkZWQuXHJcblx0XHQvLyBXZSBwcmlvcml0aXplIHRoaXMgZm9yIG1hbnVhbGx5IGFkZGVkIGZvbGRlcnMgdGhhdCBhcmUgYWxyZWFkeSBjb3JyZWN0bHkgcmVzb2x2ZWQuXHJcblx0XHRjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlck5hbWUpO1xyXG5cdFx0aWYgKGZpbGUpIHtcclxuXHRcdFx0cmV0dXJuIGZvbGRlck5hbWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gMi4gSWYgcHJvamVjdCBkZXRlY3Rpb24gaXMgYXZhaWxhYmxlLCB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBleGFjdCBpbnRlbmRlZCBwYXRoXHJcblx0XHQvLyBUaGlzIGlzIHByZWZlcnJlZCBmb3IgYXV0by1kZXRlY3RlZCBmb2xkZXJzIGJlY2F1c2UgaXQgaGFuZGxlcyB0aGUgXCJ2YXVsdCBhdCBwcm9qZWN0IHJvb3RcIiBjYXNlIGNvcnJlY3RseVxyXG5cdFx0Ly8gZXZlbiBpZiB0aGVyZSBhcmUgZm9sZGVycyB3aXRoIG1hdGNoaW5nIG5hbWVzIGVsc2V3aGVyZSBpbiB0aGUgdmF1bHQuXHJcblx0XHRpZiAocHJvamVjdERldGVjdGlvbiAmJiBwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290ICYmIHZhdWx0UGF0aCkge1xyXG5cdFx0XHQvLyBSZXNvbHZlIHByb2plY3Qgcm9vdCB0byBhYnNvbHV0ZSBwYXRoXHJcblx0XHRcdGNvbnN0IHByb2plY3RSb290ID0gcGF0aC5pc0Fic29sdXRlKHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpIFxyXG5cdFx0XHRcdD8gcHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCBcclxuXHRcdFx0XHQ6IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpO1xyXG5cclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBpbnRlbmRlZCBjb250ZW50IHR5cGUgZm9sZGVyXHJcblx0XHRcdC8vIElmIGZvbGRlck5hbWUgYWxyZWFkeSBsb29rcyBsaWtlIGEgcGF0aCBmcm9tIHByb2plY3Qgcm9vdCAoZS5nLiBzdGFydHMgd2l0aCBzcmMvY29udGVudCksIHVzZSBpdCBhcy1pc1xyXG5cdFx0XHRsZXQgY29udGVudFR5cGVBYnNvbHV0ZVBhdGg6IHN0cmluZztcclxuXHRcdFx0aWYgKGZvbGRlck5hbWUuc3RhcnRzV2l0aCgnc3JjL2NvbnRlbnQvJykgfHwgZm9sZGVyTmFtZS5pbmNsdWRlcygnL3NyYy9jb250ZW50LycpKSB7XHJcblx0XHRcdFx0Y29udGVudFR5cGVBYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUocHJvamVjdFJvb3QsIGZvbGRlck5hbWUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnRlbnRUeXBlQWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKHByb2plY3RSb290LCAnc3JjJywgJ2NvbnRlbnQnLCBmb2xkZXJOYW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHJlbGF0aXZlIHBhdGggZnJvbSB2YXVsdCB0byBjb250ZW50IHR5cGUgZm9sZGVyXHJcblx0XHRcdGNvbnN0IHZhdWx0QWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKHZhdWx0UGF0aCk7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUodmF1bHRBYnNvbHV0ZVBhdGgsIGNvbnRlbnRUeXBlQWJzb2x1dGVQYXRoKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIElmIHJlbGF0aXZlUGF0aCBpcyB3aXRoaW4gdGhlIHZhdWx0IChkb2Vzbid0IHN0YXJ0IHdpdGggJy4uJyksIHVzZSBpdFxyXG5cdFx0XHRpZiAoIXJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpICYmICFwYXRoLmlzQWJzb2x1dGUocmVsYXRpdmVQYXRoKSkge1xyXG5cdFx0XHRcdC8vIE5vcm1hbGl6ZSB0byB1c2UgZm9yd2FyZCBzbGFzaGVzICh3b3JrcyBvbiBXaW5kb3dzIHRvbylcclxuXHRcdFx0XHRyZXR1cm4gcmVsYXRpdmVQYXRoLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJykgfHwgJy4nO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gMy4gTGFzdCByZXNvcnQgZmFsbGJhY2s6IHJldHVybiBmb2xkZXIgbmFtZSBhcy1pc1xyXG5cdFx0cmV0dXJuIGZvbGRlck5hbWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGZvbGRlciBwYXRoIGZyb20gcHJvamVjdCByb290IHRvIHRoZSBjb250ZW50IHR5cGUgZm9sZGVyLlxyXG5cdCAqIFRoaXMgaXMgYWx3YXlzIFwic3JjL2NvbnRlbnQve2ZvbGRlck5hbWV9XCIgcmVsYXRpdmUgdG8gcHJvamVjdCByb290LlxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBmb2xkZXJOYW1lIFRoZSBjb250ZW50IHR5cGUgZm9sZGVyIG5hbWUgKGUuZy4sIFwiZG9jc1wiLCBcInBvc3RzXCIpXHJcblx0ICogQHJldHVybnMgUGF0aCBmcm9tIHByb2plY3Qgcm9vdCAoZS5nLiwgXCJzcmMvY29udGVudC9kb2NzXCIpXHJcblx0ICovXHJcblx0Z2V0Rm9sZGVyUGF0aEZyb21Qcm9qZWN0Um9vdChmb2xkZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGBzcmMvY29udGVudC8ke2ZvbGRlck5hbWV9YDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgZm9sZGVyIHBhdGggZm9yIEFzdHJvIENvbXBvc2VyLCB3aGljaCBuZWVkcyB0aGUgcGF0aCByZWxhdGl2ZSB0byB2YXVsdCByb290XHJcblx0ICogYnV0IHNob3VsZCB3b3JrIGNvcnJlY3RseSByZWdhcmRsZXNzIG9mIHZhdWx0IGxvY2F0aW9uLlxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBmb2xkZXJOYW1lIFRoZSBjb250ZW50IHR5cGUgZm9sZGVyIG5hbWVcclxuXHQgKiBAcGFyYW0gcHJvamVjdERldGVjdGlvbiBQcm9qZWN0IGRldGVjdGlvbiByZXN1bHRcclxuXHQgKiBAcmV0dXJucyBQYXRoIGZyb20gdmF1bHQgcm9vdCB0byBjb250ZW50IHR5cGUgZm9sZGVyXHJcblx0ICovXHJcblx0Z2V0QXN0cm9Db21wb3NlckZvbGRlclBhdGgoZm9sZGVyTmFtZTogc3RyaW5nLCBwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChmb2xkZXJOYW1lLCBwcm9qZWN0RGV0ZWN0aW9uKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgZm9sZGVyIHBhdGggZm9yIEJhc2VzIENNUyBmaWx0ZXIsIHdoaWNoIG5lZWRzIHRvIG1hdGNoIGZpbGVzXHJcblx0ICogaW4gdGhlIGNvbnRlbnQgdHlwZSBmb2xkZXIgcmVnYXJkbGVzcyBvZiB2YXVsdCBsb2NhdGlvbi5cclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZm9sZGVyTmFtZSBUaGUgY29udGVudCB0eXBlIGZvbGRlciBuYW1lXHJcblx0ICogQHBhcmFtIHByb2plY3REZXRlY3Rpb24gUHJvamVjdCBkZXRlY3Rpb24gcmVzdWx0XHJcblx0ICogQHJldHVybnMgUGF0aCBmcm9tIHZhdWx0IHJvb3QgdG8gY29udGVudCB0eXBlIGZvbGRlciAoZm9yIHVzZSBpbiBmaWxlLmZvbGRlci5zdGFydHNXaXRoIGZpbHRlcilcclxuXHQgKi9cclxuXHRnZXRCYXNlc0NNU0ZvbGRlclBhdGgoZm9sZGVyTmFtZTogc3RyaW5nLCBwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChmb2xkZXJOYW1lLCBwcm9qZWN0RGV0ZWN0aW9uKTtcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbi8qKlxuICogVXRpbGl0eSBmb3Igc2FmZWx5IHJlYWRpbmcgYW5kIHdyaXRpbmcgcGx1Z2luIGNvbmZpZ3VyYXRpb24gZmlsZXNcbiAqIHdpdGggYmFja3VwIGNyZWF0aW9uLCBKU09OIHZhbGlkYXRpb24sIGFuZCBlcnJvciBoYW5kbGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNhZmVDb25maWdXcml0ZXIge1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIEpTT04gb2JqZWN0XG5cdCAqL1xuXHRwcml2YXRlIHZhbGlkYXRlSlNPTihkYXRhOiB1bmtub3duKTogYm9vbGVhbiB7XG5cdFx0aWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSB0byBzdHJpbmdpZnkgYW5kIHBhcnNlIHRvIGVuc3VyZSBpdCdzIHZhbGlkIEpTT05cblx0XHRcdEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiYWNrdXAgb2YgYSBwbHVnaW4ncyBkYXRhLmpzb24gZmlsZVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBjcmVhdGVCYWNrdXAocGx1Z2luSWQ6IHN0cmluZywgb3JpZ2luYWxGaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChvcmlnaW5hbEZpbGUpO1xuXHRcdFx0Y29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6Ll0vZywgJy0nKTtcblx0XHRcdGNvbnN0IGJhY2t1cFBhdGggPSBgJHt0aGlzLmFwcC52YXVsdC5jb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uLmJhY2t1cC0ke3RpbWVzdGFtcH1gO1xuXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYmFja3VwUGF0aCwgY29udGVudCk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKGBTYWZlQ29uZmlnV3JpdGVyOiBDcmVhdGVkIGJhY2t1cCBhdCAke2JhY2t1cFBhdGh9YCk7XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUud2FybihgU2FmZUNvbmZpZ1dyaXRlcjogRmFpbGVkIHRvIGNyZWF0ZSBiYWNrdXAgZm9yICR7cGx1Z2luSWR9OmAsIGVycm9yKTtcblx0XHRcdC8vIERvbid0IHRocm93IC0gYmFja3VwIGZhaWx1cmUgc2hvdWxkbid0IGJsb2NrIHRoZSBvcGVyYXRpb25cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2FmZWx5IHJlYWRzIGEgcGx1Z2luJ3MgZGF0YS5qc29uIGZpbGVcblx0ICovXG5cdGFzeW5jIHJlYWRDb25maWcocGx1Z2luSWQ6IHN0cmluZyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsPiB7XG5cdFx0Y29uc3QgY29uZmlnUGF0aCA9IGAke3RoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGNvbmZpZ1BhdGgpO1xuXG5cdFx0aWYgKCFkYXRhRmlsZSB8fCAhKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRjb25zb2xlLmRlYnVnKGBTYWZlQ29uZmlnV3JpdGVyOiBDb25maWcgZmlsZSBub3QgZm91bmQgZm9yICR7cGx1Z2luSWR9YCk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpO1xuXHRcdFx0Y29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyB1bmtub3duO1xuXG5cdFx0XHRpZiAoIXRoaXMudmFsaWRhdGVKU09OKHBhcnNlZCkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihgU2FmZUNvbmZpZ1dyaXRlcjogSW52YWxpZCBKU09OIHN0cnVjdHVyZSBpbiAke3BsdWdpbklkfSBjb25maWdgKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXJzZWQgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYFNhZmVDb25maWdXcml0ZXI6IEZhaWxlZCB0byByZWFkL3BhcnNlIGNvbmZpZyBmb3IgJHtwbHVnaW5JZH06YCwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNhZmVseSB3cml0ZXMgdG8gYSBwbHVnaW4ncyBkYXRhLmpzb24gZmlsZSB3aXRoIGJhY2t1cCBhbmQgdmFsaWRhdGlvblxuXHQgKi9cblx0YXN5bmMgd3JpdGVDb25maWcoXG5cdFx0cGx1Z2luSWQ6IHN0cmluZyxcblx0XHRkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcblx0XHRvcHRpb25zOiB7IHNob3dOb3RpY2U/OiBib29sZWFuOyBjcmVhdGVCYWNrdXA/OiBib29sZWFuIH0gPSB7fVxuXHQpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zdCB7IHNob3dOb3RpY2UgPSB0cnVlLCBjcmVhdGVCYWNrdXAgPSB0cnVlIH0gPSBvcHRpb25zO1xuXG5cdFx0Ly8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlXG5cdFx0aWYgKCF0aGlzLnZhbGlkYXRlSlNPTihkYXRhKSkge1xuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGBJbnZhbGlkIGNvbmZpZ3VyYXRpb24gZGF0YSBmb3IgJHtwbHVnaW5JZH1gO1xuXHRcdFx0Y29uc29sZS5lcnJvcihgU2FmZUNvbmZpZ1dyaXRlcjogJHttZXNzYWdlfWApO1xuXHRcdFx0aWYgKHNob3dOb3RpY2UpIHtcblx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHNhdmUgJHtwbHVnaW5JZH0gc2V0dGluZ3M6IEludmFsaWQgZGF0YWApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbmZpZ1BhdGggPSBgJHt0aGlzLmFwcC52YXVsdC5jb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBDaGVjayBpZiBmaWxlIGV4aXN0c1xuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY29uZmlnUGF0aCk7XG5cblx0XHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdC8vIENyZWF0ZSBiYWNrdXAgYmVmb3JlIG1vZGlmeWluZ1xuXHRcdFx0XHRpZiAoY3JlYXRlQmFja3VwKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVCYWNrdXAocGx1Z2luSWQsIGRhdGFGaWxlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vZGlmeSBleGlzdGluZyBmaWxlXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBjb250ZW50KTtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgU2FmZUNvbmZpZ1dyaXRlcjogU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgJHtwbHVnaW5JZH0gY29uZmlnYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBDcmVhdGUgbmV3IGZpbGVcblx0XHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7dGhpcy5hcHAudmF1bHQuY29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcblx0XHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EaXIpO1xuXG5cdFx0XHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoY29uZmlnUGF0aCwgY29udGVudCk7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYFNhZmVDb25maWdXcml0ZXI6IFN1Y2Nlc3NmdWxseSBjcmVhdGVkICR7cGx1Z2luSWR9IGNvbmZpZ2ApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYFNhZmVDb25maWdXcml0ZXI6IEZhaWxlZCB0byB3cml0ZSBjb25maWcgZm9yICR7cGx1Z2luSWR9OmAsIGVycm9yKTtcblxuXHRcdFx0aWYgKHNob3dOb3RpY2UpIHtcblx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHNhdmUgJHtwbHVnaW5JZH0gc2V0dGluZ3M6ICR7bWVzc2FnZX1gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTYWZlbHkgbWVyZ2VzIG5ldyBzZXR0aW5ncyBpbnRvIGV4aXN0aW5nIHBsdWdpbiBjb25maWdcblx0ICovXG5cdGFzeW5jIG1lcmdlQ29uZmlnKFxuXHRcdHBsdWdpbklkOiBzdHJpbmcsXG5cdFx0dXBkYXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG5cdFx0b3B0aW9uczogeyBzaG93Tm90aWNlPzogYm9vbGVhbjsgY3JlYXRlQmFja3VwPzogYm9vbGVhbiB9ID0ge31cblx0KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc3QgZXhpc3RpbmdDb25maWcgPSBhd2FpdCB0aGlzLnJlYWRDb25maWcocGx1Z2luSWQpIHx8IHt9O1xuXHRcdGNvbnN0IG1lcmdlZENvbmZpZyA9IHsgLi4uZXhpc3RpbmdDb25maWcsIC4uLnVwZGF0ZXMgfTtcblx0XHRyZXR1cm4gdGhpcy53cml0ZUNvbmZpZyhwbHVnaW5JZCwgbWVyZ2VkQ29uZmlnLCBvcHRpb25zKTtcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEFzdHJvQ29tcG9zZXJDb25maWcsIENvbnRlbnRUeXBlQ29uZmlnLCBGcm9udG1hdHRlclByb3BlcnRpZXMsIFByb2plY3REZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBQYXRoUmVzb2x2ZXIgfSBmcm9tICcuL1BhdGhSZXNvbHZlcic7XG5pbXBvcnQgeyBTYWZlQ29uZmlnV3JpdGVyIH0gZnJvbSAnLi9TYWZlQ29uZmlnV3JpdGVyJztcblxudHlwZSBQbHVnaW5XaXRoU2V0dGluZ3MgPSB7XG5cdHNldHRpbmdzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XG59O1xuXG50eXBlIFBsdWdpbnNBUEkgPSB7XG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBQbHVnaW5XaXRoU2V0dGluZ3M+O1xufTtcblxuZXhwb3J0IGNsYXNzIEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3Ige1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXHRwcml2YXRlIGZyb250bWF0dGVyUHJvcGVydGllcz86IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEZyb250bWF0dGVyUHJvcGVydGllcyB9O1xuXHRwcml2YXRlIGNvbnRlbnRUeXBlcz86IENvbnRlbnRUeXBlQ29uZmlnW107XG5cdHByaXZhdGUgcGF0aFJlc29sdmVyOiBQYXRoUmVzb2x2ZXI7XG5cdHByaXZhdGUgc2FmZVdyaXRlcjogU2FmZUNvbmZpZ1dyaXRlcjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMucGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcihhcHApO1xuXHRcdHRoaXMuc2FmZVdyaXRlciA9IG5ldyBTYWZlQ29uZmlnV3JpdGVyKGFwcCk7XG5cdH1cblxuXHRjb25maWd1cmVBc3Ryb0NvbXBvc2VyKFxuXHRcdGNvbnRlbnRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSxcblx0XHRmcm9udG1hdHRlclByb3BlcnRpZXM6IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEZyb250bWF0dGVyUHJvcGVydGllcyB9LFxuXHRcdHByb2plY3RSb290OiBzdHJpbmcsXG5cdFx0Y29uZmlnRmlsZVBhdGg6IHN0cmluZyxcblx0XHRkZWZhdWx0Q29udGVudFR5cGVJZD86IHN0cmluZyxcblx0XHRwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCxcblx0XHRlbmFibGVNZHhTdXBwb3J0PzogYm9vbGVhblxuXHQpOiBQcm9taXNlPEFzdHJvQ29tcG9zZXJDb25maWc+IHtcblx0XHQvLyBTdG9yZSBmcm9udG1hdHRlclByb3BlcnRpZXMgYW5kIGNvbnRlbnRUeXBlcyBmb3IgdXNlIGluIHNhdmVDb25maWdcblx0XHR0aGlzLmZyb250bWF0dGVyUHJvcGVydGllcyA9IGZyb250bWF0dGVyUHJvcGVydGllcztcblx0XHR0aGlzLmNvbnRlbnRUeXBlcyA9IGNvbnRlbnRUeXBlcztcblx0XHRcblx0XHRjb25zdCBjb25maWc6IEFzdHJvQ29tcG9zZXJDb25maWcgPSB7XG5cdFx0XHRjdXN0b21Db250ZW50VHlwZXM6IFtdLFxuXHRcdFx0ZGVmYXVsdFRlbXBsYXRlOiAnJyxcblx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiB0aGlzLnJlbGF0aXZlUGF0aChjb25maWdGaWxlUGF0aCksXG5cdFx0XHR0ZXJtaW5hbFByb2plY3RSb290UGF0aDogdGhpcy5yZWxhdGl2ZVBhdGgocHJvamVjdFJvb3QpLFxuXHRcdFx0c2hvd01keEZpbGVzSW5FeHBsb3JlcjogZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZVxuXHRcdH07XG5cblx0XHQvLyBBZGQgYWxsIGVuYWJsZWQgY29udGVudCB0eXBlcyB0byBjdXN0b21Db250ZW50VHlwZXMgKG5ldyB1bmlmaWVkIHN0cnVjdHVyZSlcblx0XHQvLyBTZXBhcmF0ZSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBmcm9tIG90aGVycyB0byBwdXQgaXQgZmlyc3Rcblx0XHRjb25zdCBkZWZhdWx0Q29udGVudFR5cGUgPSBkZWZhdWx0Q29udGVudFR5cGVJZCA/IGNvbnRlbnRUeXBlcy5maW5kKGN0ID0+IGN0LmlkID09PSBkZWZhdWx0Q29udGVudFR5cGVJZCAmJiBjdC5lbmFibGVkKSA6IG51bGw7XG5cdFx0Y29uc3Qgb3RoZXJDb250ZW50VHlwZXMgPSBjb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQgJiYgKCFkZWZhdWx0Q29udGVudFR5cGVJZCB8fCBjdC5pZCAhPT0gZGVmYXVsdENvbnRlbnRUeXBlSWQpKTtcblxuXHRcdC8vIEFkZCBkZWZhdWx0IGNvbnRlbnQgdHlwZSBmaXJzdCBpZiBpdCBleGlzdHNcblx0XHRpZiAoZGVmYXVsdENvbnRlbnRUeXBlKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGZyb250bWF0dGVyUHJvcGVydGllc1tkZWZhdWx0Q29udGVudFR5cGUuaWRdO1xuXHRcdFx0bGV0IGxpbmtCYXNlUGF0aCA9IGRlZmF1bHRDb250ZW50VHlwZS5saW5rQmFzZVBhdGg7XG5cdFx0XHRpZiAobGlua0Jhc2VQYXRoID09PSB1bmRlZmluZWQgfHwgbGlua0Jhc2VQYXRoID09PSAnJykge1xuXHRcdFx0XHQvLyBVc2Ugb25seSB0aGUgZm9sZGVyIG5hbWUgZm9yIHRoZSBkZWZhdWx0IGxpbmsgYmFzZSBwYXRoIChlLmcuIFwic3JjL2NvbnRlbnQvcG9zdHNcIiAtPiBcIi9wb3N0cy9cIilcblx0XHRcdFx0Y29uc3QgcGF0aFBhcnRzID0gZGVmYXVsdENvbnRlbnRUeXBlLmZvbGRlci5zcGxpdCgnLycpLmZpbHRlcihwID0+IHAubGVuZ3RoID4gMCk7XG5cdFx0XHRcdGNvbnN0IGZvbGRlck5hbWUgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdIHx8IGRlZmF1bHRDb250ZW50VHlwZS5mb2xkZXI7XG5cdFx0XHRcdGxpbmtCYXNlUGF0aCA9IGAvJHtmb2xkZXJOYW1lfS9gO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBmb2xkZXJQYXRoID0gdGhpcy5wYXRoUmVzb2x2ZXIuZ2V0QXN0cm9Db21wb3NlckZvbGRlclBhdGgoZGVmYXVsdENvbnRlbnRUeXBlLmZvbGRlciwgcHJvamVjdERldGVjdGlvbik7XG5cdFx0XHRjb25maWcuY3VzdG9tQ29udGVudFR5cGVzLnB1c2goe1xuXHRcdFx0XHRpZDogZGVmYXVsdENvbnRlbnRUeXBlLmlkLFxuXHRcdFx0XHRuYW1lOiBkZWZhdWx0Q29udGVudFR5cGUubmFtZSxcblx0XHRcdFx0Zm9sZGVyOiBmb2xkZXJQYXRoLFxuXHRcdFx0XHR0ZW1wbGF0ZTogcHJvcHM/LnRlbXBsYXRlIHx8IHRoaXMuZ2VuZXJhdGVUZW1wbGF0ZShwcm9wcyksXG5cdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdGxpbmtCYXNlUGF0aDogbGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRjcmVhdGlvbk1vZGU6IGRlZmF1bHRDb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uLFxuXHRcdFx0XHRpbmRleEZpbGVOYW1lOiBkZWZhdWx0Q29udGVudFR5cGUuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gU2V0IGxlZ2FjeSBmaWVsZHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHVzaW5nIHRoZSBkZWZhdWx0IGNvbnRlbnQgdHlwZVxuXHRcdFx0Y29uZmlnLnBvc3RzRm9sZGVyID0gZm9sZGVyUGF0aDtcblx0XHRcdGNvbmZpZy5wb3N0c0NyZWF0aW9uTW9kZSA9IGRlZmF1bHRDb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uO1xuXHRcdFx0Y29uZmlnLnBvc3RzSW5kZXhGaWxlTmFtZSA9IGRlZmF1bHRDb250ZW50VHlwZS5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCc7XG5cdFx0XHRjb25maWcuZGVmYXVsdFRlbXBsYXRlID0gcHJvcHM/LnRlbXBsYXRlIHx8IHRoaXMuZ2VuZXJhdGVUZW1wbGF0ZShwcm9wcyk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIG90aGVyIGNvbnRlbnQgdHlwZXNcblx0XHRmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIG90aGVyQ29udGVudFR5cGVzKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF07XG5cdFx0XHQvLyBEZXRlcm1pbmUgbGlua0Jhc2VQYXRoOiB1c2Ugc3BlY2lmaWVkLCBvciBkZWZhdWx0IHRvIC9mb2xkZXJOYW1lL1xuXHRcdFx0Ly8gSWYgYmxhbmssIGRlZmF1bHQgdG8gL2ZvbGRlck5hbWUvLiBJZiBcIi9cIiwgdXNlIFwiL1wiIGZvciByb290LlxuXHRcdFx0bGV0IGxpbmtCYXNlUGF0aCA9IGNvbnRlbnRUeXBlLmxpbmtCYXNlUGF0aDtcblx0XHRcdGlmIChsaW5rQmFzZVBhdGggPT09IHVuZGVmaW5lZCB8fCBsaW5rQmFzZVBhdGggPT09ICcnKSB7XG5cdFx0XHRcdC8vIFVzZSBvbmx5IHRoZSBmb2xkZXIgbmFtZSBmb3IgdGhlIGRlZmF1bHQgbGluayBiYXNlIHBhdGggKGUuZy4gXCJzcmMvY29udGVudC9wb3N0c1wiIC0+IFwiL3Bvc3RzL1wiKVxuXHRcdFx0XHRjb25zdCBwYXRoUGFydHMgPSBjb250ZW50VHlwZS5mb2xkZXIuc3BsaXQoJy8nKS5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuXHRcdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXSB8fCBjb250ZW50VHlwZS5mb2xkZXI7XG5cdFx0XHRcdGxpbmtCYXNlUGF0aCA9IGAvJHtmb2xkZXJOYW1lfS9gO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdXNlciBzcGVjaWZpZWQgXCIvXCIsIGtlZXAgaXQgYXMgXCIvXCIgZm9yIHJvb3Rcblx0XHRcdFxuXHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IHRoaXMucGF0aFJlc29sdmVyLmdldEFzdHJvQ29tcG9zZXJGb2xkZXJQYXRoKGNvbnRlbnRUeXBlLmZvbGRlciwgcHJvamVjdERldGVjdGlvbik7XG5cdFx0XHRjb25maWcuY3VzdG9tQ29udGVudFR5cGVzLnB1c2goe1xuXHRcdFx0XHRpZDogY29udGVudFR5cGUuaWQsXG5cdFx0XHRcdG5hbWU6IGNvbnRlbnRUeXBlLm5hbWUsXG5cdFx0XHRcdGZvbGRlcjogZm9sZGVyUGF0aCxcblx0XHRcdFx0Ly8gVXNlIHRlbXBsYXRlIGZyb20gcHJvcHMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZ2VuZXJhdGVcblx0XHRcdFx0dGVtcGxhdGU6IHByb3BzPy50ZW1wbGF0ZSB8fCB0aGlzLmdlbmVyYXRlVGVtcGxhdGUocHJvcHMpLFxuXHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRsaW5rQmFzZVBhdGg6IGxpbmtCYXNlUGF0aCxcblx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBjb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uLFxuXHRcdFx0XHRpbmRleEZpbGVOYW1lOiBjb250ZW50VHlwZS5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVUZW1wbGF0ZShwcm9wczogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcblx0XHQvLyBVc2UgdGVtcGxhdGUgZnJvbSBwcm9wcyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBnZW5lcmF0ZSBkZWZhdWx0XG5cdFx0aWYgKHByb3BzPy50ZW1wbGF0ZSkge1xuXHRcdFx0cmV0dXJuIHByb3BzLnRlbXBsYXRlO1xuXHRcdH1cblxuXHRcdGlmICghcHJvcHMpIHtcblx0XHRcdHJldHVybiAnLS0tXFxudGl0bGU6IFwie3t0aXRsZX19XCJcXG4tLS1cXG4nO1xuXHRcdH1cblxuXHRcdGxldCB0ZW1wbGF0ZSA9ICctLS1cXG4nO1xuXHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLnRpdGxlUHJvcGVydHkgfHwgJ3RpdGxlJ306IFwie3t0aXRsZX19XCJcXG5gO1xuXHRcdFxuXHRcdGlmIChwcm9wcy5kYXRlUHJvcGVydHkpIHtcblx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRhdGVQcm9wZXJ0eX06IHt7ZGF0ZX19XFxuYDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9OiBcIlwiXFxuYDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHByb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMudGFnc1Byb3BlcnR5fTogW11cXG5gO1xuXHRcdH1cblx0XHRcblx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSkge1xuXHRcdFx0Y29uc3QgZHJhZnRWYWx1ZSA9IHByb3BzLmRyYWZ0TG9naWMgPT09ICdmYWxzZS1kcmFmdCcgPyAnZmFsc2UnIDogJ3RydWUnO1xuXHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMuZHJhZnRQcm9wZXJ0eX06ICR7ZHJhZnRWYWx1ZX1cXG5gO1xuXHRcdH1cblx0XHRcblx0XHR0ZW1wbGF0ZSArPSAnLS0tXFxuJztcblxuXHRcdHJldHVybiB0ZW1wbGF0ZTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0Q3JlYXRpb25Nb2RlRnJvbUF0dGFjaG1lbnRIYW5kbGluZyhtb2RlOiAnc3BlY2lmaWVkLWZvbGRlcicgfCAnc2FtZS1mb2xkZXInIHwgJ3N1YmZvbGRlcicpOiAnZmlsZScgfCAnZm9sZGVyJyB7XG5cdFx0Ly8gc2FtZS1mb2xkZXIgbWVhbnMgYXR0YWNobWVudHMgYXJlIGluIHRoZSBzYW1lIGZvbGRlciBhcyB0aGUgZmlsZSAoZm9sZGVyLWJhc2VkIGFwcHJvYWNoKVxuXHRcdC8vIHNwZWNpZmllZC1mb2xkZXIgYW5kIHN1YmZvbGRlciBtZWFuIGF0dGFjaG1lbnRzIGFyZSBpbiBzZXBhcmF0ZSBmb2xkZXJzIChmaWxlLWJhc2VkIGFwcHJvYWNoKVxuXHRcdHJldHVybiBtb2RlID09PSAnc2FtZS1mb2xkZXInID8gJ2ZvbGRlcicgOiAnZmlsZSc7XG5cdH1cblxuXHRwcml2YXRlIHJlbGF0aXZlUGF0aChpbnB1dFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0Ly8gSWYgcGF0aCBpcyBhbHJlYWR5IHJlbGF0aXZlLCByZXR1cm4gYXMtaXMgKG5vIGxlYWRpbmcgLyBvciBkcml2ZSBsZXR0ZXIpXG5cdFx0aWYgKCFpbnB1dFBhdGguc3RhcnRzV2l0aCgnLycpICYmICEvXltBLVpdOi8udGVzdChpbnB1dFBhdGgpKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXRQYXRoO1xuXHRcdH1cblx0XHRcblx0XHQvLyBDb252ZXJ0IGFic29sdXRlIHBhdGggdG8gcmVsYXRpdmUgZnJvbSB2YXVsdCByb290XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xuXHRcdGlmICghdmF1bHRQYXRoKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXRQYXRoO1xuXHRcdH1cblx0XHRcblx0XHQvLyBOb3JtYWxpemUgcGF0aHMgKHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMsIHJlbW92ZSB0cmFpbGluZyBzbGFzaGVzKVxuXHRcdGNvbnN0IHZhdWx0Tm9ybWFsaXplZCA9IHZhdWx0UGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0XHRjb25zdCBhYnNvbHV0ZU5vcm1hbGl6ZWQgPSBpbnB1dFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdFx0XG5cdFx0aWYgKGFic29sdXRlTm9ybWFsaXplZC5zdGFydHNXaXRoKHZhdWx0Tm9ybWFsaXplZCkpIHtcblx0XHRcdGNvbnN0IHJlbGF0aXZlID0gYWJzb2x1dGVOb3JtYWxpemVkLnNsaWNlKHZhdWx0Tm9ybWFsaXplZC5sZW5ndGgpO1xuXHRcdFx0Ly8gUmVtb3ZlIGxlYWRpbmcgcGF0aCBzZXBhcmF0b3Jcblx0XHRcdHJldHVybiByZWxhdGl2ZS5zdGFydHNXaXRoKCcvJykgPyByZWxhdGl2ZS5zbGljZSgxKSA6IHJlbGF0aXZlO1xuXHRcdH1cblx0XHRcblx0XHQvLyBQYXRoIGlzIG91dHNpZGUgdmF1bHQsIHJldHVybiBhcy1pc1xuXHRcdHJldHVybiBpbnB1dFBhdGg7XG5cdH1cblxuXHRhc3luYyBzYXZlQ29uZmlnKGNvbmZpZzogQXN0cm9Db21wb3NlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBVc2UgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZCBsaWtlIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgZG9lc1xuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XG5cdFx0XHRjb25zdCBhc3Ryb0NvbXBvc2VyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uWydhc3Ryby1jb21wb3NlciddO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWFzdHJvQ29tcG9zZXJQbHVnaW4pIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdBc3Ryb0NvbXBvc2VyQ29uZmlnOiBBc3RybyBDb21wb3NlciBwbHVnaW4gbm90IGZvdW5kLCB1c2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICghYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncykge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0FzdHJvQ29tcG9zZXJDb25maWc6IEFzdHJvIENvbXBvc2VyIHBsdWdpbiBzZXR0aW5ncyBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBsdWdpblNldHRpbmdzID0gYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncztcblx0XHRcdFxuXHRcdFx0Ly8gVXBkYXRlIHRlbXBsYXRlcyBmcm9tIGNvbmZpZ1xuXHRcdFx0aWYgKGNvbmZpZy5kZWZhdWx0VGVtcGxhdGUpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZGVmYXVsdFRlbXBsYXRlID0gY29uZmlnLmRlZmF1bHRUZW1wbGF0ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucGFnZVRlbXBsYXRlKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLnBhZ2VUZW1wbGF0ZSA9IGNvbmZpZy5wYWdlVGVtcGxhdGU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFVwZGF0ZSBwb3N0cy9wYWdlcyBmb2xkZXIgc2V0dGluZ3Ncblx0XHRcdGlmIChjb25maWcucG9zdHNGb2xkZXIpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MucG9zdHNGb2xkZXIgPSBjb25maWcucG9zdHNGb2xkZXI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnBvc3RzQ3JlYXRpb25Nb2RlKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmNyZWF0aW9uTW9kZSA9IGNvbmZpZy5wb3N0c0NyZWF0aW9uTW9kZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucG9zdHNJbmRleEZpbGVOYW1lKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmluZGV4RmlsZU5hbWUgPSBjb25maWcucG9zdHNJbmRleEZpbGVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5lbmFibGVQYWdlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmVuYWJsZVBhZ2VzID0gY29uZmlnLmVuYWJsZVBhZ2VzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5wYWdlc0ZvbGRlcikge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5wYWdlc0ZvbGRlciA9IGNvbmZpZy5wYWdlc0ZvbGRlcjtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucGFnZXNDcmVhdGlvbk1vZGUpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MucGFnZXNDcmVhdGlvbk1vZGUgPSBjb25maWcucGFnZXNDcmVhdGlvbk1vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnBhZ2VzSW5kZXhGaWxlTmFtZSkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5wYWdlc0luZGV4RmlsZU5hbWUgPSBjb25maWcucGFnZXNJbmRleEZpbGVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBVcGRhdGUgY29uZmlnIHBhdGhzXG5cdFx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoID0gY29uZmlnLmNvbmZpZ0ZpbGVQYXRoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy50ZXJtaW5hbFByb2plY3RSb290UGF0aCA9IGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRW5zdXJlIGNvbW1hbmRzIGFyZSBlbmFibGVkIG9ubHkgaWYgcGF0aHMgYXJlIHByZXNlbnRcblx0XHRcdGlmIChjb25maWcuY29uZmlnRmlsZVBhdGggJiYgY29uZmlnLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmVuYWJsZU9wZW5UZXJtaW5hbENvbW1hbmQgPSB0cnVlO1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVPcGVuQ29uZmlnRmlsZUNvbW1hbmQgPSB0cnVlO1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVUZXJtaW5hbFJpYmJvbkljb24gPSB0cnVlO1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVDb25maWdSaWJib25JY29uID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVXBkYXRlIE1EWCBzdXBwb3J0IGZsYWdcblx0XHRcdGlmIChjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3JlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLnNob3dNZHhGaWxlc0luRXhwbG9yZXIgPSBjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3Jlcjtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQXN0cm9Db21wb3NlckNvbmZpZzogU2V0IHNob3dNZHhGaWxlc0luRXhwbG9yZXIgdG8nLCBjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3Jlcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdBc3Ryb0NvbXBvc2VyQ29uZmlnOiBzaG93TWR4RmlsZXNJbkV4cGxvcmVyIGlzIHVuZGVmaW5lZCwgbm90IHVwZGF0aW5nJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFVwZGF0ZSBjb250ZW50VHlwZXMgYXJyYXkgKG5ldyB1bmlmaWVkIHN0cnVjdHVyZSlcblx0XHRcdC8vIEluaXRpYWxpemUgY29udGVudFR5cGVzIGFycmF5IGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShwbHVnaW5TZXR0aW5ncy5jb250ZW50VHlwZXMpKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmNvbnRlbnRUeXBlcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBNZXJnZS91cGRhdGUgY29udGVudFR5cGVzIGFycmF5IC0gbWF0Y2ggYnkgSUQgZmlyc3QsIHRoZW4gZmFsbGJhY2sgdG8gbmFtZStmb2xkZXJcblx0XHRcdGZvciAoY29uc3QgbmV3VHlwZSBvZiBjb25maWcuY3VzdG9tQ29udGVudFR5cGVzKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgZnJvbnRtYXR0ZXIgcHJvcGVydGllcyB0byBjaGVjayBkcmFmdCBzdGF0dXNcblx0XHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSB0aGlzLmNvbnRlbnRUeXBlcz8uZmluZChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRcdGNvbnN0IHByb3BzID0gY29udGVudFR5cGUgJiYgdGhpcy5mcm9udG1hdHRlclByb3BlcnRpZXMgPyB0aGlzLmZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF0gOiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHVuZGVyc2NvcmUgcHJlZml4IHNob3VsZCBiZSBlbmFibGVkXG5cdFx0XHRcdC8vIEVuYWJsZSBpZiBoYXNEcmFmdFN0YXR1cyBpcyB0cnVlIGJ1dCBkcmFmdFByb3BlcnR5IGlzIGJsYW5rL3VuZGVmaW5lZFxuXHRcdFx0XHRjb25zdCBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4ID0gcHJvcHM/Lmhhc0RyYWZ0U3RhdHVzID09PSB0cnVlICYmICFwcm9wcz8uZHJhZnRQcm9wZXJ0eTtcblxuXHRcdFx0XHQvLyBGaW5kIGV4aXN0aW5nIGVudHJ5IC0gcHJlZmVyIElEIG1hdGNoaW5nLCBmYWxsYmFjayB0byBuYW1lK2ZvbGRlciBmb3IgZHVwbGljYXRlIGRldGVjdGlvblxuXHRcdFx0XHRjb25zdCBjb250ZW50VHlwZXMgPSAocGx1Z2luU2V0dGluZ3MuY29udGVudFR5cGVzIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW107XG5cdFx0XHRcdGxldCBleGlzdGluZ0luZGV4ID0gLTE7XG5cdFx0XHRcdGxldCBtYXRjaGVkQnlJZCA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIEZpcnN0LCB0cnkgdG8gbWF0Y2ggYnkgSUQgKHByZWZlcnJlZCAtIHVuaXF1ZSBpZGVudGlmaWVyKVxuXHRcdFx0XHRpZiAobmV3VHlwZS5pZCkge1xuXHRcdFx0XHRcdGV4aXN0aW5nSW5kZXggPSBjb250ZW50VHlwZXMuZmluZEluZGV4KChjdDogeyBpZD86IHN0cmluZyB9KSA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRcdFx0aWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZEJ5SWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZhbGxiYWNrIHRvIG5hbWUrZm9sZGVyIGZvciBkdXBsaWNhdGUgZGV0ZWN0aW9uIChwcmV2ZW50cyBjcmVhdGluZyBkdXBsaWNhdGVzKVxuXHRcdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA8IDApIHtcblx0XHRcdFx0XHRleGlzdGluZ0luZGV4ID0gY29udGVudFR5cGVzLmZpbmRJbmRleCgoY3Q6IHsgbmFtZT86IHN0cmluZzsgZm9sZGVyPzogc3RyaW5nIH0pID0+XG5cdFx0XHRcdFx0XHRjdC5uYW1lID09PSBuZXdUeXBlLm5hbWUgJiYgY3QuZm9sZGVyID09PSBuZXdUeXBlLmZvbGRlclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZyBlbnRyeSAtIHByZXNlcnZlIG90aGVyIHByb3BlcnRpZXMgbGlrZSBpZ25vcmVTdWJmb2xkZXJzLCBlbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdFx0Ly8gSU1QT1JUQU5UOiBQcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgSUQgd2hlbiBtYXRjaGVkIGJ5IG5hbWUrZm9sZGVyIChkb24ndCBvdmVyd3JpdGUgd2l0aCBuZXcgSUQpXG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdFbnRyeSA9IGNvbnRlbnRUeXBlc1tleGlzdGluZ0luZGV4XSBhcyB7IGlkPzogc3RyaW5nIH07XG5cdFx0XHRcdFx0Y29udGVudFR5cGVzW2V4aXN0aW5nSW5kZXhdID0ge1xuXHRcdFx0XHRcdFx0Li4uZXhpc3RpbmdFbnRyeSxcblx0XHRcdFx0XHRcdC8vIE9ubHkgdXBkYXRlIElEIGlmIHdlIG1hdGNoZWQgYnkgSUQsIG90aGVyd2lzZSBrZWVwIGV4aXN0aW5nIElEIGZvciBjb25zaXN0ZW5jeVxuXHRcdFx0XHRcdFx0aWQ6IG1hdGNoZWRCeUlkID8gbmV3VHlwZS5pZCA6IChleGlzdGluZ0VudHJ5LmlkIHx8IG5ld1R5cGUuaWQpLFxuXHRcdFx0XHRcdFx0bmFtZTogbmV3VHlwZS5uYW1lLFxuXHRcdFx0XHRcdFx0Zm9sZGVyOiBuZXdUeXBlLmZvbGRlcixcblx0XHRcdFx0XHRcdGxpbmtCYXNlUGF0aDogbmV3VHlwZS5saW5rQmFzZVBhdGgsXG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogbmV3VHlwZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdGVuYWJsZWQ6IG5ld1R5cGUuZW5hYmxlZCxcblx0XHRcdFx0XHRcdGNyZWF0aW9uTW9kZTogbmV3VHlwZS5jcmVhdGlvbk1vZGUsXG5cdFx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBuZXdUeXBlLmluZGV4RmlsZU5hbWUsXG5cdFx0XHRcdFx0XHRlbmFibGVVbmRlcnNjb3JlUHJlZml4OiBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBBZGQgbmV3IGVudHJ5IHdpdGggYWxsIHJlcXVpcmVkIHByb3BlcnRpZXNcblx0XHRcdFx0XHRjb250ZW50VHlwZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRpZDogbmV3VHlwZS5pZCxcblx0XHRcdFx0XHRcdG5hbWU6IG5ld1R5cGUubmFtZSxcblx0XHRcdFx0XHRcdGZvbGRlcjogbmV3VHlwZS5mb2xkZXIsXG5cdFx0XHRcdFx0XHRsaW5rQmFzZVBhdGg6IG5ld1R5cGUubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IG5ld1R5cGUudGVtcGxhdGUsXG5cdFx0XHRcdFx0XHRlbmFibGVkOiBuZXdUeXBlLmVuYWJsZWQsXG5cdFx0XHRcdFx0XHRjcmVhdGlvbk1vZGU6IG5ld1R5cGUuY3JlYXRpb25Nb2RlLFxuXHRcdFx0XHRcdFx0aW5kZXhGaWxlTmFtZTogbmV3VHlwZS5pbmRleEZpbGVOYW1lLFxuXHRcdFx0XHRcdFx0aWdub3JlU3ViZm9sZGVyczogZmFsc2UsXG5cdFx0XHRcdFx0XHRlbmFibGVVbmRlcnNjb3JlUHJlZml4OiBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQWxzbyB1cGRhdGUgbGVnYWN5IGN1c3RvbUNvbnRlbnRUeXBlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdHBsdWdpblNldHRpbmdzLmN1c3RvbUNvbnRlbnRUeXBlcyA9IHRoaXMubWVyZ2VDdXN0b21Db250ZW50VHlwZXMoXG5cdFx0XHRcdChwbHVnaW5TZXR0aW5ncy5jdXN0b21Db250ZW50VHlwZXMgYXMgQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KSB8fCBbXSxcblx0XHRcdFx0KGNvbmZpZy5jdXN0b21Db250ZW50VHlwZXMgYXMgdW5rbm93biBhcyBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4pIHx8IFtdXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHQvLyBTYXZlIHRoZSBzZXR0aW5ncyB1c2luZyBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kXG5cdFx0XHRpZiAodHlwZW9mIGFzdHJvQ29tcG9zZXJQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGF3YWl0IGFzdHJvQ29tcG9zZXJQbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0FzdHJvQ29tcG9zZXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0FzdHJvQ29tcG9zZXJDb25maWc6IFBsdWdpbiBzYXZlU2V0dGluZ3Mgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2snKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgQXN0cm8gQ29tcG9zZXIgY29uZmlnIHZpYSBwbHVnaW4gbWV0aG9kOicsIGVycm9yKTtcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogQXN0cm9Db21wb3NlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHBsdWdpbklkID0gJ2FzdHJvLWNvbXBvc2VyJztcblxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgZGF0YSBzYWZlbHlcblx0XHRsZXQgZXhpc3RpbmdEYXRhID0gYXdhaXQgdGhpcy5zYWZlV3JpdGVyLnJlYWRDb25maWcocGx1Z2luSWQpO1xuXHRcdGlmICghZXhpc3RpbmdEYXRhKSB7XG5cdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gTWVyZ2UgY29uZmlnIGludG8gZXhpc3RpbmcgZGF0YVxuXHRcdGlmIChjb25maWcuZGVmYXVsdFRlbXBsYXRlKSBleGlzdGluZ0RhdGEuZGVmYXVsdFRlbXBsYXRlID0gY29uZmlnLmRlZmF1bHRUZW1wbGF0ZTtcblx0XHRpZiAoY29uZmlnLnBhZ2VUZW1wbGF0ZSkgZXhpc3RpbmdEYXRhLnBhZ2VUZW1wbGF0ZSA9IGNvbmZpZy5wYWdlVGVtcGxhdGU7XG5cdFx0aWYgKGNvbmZpZy5wb3N0c0ZvbGRlcikgZXhpc3RpbmdEYXRhLnBvc3RzRm9sZGVyID0gY29uZmlnLnBvc3RzRm9sZGVyO1xuXHRcdGlmIChjb25maWcucG9zdHNDcmVhdGlvbk1vZGUpIGV4aXN0aW5nRGF0YS5jcmVhdGlvbk1vZGUgPSBjb25maWcucG9zdHNDcmVhdGlvbk1vZGU7XG5cdFx0aWYgKGNvbmZpZy5wb3N0c0luZGV4RmlsZU5hbWUpIGV4aXN0aW5nRGF0YS5pbmRleEZpbGVOYW1lID0gY29uZmlnLnBvc3RzSW5kZXhGaWxlTmFtZTtcblx0XHRpZiAoY29uZmlnLmVuYWJsZVBhZ2VzICE9PSB1bmRlZmluZWQpIGV4aXN0aW5nRGF0YS5lbmFibGVQYWdlcyA9IGNvbmZpZy5lbmFibGVQYWdlcztcblx0XHRpZiAoY29uZmlnLnBhZ2VzRm9sZGVyKSBleGlzdGluZ0RhdGEucGFnZXNGb2xkZXIgPSBjb25maWcucGFnZXNGb2xkZXI7XG5cdFx0aWYgKGNvbmZpZy5wYWdlc0NyZWF0aW9uTW9kZSkgZXhpc3RpbmdEYXRhLnBhZ2VzQ3JlYXRpb25Nb2RlID0gY29uZmlnLnBhZ2VzQ3JlYXRpb25Nb2RlO1xuXHRcdGlmIChjb25maWcucGFnZXNJbmRleEZpbGVOYW1lKSBleGlzdGluZ0RhdGEucGFnZXNJbmRleEZpbGVOYW1lID0gY29uZmlnLnBhZ2VzSW5kZXhGaWxlTmFtZTtcblx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoKSBleGlzdGluZ0RhdGEuY29uZmlnRmlsZVBhdGggPSBjb25maWcuY29uZmlnRmlsZVBhdGg7XG5cdFx0aWYgKGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkgZXhpc3RpbmdEYXRhLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoID0gY29uZmlnLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoO1xuXHRcdGlmIChjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3JlciAhPT0gdW5kZWZpbmVkKSBleGlzdGluZ0RhdGEuc2hvd01keEZpbGVzSW5FeHBsb3JlciA9IGNvbmZpZy5zaG93TWR4RmlsZXNJbkV4cGxvcmVyO1xuXG5cdFx0Ly8gRW5zdXJlIGNvbW1hbmRzIGFyZSBlbmFibGVkIG9ubHkgaWYgcGF0aHMgYXJlIHByZXNlbnRcblx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoICYmIGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkge1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmVuYWJsZU9wZW5UZXJtaW5hbENvbW1hbmQgPSB0cnVlO1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmVuYWJsZU9wZW5Db25maWdGaWxlQ29tbWFuZCA9IHRydWU7XG5cdFx0XHRleGlzdGluZ0RhdGEuZW5hYmxlVGVybWluYWxSaWJib25JY29uID0gdHJ1ZTtcblx0XHRcdGV4aXN0aW5nRGF0YS5lbmFibGVDb25maWdSaWJib25JY29uID0gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gVXBkYXRlIGNvbnRlbnRUeXBlcyBhcnJheSAobmV3IHVuaWZpZWQgc3RydWN0dXJlKVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShleGlzdGluZ0RhdGEuY29udGVudFR5cGVzKSkge1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmNvbnRlbnRUeXBlcyA9IFtdO1xuXHRcdH1cblx0XHRcblx0XHQvLyBNZXJnZS91cGRhdGUgY29udGVudFR5cGVzIGFycmF5IC0gbWF0Y2ggYnkgSUQgZmlyc3QsIHRoZW4gZmFsbGJhY2sgdG8gbmFtZStmb2xkZXJcblx0XHRmb3IgKGNvbnN0IG5ld1R5cGUgb2YgY29uZmlnLmN1c3RvbUNvbnRlbnRUeXBlcykge1xuXHRcdFx0Ly8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBmcm9udG1hdHRlciBwcm9wZXJ0aWVzIHRvIGNoZWNrIGRyYWZ0IHN0YXR1c1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSB0aGlzLmNvbnRlbnRUeXBlcz8uZmluZChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGNvbnRlbnRUeXBlICYmIHRoaXMuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzID8gdGhpcy5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdIDogdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgdW5kZXJzY29yZSBwcmVmaXggc2hvdWxkIGJlIGVuYWJsZWRcblx0XHRcdC8vIEVuYWJsZSBpZiBoYXNEcmFmdFN0YXR1cyBpcyB0cnVlIGJ1dCBkcmFmdFByb3BlcnR5IGlzIGJsYW5rL3VuZGVmaW5lZFxuXHRcdFx0Y29uc3Qgc2hvdWxkRW5hYmxlVW5kZXJzY29yZVByZWZpeCA9IHByb3BzPy5oYXNEcmFmdFN0YXR1cyA9PT0gdHJ1ZSAmJiAhcHJvcHM/LmRyYWZ0UHJvcGVydHk7XG5cblx0XHRcdC8vIEZpbmQgZXhpc3RpbmcgZW50cnkgLSBwcmVmZXIgSUQgbWF0Y2hpbmcsIGZhbGxiYWNrIHRvIG5hbWUrZm9sZGVyIGZvciBkdXBsaWNhdGUgZGV0ZWN0aW9uXG5cdFx0XHRjb25zdCBjb250ZW50VHlwZXMgPSAoZXhpc3RpbmdEYXRhLmNvbnRlbnRUeXBlcyBhcyBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4pIHx8IFtdO1xuXHRcdFx0bGV0IGV4aXN0aW5nSW5kZXggPSAtMTtcblx0XHRcdGxldCBtYXRjaGVkQnlJZCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBGaXJzdCwgdHJ5IHRvIG1hdGNoIGJ5IElEIChwcmVmZXJyZWQgLSB1bmlxdWUgaWRlbnRpZmllcilcblx0XHRcdGlmIChuZXdUeXBlLmlkKSB7XG5cdFx0XHRcdGV4aXN0aW5nSW5kZXggPSBjb250ZW50VHlwZXMuZmluZEluZGV4KChjdDogeyBpZD86IHN0cmluZyB9KSA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRcdGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcblx0XHRcdFx0XHRtYXRjaGVkQnlJZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gbmFtZStmb2xkZXIgZm9yIGR1cGxpY2F0ZSBkZXRlY3Rpb24gKHByZXZlbnRzIGNyZWF0aW5nIGR1cGxpY2F0ZXMpXG5cdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA8IDApIHtcblx0XHRcdFx0ZXhpc3RpbmdJbmRleCA9IGNvbnRlbnRUeXBlcy5maW5kSW5kZXgoKGN0OiB7IG5hbWU/OiBzdHJpbmc7IGZvbGRlcj86IHN0cmluZyB9KSA9PlxuXHRcdFx0XHRcdGN0Lm5hbWUgPT09IG5ld1R5cGUubmFtZSAmJiBjdC5mb2xkZXIgPT09IG5ld1R5cGUuZm9sZGVyXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZyBlbnRyeSAtIHByZXNlcnZlIG90aGVyIHByb3BlcnRpZXNcblx0XHRcdFx0Ly8gSU1QT1JUQU5UOiBQcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgSUQgd2hlbiBtYXRjaGVkIGJ5IG5hbWUrZm9sZGVyIChkb24ndCBvdmVyd3JpdGUgd2l0aCBuZXcgSUQpXG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nRW50cnkgPSBjb250ZW50VHlwZXNbZXhpc3RpbmdJbmRleF0gYXMgeyBpZD86IHN0cmluZyB9O1xuXHRcdFx0XHRjb250ZW50VHlwZXNbZXhpc3RpbmdJbmRleF0gPSB7XG5cdFx0XHRcdFx0Li4uZXhpc3RpbmdFbnRyeSxcblx0XHRcdFx0XHQvLyBPbmx5IHVwZGF0ZSBJRCBpZiB3ZSBtYXRjaGVkIGJ5IElELCBvdGhlcndpc2Uga2VlcCBleGlzdGluZyBJRCBmb3IgY29uc2lzdGVuY3lcblx0XHRcdFx0XHRpZDogbWF0Y2hlZEJ5SWQgPyBuZXdUeXBlLmlkIDogKGV4aXN0aW5nRW50cnkuaWQgfHwgbmV3VHlwZS5pZCksXG5cdFx0XHRcdFx0bmFtZTogbmV3VHlwZS5uYW1lLFxuXHRcdFx0XHRcdGZvbGRlcjogbmV3VHlwZS5mb2xkZXIsXG5cdFx0XHRcdFx0bGlua0Jhc2VQYXRoOiBuZXdUeXBlLmxpbmtCYXNlUGF0aCxcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmV3VHlwZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRlbmFibGVkOiBuZXdUeXBlLmVuYWJsZWQsXG5cdFx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBuZXdUeXBlLmNyZWF0aW9uTW9kZSxcblx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBuZXdUeXBlLmluZGV4RmlsZU5hbWUsXG5cdFx0XHRcdFx0ZW5hYmxlVW5kZXJzY29yZVByZWZpeDogc2hvdWxkRW5hYmxlVW5kZXJzY29yZVByZWZpeFxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQWRkIG5ldyBlbnRyeVxuXHRcdFx0XHRjb250ZW50VHlwZXMucHVzaCh7XG5cdFx0XHRcdFx0aWQ6IG5ld1R5cGUuaWQsXG5cdFx0XHRcdFx0bmFtZTogbmV3VHlwZS5uYW1lLFxuXHRcdFx0XHRcdGZvbGRlcjogbmV3VHlwZS5mb2xkZXIsXG5cdFx0XHRcdFx0bGlua0Jhc2VQYXRoOiBuZXdUeXBlLmxpbmtCYXNlUGF0aCxcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmV3VHlwZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRlbmFibGVkOiBuZXdUeXBlLmVuYWJsZWQsXG5cdFx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBuZXdUeXBlLmNyZWF0aW9uTW9kZSxcblx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBuZXdUeXBlLmluZGV4RmlsZU5hbWUsXG5cdFx0XHRcdFx0aWdub3JlU3ViZm9sZGVyczogZmFsc2UsXG5cdFx0XHRcdFx0ZW5hYmxlVW5kZXJzY29yZVByZWZpeDogc2hvdWxkRW5hYmxlVW5kZXJzY29yZVByZWZpeFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gQWxzbyB1cGRhdGUgbGVnYWN5IGN1c3RvbUNvbnRlbnRUeXBlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRleGlzdGluZ0RhdGEuY3VzdG9tQ29udGVudFR5cGVzID0gdGhpcy5tZXJnZUN1c3RvbUNvbnRlbnRUeXBlcyhcblx0XHRcdChleGlzdGluZ0RhdGEuY3VzdG9tQ29udGVudFR5cGVzIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW10sXG5cdFx0XHQoY29uZmlnLmN1c3RvbUNvbnRlbnRUeXBlcyBhcyB1bmtub3duIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW11cblx0XHQpO1xuXG5cdFx0Ly8gV3JpdGUgY29uZmlnIHNhZmVseSB3aXRoIGJhY2t1cCBhbmQgdmFsaWRhdGlvblxuXHRcdGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnNhZmVXcml0ZXIud3JpdGVDb25maWcocGx1Z2luSWQsIGV4aXN0aW5nRGF0YSwge1xuXHRcdFx0c2hvd05vdGljZTogdHJ1ZSxcblx0XHRcdGNyZWF0ZUJhY2t1cDogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFzdWNjZXNzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEFzdHJvIENvbXBvc2VyIGNvbmZpZ3VyYXRpb24nKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG1lcmdlQ3VzdG9tQ29udGVudFR5cGVzKGV4aXN0aW5nOiBBcnJheTx7IGlkPzogc3RyaW5nOyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0+LCBuZXdUeXBlczogQXJyYXk8eyBpZD86IHN0cmluZzsgW2tleTogc3RyaW5nXTogdW5rbm93biB9Pik6IEFycmF5PHsgaWQ/OiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IHVua25vd24gfT4ge1xuXHRcdGNvbnN0IG1lcmdlZCA9IFsuLi5leGlzdGluZ107XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBuZXdUeXBlIG9mIG5ld1R5cGVzKSB7XG5cdFx0XHRjb25zdCBleGlzdGluZ0luZGV4ID0gbWVyZ2VkLmZpbmRJbmRleChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZ1xuXHRcdFx0XHRtZXJnZWRbZXhpc3RpbmdJbmRleF0gPSB7IC4uLm1lcmdlZFtleGlzdGluZ0luZGV4XSwgLi4ubmV3VHlwZSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQWRkIG5ld1xuXHRcdFx0XHRtZXJnZWQucHVzaChuZXdUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG1lcmdlZDtcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzIChtYXkgbm90IGJlIGluIHR5cGVzIHlldClcbmZ1bmN0aW9uIHNldENzc1Byb3BzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG5cdH1cbn1cbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSwgRXhhbXBsZUZyb250bWF0dGVyIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBbmFseXplciB9IGZyb20gJy4uLy4uL3V0aWxzL0Zyb250bWF0dGVyQW5hbHl6ZXInO1xuaW1wb3J0IHsgUGF0aFJlc29sdmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvUGF0aFJlc29sdmVyJztcblxuZXhwb3J0IGNsYXNzIEZyb250bWF0dGVyUHJvcGVydGllc1N0ZXAgZXh0ZW5kcyBCYXNlV2l6YXJkU3RlcCB7XG5cdHByaXZhdGUgZnJvbnRtYXR0ZXJBbmFseXplcjogRnJvbnRtYXR0ZXJBbmFseXplcjtcblx0cHJpdmF0ZSBleGFtcGxlczogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRXhhbXBsZUZyb250bWF0dGVyIHwgdW5kZWZpbmVkIH0gPSB7fTtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xuXHRcdHN1cGVyKGFwcCwgY29udGFpbmVyRWwsIHN0YXRlLCBvbk5leHQsIG9uQmFjaywgb25DYW5jZWwpO1xuXHRcdHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplciA9IG5ldyBGcm9udG1hdHRlckFuYWx5emVyKGFwcCk7XG5cdH1cblxuXHRhc3luYyBkaXNwbGF5KCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cblx0XHQvLyBDbGVhciBvbmx5IHRoZSBzdGVwIGNvbnRlbnQsIHByZXNlcnZlIG5hdmlnYXRpb24gZm9vdGVyXG5cdFx0Y29uc3QgZXhpc3RpbmdXcmFwcGVyID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignLmZyb250bWF0dGVyLXN0ZXAtY29udGVudCcpO1xuXHRcdGlmIChleGlzdGluZ1dyYXBwZXIpIHtcblx0XHRcdGV4aXN0aW5nV3JhcHBlci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRjb25zdCBzdGVwQ29udGVudFdyYXBwZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdmcm9udG1hdHRlci1zdGVwLWNvbnRlbnQnIH0pO1xuXG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0Zyb250bWF0dGVyIHByb3BlcnRpZXMnIH0pO1xuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgncCcsIHtcblx0XHRcdHRleHQ6ICdNYXAgZnJvbnRtYXR0ZXIgcHJvcGVydGllcyBmb3IgZWFjaCBjb250ZW50IHR5cGUuIFdlXFwnbGwgZmluZCBleGFtcGxlIGZpbGVzIHRvIGhlbHAgeW91Lidcblx0XHR9KTtcblxuXHRcdGZvciAoY29uc3QgY29udGVudFR5cGUgb2YgdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMpIHtcblx0XHRcdGlmICghY29udGVudFR5cGUuZW5hYmxlZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIGEgd3JhcHBlciBmb3IgdGhpcyBjb250ZW50IHR5cGUncyBzZXR0aW5nc1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGVXcmFwcGVyID0gc3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZURpdih7IGNsczogJ2NvbnRlbnQtdHlwZS1zZXR0aW5ncycgfSk7XG5cblx0XHRcdC8vIEZpbmQgZXhhbXBsZSBmaWxlIGFuZCBhbGwgcHJvcGVydGllc1xuXHRcdFx0Y29uc3QgcGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcih0aGlzLmFwcCk7XG5cdFx0XHRjb25zdCBmb2xkZXJQYXRoID0gcGF0aFJlc29sdmVyLmdldEZvbGRlclBhdGhGcm9tVmF1bHRSb290KGNvbnRlbnRUeXBlLmZvbGRlciwgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcblxuXHRcdFx0aWYgKCF0aGlzLmV4YW1wbGVzW2NvbnRlbnRUeXBlLmlkXSkge1xuXHRcdFx0XHRjb25zdCBleGFtcGxlID0gYXdhaXQgdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmZpbmRFeGFtcGxlRmlsZShmb2xkZXJQYXRoLCB0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQpO1xuXHRcdFx0XHRpZiAoZXhhbXBsZSkge1xuXHRcdFx0XHRcdHRoaXMuZXhhbXBsZXNbY29udGVudFR5cGUuaWRdID0gZXhhbXBsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBleGFtcGxlID0gdGhpcy5leGFtcGxlc1tjb250ZW50VHlwZS5pZF07XG5cblx0XHRcdC8vIEdldCBBTEwgcHJvcGVydGllcyBpbiB0aGlzIGZvbGRlciBmb3IgYmV0dGVyIGF1dG8tZGV0ZWN0aW9uXG5cdFx0XHRjb25zdCBhZ2dyZWdhdGVQcm9wcyA9IGF3YWl0IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5nZXRQcm9wZXJ0aWVzSW5Gb2xkZXIoZm9sZGVyUGF0aCwgdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0KTtcblx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IGZyb250bWF0dGVyIG9iamVjdCBmcm9tIGFsbCBmb3VuZCBrZXlzIGZvciBkZXRlY3RvciBmdW5jdGlvbnNcblx0XHRcdGNvbnN0IGR1bW15RnJvbnRtYXR0ZXI6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG5cdFx0XHRhZ2dyZWdhdGVQcm9wcy5mb3JFYWNoKGtleSA9PiBkdW1teUZyb250bWF0dGVyW2tleV0gPSBudWxsKTtcblxuXHRcdFx0Y29udGVudFR5cGVXcmFwcGVyLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogY29udGVudFR5cGUubmFtZSB9KTtcblxuXHRcdFx0aWYgKGV4YW1wbGUpIHtcblx0XHRcdFx0Y29udGVudFR5cGVXcmFwcGVyLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgRXhhbXBsZSBmaWxlOiAke2V4YW1wbGUuZmlsZX1gIH0pO1xuXHRcdFx0XHRjb25zdCBwcmVFbCA9IGNvbnRlbnRUeXBlV3JhcHBlci5jcmVhdGVFbCgncHJlJywge1xuXHRcdFx0XHRcdHRleHQ6IGV4YW1wbGUucmF3WWFtbCxcblx0XHRcdFx0XHRjbHM6ICdmcm9udG1hdHRlci1leGFtcGxlJ1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gU3R5bGUgdGhlIHByZSBlbGVtZW50IGZvciBiZXR0ZXIgZGlzcGxheVxuXHRcdFx0XHRzZXRDc3NQcm9wcyhwcmVFbCwge1xuXHRcdFx0XHRcdGZvbnRGYW1pbHk6ICd2YXIoLS1mb250LW1vbm9zcGFjZSknLFxuXHRcdFx0XHRcdGZvbnRTaXplOiAnMC44NWVtJyxcblx0XHRcdFx0XHR3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuXHRcdFx0XHRcdG92ZXJmbG93V3JhcDogJ2JyZWFrLXdvcmQnLFxuXHRcdFx0XHRcdG1heFdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0cGFkZGluZzogJzEwcHgnLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWJhY2tncm91bmQtc2Vjb25kYXJ5KScsXG5cdFx0XHRcdFx0Ym9yZGVyUmFkaXVzOiAnNHB4Jyxcblx0XHRcdFx0XHRib3JkZXI6ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBwcm9wZXJ0aWVzIGlmIG5vdCBleGlzdHNcblx0XHRcdGlmICghdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdKSB7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGVkRHJhZnQgPSB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERyYWZ0UHJvcGVydHkoZHVtbXlGcm9udG1hdHRlcik7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGVkVGFncyA9IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGR1bW15RnJvbnRtYXR0ZXIpO1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZEltYWdlID0gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RJbWFnZVByb3BlcnR5KGR1bW15RnJvbnRtYXR0ZXIpO1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZERlc2MgPSB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERlc2NyaXB0aW9uUHJvcGVydHkoZHVtbXlGcm9udG1hdHRlcik7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGVkVGl0bGUgPSB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdFRpdGxlUHJvcGVydHkoZHVtbXlGcm9udG1hdHRlcik7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGVkRGF0ZSA9IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RGF0ZVByb3BlcnR5KGR1bW15RnJvbnRtYXR0ZXIpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGZvciB1bmRlcnNjb3JlLXByZWZpeGVkIGZpbGVzXG5cdFx0XHRcdGNvbnN0IGhhc1VuZGVyc2NvcmVGaWxlcyA9IGF3YWl0IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5oYXNVbmRlcnNjb3JlRmlsZXMoZm9sZGVyUGF0aCk7XG5cblx0XHRcdFx0dGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdID0ge1xuXHRcdFx0XHRcdHRpdGxlUHJvcGVydHk6IGRldGVjdGVkVGl0bGUgfHwgdW5kZWZpbmVkLCAvLyBPbmx5IHNldCBpZiBkZXRlY3RlZCwgb3RoZXJ3aXNlIGJsYW5rXG5cdFx0XHRcdFx0ZGF0ZVByb3BlcnR5OiBkZXRlY3RlZERhdGUgfHwgdW5kZWZpbmVkLCAvLyBPbmx5IHNldCBpZiBkZXRlY3RlZCwgb3RoZXJ3aXNlIGJsYW5rXG5cdFx0XHRcdFx0ZGVzY3JpcHRpb25Qcm9wZXJ0eTogZGV0ZWN0ZWREZXNjIHx8IHVuZGVmaW5lZCxcblx0XHRcdFx0XHR0YWdzUHJvcGVydHk6IGRldGVjdGVkVGFncyB8fCB1bmRlZmluZWQsXG5cdFx0XHRcdFx0ZHJhZnRQcm9wZXJ0eTogZGV0ZWN0ZWREcmFmdD8ucHJvcGVydHksXG5cdFx0XHRcdFx0ZHJhZnRMb2dpYzogZGV0ZWN0ZWREcmFmdD8ucHJvcGVydHkgPT09ICdwdWJsaXNoZWQnID8gJ2ZhbHNlLWRyYWZ0JyA6IChkZXRlY3RlZERyYWZ0ID8gJ3RydWUtZHJhZnQnIDogdW5kZWZpbmVkKSxcblx0XHRcdFx0XHRoYXNEcmFmdFN0YXR1czogISFkZXRlY3RlZERyYWZ0Py5wcm9wZXJ0eSB8fCBoYXNVbmRlcnNjb3JlRmlsZXMsIC8vIFRyYWNrIGlmIGRyYWZ0IHN0YXR1cyBpcyBlbmFibGVkXG5cdFx0XHRcdFx0aW1hZ2VQcm9wZXJ0eTogZGV0ZWN0ZWRJbWFnZSB8fCB1bmRlZmluZWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcHJvcHMgPSB0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF07XG5cblx0XHRcdG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ1RpdGxlIHByb3BlcnR5Jylcblx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSB0aXRsZSAoZS5nLiwgdGl0bGUsIG5hbWUsIGhlYWRpbmcpLiBMZWF2ZSBibGFuayB0byB1c2UgZnVsbCBmaWxlIG5hbWUgaW5zdGVhZC4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZCA9ICd0aXRsZSc7XG5cdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihkZXRlY3RlZClcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy50aXRsZVByb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0cHJvcHMudGl0bGVQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0RhdGUgcHJvcGVydHknKVxuXHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGRhdGUgKGUuZy4sIGRhdGUsIHB1YkRhdGUsIHB1Ymxpc2hlZERhdGUsIHB1Ymxpc2hEYXRlKS4gTGVhdmUgYmxhbmsgdG8gdXNlIGZpbGUgY3JlYXRlZCBkYXRlIGluc3RlYWQuJylcblx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REYXRlUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQgfHwgJ2RhdGUnKVxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRhdGVQcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdHByb3BzLmRhdGVQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IGRlc2NTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnSGFzIGRlc2NyaXB0aW9uL3N1bW1hcnk/Jylcblx0XHRcdFx0LnNldERlc2MoJ0RvZXMgdGhpcyBjb250ZW50IHR5cGUgaGF2ZSBhIGRlc2NyaXB0aW9uIG9yIHN1bW1hcnkgZmllbGQ/Jyk7XG5cblx0XHRcdGxldCBkZXNjVGV4dFNldHRpbmc6IFNldHRpbmcgfCBudWxsID0gbnVsbDtcblxuXHRcdFx0ZGVzY1NldHRpbmcuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0LnNldFZhbHVlKCEhcHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSlcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgIXByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgPSBleGFtcGxlID9cblx0XHRcdFx0XHRcdFx0dGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REZXNjcmlwdGlvblByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIHx8ICdkZXNjcmlwdGlvbicgOlxuXHRcdFx0XHRcdFx0XHQnZGVzY3JpcHRpb24nO1xuXHRcdFx0XHRcdFx0Ly8gU2hvdyB0ZXh0IGZpZWxkXG5cdFx0XHRcdFx0XHRpZiAoIWRlc2NUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkZXNjVGV4dFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0Rlc2NyaXB0aW9uIHByb3BlcnR5Jylcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIChlLmcuLCBkZXNjcmlwdGlvbiwgc3VtbWFyeSwgZXhjZXJwdCwgaW50cm8sIHNuaXBwZXQsIGJsdXJiKScpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdGRlc2NUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGRlc2NTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZGVzY1RleHRTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUpIHtcblx0XHRcdFx0XHRcdHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHQvLyBIaWRlIHRleHQgZmllbGRcblx0XHRcdFx0XHRcdGlmIChkZXNjVGV4dFNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0aWYgKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdC5zZXROYW1lKCdEZXNjcmlwdGlvbiBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiAoZS5nLiwgZGVzY3JpcHRpb24sIHN1bW1hcnksIGV4Y2VycHQsIGludHJvLCBzbmlwcGV0LCBibHVyYiknKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSB0b2dnbGUgc2V0dGluZ1xuXHRcdFx0XHRkZXNjVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRkZXNjU2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRlc2NUZXh0U2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYXMgVGFncz9cblx0XHRcdGNvbnN0IHRhZ3NTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnSGFzIHRhZ3M/Jylcblx0XHRcdFx0LnNldERlc2MoJ0RvZXMgdGhpcyBjb250ZW50IHR5cGUgaGF2ZSB0YWdzPycpO1xuXG5cdFx0XHRsZXQgdGFnc1RleHRTZXR0aW5nOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cblx0XHRcdHRhZ3NTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSghIXByb3BzLnRhZ3NQcm9wZXJ0eSlcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgIXByb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RUYWdzUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0cHJvcHMudGFnc1Byb3BlcnR5ID0gZGV0ZWN0ZWQgfHwgJ3RhZ3MnO1xuXHRcdFx0XHRcdFx0Ly8gU2hvdyB0ZXh0IGZpZWxkXG5cdFx0XHRcdFx0XHRpZiAoIXRhZ3NUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHR0YWdzVGV4dFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ1RhZ3MgcHJvcGVydHknKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0YWdzIChlLmcuLCB0YWdzLCB0YWcsIGNhdGVnb3JpZXMsIGNhdGVnb3J5KS4gTGVhdmUgYmxhbmsgaWYgbm90IGFwcGxpY2FibGUuJylcblx0XHRcdFx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQgfHwgJ3RhZ3MnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMudGFnc1Byb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLnRhZ3NQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdHRhZ3NUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdHRhZ3NTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgdGFnc1RleHRTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUpIHtcblx0XHRcdFx0XHRcdHByb3BzLnRhZ3NQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdC8vIEhpZGUgdGV4dCBmaWVsZFxuXHRcdFx0XHRcdFx0aWYgKHRhZ3NUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHR0YWdzVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHR0YWdzVGV4dFNldHRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRpZiAocHJvcHMudGFnc1Byb3BlcnR5KSB7XG5cdFx0XHRcdHRhZ3NUZXh0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHQuc2V0TmFtZSgnVGFncyBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRhZ3MgKGUuZy4sIHRhZ3MsIHRhZywgY2F0ZWdvcmllcywgY2F0ZWdvcnkpLiBMZWF2ZSBibGFuayBpZiBub3QgYXBwbGljYWJsZS4nKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RUYWdzUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihkZXRlY3RlZCB8fCAndGFncycpXG5cdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy50YWdzUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcHMudGFnc1Byb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgdG9nZ2xlIHNldHRpbmdcblx0XHRcdFx0dGFnc1RleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0dGFnc1NldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCB0YWdzVGV4dFNldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFzIERyYWZ0IFN0YXR1cz9cblx0XHRcdGNvbnN0IGRyYWZ0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0hhcyBkcmFmdCBzdGF0dXM/Jylcblx0XHRcdFx0LnNldERlc2MoJ0RvZXMgdGhpcyBjb250ZW50IHR5cGUgaGF2ZSBkcmFmdCBzdGF0dXM/Jyk7XG5cblx0XHRcdGxldCBkcmFmdFByb3BlcnR5U2V0dGluZzogU2V0dGluZyB8IG51bGwgPSBudWxsO1xuXHRcdFx0bGV0IGRyYWZ0TG9naWNTZXR0aW5nOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgaGFzRHJhZnRTdGF0dXMgaWYgbm90IHNldCAoZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuXHRcdFx0aWYgKHByb3BzLmhhc0RyYWZ0U3RhdHVzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHJvcHMuaGFzRHJhZnRTdGF0dXMgPSAhIXByb3BzLmRyYWZ0UHJvcGVydHk7XG5cdFx0XHR9XG5cblx0XHRcdGRyYWZ0U2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuXHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuaGFzRHJhZnRTdGF0dXMgPz8gISFwcm9wcy5kcmFmdFByb3BlcnR5KVxuXHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdHByb3BzLmhhc0RyYWZ0U3RhdHVzID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmICFwcm9wcy5kcmFmdFByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZERyYWZ0ID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RHJhZnRQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHRwcm9wcy5kcmFmdFByb3BlcnR5ID0gZGV0ZWN0ZWREcmFmdD8ucHJvcGVydHkgfHwgJ2RyYWZ0Jztcblx0XHRcdFx0XHRcdC8vIEZpeCBsb2dpYzogaWYgcHJvcGVydHkgaXMgXCJkcmFmdFwiLCB1c2UgXCJ0cnVlLWRyYWZ0XCIsIGlmIFwicHVibGlzaGVkXCIgdXNlIFwiZmFsc2UtZHJhZnRcIlxuXHRcdFx0XHRcdFx0aWYgKGRldGVjdGVkRHJhZnQ/LnByb3BlcnR5ID09PSAncHVibGlzaGVkJykge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gJ2ZhbHNlLWRyYWZ0Jztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSAndHJ1ZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBTaG93IGZpZWxkc1xuXHRcdFx0XHRcdFx0aWYgKCFkcmFmdFByb3BlcnR5U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHRcdFx0XHQuc2V0TmFtZSgnRHJhZnQgcHJvcGVydHknKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyBkcmFmdCBzdGF0dXMuIExlYXZlIGJsYW5rIHRvIHVzZSBhbiB1bmRlcnNjb3JlIHByZWZpeCBpbnN0ZWFkLicpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZCA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERyYWZ0UHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihkZXRlY3RlZD8ucHJvcGVydHkgfHwgJ2RyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRyYWZ0UHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVXBkYXRlIGxvZ2ljIGJhc2VkIG9uIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPT09ICdwdWJsaXNoZWQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gJ2ZhbHNlLWRyYWZ0Jztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gJ3RydWUtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTaG93L2hpZGUgbG9naWMgZHJvcGRvd25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgIWRyYWZ0TG9naWNTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0RyYWZ0IGxvZ2ljJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldERlc2MoJ0hvdyBkcmFmdCBzdGF0dXMgaXMgcmVwcmVzZW50ZWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCd0cnVlLWRyYWZ0JywgJ3RydWUgPSBkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZE9wdGlvbignZmFsc2UtZHJhZnQnLCAnZmFsc2UgPSBkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRyYWZ0TG9naWMgfHwgJ3RydWUtZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZShkcm9wZG93blZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSBkcm9wZG93blZhbHVlIGFzICd0cnVlLWRyYWZ0JyB8ICdmYWxzZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGRyYWZ0UHJvcGVydHlTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCF2YWx1ZSAmJiBkcmFmdExvZ2ljU2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgdG9nZ2xlIHNldHRpbmdcblx0XHRcdFx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRkcmFmdFNldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gU2hvdyBsb2dpYyBkcm9wZG93biBpZiBwcm9wZXJ0eSBpcyBzZXRcblx0XHRcdFx0XHRcdGlmIChwcm9wcy5kcmFmdFByb3BlcnR5ICYmICFkcmFmdExvZ2ljU2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHRcdFx0XHQuc2V0TmFtZSgnRHJhZnQgbG9naWMnKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdIb3cgZHJhZnQgc3RhdHVzIGlzIHJlcHJlc2VudGVkJylcblx0XHRcdFx0XHRcdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cblx0XHRcdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ3RydWUtZHJhZnQnLCAndHJ1ZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZhbHNlLWRyYWZ0JywgJ2ZhbHNlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRyYWZ0TG9naWMgfHwgJ3RydWUtZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9IHZhbHVlIGFzICd0cnVlLWRyYWZ0JyB8ICdmYWxzZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgZHJhZnQgcHJvcGVydHkgc2V0dGluZ1xuXHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5kcmFmdFByb3BlcnR5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdHByb3BzLmhhc0RyYWZ0U3RhdHVzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHQvLyBIaWRlIGZpZWxkc1xuXHRcdFx0XHRcdFx0aWYgKGRyYWZ0UHJvcGVydHlTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGRyYWZ0TG9naWNTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRpZiAocHJvcHMuaGFzRHJhZnRTdGF0dXMpIHtcblx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0LnNldE5hbWUoJ0RyYWZ0IHByb3BlcnR5Jylcblx0XHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgZHJhZnQgc3RhdHVzLiBMZWF2ZSBibGFuayB0byB1c2UgYW4gdW5kZXJzY29yZSBwcmVmaXggaW5zdGVhZC4nKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REcmFmdFByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQ/LnByb3BlcnR5IHx8ICdkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kcmFmdFByb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0UHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVwZGF0ZSBsb2dpYyBiYXNlZCBvbiBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID09PSAncHVibGlzaGVkJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9ICdmYWxzZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9ICd0cnVlLWRyYWZ0Jztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gU2hvdy9oaWRlIGxvZ2ljIGRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmICFkcmFmdExvZ2ljU2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXROYW1lKCdEcmFmdCBsb2dpYycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdIb3cgZHJhZnQgc3RhdHVzIGlzIHJlcHJlc2VudGVkJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZE9wdGlvbigndHJ1ZS1kcmFmdCcsICd0cnVlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZhbHNlLWRyYWZ0JywgJ2ZhbHNlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kcmFmdExvZ2ljIHx8ICd0cnVlLWRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UoZHJvcGRvd25WYWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gZHJvcGRvd25WYWx1ZSBhcyAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUgJiYgZHJhZnRMb2dpY1NldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0ZHJhZnRTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsKTtcblxuXHRcdFx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdFx0LnNldE5hbWUoJ0RyYWZ0IGxvZ2ljJylcblx0XHRcdFx0XHRcdC5zZXREZXNjKCdIb3cgZHJhZnQgc3RhdHVzIGlzIHJlcHJlc2VudGVkJylcblx0XHRcdFx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuXHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCd0cnVlLWRyYWZ0JywgJ3RydWUgPSBkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZhbHNlLWRyYWZ0JywgJ2ZhbHNlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuZHJhZnRMb2dpYyB8fCAndHJ1ZS1kcmFmdCcpXG5cdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRMb2dpYyA9IHZhbHVlIGFzICd0cnVlLWRyYWZ0JyB8ICdmYWxzZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIGRyYWZ0IHByb3BlcnR5IHNldHRpbmdcblx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0aWYgKGRyYWZ0UHJvcGVydHlTZXR0aW5nICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhcyBJbWFnZSBQcm9wZXJ0eT9cblx0XHRcdGNvbnN0IGltYWdlU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0hhcyBpbWFnZS9jb3ZlciBwcm9wZXJ0eT8nKVxuXHRcdFx0XHQuc2V0RGVzYygnRG9lcyB0aGlzIGNvbnRlbnQgdHlwZSBoYXZlIGFuIGltYWdlIG9yIGNvdmVyIHByb3BlcnR5PyBVc2VkIGZvciBCYXNlcyBDTVMgY292ZXIgaW1hZ2VzIGFuZCBJbWFnZSBNYW5hZ2VyLicpO1xuXG5cdFx0XHRsZXQgaW1hZ2VUZXh0U2V0dGluZzogU2V0dGluZyB8IG51bGwgPSBudWxsO1xuXG5cdFx0XHRpbWFnZVNldHRpbmcuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0LnNldFZhbHVlKCEhcHJvcHMuaW1hZ2VQcm9wZXJ0eSlcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgIXByb3BzLmltYWdlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0SW1hZ2VQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHRwcm9wcy5pbWFnZVByb3BlcnR5ID0gZGV0ZWN0ZWQgfHwgJ2ltYWdlJztcblx0XHRcdFx0XHRcdC8vIFNob3cgdGV4dCBmaWVsZFxuXHRcdFx0XHRcdFx0aWYgKCFpbWFnZVRleHRTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdGltYWdlVGV4dFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0ltYWdlIHByb3BlcnR5Jylcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGltYWdlL2NvdmVyIChlLmcuLCBpbWFnZSwgY292ZXIsIGNvdmVySW1hZ2UsIHRodW1ibmFpbCwgZmVhdHVyZWRJbWFnZSkuIExlYXZlIGJsYW5rIGlmIG5vdCBhcHBsaWNhYmxlLicpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZCA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdEltYWdlUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihkZXRlY3RlZCB8fCAnaW1hZ2UnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuaW1hZ2VQcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5pbWFnZVByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgdG9nZ2xlIHNldHRpbmdcblx0XHRcdFx0XHRcdFx0aW1hZ2VUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGltYWdlU2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGltYWdlVGV4dFNldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRcdFx0cHJvcHMuaW1hZ2VQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdC8vIEhpZGUgdGV4dCBmaWVsZFxuXHRcdFx0XHRcdFx0aWYgKGltYWdlVGV4dFNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0aW1hZ2VUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGltYWdlVGV4dFNldHRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRpZiAocHJvcHMuaW1hZ2VQcm9wZXJ0eSkge1xuXHRcdFx0XHRpbWFnZVRleHRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdC5zZXROYW1lKCdJbWFnZSBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpbWFnZS9jb3ZlciAoZS5nLiwgaW1hZ2UsIGNvdmVyLCBjb3ZlckltYWdlLCB0aHVtYm5haWwsIGZlYXR1cmVkSW1hZ2UpLiBMZWF2ZSBibGFuayBpZiBub3QgYXBwbGljYWJsZS4nKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RJbWFnZVByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQgfHwgJ2ltYWdlJylcblx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmltYWdlUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcHMuaW1hZ2VQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdGltYWdlVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRpbWFnZVNldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBpbWFnZVRleHRTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRlbXBsYXRlIGVkaXRvclxuXHRcdFx0Y29udGVudFR5cGVXcmFwcGVyLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ1RlbXBsYXRlJyB9KTtcblx0XHRcdGNvbnRlbnRUeXBlV3JhcHBlci5jcmVhdGVFbCgncCcsIHtcblx0XHRcdFx0dGV4dDogJ0VkaXQgdGhlIHRlbXBsYXRlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IGZpbGVzIG9mIHRoaXMgY29udGVudCB0eXBlLiBVc2Uge3t0aXRsZX19IGFuZCB7e2RhdGV9fSBhcyB2YXJpYWJsZXMuIE5vdGU6IHt7dGl0bGV9fSBzaG91bGQgYmUgaW4gcXVvdGVzIChlLmcuLCB0aXRsZTogXCJ7e3RpdGxlfX1cIiksIHdoaWxlIHt7ZGF0ZX19IHNob3VsZCBub3QgYmUgaW4gcXVvdGVzIChlLmcuLCBkYXRlOiB7e2RhdGV9fSkuJ1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdGVtcGxhdGUgaWYgbm90IGV4aXN0c1xuXHRcdFx0aWYgKCFwcm9wcy50ZW1wbGF0ZSkge1xuXHRcdFx0XHQvLyBHZXQgY29ycmVjdCBmb2xkZXIgcGF0aCBmb3IgYWdncmVnYXRpb25cblx0XHRcdFx0Y29uc3QgcGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcih0aGlzLmFwcCk7XG5cdFx0XHRcdGNvbnN0IGZvbGRlclBhdGggPSBwYXRoUmVzb2x2ZXIuZ2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoY29udGVudFR5cGUuZm9sZGVyLCB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0XHRjb25zdCBhZ2dyZWdhdGVQcm9wcyA9IGF3YWl0IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5nZXRQcm9wZXJ0aWVzSW5Gb2xkZXIoZm9sZGVyUGF0aCwgdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0KTtcblxuXHRcdFx0XHQvLyBHZW5lcmF0ZSBkZWZhdWx0IHRlbXBsYXRlIGJhc2VkIG9uIHByb3BlcnRpZXMgYW5kIEFMTCBmb3VuZCBrZXlzXG5cdFx0XHRcdHByb3BzLnRlbXBsYXRlID0gdGhpcy5nZW5lcmF0ZURlZmF1bHRUZW1wbGF0ZShwcm9wcywgZXhhbXBsZSwgYWdncmVnYXRlUHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0ZW1wbGF0ZVRleHRBcmVhID0gY29udGVudFR5cGVXcmFwcGVyLmNyZWF0ZUVsKCd0ZXh0YXJlYScsIHtcblx0XHRcdFx0Y2xzOiAndGVtcGxhdGUtZWRpdG9yJyxcblx0XHRcdFx0YXR0cjoge1xuXHRcdFx0XHRcdHJvd3M6ICcxMCcsXG5cdFx0XHRcdFx0c3R5bGU6ICd3aWR0aDogMTAwJTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsnLFxuXHRcdFx0XHRcdHNwZWxsY2hlY2s6ICdmYWxzZSdcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0ZW1wbGF0ZVRleHRBcmVhLnZhbHVlID0gcHJvcHMudGVtcGxhdGUgfHwgJyc7XG5cdFx0XHR0ZW1wbGF0ZVRleHRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcblx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTFRleHRBcmVhRWxlbWVudDtcblx0XHRcdFx0cHJvcHMudGVtcGxhdGUgPSB0YXJnZXQudmFsdWU7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlRGVmYXVsdFRlbXBsYXRlKHByb3BzOiB7IHRpdGxlUHJvcGVydHk/OiBzdHJpbmc7IGRhdGVQcm9wZXJ0eT86IHN0cmluZzsgZGVzY3JpcHRpb25Qcm9wZXJ0eT86IHN0cmluZzsgdGFnc1Byb3BlcnR5Pzogc3RyaW5nOyBkcmFmdFByb3BlcnR5Pzogc3RyaW5nOyBkcmFmdExvZ2ljPzogJ3RydWUtZHJhZnQnIHwgJ2ZhbHNlLWRyYWZ0JzsgaW1hZ2VQcm9wZXJ0eT86IHN0cmluZyB9LCBleGFtcGxlOiBFeGFtcGxlRnJvbnRtYXR0ZXIgfCB1bmRlZmluZWQsIGFnZ3JlZ2F0ZVByb3BzOiBTZXQ8c3RyaW5nPik6IHN0cmluZyB7XG5cdFx0bGV0IHRlbXBsYXRlID0gJy0tLVxcbic7XG5cblx0XHQvLyBQYXJzZSB0aGUgb3JpZ2luYWwgWUFNTCB0byBtYWludGFpbiBvcmRlclxuXHRcdGlmIChleGFtcGxlICYmIGV4YW1wbGUucmF3WWFtbCkge1xuXHRcdFx0Ly8gUGFyc2UgdGhlIHJhdyBZQU1MIGxpbmUgYnkgbGluZSB0byBtYWludGFpbiBvcmRlclxuXHRcdFx0Y29uc3QgbGluZXMgPSBleGFtcGxlLnJhd1lhbWwuc3BsaXQoJ1xcbicpO1xuXHRcdFx0Y29uc3QgcHJvY2Vzc2VkUHJvcHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuXHRcdFx0Ly8gRmlyc3QsIGFkZCB0aXRsZSBwcm9wZXJ0eSBpZiBpdCdzIGRldGVjdGVkL2VuYWJsZWQgKEFMV0FZUyBpbmNsdWRlIGl0KVxuXHRcdFx0bGV0IHRpdGxlQWRkZWQgPSBmYWxzZTtcblx0XHRcdGlmIChwcm9wcy50aXRsZVByb3BlcnR5KSB7XG5cdFx0XHRcdGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuXHRcdFx0XHRcdGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcblx0XHRcdFx0XHRpZiAoIXRyaW1tZWQgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcjJykpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0Y29uc3QgY29sb25JbmRleCA9IHRyaW1tZWQuaW5kZXhPZignOicpO1xuXHRcdFx0XHRcdGlmIChjb2xvbkluZGV4ID4gMCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcHJvcCA9IHRyaW1tZWQuc3Vic3RyaW5nKDAsIGNvbG9uSW5kZXgpLnRyaW0oKTtcblx0XHRcdFx0XHRcdGlmIChwcm9wID09PSBwcm9wcy50aXRsZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLnRpdGxlUHJvcGVydHl9OiBcInt7dGl0bGV9fVwiXFxuYDtcblx0XHRcdFx0XHRcdFx0dGl0bGVBZGRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3NlZFByb3BzLmFkZChwcm9wKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGl0bGVBZGRlZCkge1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLnRpdGxlUHJvcGVydHl9OiBcInt7dGl0bGV9fVwiXFxuYDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBBZGQgZGF0ZSBwcm9wZXJ0eSBpZiBpdCdzIGRldGVjdGVkL2VuYWJsZWQgKEFMV0FZUyBpbmNsdWRlIGl0KVxuXHRcdFx0bGV0IGRhdGVBZGRlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHByb3BzLmRhdGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdFx0XHRjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XG5cdFx0XHRcdFx0aWYgKCF0cmltbWVkIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnIycpKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbG9uSW5kZXggPSB0cmltbWVkLmluZGV4T2YoJzonKTtcblx0XHRcdFx0XHRpZiAoY29sb25JbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IHByb3AgPSB0cmltbWVkLnN1YnN0cmluZygwLCBjb2xvbkluZGV4KS50cmltKCk7XG5cdFx0XHRcdFx0XHRpZiAocHJvcCA9PT0gcHJvcHMuZGF0ZVByb3BlcnR5ICYmICFwcm9jZXNzZWRQcm9wcy5oYXMocHJvcCkpIHtcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMuZGF0ZVByb3BlcnR5fToge3tkYXRlfX1cXG5gO1xuXHRcdFx0XHRcdFx0XHRkYXRlQWRkZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRwcm9jZXNzZWRQcm9wcy5hZGQocHJvcCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRhdGVBZGRlZCAmJiAhcHJvY2Vzc2VkUHJvcHMuaGFzKHByb3BzLmRhdGVQcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy5kYXRlUHJvcGVydHl9OiB7e2RhdGV9fVxcbmA7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkUHJvcHMuYWRkKHByb3BzLmRhdGVQcm9wZXJ0eSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gMy4gVGhlbiBwcm9jZXNzIG90aGVyIGxpbmVzIGluIG9yZGVyXG5cdFx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdFx0Y29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xuXHRcdFx0XHRpZiAoIXRyaW1tZWQgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcjJykpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IGNvbG9uSW5kZXggPSB0cmltbWVkLmluZGV4T2YoJzonKTtcblx0XHRcdFx0aWYgKGNvbG9uSW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcHJvcCA9IHRyaW1tZWQuc3Vic3RyaW5nKDAsIGNvbG9uSW5kZXgpLnRyaW0oKTtcblxuXHRcdFx0XHRcdC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWQgKHRpdGxlIG9yIHByaW1hcnkgZGF0ZSlcblx0XHRcdFx0XHRpZiAocHJvY2Vzc2VkUHJvcHMuaGFzKHByb3ApKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgZGVzY3JpcHRpb24gcHJvcGVydHlcblx0XHRcdFx0XHRpZiAocHJvcCA9PT0gcHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IFwiXCJcXG5gO1xuXHRcdFx0XHRcdFx0cHJvY2Vzc2VkUHJvcHMuYWRkKHByb3ApO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJvY2VzcyBvdGhlciBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBleGFtcGxlLmZyb250bWF0dGVyW3Byb3BdO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTpcXG5gO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiBbXVxcbmA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06ICR7dmFsdWV9XFxuYDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiAke3ZhbHVlfVxcbmA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHQvLyBETyBOT1QgYXV0by1hZGQge3tkYXRlfX0gdG8gc2Vjb25kYXJ5IHByb3BlcnRpZXMgYW55bW9yZSB0byBhdm9pZCBcInVwZGF0ZWQ6IHt7ZGF0ZX19XCIgc3BhbVxuXHRcdFx0XHRcdFx0Ly8gSnVzdCB1c2UgYW4gZW1wdHkgc3RyaW5nIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHVua25vd24gc3RyaW5nc1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IFwiXCJcXG5gO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTogXCJcIlxcbmA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cHJvY2Vzc2VkUHJvcHMuYWRkKHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIDQuIEZpbmFsbHksIGFkZCBhbnkgbWlzc2luZyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBmb3VuZCBpbiB0aGUgZm9sZGVyIGJ1dCB3ZXJlbid0IGluIHRoZSBleGFtcGxlXG5cdFx0XHRmb3IgKGNvbnN0IHByb3Agb2YgYWdncmVnYXRlUHJvcHMpIHtcblx0XHRcdFx0aWYgKHByb2Nlc3NlZFByb3BzLmhhcyhwcm9wKSkgY29udGludWU7XG5cblx0XHRcdFx0aWYgKHByb3AgPT09IHByb3BzLnRpdGxlUHJvcGVydHkpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTogXCJ7e3RpdGxlfX1cIlxcbmA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvcCA9PT0gcHJvcHMuZGF0ZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IHt7ZGF0ZX19XFxuYDtcblx0XHRcdFx0fSBlbHNlIGlmIChwcm9wID09PSBwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IFwiXCJcXG5gO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByb3AgPT09IHByb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiBbXVxcbmA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvcCA9PT0gcHJvcHMuaW1hZ2VQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiBcIlwiXFxuYDtcblx0XHRcdFx0fSBlbHNlIGlmIChwcm9wID09PSBwcm9wcy5kcmFmdFByb3BlcnR5KSB7XG5cdFx0XHRcdFx0Y29uc3QgZHJhZnRWYWx1ZSA9IHByb3BzLmRyYWZ0TG9naWMgPT09ICdmYWxzZS1kcmFmdCcgPyAnZmFsc2UnIDogJ3RydWUnO1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiAke2RyYWZ0VmFsdWV9XFxuYDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBHZW5lcmljIGZhbGxiYWNrXG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IFwiXCJcXG5gO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb2Nlc3NlZFByb3BzLmFkZChwcm9wKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRGVmYXVsdCB0ZW1wbGF0ZSBpZiBubyBleGFtcGxlIC0gb25seSBpbmNsdWRlIHByb3BlcnRpZXMgdGhhdCBhcmUgc2V0XG5cdFx0XHRpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy50aXRsZVByb3BlcnR5fTogXCJ7e3RpdGxlfX1cIlxcbmA7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvcHMuZGF0ZVByb3BlcnR5KSB7XG5cdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRhdGVQcm9wZXJ0eX06IHt7ZGF0ZX19XFxuYDtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9OiBcIlwiXFxuYDtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9wcy50YWdzUHJvcGVydHkpIHtcblx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMudGFnc1Byb3BlcnR5fTogW11cXG5gO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdFx0Y29uc3QgZHJhZnRWYWx1ZSA9IHByb3BzLmRyYWZ0TG9naWMgPT09ICdmYWxzZS1kcmFmdCcgPyAnZmFsc2UnIDogJ3RydWUnO1xuXHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy5kcmFmdFByb3BlcnR5fTogJHtkcmFmdFZhbHVlfVxcbmA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGVtcGxhdGUgKz0gJy0tLVxcbic7XG5cdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHR9XG5cblx0dmFsaWRhdGUoKTogYm9vbGVhbiB7XG5cdFx0Ly8gVmFsaWRhdGlvbjogdGl0bGVQcm9wZXJ0eSBpcyByZXF1aXJlZCAoYnV0IGNhbiBiZSBlbXB0eSBzdHJpbmcsIHdpbGwgdXNlIGZpbGUuZnVsbG5hbWUpXG5cdFx0Ly8gQWN0dWFsbHksIHRpdGxlUHJvcGVydHkgY2FuIGJlIGJsYW5rIC0gaWYgYmxhbmssIGl0IHdpbGwgdXNlIGZpbGUuZnVsbG5hbWUgYXMgZmFsbGJhY2tcblx0XHQvLyBTbyB2YWxpZGF0aW9uIHNob3VsZCBhbHdheXMgcGFzcyAtIHRoZSBzdGVwIGlzIG9wdGlvbmFsXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnRnJvbnRtYXR0ZXIgcHJvcGVydGllcyc7XG5cdH1cblxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnTWFwIGZyb250bWF0dGVyIHByb3BlcnRpZXMnO1xuXHR9XG59XG5cbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlLCBURm9sZGVyIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRXhhbXBsZUZyb250bWF0dGVyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgeWFtbCBmcm9tICd5YW1sJztcblxuZXhwb3J0IGNsYXNzIEZyb250bWF0dGVyQW5hbHl6ZXIge1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdH1cblxuXHRhc3luYyBmaW5kRXhhbXBsZUZpbGUoZm9sZGVyUGF0aDogc3RyaW5nLCBpbmNsdWRlTWR4OiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPEV4YW1wbGVGcm9udG1hdHRlciB8IG51bGw+IHtcblx0XHRjb25zdCBmb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCk7XG5cblx0XHRpZiAoIWZvbGRlcikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKGZvbGRlciBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRjb25zdCBleHQgPSBmb2xkZXIuZXh0ZW5zaW9uO1xuXHRcdFx0aWYgKGV4dCA9PT0gJ21kJyB8fCAoaW5jbHVkZU1keCAmJiBleHQgPT09ICdtZHgnKSkge1xuXHRcdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5wYXJzZUZyb250bWF0dGVyKGZvbGRlcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBJdCdzIGEgZm9sZGVyLCBnZXQgZmlsZXMgZnJvbSBpdFxuXHRcdGlmICghKGZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0bGV0IGZpbGVzID0gdGhpcy5nZXRNYXJrZG93bkZpbGVzKGZvbGRlciwgZmFsc2UsIHVuZGVmaW5lZCwgMCwgaW5jbHVkZU1keCk7IC8vIGZhbHNlID0gb25seSBpbW1lZGlhdGUgY2hpbGRyZW5cblxuXHRcdC8vIElmIG5vIGZpbGVzIGZvdW5kIGluIGltbWVkaWF0ZSBmb2xkZXIsIHNlYXJjaCBkZWVwZXIgKG9uZSBsZXZlbCBhdCBhIHRpbWUpXG5cdFx0aWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Ly8gU2VhcmNoIG9uZSBsZXZlbCBkZWVwZXJcblx0XHRcdGZpbGVzID0gdGhpcy5nZXRNYXJrZG93bkZpbGVzKGZvbGRlciwgdHJ1ZSwgMSwgMCwgaW5jbHVkZU1keCk7IC8vIHRydWUgPSByZWN1cnNpdmUsIG1heERlcHRoID0gMVxuXG5cdFx0XHQvLyBJZiBzdGlsbCBubyBmaWxlcywgc2VhcmNoIHR3byBsZXZlbHMgZGVlcGVyXG5cdFx0XHRpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGZpbGVzID0gdGhpcy5nZXRNYXJrZG93bkZpbGVzKGZvbGRlciwgdHJ1ZSwgMiwgMCwgaW5jbHVkZU1keCk7IC8vIG1heERlcHRoID0gMlxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBzdGlsbCBubyBmaWxlcywgc2VhcmNoIGFsbCBsZXZlbHMgKHVubGltaXRlZCBkZXB0aClcblx0XHRcdGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0ZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCB0cnVlLCB1bmRlZmluZWQsIDAsIGluY2x1ZGVNZHgpOyAvLyB1bmxpbWl0ZWQgZGVwdGhcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcblx0XHRcdGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnBhcnNlRnJvbnRtYXR0ZXIoZmlsZSk7XG5cdFx0XHRpZiAoZXhhbXBsZSkge1xuXHRcdFx0XHRyZXR1cm4gZXhhbXBsZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTY2FucyBtdWx0aXBsZSBmaWxlcyBpbiBhIGZvbGRlciB0byBhZ2dyZWdhdGUgYWxsIHVuaXF1ZSBmcm9udG1hdHRlciBwcm9wZXJ0aWVzLlxuXHQgKiBUaGlzIGVuc3VyZXMgcHJvcGVydGllcyBhcmVuJ3QgbWlzc2VkIGp1c3QgYmVjYXVzZSB0aGV5J3JlIG5vdCBpbiB0aGUgc2luZ2xlIFwibGF0ZXN0XCIgZmlsZS5cblx0ICovXG5cdGFzeW5jIGdldFByb3BlcnRpZXNJbkZvbGRlcihmb2xkZXJQYXRoOiBzdHJpbmcsIGluY2x1ZGVNZHg6IGJvb2xlYW4gPSBmYWxzZSwgbGltaXQ6IG51bWJlciA9IDUwKTogUHJvbWlzZTxTZXQ8c3RyaW5nPj4ge1xuXHRcdGNvbnN0IGZvbGRlciA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmb2xkZXJQYXRoKTtcblx0XHRpZiAoIShmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpbGVzID0gdGhpcy5nZXRNYXJrZG93bkZpbGVzKGZvbGRlciwgdHJ1ZSwgdW5kZWZpbmVkLCAwLCBpbmNsdWRlTWR4KTtcblx0XHRjb25zdCBhZ2dyZWdhdGVQcm9wcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5cdFx0Ly8gTGltaXQgdGhlIG51bWJlciBvZiBmaWxlcyB3ZSBzY2FuIHRvIGtlZXAgaXQgcGVyZm9ybWFudFxuXHRcdGNvbnN0IGZpbGVzVG9TY2FuID0gZmlsZXMuc2xpY2UoMCwgbGltaXQpO1xuXG5cdFx0Zm9yIChjb25zdCBmaWxlIG9mIGZpbGVzVG9TY2FuKSB7XG5cdFx0XHRpZiAoZmlsZS5leHRlbnNpb24gPT09ICdtZCcpIHtcblx0XHRcdFx0Ly8gVXNlIE9ic2lkaWFuJ3MgbWV0YWRhdGEgY2FjaGUgZm9yIHN0YW5kYXJkIG1hcmtkb3duIGZpbGVzICh2ZXJ5IGZhc3QpXG5cdFx0XHRcdGNvbnN0IGNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG5cdFx0XHRcdGlmIChjYWNoZSAmJiBjYWNoZS5mcm9udG1hdHRlcikge1xuXHRcdFx0XHRcdE9iamVjdC5rZXlzKGNhY2hlLmZyb250bWF0dGVyKS5mb3JFYWNoKGtleSA9PiBhZ2dyZWdhdGVQcm9wcy5hZGQoa2V5KSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoaW5jbHVkZU1keCAmJiBmaWxlLmV4dGVuc2lvbiA9PT0gJ21keCcpIHtcblx0XHRcdFx0Ly8gTURYIGZpbGVzIGFyZW4ndCBpbiBPYnNpZGlhbidzIG1ldGFkYXRhIGNhY2hlIG5hdGl2ZWx5LCBzbyB3ZSBoYXZlIHRvIHBhcnNlIG1hbnVhbGx5XG5cdFx0XHRcdGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnBhcnNlRnJvbnRtYXR0ZXIoZmlsZSk7XG5cdFx0XHRcdGlmIChleGFtcGxlICYmIGV4YW1wbGUuZnJvbnRtYXR0ZXIpIHtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhleGFtcGxlLmZyb250bWF0dGVyKS5mb3JFYWNoKGtleSA9PiBhZ2dyZWdhdGVQcm9wcy5hZGQoa2V5KSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYWdncmVnYXRlUHJvcHM7XG5cdH1cblxuXHRoYXNVbmRlcnNjb3JlRmlsZXMoZm9sZGVyUGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc3QgZm9sZGVyID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlclBhdGgpO1xuXG5cdFx0aWYgKCEoZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpbGVzID0gdGhpcy5nZXRNYXJrZG93bkZpbGVzKGZvbGRlciwgdHJ1ZSk7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlcy5zb21lKGZpbGUgPT4gZmlsZS5uYW1lLnN0YXJ0c1dpdGgoJ18nKSkpO1xuXHR9XG5cblx0cHJpdmF0ZSBnZXRNYXJrZG93bkZpbGVzKGZvbGRlcjogVEZvbGRlciwgcmVjdXJzaXZlOiBib29sZWFuID0gdHJ1ZSwgbWF4RGVwdGg/OiBudW1iZXIsIGN1cnJlbnREZXB0aDogbnVtYmVyID0gMCwgaW5jbHVkZU1keDogYm9vbGVhbiA9IGZhbHNlKTogVEZpbGVbXSB7XG5cdFx0Y29uc3QgZmlsZXM6IFRGaWxlW10gPSBbXTtcblxuXHRcdGlmICghZm9sZGVyLmNoaWxkcmVuKSB7XG5cdFx0XHRyZXR1cm4gZmlsZXM7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UndmUgZXhjZWVkZWQgbWF4IGRlcHRoXG5cdFx0aWYgKG1heERlcHRoICE9PSB1bmRlZmluZWQgJiYgY3VycmVudERlcHRoID49IG1heERlcHRoKSB7XG5cdFx0XHRyZXR1cm4gZmlsZXM7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBjaGlsZCBvZiBmb2xkZXIuY2hpbGRyZW4pIHtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5leHRlbnNpb24gPT09ICdtZCcgfHwgKGluY2x1ZGVNZHggJiYgY2hpbGQuZXh0ZW5zaW9uID09PSAnbWR4JykpIHtcblx0XHRcdFx0XHRmaWxlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChyZWN1cnNpdmUgJiYgY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyICYmIGNoaWxkLmNoaWxkcmVuKSB7XG5cdFx0XHRcdC8vIFJlY3Vyc2l2ZWx5IHNlYXJjaCBzdWJmb2xkZXJzXG5cdFx0XHRcdGZpbGVzLnB1c2goLi4udGhpcy5nZXRNYXJrZG93bkZpbGVzKGNoaWxkLCByZWN1cnNpdmUsIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxLCBpbmNsdWRlTWR4KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpbGVzO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwYXJzZUZyb250bWF0dGVyKGZpbGU6IFRGaWxlKTogUHJvbWlzZTxFeGFtcGxlRnJvbnRtYXR0ZXIgfCBudWxsPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0Y29uc3QgZnJvbnRtYXR0ZXJSZWdleCA9IC9eLS0tXFxzKlxcbihbXFxzXFxTXSo/KVxcbi0tLVxccypcXG4vO1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBjb250ZW50Lm1hdGNoKGZyb250bWF0dGVyUmVnZXgpO1xuXG5cdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB5YW1sQ29udGVudCA9IG1hdGNoWzFdO1xuXHRcdFx0Y29uc3QgZnJvbnRtYXR0ZXIgPSB5YW1sLnBhcnNlKHlhbWxDb250ZW50KSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IG51bGw7XG5cblx0XHRcdGlmICghZnJvbnRtYXR0ZXIgfHwgdHlwZW9mIGZyb250bWF0dGVyICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZmlsZTogZmlsZS5wYXRoLFxuXHRcdFx0XHRmcm9udG1hdHRlcixcblx0XHRcdFx0cmF3WWFtbDogeWFtbENvbnRlbnRcblx0XHRcdH07XG5cdFx0fSBjYXRjaCB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRhdXRvRGV0ZWN0VGl0bGVQcm9wZXJ0eShmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcgfCBudWxsIHtcblx0XHRjb25zdCB0aXRsZVByb3BlcnRpZXMgPSBbJ3RpdGxlJywgJ25hbWUnLCAnaGVhZGxpbmUnLCAnaGVhZGluZycsICdzdWJqZWN0J107XG5cblx0XHRmb3IgKGNvbnN0IHByb3Agb2YgdGl0bGVQcm9wZXJ0aWVzKSB7XG5cdFx0XHRpZiAoZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0cmV0dXJuIHByb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhdXRvRGV0ZWN0RGF0ZVByb3BlcnR5KGZyb250bWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB8IG51bGwge1xuXHRcdGNvbnN0IGRhdGVQcm9wZXJ0aWVzID0gWydkYXRlJywgJ3B1YkRhdGUnLCAncHVibGlzaGVkRGF0ZScsICdwdWJsaXNoRGF0ZScsICdjcmVhdGVkJywgJ3VwZGF0ZWQnLCAnbW9kaWZpZWQnXTtcblxuXHRcdC8vIEZpcnN0IHBhc3M6IENoZWNrIGZvciBleGFjdCBwcm9wZXJ0eSBuYW1lcyB3aXRoIHZhbGlkIGRhdGUgdmFsdWVzXG5cdFx0Zm9yIChjb25zdCBwcm9wIG9mIGRhdGVQcm9wZXJ0aWVzKSB7XG5cdFx0XHRpZiAoZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBmcm9udG1hdHRlcltwcm9wXTtcblx0XHRcdFx0aWYgKHRoaXMubG9va3NMaWtlRGF0ZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNlY29uZCBwYXNzOiBDYXRjaCBhbnl0aGluZyB3aXRoIFwiZGF0ZVwiIGluIHRoZSBuYW1lIHRoYXQgbG9va3MgbGlrZSBhIGRhdGVcblx0XHRmb3IgKGNvbnN0IHByb3AgaW4gZnJvbnRtYXR0ZXIpIHtcblx0XHRcdGlmIChwcm9wLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RhdGUnKSAmJiB0aGlzLmxvb2tzTGlrZURhdGUoZnJvbnRtYXR0ZXJbcHJvcF0pKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cHJpdmF0ZSBsb29rc0xpa2VEYXRlKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiB7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdC8vIFlZWVktTU0tREQgb3IgSVNPIDg2MDFcblx0XHRcdHJldHVybiAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9Ly50ZXN0KHZhbHVlKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIFNpbXBsZSB0aW1lc3RhbXAgY2hlY2sgKDEwKyBkaWdpdHMpXG5cdFx0XHRyZXR1cm4gdmFsdWUgPiAxMDAwMDAwMDAwO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRhdXRvRGV0ZWN0RGVzY3JpcHRpb25Qcm9wZXJ0eShmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcgfCBudWxsIHtcblx0XHRjb25zdCBkZXNjcmlwdGlvblByb3BlcnRpZXMgPSBbJ2Rlc2NyaXB0aW9uJywgJ3N1bW1hcnknLCAnZXhjZXJwdCcsICdpbnRybycsICdzbmlwcGV0JywgJ2JsdXJiJ107XG5cblx0XHRmb3IgKGNvbnN0IHByb3Agb2YgZGVzY3JpcHRpb25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRpZiAoZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0cmV0dXJuIHByb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGZyb250bWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB8IG51bGwge1xuXHRcdC8vIE9ubHkgbWF0Y2ggXCJ0YWdzXCIgLSBzdHJpY3QgbWF0Y2hpbmcsIG5vIGZ1enp5IG1hdGNoaW5nXG5cdFx0aWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KCd0YWdzJykpIHtcblx0XHRcdHJldHVybiAndGFncyc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhdXRvRGV0ZWN0RHJhZnRQcm9wZXJ0eShmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB7IHByb3BlcnR5OiBzdHJpbmc7IGxvZ2ljOiAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnIH0gfCBudWxsIHtcblx0XHRpZiAoZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkoJ2RyYWZ0JykpIHtcblx0XHRcdGNvbnN0IHZhbCA9IGZyb250bWF0dGVyWydkcmFmdCddO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRyZXR1cm4geyBwcm9wZXJ0eTogJ2RyYWZ0JywgbG9naWM6ICd0cnVlLWRyYWZ0JyB9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChmcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eSgncHVibGlzaGVkJykpIHtcblx0XHRcdGNvbnN0IHZhbCA9IGZyb250bWF0dGVyWydwdWJsaXNoZWQnXTtcblx0XHRcdC8vIElmIHB1Ymxpc2hlZCBpcyBhIGJvb2xlYW4sIGl0J3MgZHJhZnQgbG9naWNcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0cmV0dXJuIHsgcHJvcGVydHk6ICdwdWJsaXNoZWQnLCBsb2dpYzogJ2ZhbHNlLWRyYWZ0JyB9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgcHVibGlzaGVkIGlzIGEgZGF0ZSAoY2hlY2tlZCBpbiBhdXRvRGV0ZWN0RGF0ZVByb3BlcnR5KSwgd2Ugc2tpcCBpdCBoZXJlXG5cdFx0fVxuXG5cdFx0aWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KCd2aXNpYmxlJykpIHtcblx0XHRcdGNvbnN0IHZhbCA9IGZyb250bWF0dGVyWyd2aXNpYmxlJ107XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHJldHVybiB7IHByb3BlcnR5OiAndmlzaWJsZScsIGxvZ2ljOiAnZmFsc2UtZHJhZnQnIH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhdXRvRGV0ZWN0SW1hZ2VQcm9wZXJ0eShmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcgfCBudWxsIHtcblx0XHRjb25zdCBpbWFnZVByb3BlcnRpZXMgPSBbJ2ltYWdlJywgJ2NvdmVyJywgJ2NvdmVySW1hZ2UnLCAndGh1bWJuYWlsJywgJ2ZlYXR1cmVkSW1hZ2UnXTtcblxuXHRcdGZvciAoY29uc3QgcHJvcCBvZiBpbWFnZVByb3BlcnRpZXMpIHtcblx0XHRcdGlmIChmcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufVxuXG4iLCAiY29uc3QgQUxJQVMgPSBTeW1ib2wuZm9yKCd5YW1sLmFsaWFzJyk7XG5jb25zdCBET0MgPSBTeW1ib2wuZm9yKCd5YW1sLmRvY3VtZW50Jyk7XG5jb25zdCBNQVAgPSBTeW1ib2wuZm9yKCd5YW1sLm1hcCcpO1xuY29uc3QgUEFJUiA9IFN5bWJvbC5mb3IoJ3lhbWwucGFpcicpO1xuY29uc3QgU0NBTEFSID0gU3ltYm9sLmZvcigneWFtbC5zY2FsYXInKTtcbmNvbnN0IFNFUSA9IFN5bWJvbC5mb3IoJ3lhbWwuc2VxJyk7XG5jb25zdCBOT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCd5YW1sLm5vZGUudHlwZScpO1xuY29uc3QgaXNBbGlhcyA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gQUxJQVM7XG5jb25zdCBpc0RvY3VtZW50ID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBET0M7XG5jb25zdCBpc01hcCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gTUFQO1xuY29uc3QgaXNQYWlyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBQQUlSO1xuY29uc3QgaXNTY2FsYXIgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IFNDQUxBUjtcbmNvbnN0IGlzU2VxID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTRVE7XG5mdW5jdGlvbiBpc0NvbGxlY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JylcbiAgICAgICAgc3dpdGNoIChub2RlW05PREVfVFlQRV0pIHtcbiAgICAgICAgICAgIGNhc2UgTUFQOlxuICAgICAgICAgICAgY2FzZSBTRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICAgIGlmIChub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JylcbiAgICAgICAgc3dpdGNoIChub2RlW05PREVfVFlQRV0pIHtcbiAgICAgICAgICAgIGNhc2UgQUxJQVM6XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgY2FzZSBTRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBoYXNBbmNob3IgPSAobm9kZSkgPT4gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgISFub2RlLmFuY2hvcjtcblxuZXhwb3J0IHsgQUxJQVMsIERPQywgTUFQLCBOT0RFX1RZUEUsIFBBSVIsIFNDQUxBUiwgU0VRLCBoYXNBbmNob3IsIGlzQWxpYXMsIGlzQ29sbGVjdGlvbiwgaXNEb2N1bWVudCwgaXNNYXAsIGlzTm9kZSwgaXNQYWlyLCBpc1NjYWxhciwgaXNTZXEgfTtcbiIsICJpbXBvcnQgeyBpc0RvY3VtZW50LCBpc05vZGUsIGlzUGFpciwgaXNDb2xsZWN0aW9uLCBpc01hcCwgaXNTZXEsIGlzU2NhbGFyLCBpc0FsaWFzIH0gZnJvbSAnLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5cbmNvbnN0IEJSRUFLID0gU3ltYm9sKCdicmVhayB2aXNpdCcpO1xuY29uc3QgU0tJUCA9IFN5bWJvbCgnc2tpcCBjaGlsZHJlbicpO1xuY29uc3QgUkVNT1ZFID0gU3ltYm9sKCdyZW1vdmUgbm9kZScpO1xuLyoqXG4gKiBBcHBseSBhIHZpc2l0b3IgdG8gYW4gQVNUIG5vZGUgb3IgZG9jdW1lbnQuXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gYG5vZGVgLCBjYWxsaW5nIGFcbiAqIGB2aXNpdG9yYCBmdW5jdGlvbiB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAgLSBga2V5YDogRm9yIHNlcXVlbmNlIHZhbHVlcyBhbmQgbWFwIGBQYWlyYCwgdGhlIG5vZGUncyBpbmRleCBpbiB0aGVcbiAqICAgICBjb2xsZWN0aW9uLiBXaXRoaW4gYSBgUGFpcmAsIGAna2V5J2Agb3IgYCd2YWx1ZSdgLCBjb3JyZXNwb25kaW5nbHkuXG4gKiAgICAgYG51bGxgIGZvciB0aGUgcm9vdCBub2RlLlxuICogICAtIGBub2RlYDogVGhlIGN1cnJlbnQgbm9kZS5cbiAqICAgLSBgcGF0aGA6IFRoZSBhbmNlc3RyeSBvZiB0aGUgY3VycmVudCBub2RlLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHZpc2l0b3IgbWF5IGJlIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhdmVyc2FsOlxuICogICAtIGB1bmRlZmluZWRgIChkZWZhdWx0KTogRG8gbm90aGluZyBhbmQgY29udGludWVcbiAqICAgLSBgdmlzaXQuU0tJUGA6IERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCBjb250aW51ZSB3aXRoIG5leHRcbiAqICAgICBzaWJsaW5nXG4gKiAgIC0gYHZpc2l0LkJSRUFLYDogVGVybWluYXRlIHRyYXZlcnNhbCBjb21wbGV0ZWx5XG4gKiAgIC0gYHZpc2l0LlJFTU9WRWA6IFJlbW92ZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgb25lXG4gKiAgIC0gYE5vZGVgOiBSZXBsYWNlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgYnkgdmlzaXRpbmcgaXRcbiAqICAgLSBgbnVtYmVyYDogV2hpbGUgaXRlcmF0aW5nIHRoZSBpdGVtcyBvZiBhIHNlcXVlbmNlIG9yIG1hcCwgc2V0IHRoZSBpbmRleFxuICogICAgIG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWYgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50XG4gKiAgICAgbm9kZSBoYXMgY2hhbmdlZC5cbiAqXG4gKiBJZiBgdmlzaXRvcmAgaXMgYSBzaW5nbGUgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHZhbHVlc1xuICogZW5jb3VudGVyZWQgaW4gdGhlIHRyZWUsIGluY2x1ZGluZyBlLmcuIGBudWxsYCB2YWx1ZXMuIEFsdGVybmF0aXZlbHksXG4gKiBzZXBhcmF0ZSB2aXNpdG9yIGZ1bmN0aW9ucyBtYXkgYmUgZGVmaW5lZCBmb3IgZWFjaCBgTWFwYCwgYFBhaXJgLCBgU2VxYCxcbiAqIGBBbGlhc2AgYW5kIGBTY2FsYXJgIG5vZGUuIFRvIGRlZmluZSB0aGUgc2FtZSB2aXNpdG9yIGZ1bmN0aW9uIGZvciBtb3JlIHRoYW5cbiAqIG9uZSBub2RlIHR5cGUsIHVzZSB0aGUgYENvbGxlY3Rpb25gIChtYXAgYW5kIHNlcSksIGBWYWx1ZWAgKG1hcCwgc2VxICYgc2NhbGFyKVxuICogYW5kIGBOb2RlYCAoYWxpYXMsIG1hcCwgc2VxICYgc2NhbGFyKSB0YXJnZXRzLiBPZiBhbGwgdGhlc2UsIG9ubHkgdGhlIG1vc3RcbiAqIHNwZWNpZmljIGRlZmluZWQgb25lIHdpbGwgYmUgdXNlZCBmb3IgZWFjaCBub2RlLlxuICovXG5mdW5jdGlvbiB2aXNpdChub2RlLCB2aXNpdG9yKSB7XG4gICAgY29uc3QgdmlzaXRvcl8gPSBpbml0VmlzaXRvcih2aXNpdG9yKTtcbiAgICBpZiAoaXNEb2N1bWVudChub2RlKSkge1xuICAgICAgICBjb25zdCBjZCA9IHZpc2l0XyhudWxsLCBub2RlLmNvbnRlbnRzLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbbm9kZV0pKTtcbiAgICAgICAgaWYgKGNkID09PSBSRU1PVkUpXG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICB2aXNpdF8obnVsbCwgbm9kZSwgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW10pKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXQuQlJFQUsgPSBCUkVBSztcbi8qKiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBub2RlICovXG52aXNpdC5SRU1PVkUgPSBSRU1PVkU7XG5mdW5jdGlvbiB2aXNpdF8oa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKSB7XG4gICAgY29uc3QgY3RybCA9IGNhbGxWaXNpdG9yKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCk7XG4gICAgaWYgKGlzTm9kZShjdHJsKSB8fCBpc1BhaXIoY3RybCkpIHtcbiAgICAgICAgcmVwbGFjZU5vZGUoa2V5LCBwYXRoLCBjdHJsKTtcbiAgICAgICAgcmV0dXJuIHZpc2l0XyhrZXksIGN0cmwsIHZpc2l0b3IsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN0cmwgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gdmlzaXRfKGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IHZpc2l0Xygna2V5Jywgbm9kZS5rZXksIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGNrID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjayA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGN2ID0gdmlzaXRfKCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuLyoqXG4gKiBBcHBseSBhbiBhc3luYyB2aXNpdG9yIHRvIGFuIEFTVCBub2RlIG9yIGRvY3VtZW50LlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIGBub2RlYCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIC0gYGtleWA6IEZvciBzZXF1ZW5jZSB2YWx1ZXMgYW5kIG1hcCBgUGFpcmAsIHRoZSBub2RlJ3MgaW5kZXggaW4gdGhlXG4gKiAgICAgY29sbGVjdGlvbi4gV2l0aGluIGEgYFBhaXJgLCBgJ2tleSdgIG9yIGAndmFsdWUnYCwgY29ycmVzcG9uZGluZ2x5LlxuICogICAgIGBudWxsYCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAqICAgLSBgbm9kZWA6IFRoZSBjdXJyZW50IG5vZGUuXG4gKiAgIC0gYHBhdGhgOiBUaGUgYW5jZXN0cnkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgUHJvbWlzZWA6IE11c3QgcmVzb2x2ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXNcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgY29udGludWUgd2l0aCBuZXh0XG4gKiAgICAgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBOb2RlYDogUmVwbGFjZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIGJ5IHZpc2l0aW5nIGl0XG4gKiAgIC0gYG51bWJlcmA6IFdoaWxlIGl0ZXJhdGluZyB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSBvciBtYXAsIHNldCB0aGUgaW5kZXhcbiAqICAgICBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICogICAgIG5vZGUgaGFzIGNoYW5nZWQuXG4gKlxuICogSWYgYHZpc2l0b3JgIGlzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB2YWx1ZXNcbiAqIGVuY291bnRlcmVkIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgZS5nLiBgbnVsbGAgdmFsdWVzLiBBbHRlcm5hdGl2ZWx5LFxuICogc2VwYXJhdGUgdmlzaXRvciBmdW5jdGlvbnMgbWF5IGJlIGRlZmluZWQgZm9yIGVhY2ggYE1hcGAsIGBQYWlyYCwgYFNlcWAsXG4gKiBgQWxpYXNgIGFuZCBgU2NhbGFyYCBub2RlLiBUbyBkZWZpbmUgdGhlIHNhbWUgdmlzaXRvciBmdW5jdGlvbiBmb3IgbW9yZSB0aGFuXG4gKiBvbmUgbm9kZSB0eXBlLCB1c2UgdGhlIGBDb2xsZWN0aW9uYCAobWFwIGFuZCBzZXEpLCBgVmFsdWVgIChtYXAsIHNlcSAmIHNjYWxhcilcbiAqIGFuZCBgTm9kZWAgKGFsaWFzLCBtYXAsIHNlcSAmIHNjYWxhcikgdGFyZ2V0cy4gT2YgYWxsIHRoZXNlLCBvbmx5IHRoZSBtb3N0XG4gKiBzcGVjaWZpYyBkZWZpbmVkIG9uZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggbm9kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmlzaXRBc3luYyhub2RlLCB2aXNpdG9yKSB7XG4gICAgY29uc3QgdmlzaXRvcl8gPSBpbml0VmlzaXRvcih2aXNpdG9yKTtcbiAgICBpZiAoaXNEb2N1bWVudChub2RlKSkge1xuICAgICAgICBjb25zdCBjZCA9IGF3YWl0IHZpc2l0QXN5bmNfKG51bGwsIG5vZGUuY29udGVudHMsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtub2RlXSkpO1xuICAgICAgICBpZiAoY2QgPT09IFJFTU9WRSlcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIGF3YWl0IHZpc2l0QXN5bmNfKG51bGwsIG5vZGUsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtdKSk7XG59XG4vLyBXaXRob3V0IHRoZSBgYXMgc3ltYm9sYCBjYXN0cywgVFMgZGVjbGFyZXMgdGhlc2UgaW4gdGhlIGB2aXNpdGBcbi8vIG5hbWVzcGFjZSB1c2luZyBgdmFyYCwgYnV0IHRoZW4gY29tcGxhaW5zIGFib3V0IHRoYXQgYmVjYXVzZVxuLy8gYHVuaXF1ZSBzeW1ib2xgIG11c3QgYmUgYGNvbnN0YC5cbi8qKiBUZXJtaW5hdGUgdmlzaXQgdHJhdmVyc2FsIGNvbXBsZXRlbHkgKi9cbnZpc2l0QXN5bmMuQlJFQUsgPSBCUkVBSztcbi8qKiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0QXN5bmMuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0QXN5bmMuUkVNT1ZFID0gUkVNT1ZFO1xuYXN5bmMgZnVuY3Rpb24gdmlzaXRBc3luY18oa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKSB7XG4gICAgY29uc3QgY3RybCA9IGF3YWl0IGNhbGxWaXNpdG9yKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCk7XG4gICAgaWYgKGlzTm9kZShjdHJsKSB8fCBpc1BhaXIoY3RybCkpIHtcbiAgICAgICAgcmVwbGFjZU5vZGUoa2V5LCBwYXRoLCBjdHJsKTtcbiAgICAgICAgcmV0dXJuIHZpc2l0QXN5bmNfKGtleSwgY3RybCwgdmlzaXRvciwgcGF0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3RybCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2kgPSBhd2FpdCB2aXNpdEFzeW5jXyhpLCBub2RlLml0ZW1zW2ldLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgY29uc3QgY2sgPSBhd2FpdCB2aXNpdEFzeW5jXygna2V5Jywgbm9kZS5rZXksIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGNrID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjayA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGN2ID0gYXdhaXQgdmlzaXRBc3luY18oJ3ZhbHVlJywgbm9kZS52YWx1ZSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY3YgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGN2ID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0cmw7XG59XG5mdW5jdGlvbiBpbml0VmlzaXRvcih2aXNpdG9yKSB7XG4gICAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAodmlzaXRvci5Db2xsZWN0aW9uIHx8IHZpc2l0b3IuTm9kZSB8fCB2aXNpdG9yLlZhbHVlKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBBbGlhczogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBTY2FsYXI6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5Ob2RlXG4gICAgICAgIH0sIHZpc2l0b3IuVmFsdWUgJiYge1xuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLlZhbHVlLFxuICAgICAgICAgICAgU2NhbGFyOiB2aXNpdG9yLlZhbHVlLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLlZhbHVlXG4gICAgICAgIH0sIHZpc2l0b3IuQ29sbGVjdGlvbiAmJiB7XG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuQ29sbGVjdGlvbixcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5Db2xsZWN0aW9uXG4gICAgICAgIH0sIHZpc2l0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdmlzaXRvcjtcbn1cbmZ1bmN0aW9uIGNhbGxWaXNpdG9yKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpc2l0b3Ioa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaXNNYXAobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLk1hcD8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlzU2VxKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5TZXE/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpc1BhaXIobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLlBhaXI/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpc1NjYWxhcihub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuU2NhbGFyPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaXNBbGlhcyhub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuQWxpYXM/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXBsYWNlTm9kZShrZXksIHBhdGgsIG5vZGUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzQ29sbGVjdGlvbihwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5pdGVtc1trZXldID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQYWlyKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2tleScpXG4gICAgICAgICAgICBwYXJlbnQua2V5ID0gbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEb2N1bWVudChwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5jb250ZW50cyA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwdCA9IGlzQWxpYXMocGFyZW50KSA/ICdhbGlhcycgOiAnc2NhbGFyJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlIHdpdGggJHtwdH0gcGFyZW50YCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyB2aXNpdCwgdmlzaXRBc3luYyB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG5jb25zdCBlc2NhcGVDaGFycyA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgICcsJzogJyUyQycsXG4gICAgJ1snOiAnJTVCJyxcbiAgICAnXSc6ICclNUQnLFxuICAgICd7JzogJyU3QicsXG4gICAgJ30nOiAnJTdEJ1xufTtcbmNvbnN0IGVzY2FwZVRhZ05hbWUgPSAodG4pID0+IHRuLnJlcGxhY2UoL1shLFtcXF17fV0vZywgY2ggPT4gZXNjYXBlQ2hhcnNbY2hdKTtcbmNsYXNzIERpcmVjdGl2ZXMge1xuICAgIGNvbnN0cnVjdG9yKHlhbWwsIHRhZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXJlY3RpdmVzLWVuZC9kb2Mtc3RhcnQgbWFya2VyIGAtLS1gLiBJZiBgbnVsbGAsIGEgbWFya2VyIG1heSBzdGlsbCBiZVxuICAgICAgICAgKiBpbmNsdWRlZCBpbiB0aGUgZG9jdW1lbnQncyBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jU3RhcnQgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGRvYy1lbmQgbWFya2VyIGAuLi5gLiAgKi9cbiAgICAgICAgdGhpcy5kb2NFbmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55YW1sID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCwgeWFtbCk7XG4gICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MsIHRhZ3MpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBEaXJlY3RpdmVzKHRoaXMueWFtbCwgdGhpcy50YWdzKTtcbiAgICAgICAgY29weS5kb2NTdGFydCA9IHRoaXMuZG9jU3RhcnQ7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEdXJpbmcgcGFyc2luZywgZ2V0IGEgRGlyZWN0aXZlcyBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQgYW5kXG4gICAgICogdXBkYXRlIHRoZSBzdHJlYW0gc3RhdGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHZlcnNpb24ncyBzcGVjLlxuICAgICAqL1xuICAgIGF0RG9jdW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBEaXJlY3RpdmVzKHRoaXMueWFtbCwgdGhpcy50YWdzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnlhbWwudmVyc2lvbikge1xuICAgICAgICAgICAgY2FzZSAnMS4xJzpcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzEuMic6XG4gICAgICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMueWFtbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXhwbGljaXQ6IERpcmVjdGl2ZXMuZGVmYXVsdFlhbWwuZXhwbGljaXQsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjInXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRUYWdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25FcnJvciAtIE1heSBiZSBjYWxsZWQgZXZlbiBpZiB0aGUgYWN0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICogQHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3NcbiAgICAgKi9cbiAgICBhZGQobGluZSwgb25FcnJvcikge1xuICAgICAgICBpZiAodGhpcy5hdE5leHREb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy55YW1sID0geyBleHBsaWNpdDogRGlyZWN0aXZlcy5kZWZhdWx0WWFtbC5leHBsaWNpdCwgdmVyc2lvbjogJzEuMScgfTtcbiAgICAgICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MpO1xuICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS50cmltKCkuc3BsaXQoL1sgXFx0XSsvKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnJVRBRyc6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoMCwgJyVUQUcgZGlyZWN0aXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgdHdvIHBhcnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbaGFuZGxlLCBwcmVmaXhdID0gcGFydHM7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICclWUFNTCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnlhbWwuZXhwbGljaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcigwLCAnJVlBTUwgZGlyZWN0aXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHBhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbdmVyc2lvbl0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gJzEuMScgfHwgdmVyc2lvbiA9PT0gJzEuMicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55YW1sLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSAvXlxcZCtcXC5cXGQrJC8udGVzdCh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcig2LCBgVW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uICR7dmVyc2lvbn1gLCBpc1ZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcigwLCBgVW5rbm93biBkaXJlY3RpdmUgJHtuYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHRhZywgbWF0Y2hpbmcgaGFuZGxlcyB0byB0aG9zZSBkZWZpbmVkIGluICVUQUcgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVkIHRhZywgd2hpY2ggbWF5IGFsc28gYmUgdGhlIG5vbi1zcGVjaWZpYyB0YWcgYCchJ2Agb3IgYVxuICAgICAqICAgYCchbG9jYWwnYCB0YWcsIG9yIGBudWxsYCBpZiB1bnJlc29sdmFibGUuXG4gICAgICovXG4gICAgdGFnTmFtZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuICchJzsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgICAgICBpZiAoc291cmNlWzBdICE9PSAnIScpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoYE5vdCBhIHZhbGlkIHRhZzogJHtzb3VyY2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlWzFdID09PSAnPCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcmJhdGltID0gc291cmNlLnNsaWNlKDIsIC0xKTtcbiAgICAgICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gJyEnIHx8IHZlcmJhdGltID09PSAnISEnKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihgVmVyYmF0aW0gdGFncyBhcmVuJ3QgcmVzb2x2ZWQsIHNvICR7c291cmNlfSBpcyBpbnZhbGlkLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09ICc+JylcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdWZXJiYXRpbSB0YWdzIG11c3QgZW5kIHdpdGggYSA+Jyk7XG4gICAgICAgICAgICByZXR1cm4gdmVyYmF0aW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgaGFuZGxlLCBzdWZmaXhdID0gc291cmNlLm1hdGNoKC9eKC4qISkoW14hXSopJC9zKTtcbiAgICAgICAgaWYgKCFzdWZmaXgpXG4gICAgICAgICAgICBvbkVycm9yKGBUaGUgJHtzb3VyY2V9IHRhZyBoYXMgbm8gc3VmZml4YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMudGFnc1toYW5kbGVdO1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBkZWNvZGVVUklDb21wb25lbnQoc3VmZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoU3RyaW5nKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTsgLy8gbG9jYWwgdGFnXG4gICAgICAgIG9uRXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIHRhZzogJHtzb3VyY2V9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGZ1bGx5IHJlc29sdmVkIHRhZywgcmV0dXJucyBpdHMgcHJpbnRhYmxlIHN0cmluZyBmb3JtLFxuICAgICAqIHRha2luZyBpbnRvIGFjY291bnQgY3VycmVudCB0YWcgcHJlZml4ZXMgYW5kIGRlZmF1bHRzLlxuICAgICAqL1xuICAgIHRhZ1N0cmluZyh0YWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlLCBwcmVmaXhdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMudGFncykpIHtcbiAgICAgICAgICAgIGlmICh0YWcuc3RhcnRzV2l0aChwcmVmaXgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUgKyBlc2NhcGVUYWdOYW1lKHRhZy5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWdbMF0gPT09ICchJyA/IHRhZyA6IGAhPCR7dGFnfT5gO1xuICAgIH1cbiAgICB0b1N0cmluZyhkb2MpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLnlhbWwuZXhwbGljaXRcbiAgICAgICAgICAgID8gW2AlWUFNTCAke3RoaXMueWFtbC52ZXJzaW9uIHx8ICcxLjInfWBdXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCB0YWdFbnRyaWVzID0gT2JqZWN0LmVudHJpZXModGhpcy50YWdzKTtcbiAgICAgICAgbGV0IHRhZ05hbWVzO1xuICAgICAgICBpZiAoZG9jICYmIHRhZ0VudHJpZXMubGVuZ3RoID4gMCAmJiBpc05vZGUoZG9jLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IHt9O1xuICAgICAgICAgICAgdmlzaXQoZG9jLmNvbnRlbnRzLCAoX2tleSwgbm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGUobm9kZSkgJiYgbm9kZS50YWcpXG4gICAgICAgICAgICAgICAgICAgIHRhZ3Nbbm9kZS50YWddID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFnTmFtZXMgPSBPYmplY3Qua2V5cyh0YWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YWdOYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gb2YgdGFnRW50cmllcykge1xuICAgICAgICAgICAgaWYgKGhhbmRsZSA9PT0gJyEhJyAmJiBwcmVmaXggPT09ICd0YWc6eWFtbC5vcmcsMjAwMjonKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFkb2MgfHwgdGFnTmFtZXMuc29tZSh0biA9PiB0bi5zdGFydHNXaXRoKHByZWZpeCkpKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCVUQUcgJHtoYW5kbGV9ICR7cHJlZml4fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9XG59XG5EaXJlY3RpdmVzLmRlZmF1bHRZYW1sID0geyBleHBsaWNpdDogZmFsc2UsIHZlcnNpb246ICcxLjInIH07XG5EaXJlY3RpdmVzLmRlZmF1bHRUYWdzID0geyAnISEnOiAndGFnOnlhbWwub3JnLDIwMDI6JyB9O1xuXG5leHBvcnQgeyBEaXJlY3RpdmVzIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIsIGlzQ29sbGVjdGlvbiB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG4vKipcbiAqIFZlcmlmeSB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSB2YWxpZCBhbmNob3IuXG4gKlxuICogV2lsbCB0aHJvdyBvbiBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIGFuY2hvcklzVmFsaWQoYW5jaG9yKSB7XG4gICAgaWYgKC9bXFx4MDAtXFx4MTlcXHMsW1xcXXt9XS8udGVzdChhbmNob3IpKSB7XG4gICAgICAgIGNvbnN0IHNhID0gSlNPTi5zdHJpbmdpZnkoYW5jaG9yKTtcbiAgICAgICAgY29uc3QgbXNnID0gYEFuY2hvciBtdXN0IG5vdCBjb250YWluIHdoaXRlc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXJzOiAke3NhfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFuY2hvck5hbWVzKHJvb3QpIHtcbiAgICBjb25zdCBhbmNob3JzID0gbmV3IFNldCgpO1xuICAgIHZpc2l0KHJvb3QsIHtcbiAgICAgICAgVmFsdWUoX2tleSwgbm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yKVxuICAgICAgICAgICAgICAgIGFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbmNob3JzO1xufVxuLyoqIEZpbmQgYSBuZXcgYW5jaG9yIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYHByZWZpeGAgYW5kIGEgb25lLWluZGV4ZWQgc3VmZml4LiAqL1xuZnVuY3Rpb24gZmluZE5ld0FuY2hvcihwcmVmaXgsIGV4Y2x1ZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgdHJ1ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwcmVmaXh9JHtpfWA7XG4gICAgICAgIGlmICghZXhjbHVkZS5oYXMobmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlQW5jaG9ycyhkb2MsIHByZWZpeCkge1xuICAgIGNvbnN0IGFsaWFzT2JqZWN0cyA9IFtdO1xuICAgIGNvbnN0IHNvdXJjZU9iamVjdHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHByZXZBbmNob3JzID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkFuY2hvcjogKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgYWxpYXNPYmplY3RzLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHByZXZBbmNob3JzID8/IChwcmV2QW5jaG9ycyA9IGFuY2hvck5hbWVzKGRvYykpO1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gZmluZE5ld0FuY2hvcihwcmVmaXgsIHByZXZBbmNob3JzKTtcbiAgICAgICAgICAgIHByZXZBbmNob3JzLmFkZChhbmNob3IpO1xuICAgICAgICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpdGggY2lyY3VsYXIgcmVmZXJlbmNlcywgdGhlIHNvdXJjZSBub2RlIGlzIG9ubHkgcmVzb2x2ZWQgYWZ0ZXIgYWxsXG4gICAgICAgICAqIG9mIGl0cyBjaGlsZCBub2RlcyBhcmUuIFRoaXMgaXMgd2h5IGFuY2hvcnMgYXJlIHNldCBvbmx5IGFmdGVyIGFsbCBvZlxuICAgICAgICAgKiB0aGUgbm9kZXMgaGF2ZSBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRBbmNob3JzOiAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBhbGlhc09iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBzb3VyY2VPYmplY3RzLmdldChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuYW5jaG9yICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1NjYWxhcihyZWYubm9kZSkgfHwgaXNDb2xsZWN0aW9uKHJlZi5ub2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLm5vZGUuYW5jaG9yID0gcmVmLmFuY2hvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSByZXBlYXRlZCBvYmplY3QgKHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4pJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VPYmplY3RzXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgYW5jaG9ySXNWYWxpZCwgYW5jaG9yTmFtZXMsIGNyZWF0ZU5vZGVBbmNob3JzLCBmaW5kTmV3QW5jaG9yIH07XG4iLCAiLyoqXG4gKiBBcHBsaWVzIHRoZSBKU09OLnBhcnNlIHJldml2ZXIgYWxnb3JpdGhtIGFzIGRlZmluZWQgaW4gdGhlIEVDTUEtMjYyIHNwZWMsXG4gKiBpbiBzZWN0aW9uIDI0LjUuMS4xIFwiUnVudGltZSBTZW1hbnRpY3M6IEludGVybmFsaXplSlNPTlByb3BlcnR5XCIgb2YgdGhlXG4gKiAyMDIxIGVkaXRpb246IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi5wYXJzZVxuICpcbiAqIEluY2x1ZGVzIGV4dGVuc2lvbnMgZm9yIGhhbmRsaW5nIE1hcCBhbmQgU2V0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UmV2aXZlcihyZXZpdmVyLCBvYmosIGtleSwgdmFsKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWxbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCBTdHJpbmcoaSksIHYwKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWFycmF5LWRlbGV0ZVxuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2ldO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2ldID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgQXJyYXkuZnJvbSh2YWwua2V5cygpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gdmFsLmdldChrKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIGssIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApXG4gICAgICAgICAgICAgICAgICAgIHZhbC5zZXQoaywgdjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2MCBvZiBBcnJheS5mcm9tKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIHYwLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKHYwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmFkZCh2MSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdjBdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIGssIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbFtrXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApXG4gICAgICAgICAgICAgICAgICAgIHZhbFtrXSA9IHYxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXZpdmVyLmNhbGwob2JqLCBrZXksIHZhbCk7XG59XG5cbmV4cG9ydCB7IGFwcGx5UmV2aXZlciB9O1xuIiwgImltcG9ydCB7IGhhc0FuY2hvciB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgYW55IG5vZGUgb3IgaXRzIGNvbnRlbnRzIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGlucHV0IHZhbHVlXG4gKiBAcGFyYW0gYXJnIC0gSWYgYHZhbHVlYCBkZWZpbmVzIGEgYHRvSlNPTigpYCBtZXRob2QsIHVzZSB0aGlzXG4gKiAgIGFzIGl0cyBmaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpLiBJZlxuICogICBgeyBrZWVwOiB0cnVlIH1gIGlzIG5vdCBzZXQsIG91dHB1dCBzaG91bGQgYmUgc3VpdGFibGUgZm9yIEpTT05cbiAqICAgc3RyaW5naWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiB0b0pTKHZhbHVlLCBhcmcsIGN0eCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gdG9KUyh2LCBTdHJpbmcoaSksIGN0eCkpO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgaWYgKCFjdHggfHwgIWhhc0FuY2hvcih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYWxpYXNDb3VudDogMCwgY291bnQ6IDEsIHJlczogdW5kZWZpbmVkIH07XG4gICAgICAgIGN0eC5hbmNob3JzLnNldCh2YWx1ZSwgZGF0YSk7XG4gICAgICAgIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICAgICAgICBkYXRhLnJlcyA9IHJlcztcbiAgICAgICAgICAgIGRlbGV0ZSBjdHgub25DcmVhdGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGlmIChjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgIWN0eD8ua2VlcClcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyB0b0pTIH07XG4iLCAiaW1wb3J0IHsgYXBwbHlSZXZpdmVyIH0gZnJvbSAnLi4vZG9jL2FwcGx5UmV2aXZlci5qcyc7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIGlzRG9jdW1lbnQgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jbGFzcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiB0eXBlIH0pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUuICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEEgcGxhaW4gSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuICovXG4gICAgdG9KUyhkb2MsIHsgbWFwQXNNYXAsIG1heEFsaWFzQ291bnQsIG9uQW5jaG9yLCByZXZpdmVyIH0gPSB7fSkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnQoZG9jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgZG9jdW1lbnQgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgYW5jaG9yczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAga2VlcDogdHJ1ZSxcbiAgICAgICAgICAgIG1hcEFzTWFwOiBtYXBBc01hcCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIG1hcEtleVdhcm5lZDogZmFsc2UsXG4gICAgICAgICAgICBtYXhBbGlhc0NvdW50OiB0eXBlb2YgbWF4QWxpYXNDb3VudCA9PT0gJ251bWJlcicgPyBtYXhBbGlhc0NvdW50IDogMTAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvSlModGhpcywgJycsIGN0eCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BbmNob3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgY291bnQsIHJlcyB9IG9mIGN0eC5hbmNob3JzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgIG9uQW5jaG9yKHJlcywgY291bnQpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHsgJyc6IHJlcyB9LCAnJywgcmVzKVxuICAgICAgICAgICAgOiByZXM7XG4gICAgfVxufVxuXG5leHBvcnQgeyBOb2RlQmFzZSB9O1xuIiwgImltcG9ydCB7IGFuY2hvcklzVmFsaWQgfSBmcm9tICcuLi9kb2MvYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gJy4uL3Zpc2l0LmpzJztcbmltcG9ydCB7IEFMSUFTLCBpc0FsaWFzLCBpc0NvbGxlY3Rpb24sIGlzUGFpciwgaGFzQW5jaG9yIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY2xhc3MgQWxpYXMgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKEFMSUFTKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndGFnJywge1xuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxpYXMgbm9kZXMgY2Fubm90IGhhdmUgdGFncycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSB0aGUgdmFsdWUgb2YgdGhpcyBhbGlhcyB3aXRoaW4gYGRvY2AsIGZpbmRpbmcgdGhlIGxhc3RcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgYHNvdXJjZWAgYW5jaG9yIGJlZm9yZSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgcmVzb2x2ZShkb2MsIGN0eCkge1xuICAgICAgICBsZXQgbm9kZXM7XG4gICAgICAgIGlmIChjdHg/LmFsaWFzUmVzb2x2ZUNhY2hlKSB7XG4gICAgICAgICAgICBub2RlcyA9IGN0eC5hbGlhc1Jlc29sdmVDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzID0gW107XG4gICAgICAgICAgICB2aXNpdChkb2MsIHtcbiAgICAgICAgICAgICAgICBOb2RlOiAoX2tleSwgbm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbGlhcyhub2RlKSB8fCBoYXNBbmNob3Iobm9kZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGN0eClcbiAgICAgICAgICAgICAgICBjdHguYWxpYXNSZXNvbHZlQ2FjaGUgPSBub2RlcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobm9kZS5hbmNob3IgPT09IHRoaXMuc291cmNlKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHRvSlNPTihfYXJnLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2U6IHRoaXMuc291cmNlIH07XG4gICAgICAgIGNvbnN0IHsgYW5jaG9ycywgZG9jLCBtYXhBbGlhc0NvdW50IH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb2x2ZShkb2MsIGN0eCk7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgVW5yZXNvbHZlZCBhbGlhcyAodGhlIGFuY2hvciBtdXN0IGJlIHNldCBiZWZvcmUgdGhlIGFsaWFzKTogJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgYW5jaG9ycyBmb3IgTm9kZS5wcm90b3R5cGUudG9KUygpXG4gICAgICAgICAgICB0b0pTKHNvdXJjZSwgbnVsbCwgY3R4KTtcbiAgICAgICAgICAgIGRhdGEgPSBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZGF0YT8ucmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdUaGlzIHNob3VsZCBub3QgaGFwcGVuOiBBbGlhcyBhbmNob3Igd2FzIG5vdCByZXNvbHZlZD8nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgICAgICAgZGF0YS5jb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEuYWxpYXNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBkYXRhLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KGRvYywgc291cmNlLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvdW50ICogZGF0YS5hbGlhc0NvdW50ID4gbWF4QWxpYXNDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdFeGNlc3NpdmUgYWxpYXMgY291bnQgaW5kaWNhdGVzIGEgcmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2snO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnJlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBfb25Db21tZW50LCBfb25DaG9tcEtlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjID0gYCoke3RoaXMuc291cmNlfWA7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGFuY2hvcklzVmFsaWQodGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLnZlcmlmeUFsaWFzT3JkZXIgJiYgIWN0eC5hbmNob3JzLmhhcyh0aGlzLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVW5yZXNvbHZlZCBhbGlhcyAodGhlIGFuY2hvciBtdXN0IGJlIHNldCBiZWZvcmUgdGhlIGFsaWFzKTogJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN0eC5pbXBsaWNpdEtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c3JjfSBgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUsIGFuY2hvcnMpIHtcbiAgICBpZiAoaXNBbGlhcyhub2RlKSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnJlc29sdmUoZG9jKTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gYW5jaG9ycyAmJiBzb3VyY2UgJiYgYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvciA/IGFuY2hvci5jb3VudCAqIGFuY2hvci5hbGlhc0NvdW50IDogMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLml0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZ2V0QWxpYXNDb3VudChkb2MsIGl0ZW0sIGFuY2hvcnMpO1xuICAgICAgICAgICAgaWYgKGMgPiBjb3VudClcbiAgICAgICAgICAgICAgICBjb3VudCA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgY29uc3Qga2MgPSBnZXRBbGlhc0NvdW50KGRvYywgbm9kZS5rZXksIGFuY2hvcnMpO1xuICAgICAgICBjb25zdCB2YyA9IGdldEFsaWFzQ291bnQoZG9jLCBub2RlLnZhbHVlLCBhbmNob3JzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGtjLCB2Yyk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufVxuXG5leHBvcnQgeyBBbGlhcyB9O1xuIiwgImltcG9ydCB7IFNDQUxBUiB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgTm9kZUJhc2UgfSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4vdG9KUy5qcyc7XG5cbmNvbnN0IGlzU2NhbGFyVmFsdWUgPSAodmFsdWUpID0+ICF2YWx1ZSB8fCAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpO1xuY2xhc3MgU2NhbGFyIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKFNDQUxBUik7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9KU09OKGFyZywgY3R4KSB7XG4gICAgICAgIHJldHVybiBjdHg/LmtlZXAgPyB0aGlzLnZhbHVlIDogdG9KUyh0aGlzLnZhbHVlLCBhcmcsIGN0eCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblNjYWxhci5CTE9DS19GT0xERUQgPSAnQkxPQ0tfRk9MREVEJztcblNjYWxhci5CTE9DS19MSVRFUkFMID0gJ0JMT0NLX0xJVEVSQUwnO1xuU2NhbGFyLlBMQUlOID0gJ1BMQUlOJztcblNjYWxhci5RVU9URV9ET1VCTEUgPSAnUVVPVEVfRE9VQkxFJztcblNjYWxhci5RVU9URV9TSU5HTEUgPSAnUVVPVEVfU0lOR0xFJztcblxuZXhwb3J0IHsgU2NhbGFyLCBpc1NjYWxhclZhbHVlIH07XG4iLCAiaW1wb3J0IHsgQWxpYXMgfSBmcm9tICcuLi9ub2Rlcy9BbGlhcy5qcyc7XG5pbXBvcnQgeyBpc05vZGUsIGlzUGFpciwgTUFQLCBTRVEsIGlzRG9jdW1lbnQgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSB0YWdOYW1lKTtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCkgPz8gbWF0Y2hbMF07XG4gICAgICAgIGlmICghdGFnT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgJHt0YWdOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHRhZ09iajtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+IHQuaWRlbnRpZnk/Lih2YWx1ZSkgJiYgIXQuZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGN0eCkge1xuICAgIGlmIChpc0RvY3VtZW50KHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5jb250ZW50cztcbiAgICBpZiAoaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChpc1BhaXIodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IGN0eC5zY2hlbWFbTUFQXS5jcmVhdGVOb2RlPy4oY3R4LnNjaGVtYSwgbnVsbCwgY3R4KTtcbiAgICAgICAgbWFwLml0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICh0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJpZ0ludCkgLy8gbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlXG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2VyaWFsaXplanNvbnByb3BlcnR5XG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cbiAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgb25BbmNob3IsIG9uVGFnT2JqLCBzY2hlbWEsIHNvdXJjZU9iamVjdHMgfSA9IGN0eDtcbiAgICAvLyBEZXRlY3QgZHVwbGljYXRlIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgb2JqZWN0ICYgdXNlIEFsaWFzIG5vZGVzIGZvciBhbGxcbiAgICAvLyBhZnRlciBmaXJzdC4gVGhlIGByZWZgIHdyYXBwZXIgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG4gICAgbGV0IHJlZiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoYWxpYXNEdXBsaWNhdGVPYmplY3RzICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVmID0gc291cmNlT2JqZWN0cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICByZWYuYW5jaG9yID8/IChyZWYuYW5jaG9yID0gb25BbmNob3IodmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxpYXMocmVmLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB7IGFuY2hvcjogbnVsbCwgbm9kZTogbnVsbCB9O1xuICAgICAgICAgICAgc291cmNlT2JqZWN0cy5zZXQodmFsdWUsIHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWU/LnN0YXJ0c1dpdGgoJyEhJykpXG4gICAgICAgIHRhZ05hbWUgPSBkZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlZilcbiAgICAgICAgICAgICAgICByZWYubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0YWdPYmogPVxuICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICAgICAgICA/IHNjaGVtYVtNQVBdXG4gICAgICAgICAgICAgICAgOiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IHNjaGVtYVtTRVFdXG4gICAgICAgICAgICAgICAgICAgIDogc2NoZW1hW01BUF07XG4gICAgfVxuICAgIGlmIChvblRhZ09iaikge1xuICAgICAgICBvblRhZ09iaih0YWdPYmopO1xuICAgICAgICBkZWxldGUgY3R4Lm9uVGFnT2JqO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gdGFnT2JqPy5jcmVhdGVOb2RlXG4gICAgICAgID8gdGFnT2JqLmNyZWF0ZU5vZGUoY3R4LnNjaGVtYSwgdmFsdWUsIGN0eClcbiAgICAgICAgOiB0eXBlb2YgdGFnT2JqPy5ub2RlQ2xhc3M/LmZyb20gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gdGFnT2JqLm5vZGVDbGFzcy5mcm9tKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpXG4gICAgICAgICAgICA6IG5ldyBTY2FsYXIodmFsdWUpO1xuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBub2RlLnRhZyA9IHRhZ05hbWU7XG4gICAgZWxzZSBpZiAoIXRhZ09iai5kZWZhdWx0KVxuICAgICAgICBub2RlLnRhZyA9IHRhZ09iai50YWc7XG4gICAgaWYgKHJlZilcbiAgICAgICAgcmVmLm5vZGUgPSBub2RlO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgeyBjcmVhdGVOb2RlIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IGlzTm9kZSwgaXNQYWlyLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSB9IGZyb20gJy4vTm9kZS5qcyc7XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25Gcm9tUGF0aChzY2hlbWEsIHBhdGgsIHZhbHVlKSB7XG4gICAgbGV0IHYgPSB2YWx1ZTtcbiAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBrID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKGspICYmIGsgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgYVtrXSA9IHY7XG4gICAgICAgICAgICB2ID0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSBuZXcgTWFwKFtbaywgdl1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTm9kZSh2LCB1bmRlZmluZWQsIHtcbiAgICAgICAgYWxpYXNEdXBsaWNhdGVPYmplY3RzOiBmYWxzZSxcbiAgICAgICAga2VlcFVuZGVmaW5lZDogZmFsc2UsXG4gICAgICAgIG9uQW5jaG9yOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIHBsZWFzZSByZXBvcnQgYSBidWcuJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgc291cmNlT2JqZWN0czogbmV3IE1hcCgpXG4gICAgfSk7XG59XG4vLyBUeXBlIGd1YXJkIGlzIGludGVudGlvbmFsbHkgYSBsaXR0bGUgd3Jvbmcgc28gYXMgdG8gYmUgbW9yZSB1c2VmdWwsXG4vLyBhcyBpdCBkb2VzIG5vdCBjb3ZlciB1bnR5cGFibGUgZW1wdHkgbm9uLXN0cmluZyBpdGVyYWJsZXMgKGUuZy4gW10pLlxuY29uc3QgaXNFbXB0eVBhdGggPSAocGF0aCkgPT4gcGF0aCA9PSBudWxsIHx8XG4gICAgKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiAhIXBhdGhbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS5kb25lKTtcbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHR5cGUpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBJZiBkZWZpbmVkLCBvdmVyd3JpdGVzIHRoZSBvcmlnaW5hbCdzIHNjaGVtYVxuICAgICAqL1xuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIGNvcHkuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBjb3B5Lml0ZW1zID0gY29weS5pdGVtcy5tYXAoaXQgPT4gaXNOb2RlKGl0KSB8fCBpc1BhaXIoaXQpID8gaXQuY2xvbmUoc2NoZW1hKSA6IGl0KTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLiBGb3IgYCEhbWFwYCBhbmQgYCEhb21hcGAgdGhlIHZhbHVlIG11c3RcbiAgICAgKiBiZSBhIFBhaXIgaW5zdGFuY2Ugb3IgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdCwgd2hpY2ggbWF5IG5vdCBoYXZlIGEga2V5XG4gICAgICogdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIobm9kZSkgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhc0FsbE51bGxWYWx1ZXMoYWxsb3dTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUGFpcihub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGFsbG93U2NhbGFyICYmXG4gICAgICAgICAgICAgICAgICAgIGlzU2NhbGFyKG4pICYmXG4gICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50QmVmb3JlICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4udGFnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuaGFzSW4ocmVzdCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgQ29sbGVjdGlvbiwgY29sbGVjdGlvbkZyb21QYXRoLCBpc0VtcHR5UGF0aCB9O1xuIiwgIi8qKlxuICogU3RyaW5naWZpZXMgYSBjb21tZW50LlxuICpcbiAqIEVtcHR5IGNvbW1lbnQgbGluZXMgYXJlIGxlZnQgZW1wdHksXG4gKiBsaW5lcyBjb25zaXN0aW5nIG9mIGEgc2luZ2xlIHNwYWNlIGFyZSByZXBsYWNlZCBieSBgI2AsXG4gKiBhbmQgYWxsIG90aGVyIGxpbmVzIGFyZSBwcmVmaXhlZCB3aXRoIGEgYCNgLlxuICovXG5jb25zdCBzdHJpbmdpZnlDb21tZW50ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL14oPyEkKSg/OiAkKT8vZ20sICcjJyk7XG5mdW5jdGlvbiBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudCkge1xuICAgIGlmICgvXlxcbiskLy50ZXN0KGNvbW1lbnQpKVxuICAgICAgICByZXR1cm4gY29tbWVudC5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIGluZGVudCA/IGNvbW1lbnQucmVwbGFjZSgvXig/ISAqJCkvZ20sIGluZGVudCkgOiBjb21tZW50O1xufVxuY29uc3QgbGluZUNvbW1lbnQgPSAoc3RyLCBpbmRlbnQsIGNvbW1lbnQpID0+IHN0ci5lbmRzV2l0aCgnXFxuJylcbiAgICA/IGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgIDogY29tbWVudC5pbmNsdWRlcygnXFxuJylcbiAgICAgICAgPyAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgICAgICA6IChzdHIuZW5kc1dpdGgoJyAnKSA/ICcnIDogJyAnKSArIGNvbW1lbnQ7XG5cbmV4cG9ydCB7IGluZGVudENvbW1lbnQsIGxpbmVDb21tZW50LCBzdHJpbmdpZnlDb21tZW50IH07XG4iLCAiY29uc3QgRk9MRF9GTE9XID0gJ2Zsb3cnO1xuY29uc3QgRk9MRF9CTE9DSyA9ICdibG9jayc7XG5jb25zdCBGT0xEX1FVT1RFRCA9ICdxdW90ZWQnO1xuLyoqXG4gKiBUcmllcyB0byBrZWVwIGlucHV0IGF0IHVwIHRvIGBsaW5lV2lkdGhgIGNoYXJhY3RlcnMsIHNwbGl0dGluZyBvbmx5IG9uIHNwYWNlc1xuICogbm90IGZvbGxvd2VkIGJ5IG5ld2xpbmVzIG9yIHNwYWNlcyB1bmxlc3MgYG1vZGVgIGlzIGAncXVvdGVkJ2AuIExpbmVzIGFyZVxuICogdGVybWluYXRlZCB3aXRoIGBcXG5gIGFuZCBzdGFydGVkIHdpdGggYGluZGVudGAuXG4gKi9cbmZ1bmN0aW9uIGZvbGRGbG93TGluZXModGV4dCwgaW5kZW50LCBtb2RlID0gJ2Zsb3cnLCB7IGluZGVudEF0U3RhcnQsIGxpbmVXaWR0aCA9IDgwLCBtaW5Db250ZW50V2lkdGggPSAyMCwgb25Gb2xkLCBvbk92ZXJmbG93IH0gPSB7fSkge1xuICAgIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGlmIChsaW5lV2lkdGggPCBtaW5Db250ZW50V2lkdGgpXG4gICAgICAgIG1pbkNvbnRlbnRXaWR0aCA9IDA7XG4gICAgY29uc3QgZW5kU3RlcCA9IE1hdGgubWF4KDEgKyBtaW5Db250ZW50V2lkdGgsIDEgKyBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoKTtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gZW5kU3RlcClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgY29uc3QgZm9sZHMgPSBbXTtcbiAgICBjb25zdCBlc2NhcGVkRm9sZHMgPSB7fTtcbiAgICBsZXQgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGluZGVudEF0U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbmRlbnRBdFN0YXJ0ID4gbGluZVdpZHRoIC0gTWF0aC5tYXgoMiwgbWluQ29udGVudFdpZHRoKSlcbiAgICAgICAgICAgIGZvbGRzLnB1c2goMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudEF0U3RhcnQ7XG4gICAgfVxuICAgIGxldCBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcHJldiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb3ZlcmZsb3cgPSBmYWxzZTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGxldCBlc2NTdGFydCA9IC0xO1xuICAgIGxldCBlc2NFbmQgPSAtMTtcbiAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykge1xuICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGksIGluZGVudC5sZW5ndGgpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpXG4gICAgICAgICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICB9XG4gICAgZm9yIChsZXQgY2g7IChjaCA9IHRleHRbKGkgKz0gMSldKTspIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEICYmIGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGVzY1N0YXJ0ID0gaTtcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dFtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NFbmQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKVxuICAgICAgICAgICAgICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSwgaW5kZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbmQgPSBpICsgaW5kZW50Lmxlbmd0aCArIGVuZFN0ZXA7XG4gICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnICYmXG4gICAgICAgICAgICAgICAgcHJldiAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICdcXG4nICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGFjZSBzdXJyb3VuZGVkIGJ5IG5vbi1zcGFjZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBuZXdsaW5lICsgaW5kZW50XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRleHRbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09ICcgJyAmJiBuZXh0ICE9PSAnXFxuJyAmJiBuZXh0ICE9PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRzLnB1c2goc3BsaXQpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzcGxpdCArIGVuZFN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGl0ZS1zcGFjZSBjb2xsZWN0ZWQgYXQgZW5kIG1heSBzdHJldGNoIHBhc3QgbGluZVdpZHRoXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcmV2ID09PSAnICcgfHwgcHJldiA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gdGV4dFsoaSArPSAxKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgbmV3bGluZSBlc2NhcGUsIGJ1dCBkb24ndCBicmVhayBwcmVjZWRpbmcgZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGogPSBpID4gZXNjRW5kICsgMSA/IGkgLSAyIDogZXNjU3RhcnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBpZiBsaW5lV2lkdGggJiBtaW5Db250ZW50V2lkdGggYXJlIHNob3J0ZXIgdGhhbiBhbiBlc2NhcGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkRm9sZHNbal0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgZm9sZHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlZEZvbGRzW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gaiArIGVuZFN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gY2g7XG4gICAgfVxuICAgIGlmIChvdmVyZmxvdyAmJiBvbk92ZXJmbG93KVxuICAgICAgICBvbk92ZXJmbG93KCk7XG4gICAgaWYgKGZvbGRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgaWYgKG9uRm9sZClcbiAgICAgICAgb25Gb2xkKCk7XG4gICAgbGV0IHJlcyA9IHRleHQuc2xpY2UoMCwgZm9sZHNbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZm9sZCA9IGZvbGRzW2ldO1xuICAgICAgICBjb25zdCBlbmQgPSBmb2xkc1tpICsgMV0gfHwgdGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChmb2xkID09PSAwKVxuICAgICAgICAgICAgcmVzID0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZSgwLCBlbmQpfWA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEICYmIGVzY2FwZWRGb2xkc1tmb2xkXSlcbiAgICAgICAgICAgICAgICByZXMgKz0gYCR7dGV4dFtmb2xkXX1cXFxcYDtcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKGZvbGQgKyAxLCBlbmQpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogUHJlc3VtZXMgYGkgKyAxYCBpcyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lXG4gKiBAcmV0dXJucyBpbmRleCBvZiBsYXN0IG5ld2xpbmUgaW4gbW9yZS1pbmRlbnRlZCBibG9ja1xuICovXG5mdW5jdGlvbiBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSwgaW5kZW50KSB7XG4gICAgbGV0IGVuZCA9IGk7XG4gICAgbGV0IHN0YXJ0ID0gaSArIDE7XG4gICAgbGV0IGNoID0gdGV4dFtzdGFydF07XG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgIGlmIChpIDwgc3RhcnQgKyBpbmRlbnQpIHtcbiAgICAgICAgICAgIGNoID0gdGV4dFsrK2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNoID0gdGV4dFsrK2ldO1xuICAgICAgICAgICAgfSB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKTtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgY2ggPSB0ZXh0W3N0YXJ0XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuXG5leHBvcnQgeyBGT0xEX0JMT0NLLCBGT0xEX0ZMT1csIEZPTERfUVVPVEVELCBmb2xkRmxvd0xpbmVzIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IGZvbGRGbG93TGluZXMsIEZPTERfRkxPVywgRk9MRF9RVU9URUQsIEZPTERfQkxPQ0sgfSBmcm9tICcuL2ZvbGRGbG93TGluZXMuanMnO1xuXG5jb25zdCBnZXRGb2xkT3B0aW9ucyA9IChjdHgsIGlzQmxvY2spID0+ICh7XG4gICAgaW5kZW50QXRTdGFydDogaXNCbG9jayA/IGN0eC5pbmRlbnQubGVuZ3RoIDogY3R4LmluZGVudEF0U3RhcnQsXG4gICAgbGluZVdpZHRoOiBjdHgub3B0aW9ucy5saW5lV2lkdGgsXG4gICAgbWluQ29udGVudFdpZHRoOiBjdHgub3B0aW9ucy5taW5Db250ZW50V2lkdGhcbn0pO1xuLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuY29uc3QgY29udGFpbnNEb2N1bWVudE1hcmtlciA9IChzdHIpID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5mdW5jdGlvbiBsaW5lTGVuZ3RoT3ZlckxpbWl0KHN0ciwgbGluZVdpZHRoLCBpbmRlbnRMZW5ndGgpIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuIDw9IGxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkQXNKU09OKVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5IH0gPSBjdHg7XG4gICAgY29uc3QgbWluTXVsdGlMaW5lTGVuZ3RoID0gY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICAgICAgaWYgKGNoID09PSAnICcgJiYganNvbltpICsgMV0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAyXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXFxcICc7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICBjaCA9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJylcbiAgICAgICAgICAgIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGpzb24uc3Vic3RyKGkgKyAyLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMWInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDA4NSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXE4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxMJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXFAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx4JyArIGNvZGUuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDJdID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmxlbmd0aCA8IG1pbk11bHRpTGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqc29uW2kgKyAyXSA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgM10gPT09ICduJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSBhZnRlciBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25baSArIDJdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX1FVT1RFRCwgZ2V0Rm9sZE9wdGlvbnMoY3R4LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gc2luZ2xlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuc2luZ2xlUXVvdGUgPT09IGZhbHNlIHx8XG4gICAgICAgIChjdHguaW1wbGljaXRLZXkgJiYgdmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB8fFxuICAgICAgICAvWyBcXHRdXFxufFxcblsgXFx0XS8udGVzdCh2YWx1ZSkgLy8gc2luZ2xlIHF1b3RlZCBzdHJpbmcgY2FuJ3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgYXJvdW5kIG5ld2xpbmVcbiAgICApXG4gICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgY29uc3QgaW5kZW50ID0gY3R4LmluZGVudCB8fCAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICAgIGNvbnN0IHJlcyA9IFwiJ1wiICsgdmFsdWUucmVwbGFjZSgvJy9nLCBcIicnXCIpLnJlcGxhY2UoL1xcbisvZywgYCQmXFxuJHtpbmRlbnR9YCkgKyBcIidcIjtcbiAgICByZXR1cm4gY3R4LmltcGxpY2l0S2V5XG4gICAgICAgID8gcmVzXG4gICAgICAgIDogZm9sZEZsb3dMaW5lcyhyZXMsIGluZGVudCwgRk9MRF9GTE9XLCBnZXRGb2xkT3B0aW9ucyhjdHgsIGZhbHNlKSk7XG59XG5mdW5jdGlvbiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IHsgc2luZ2xlUXVvdGUgfSA9IGN0eC5vcHRpb25zO1xuICAgIGxldCBxcztcbiAgICBpZiAoc2luZ2xlUXVvdGUgPT09IGZhbHNlKVxuICAgICAgICBxcyA9IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgaGFzRG91YmxlID0gdmFsdWUuaW5jbHVkZXMoJ1wiJyk7XG4gICAgICAgIGNvbnN0IGhhc1NpbmdsZSA9IHZhbHVlLmluY2x1ZGVzKFwiJ1wiKTtcbiAgICAgICAgaWYgKGhhc0RvdWJsZSAmJiAhaGFzU2luZ2xlKVxuICAgICAgICAgICAgcXMgPSBzaW5nbGVRdW90ZWRTdHJpbmc7XG4gICAgICAgIGVsc2UgaWYgKGhhc1NpbmdsZSAmJiAhaGFzRG91YmxlKVxuICAgICAgICAgICAgcXMgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHFzID0gc2luZ2xlUXVvdGUgPyBzaW5nbGVRdW90ZWRTdHJpbmcgOiBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBxcyh2YWx1ZSwgY3R4KTtcbn1cbi8vIFRoZSBuZWdhdGl2ZSBsb29rYmVoaW5kIGF2b2lkcyBhIHBvbHlub21pYWwgc2VhcmNoLFxuLy8gYnV0IGlzbid0IHN1cHBvcnRlZCB5ZXQgb24gU2FmYXJpOiBodHRwczovL2Nhbml1c2UuY29tL2pzLXJlZ2V4cC1sb29rYmVoaW5kXG5sZXQgYmxvY2tFbmROZXdsaW5lcztcbnRyeSB7XG4gICAgYmxvY2tFbmROZXdsaW5lcyA9IG5ldyBSZWdFeHAoJyhefCg/PCFcXG4pKVxcbisoPyFcXG58JCknLCAnZycpO1xufVxuY2F0Y2gge1xuICAgIGJsb2NrRW5kTmV3bGluZXMgPSAvXFxuKyg/IVxcbnwkKS9nO1xufVxuZnVuY3Rpb24gYmxvY2tTdHJpbmcoeyBjb21tZW50LCB0eXBlLCB2YWx1ZSB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IGJsb2NrUXVvdGUsIGNvbW1lbnRTdHJpbmcsIGxpbmVXaWR0aCB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgLy8gMS4gQmxvY2sgY2FuJ3QgZW5kIGluIHdoaXRlc3BhY2UgdW5sZXNzIHRoZSBsYXN0IGxpbmUgaXMgbm9uLWVtcHR5LlxuICAgIC8vIDIuIFN0cmluZ3MgY29uc2lzdGluZyBvZiBvbmx5IHdoaXRlc3BhY2UgYXJlIGJlc3QgcmVuZGVyZWQgZXhwbGljaXRseS5cbiAgICBpZiAoIWJsb2NrUXVvdGUgfHwgL1xcbltcXHQgXSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8XG4gICAgICAgIChjdHguZm9yY2VCbG9ja0luZGVudCB8fCBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgY29uc3QgbGl0ZXJhbCA9IGJsb2NrUXVvdGUgPT09ICdsaXRlcmFsJ1xuICAgICAgICA/IHRydWVcbiAgICAgICAgOiBibG9ja1F1b3RlID09PSAnZm9sZGVkJyB8fCB0eXBlID09PSBTY2FsYXIuQkxPQ0tfRk9MREVEXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IHR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMXG4gICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgOiAhbGluZUxlbmd0aE92ZXJMaW1pdCh2YWx1ZSwgbGluZVdpZHRoLCBpbmRlbnQubGVuZ3RoKTtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gbGl0ZXJhbCA/ICd8XFxuJyA6ICc+XFxuJztcbiAgICAvLyBkZXRlcm1pbmUgY2hvbXBpbmcgZnJvbSB3aGl0ZXNwYWNlIGF0IHZhbHVlIGVuZFxuICAgIGxldCBjaG9tcDtcbiAgICBsZXQgZW5kU3RhcnQ7XG4gICAgZm9yIChlbmRTdGFydCA9IHZhbHVlLmxlbmd0aDsgZW5kU3RhcnQgPiAwOyAtLWVuZFN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGNoID0gdmFsdWVbZW5kU3RhcnQgLSAxXTtcbiAgICAgICAgaWYgKGNoICE9PSAnXFxuJyAmJiBjaCAhPT0gJ1xcdCcgJiYgY2ggIT09ICcgJylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgZW5kID0gdmFsdWUuc3Vic3RyaW5nKGVuZFN0YXJ0KTtcbiAgICBjb25zdCBlbmRObFBvcyA9IGVuZC5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoZW5kTmxQb3MgPT09IC0xKSB7XG4gICAgICAgIGNob21wID0gJy0nOyAvLyBzdHJpcFxuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gZW5kIHx8IGVuZE5sUG9zICE9PSBlbmQubGVuZ3RoIC0gMSkge1xuICAgICAgICBjaG9tcCA9ICcrJzsgLy8ga2VlcFxuICAgICAgICBpZiAob25DaG9tcEtlZXApXG4gICAgICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hvbXAgPSAnJzsgLy8gY2xpcFxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLWVuZC5sZW5ndGgpO1xuICAgICAgICBpZiAoZW5kW2VuZC5sZW5ndGggLSAxXSA9PT0gJ1xcbicpXG4gICAgICAgICAgICBlbmQgPSBlbmQuc2xpY2UoMCwgLTEpO1xuICAgICAgICBlbmQgPSBlbmQucmVwbGFjZShibG9ja0VuZE5ld2xpbmVzLCBgJCYke2luZGVudH1gKTtcbiAgICB9XG4gICAgLy8gZGV0ZXJtaW5lIGluZGVudCBpbmRpY2F0b3IgZnJvbSB3aGl0ZXNwYWNlIGF0IHZhbHVlIHN0YXJ0XG4gICAgbGV0IHN0YXJ0V2l0aFNwYWNlID0gZmFsc2U7XG4gICAgbGV0IHN0YXJ0RW5kO1xuICAgIGxldCBzdGFydE5sUG9zID0gLTE7XG4gICAgZm9yIChzdGFydEVuZCA9IDA7IHN0YXJ0RW5kIDwgdmFsdWUubGVuZ3RoOyArK3N0YXJ0RW5kKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdmFsdWVbc3RhcnRFbmRdO1xuICAgICAgICBpZiAoY2ggPT09ICcgJylcbiAgICAgICAgICAgIHN0YXJ0V2l0aFNwYWNlID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RhcnRObFBvcyA9IHN0YXJ0RW5kO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHN0YXJ0TmxQb3MgPCBzdGFydEVuZCA/IHN0YXJ0TmxQb3MgKyAxIDogc3RhcnRFbmQpO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhzdGFydC5sZW5ndGgpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudFNpemUgPSBpbmRlbnQgPyAnMicgOiAnMSc7IC8vIHJvb3QgaXMgYXQgLTFcbiAgICAvLyBMZWFkaW5nIHwgb3IgPiBpcyBhZGRlZCBsYXRlclxuICAgIGxldCBoZWFkZXIgPSAoc3RhcnRXaXRoU3BhY2UgPyBpbmRlbnRTaXplIDogJycpICsgY2hvbXA7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgaGVhZGVyICs9ICcgJyArIGNvbW1lbnRTdHJpbmcoY29tbWVudC5yZXBsYWNlKC8gP1tcXHJcXG5dKy9nLCAnICcpKTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBpZiAoIWxpdGVyYWwpIHtcbiAgICAgICAgY29uc3QgZm9sZGVkVmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgJ1xcbiQmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oPzpefFxcbikoW1xcdCBdLiopKD86KFtcXG5cXHQgXSopXFxuKD8hW1xcblxcdCBdKSk/L2csICckMSQyJykgLy8gbW9yZS1pbmRlbnRlZCBsaW5lcyBhcmVuJ3QgZm9sZGVkXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBeIG1vcmUtaW5kLiBeIGVtcHR5ICAgICBeIGNhcHR1cmUgbmV4dCBlbXB0eSBsaW5lcyBvbmx5IGF0IGVuZCBvZiBpbmRlbnRcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgICAgICBsZXQgbGl0ZXJhbEZhbGxiYWNrID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGZvbGRPcHRpb25zID0gZ2V0Rm9sZE9wdGlvbnMoY3R4LCB0cnVlKTtcbiAgICAgICAgaWYgKGJsb2NrUXVvdGUgIT09ICdmb2xkZWQnICYmIHR5cGUgIT09IFNjYWxhci5CTE9DS19GT0xERUQpIHtcbiAgICAgICAgICAgIGZvbGRPcHRpb25zLm9uT3ZlcmZsb3cgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGl0ZXJhbEZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGZvbGRGbG93TGluZXMoYCR7c3RhcnR9JHtmb2xkZWRWYWx1ZX0ke2VuZH1gLCBpbmRlbnQsIEZPTERfQkxPQ0ssIGZvbGRPcHRpb25zKTtcbiAgICAgICAgaWYgKCFsaXRlcmFsRmFsbGJhY2spXG4gICAgICAgICAgICByZXR1cm4gYD4ke2hlYWRlcn1cXG4ke2luZGVudH0ke2JvZHl9YDtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIHJldHVybiBgfCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7c3RhcnR9JHt2YWx1ZX0ke2VuZH1gO1xufVxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbTtcbiAgICBjb25zdCB7IGFjdHVhbFN0cmluZywgaW1wbGljaXRLZXksIGluZGVudCwgaW5kZW50U3RlcCwgaW5GbG93IH0gPSBjdHg7XG4gICAgaWYgKChpbXBsaWNpdEtleSAmJiB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHx8XG4gICAgICAgIChpbkZsb3cgJiYgL1tbXFxde30sXS8udGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGlmICgvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgICAgIC8vIC0gJy0nIG9yICc/J1xuICAgICAgICAvLyAtIHN0YXJ0IHdpdGggYW4gaW5kaWNhdG9yIGNoYXJhY3RlciAoZXhjZXB0IFs/Oi1dKSBvciAvWz8tXSAvXG4gICAgICAgIC8vIC0gJ1xcbiAnLCAnOiAnIG9yICcgXFxuJyBhbnl3aGVyZVxuICAgICAgICAvLyAtICcjJyBub3QgcHJlY2VkZWQgYnkgYSBub24tc3BhY2UgY2hhclxuICAgICAgICAvLyAtIGVuZCB3aXRoICcgJyBvciAnOidcbiAgICAgICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvdyB8fCAhdmFsdWUuaW5jbHVkZXMoJ1xcbicpXG4gICAgICAgICAgICA/IHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KVxuICAgICAgICAgICAgOiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoIWltcGxpY2l0S2V5ICYmXG4gICAgICAgICFpbkZsb3cgJiZcbiAgICAgICAgdHlwZSAhPT0gU2NhbGFyLlBMQUlOICYmXG4gICAgICAgIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAvLyBXaGVyZSBhbGxvd2VkICYgdHlwZSBub3Qgc2V0IGV4cGxpY2l0bHksIHByZWZlciBibG9jayBzdHlsZSBmb3IgbXVsdGlsaW5lIHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxuICAgIGlmIChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgICAgICBpZiAoaW5kZW50ID09PSAnJykge1xuICAgICAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1wbGljaXRLZXkgJiYgaW5kZW50ID09PSBpbmRlbnRTdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmXFxuJHtpbmRlbnR9YCk7XG4gICAgLy8gVmVyaWZ5IHRoYXQgb3V0cHV0IHdpbGwgYmUgcGFyc2VkIGFzIGEgc3RyaW5nLCBhcyBlLmcuIHBsYWluIG51bWJlcnMgYW5kXG4gICAgLy8gYm9vbGVhbnMgZ2V0IHBhcnNlZCB3aXRoIHRob3NlIHR5cGVzIGluIHYxLjIgKGUuZy4gJzQyJywgJ3RydWUnICYgJzAuOWUtMycpLFxuICAgIC8vIGFuZCBvdGhlcnMgaW4gdjEuMS5cbiAgICBpZiAoYWN0dWFsU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHRlc3QgPSAodGFnKSA9PiB0YWcuZGVmYXVsdCAmJiB0YWcudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyAmJiB0YWcudGVzdD8udGVzdChzdHIpO1xuICAgICAgICBjb25zdCB7IGNvbXBhdCwgdGFncyB9ID0gY3R4LmRvYy5zY2hlbWE7XG4gICAgICAgIGlmICh0YWdzLnNvbWUodGVzdCkgfHwgY29tcGF0Py5zb21lKHRlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIGltcGxpY2l0S2V5XG4gICAgICAgID8gc3RyXG4gICAgICAgIDogZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgRk9MRF9GTE9XLCBnZXRGb2xkT3B0aW9ucyhjdHgsIGZhbHNlKSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSwgaW5GbG93IH0gPSBjdHg7XG4gICAgY29uc3Qgc3MgPSB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyB2YWx1ZTogU3RyaW5nKGl0ZW0udmFsdWUpIH0pO1xuICAgIGxldCB7IHR5cGUgfSA9IGl0ZW07XG4gICAgaWYgKHR5cGUgIT09IFNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnMgJiB1bnBhaXJlZCBzdXJyb2dhdGVzXG4gICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5ZlxcdXtEODAwfS1cXHV7REZGRn1dL3UudGVzdChzcy52YWx1ZSkpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICB9XG4gICAgY29uc3QgX3N0cmluZ2lmeSA9IChfdHlwZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19GT0xERUQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3dcbiAgICAgICAgICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCkgLy8gYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICA6IGJsb2NrU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUVVPVEVfRE9VQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5RVU9URV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlBMQUlOOlxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFpblN0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0S2V5VHlwZSwgZGVmYXVsdFN0cmluZ1R5cGUgfSA9IGN0eC5vcHRpb25zO1xuICAgICAgICBjb25zdCB0ID0gKGltcGxpY2l0S2V5ICYmIGRlZmF1bHRLZXlUeXBlKSB8fCBkZWZhdWx0U3RyaW5nVHlwZTtcbiAgICAgICAgcmVzID0gX3N0cmluZ2lmeSh0KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9O1xuIiwgImltcG9ydCB7IGFuY2hvcklzVmFsaWQgfSBmcm9tICcuLi9kb2MvYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBpc1BhaXIsIGlzQWxpYXMsIGlzTm9kZSwgaXNTY2FsYXIsIGlzQ29sbGVjdGlvbiB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeUNvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBibG9ja1F1b3RlOiB0cnVlLFxuICAgICAgICBjb21tZW50U3RyaW5nOiBzdHJpbmdpZnlDb21tZW50LFxuICAgICAgICBkZWZhdWx0S2V5VHlwZTogbnVsbCxcbiAgICAgICAgZGVmYXVsdFN0cmluZ1R5cGU6ICdQTEFJTicsXG4gICAgICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgICAgIGRvdWJsZVF1b3RlZEFzSlNPTjogZmFsc2UsXG4gICAgICAgIGRvdWJsZVF1b3RlZE1pbk11bHRpTGluZUxlbmd0aDogNDAsXG4gICAgICAgIGZhbHNlU3RyOiAnZmFsc2UnLFxuICAgICAgICBmbG93Q29sbGVjdGlvblBhZGRpbmc6IHRydWUsXG4gICAgICAgIGluZGVudFNlcTogdHJ1ZSxcbiAgICAgICAgbGluZVdpZHRoOiA4MCxcbiAgICAgICAgbWluQ29udGVudFdpZHRoOiAyMCxcbiAgICAgICAgbnVsbFN0cjogJ251bGwnLFxuICAgICAgICBzaW1wbGVLZXlzOiBmYWxzZSxcbiAgICAgICAgc2luZ2xlUXVvdGU6IG51bGwsXG4gICAgICAgIHRydWVTdHI6ICd0cnVlJyxcbiAgICAgICAgdmVyaWZ5QWxpYXNPcmRlcjogdHJ1ZVxuICAgIH0sIGRvYy5zY2hlbWEudG9TdHJpbmdPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgaW5GbG93O1xuICAgIHN3aXRjaCAob3B0LmNvbGxlY3Rpb25TdHlsZSkge1xuICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICBpbkZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgIGluRmxvdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFuY2hvcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgZG9jLFxuICAgICAgICBmbG93Q29sbGVjdGlvblBhZGRpbmc6IG9wdC5mbG93Q29sbGVjdGlvblBhZGRpbmcgPyAnICcgOiAnJyxcbiAgICAgICAgaW5kZW50OiAnJyxcbiAgICAgICAgaW5kZW50U3RlcDogdHlwZW9mIG9wdC5pbmRlbnQgPT09ICdudW1iZXInID8gJyAnLnJlcGVhdChvcHQuaW5kZW50KSA6ICcgICcsXG4gICAgICAgIGluRmxvdyxcbiAgICAgICAgb3B0aW9uczogb3B0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFRhZ09iamVjdCh0YWdzLCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0udGFnKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LnRhZyA9PT0gaXRlbS50YWcpO1xuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSA/PyBtYXRjaFswXTtcbiAgICB9XG4gICAgbGV0IHRhZ09iaiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb2JqO1xuICAgIGlmIChpc1NjYWxhcihpdGVtKSkge1xuICAgICAgICBvYmogPSBpdGVtLnZhbHVlO1xuICAgICAgICBsZXQgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQuaWRlbnRpZnk/LihvYmopKTtcbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RNYXRjaCA9IG1hdGNoLmZpbHRlcih0ID0+IHQudGVzdCk7XG4gICAgICAgICAgICBpZiAodGVzdE1hdGNoLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdGFnT2JqID1cbiAgICAgICAgICAgIG1hdGNoLmZpbmQodCA9PiB0LmZvcm1hdCA9PT0gaXRlbS5mb3JtYXQpID8/IG1hdGNoLmZpbmQodCA9PiAhdC5mb3JtYXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2JqID0gaXRlbTtcbiAgICAgICAgdGFnT2JqID0gdGFncy5maW5kKHQgPT4gdC5ub2RlQ2xhc3MgJiYgb2JqIGluc3RhbmNlb2YgdC5ub2RlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoIXRhZ09iaikge1xuICAgICAgICBjb25zdCBuYW1lID0gb2JqPy5jb25zdHJ1Y3Rvcj8ubmFtZSA/PyAob2JqID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIG9iaik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFnIG5vdCByZXNvbHZlZCBmb3IgJHtuYW1lfSB2YWx1ZWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFnT2JqO1xufVxuLy8gbmVlZHMgdG8gYmUgY2FsbGVkIGJlZm9yZSB2YWx1ZSBzdHJpbmdpZmllciB0byBhbGxvdyBmb3IgY2lyY3VsYXIgYW5jaG9yIHJlZnNcbmZ1bmN0aW9uIHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgeyBhbmNob3JzLCBkb2MgfSkge1xuICAgIGlmICghZG9jLmRpcmVjdGl2ZXMpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGNvbnN0IGFuY2hvciA9IChpc1NjYWxhcihub2RlKSB8fCBpc0NvbGxlY3Rpb24obm9kZSkpICYmIG5vZGUuYW5jaG9yO1xuICAgIGlmIChhbmNob3IgJiYgYW5jaG9ySXNWYWxpZChhbmNob3IpKSB7XG4gICAgICAgIGFuY2hvcnMuYWRkKGFuY2hvcik7XG4gICAgICAgIHByb3BzLnB1c2goYCYke2FuY2hvcn1gKTtcbiAgICB9XG4gICAgY29uc3QgdGFnID0gbm9kZS50YWcgPz8gKHRhZ09iai5kZWZhdWx0ID8gbnVsbCA6IHRhZ09iai50YWcpO1xuICAgIGlmICh0YWcpXG4gICAgICAgIHByb3BzLnB1c2goZG9jLmRpcmVjdGl2ZXMudGFnU3RyaW5nKHRhZykpO1xuICAgIHJldHVybiBwcm9wcy5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgaWYgKGlzUGFpcihpdGVtKSlcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICBpZiAoaXNBbGlhcyhpdGVtKSkge1xuICAgICAgICBpZiAoY3R4LmRvYy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4KTtcbiAgICAgICAgaWYgKGN0eC5yZXNvbHZlZEFsaWFzZXM/LmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IHN0cmluZ2lmeSBjaXJjdWxhciBzdHJ1Y3R1cmUgd2l0aG91dCBhbGlhcyBub2Rlc2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN0eC5yZXNvbHZlZEFsaWFzZXMpXG4gICAgICAgICAgICAgICAgY3R4LnJlc29sdmVkQWxpYXNlcy5hZGQoaXRlbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3R4LnJlc29sdmVkQWxpYXNlcyA9IG5ldyBTZXQoW2l0ZW1dKTtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlc29sdmUoY3R4LmRvYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRhZ09iaiA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub2RlID0gaXNOb2RlKGl0ZW0pXG4gICAgICAgID8gaXRlbVxuICAgICAgICA6IGN0eC5kb2MuY3JlYXRlTm9kZShpdGVtLCB7IG9uVGFnT2JqOiBvID0+ICh0YWdPYmogPSBvKSB9KTtcbiAgICB0YWdPYmogPz8gKHRhZ09iaiA9IGdldFRhZ09iamVjdChjdHguZG9jLnNjaGVtYS50YWdzLCBub2RlKSk7XG4gICAgY29uc3QgcHJvcHMgPSBzdHJpbmdpZnlQcm9wcyhub2RlLCB0YWdPYmosIGN0eCk7XG4gICAgaWYgKHByb3BzLmxlbmd0aCA+IDApXG4gICAgICAgIGN0eC5pbmRlbnRBdFN0YXJ0ID0gKGN0eC5pbmRlbnRBdFN0YXJ0ID8/IDApICsgcHJvcHMubGVuZ3RoICsgMTtcbiAgICBjb25zdCBzdHIgPSB0eXBlb2YgdGFnT2JqLnN0cmluZ2lmeSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHRhZ09iai5zdHJpbmdpZnkobm9kZSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICA6IGlzU2NhbGFyKG5vZGUpXG4gICAgICAgICAgICA/IHN0cmluZ2lmeVN0cmluZyhub2RlLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgICAgICA6IG5vZGUudG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIHJldHVybiBpc1NjYWxhcihub2RlKSB8fCBzdHJbMF0gPT09ICd7JyB8fCBzdHJbMF0gPT09ICdbJ1xuICAgICAgICA/IGAke3Byb3BzfSAke3N0cn1gXG4gICAgICAgIDogYCR7cHJvcHN9XFxuJHtjdHguaW5kZW50fSR7c3RyfWA7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQsIHN0cmluZ2lmeSB9O1xuIiwgImltcG9ydCB7IGlzQ29sbGVjdGlvbiwgaXNOb2RlLCBpc1NjYWxhciwgaXNTZXEgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgbGluZUNvbW1lbnQsIGluZGVudENvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlQYWlyKHsga2V5LCB2YWx1ZSB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IGFsbE51bGxWYWx1ZXMsIGRvYywgaW5kZW50LCBpbmRlbnRTdGVwLCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcsIGluZGVudFNlcSwgc2ltcGxlS2V5cyB9IH0gPSBjdHg7XG4gICAgbGV0IGtleUNvbW1lbnQgPSAoaXNOb2RlKGtleSkgJiYga2V5LmNvbW1lbnQpIHx8IG51bGw7XG4gICAgaWYgKHNpbXBsZUtleXMpIHtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywga2V5IG5vZGVzIGNhbm5vdCBoYXZlIGNvbW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihrZXkpIHx8ICghaXNOb2RlKGtleSkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnV2l0aCBzaW1wbGUga2V5cywgY29sbGVjdGlvbiBjYW5ub3QgYmUgdXNlZCBhcyBhIGtleSB2YWx1ZSc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXhwbGljaXRLZXkgPSAhc2ltcGxlS2V5cyAmJlxuICAgICAgICAoIWtleSB8fFxuICAgICAgICAgICAgKGtleUNvbW1lbnQgJiYgdmFsdWUgPT0gbnVsbCAmJiAhY3R4LmluRmxvdykgfHxcbiAgICAgICAgICAgIGlzQ29sbGVjdGlvbihrZXkpIHx8XG4gICAgICAgICAgICAoaXNTY2FsYXIoa2V5KVxuICAgICAgICAgICAgICAgID8ga2V5LnR5cGUgPT09IFNjYWxhci5CTE9DS19GT0xERUQgfHwga2V5LnR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JykpO1xuICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwge1xuICAgICAgICBhbGxOdWxsVmFsdWVzOiBmYWxzZSxcbiAgICAgICAgaW1wbGljaXRLZXk6ICFleHBsaWNpdEtleSAmJiAoc2ltcGxlS2V5cyB8fCAhYWxsTnVsbFZhbHVlcyksXG4gICAgICAgIGluZGVudDogaW5kZW50ICsgaW5kZW50U3RlcFxuICAgIH0pO1xuICAgIGxldCBrZXlDb21tZW50RG9uZSA9IGZhbHNlO1xuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICBsZXQgc3RyID0gc3RyaW5naWZ5KGtleSwgY3R4LCAoKSA9PiAoa2V5Q29tbWVudERvbmUgPSB0cnVlKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICBpZiAoIWV4cGxpY2l0S2V5ICYmICFjdHguaW5GbG93ICYmIHN0ci5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgIGlmIChzaW1wbGVLZXlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoIHNpbXBsZSBrZXlzLCBzaW5nbGUgbGluZSBzY2FsYXIgbXVzdCBub3Qgc3BhbiBtb3JlIHRoYW4gMTAyNCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIGV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN0eC5pbkZsb3cpIHtcbiAgICAgICAgaWYgKGFsbE51bGxWYWx1ZXMgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtleUNvbW1lbnREb25lICYmIG9uQ29tbWVudClcbiAgICAgICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBzdHIgPT09ICcnID8gJz8nIDogZXhwbGljaXRLZXkgPyBgPyAke3N0cn1gIDogc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChhbGxOdWxsVmFsdWVzICYmICFzaW1wbGVLZXlzKSB8fCAodmFsdWUgPT0gbnVsbCAmJiBleHBsaWNpdEtleSkpIHtcbiAgICAgICAgc3RyID0gYD8gJHtzdHJ9YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQgJiYgIWtleUNvbW1lbnREb25lKSB7XG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaG9tcEtlZXAgJiYgb25DaG9tcEtlZXApXG4gICAgICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAoa2V5Q29tbWVudERvbmUpXG4gICAgICAgIGtleUNvbW1lbnQgPSBudWxsO1xuICAgIGlmIChleHBsaWNpdEtleSkge1xuICAgICAgICBpZiAoa2V5Q29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1cXG4ke2luZGVudH06YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGAke3N0cn06YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICB9XG4gICAgbGV0IHZzYiwgdmNiLCB2YWx1ZUNvbW1lbnQ7XG4gICAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdnNiID0gISF2YWx1ZS5zcGFjZUJlZm9yZTtcbiAgICAgICAgdmNiID0gdmFsdWUuY29tbWVudEJlZm9yZTtcbiAgICAgICAgdmFsdWVDb21tZW50ID0gdmFsdWUuY29tbWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZzYiA9IGZhbHNlO1xuICAgICAgICB2Y2IgPSBudWxsO1xuICAgICAgICB2YWx1ZUNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHZhbHVlID0gZG9jLmNyZWF0ZU5vZGUodmFsdWUpO1xuICAgIH1cbiAgICBjdHguaW1wbGljaXRLZXkgPSBmYWxzZTtcbiAgICBpZiAoIWV4cGxpY2l0S2V5ICYmICFrZXlDb21tZW50ICYmIGlzU2NhbGFyKHZhbHVlKSlcbiAgICAgICAgY3R4LmluZGVudEF0U3RhcnQgPSBzdHIubGVuZ3RoICsgMTtcbiAgICBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICBpZiAoIWluZGVudFNlcSAmJlxuICAgICAgICBpbmRlbnRTdGVwLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICFjdHguaW5GbG93ICYmXG4gICAgICAgICFleHBsaWNpdEtleSAmJlxuICAgICAgICBpc1NlcSh2YWx1ZSkgJiZcbiAgICAgICAgIXZhbHVlLmZsb3cgJiZcbiAgICAgICAgIXZhbHVlLnRhZyAmJlxuICAgICAgICAhdmFsdWUuYW5jaG9yKSB7XG4gICAgICAgIC8vIElmIGluZGVudFNlcSA9PT0gZmFsc2UsIGNvbnNpZGVyICctICcgYXMgcGFydCBvZiBpbmRlbnRhdGlvbiB3aGVyZSBwb3NzaWJsZVxuICAgICAgICBjdHguaW5kZW50ID0gY3R4LmluZGVudC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIGxldCB2YWx1ZUNvbW1lbnREb25lID0gZmFsc2U7XG4gICAgY29uc3QgdmFsdWVTdHIgPSBzdHJpbmdpZnkodmFsdWUsIGN0eCwgKCkgPT4gKHZhbHVlQ29tbWVudERvbmUgPSB0cnVlKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICBsZXQgd3MgPSAnICc7XG4gICAgaWYgKGtleUNvbW1lbnQgfHwgdnNiIHx8IHZjYikge1xuICAgICAgICB3cyA9IHZzYiA/ICdcXG4nIDogJyc7XG4gICAgICAgIGlmICh2Y2IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyh2Y2IpO1xuICAgICAgICAgICAgd3MgKz0gYFxcbiR7aW5kZW50Q29tbWVudChjcywgY3R4LmluZGVudCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVTdHIgPT09ICcnICYmICFjdHguaW5GbG93KSB7XG4gICAgICAgICAgICBpZiAod3MgPT09ICdcXG4nICYmIHZhbHVlQ29tbWVudClcbiAgICAgICAgICAgICAgICB3cyA9ICdcXG5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3MgKz0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFleHBsaWNpdEtleSAmJiBpc0NvbGxlY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHZzMCA9IHZhbHVlU3RyWzBdO1xuICAgICAgICBjb25zdCBubDAgPSB2YWx1ZVN0ci5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgY29uc3QgaGFzTmV3bGluZSA9IG5sMCAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGZsb3cgPSBjdHguaW5GbG93ID8/IHZhbHVlLmZsb3cgPz8gdmFsdWUuaXRlbXMubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoaGFzTmV3bGluZSB8fCAhZmxvdykge1xuICAgICAgICAgICAgbGV0IGhhc1Byb3BzTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhhc05ld2xpbmUgJiYgKHZzMCA9PT0gJyYnIHx8IHZzMCA9PT0gJyEnKSkge1xuICAgICAgICAgICAgICAgIGxldCBzcDAgPSB2YWx1ZVN0ci5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZzMCA9PT0gJyYnICYmXG4gICAgICAgICAgICAgICAgICAgIHNwMCAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgc3AwIDwgbmwwICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3RyW3NwMCArIDFdID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3AwID0gdmFsdWVTdHIuaW5kZXhPZignICcsIHNwMCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3AwID09PSAtMSB8fCBubDAgPCBzcDApXG4gICAgICAgICAgICAgICAgICAgIGhhc1Byb3BzTGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3BzTGluZSlcbiAgICAgICAgICAgICAgICB3cyA9IGBcXG4ke2N0eC5pbmRlbnR9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVN0ciA9PT0gJycgfHwgdmFsdWVTdHJbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgIHdzID0gJyc7XG4gICAgfVxuICAgIHN0ciArPSB3cyArIHZhbHVlU3RyO1xuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmICh2YWx1ZUNvbW1lbnREb25lICYmIG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZUNvbW1lbnQgJiYgIXZhbHVlQ29tbWVudERvbmUpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyh2YWx1ZUNvbW1lbnQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVBhaXIgfTtcbiIsICJmdW5jdGlvbiBkZWJ1Zyhsb2dMZXZlbCwgLi4ubWVzc2FnZXMpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycpXG4gICAgICAgIGNvbnNvbGUubG9nKC4uLm1lc3NhZ2VzKTtcbn1cbmZ1bmN0aW9uIHdhcm4obG9nTGV2ZWwsIHdhcm5pbmcpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycgfHwgbG9nTGV2ZWwgPT09ICd3YXJuJykge1xuICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkZWJ1Zywgd2FybiB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBpc0FsaWFzLCBpc1NlcSwgaXNNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG4vLyBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEgbWVyZ2Uga2V5IGlzIGEgc2luZ2xlIG1hcHBpbmcgbm9kZSwgZWFjaCBvZlxuLy8gaXRzIGtleS92YWx1ZSBwYWlycyBpcyBpbnNlcnRlZCBpbnRvIHRoZSBjdXJyZW50IG1hcHBpbmcsIHVubGVzcyB0aGUga2V5XG4vLyBhbHJlYWR5IGV4aXN0cyBpbiBpdC4gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVyZ2Uga2V5IGlzIGFcbi8vIHNlcXVlbmNlLCB0aGVuIHRoaXMgc2VxdWVuY2UgaXMgZXhwZWN0ZWQgdG8gY29udGFpbiBtYXBwaW5nIG5vZGVzIGFuZCBlYWNoXG4vLyBvZiB0aGVzZSBub2RlcyBpcyBtZXJnZWQgaW4gdHVybiBhY2NvcmRpbmcgdG8gaXRzIG9yZGVyIGluIHRoZSBzZXF1ZW5jZS5cbi8vIEtleXMgaW4gbWFwcGluZyBub2RlcyBlYXJsaWVyIGluIHRoZSBzZXF1ZW5jZSBvdmVycmlkZSBrZXlzIHNwZWNpZmllZCBpblxuLy8gbGF0ZXIgbWFwcGluZyBub2Rlcy4gLS0gaHR0cDovL3lhbWwub3JnL3R5cGUvbWVyZ2UuaHRtbFxuY29uc3QgTUVSR0VfS0VZID0gJzw8JztcbmNvbnN0IG1lcmdlID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gTUVSR0VfS0VZIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnICYmIHZhbHVlLmRlc2NyaXB0aW9uID09PSBNRVJHRV9LRVkpLFxuICAgIGRlZmF1bHQ6ICdrZXknLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJyxcbiAgICB0ZXN0OiAvXjw8JC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gT2JqZWN0LmFzc2lnbihuZXcgU2NhbGFyKFN5bWJvbChNRVJHRV9LRVkpKSwge1xuICAgICAgICBhZGRUb0pTTWFwOiBhZGRNZXJnZVRvSlNNYXBcbiAgICB9KSxcbiAgICBzdHJpbmdpZnk6ICgpID0+IE1FUkdFX0tFWVxufTtcbmNvbnN0IGlzTWVyZ2VLZXkgPSAoY3R4LCBrZXkpID0+IChtZXJnZS5pZGVudGlmeShrZXkpIHx8XG4gICAgKGlzU2NhbGFyKGtleSkgJiZcbiAgICAgICAgKCFrZXkudHlwZSB8fCBrZXkudHlwZSA9PT0gU2NhbGFyLlBMQUlOKSAmJlxuICAgICAgICBtZXJnZS5pZGVudGlmeShrZXkudmFsdWUpKSkgJiZcbiAgICBjdHg/LmRvYy5zY2hlbWEudGFncy5zb21lKHRhZyA9PiB0YWcudGFnID09PSBtZXJnZS50YWcgJiYgdGFnLmRlZmF1bHQpO1xuZnVuY3Rpb24gYWRkTWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCB2YWx1ZSkge1xuICAgIHZhbHVlID0gY3R4ICYmIGlzQWxpYXModmFsdWUpID8gdmFsdWUucmVzb2x2ZShjdHguZG9jKSA6IHZhbHVlO1xuICAgIGlmIChpc1NlcSh2YWx1ZSkpXG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgdmFsdWUuaXRlbXMpXG4gICAgICAgICAgICBtZXJnZVZhbHVlKGN0eCwgbWFwLCBpdCk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgdmFsdWUpXG4gICAgICAgICAgICBtZXJnZVZhbHVlKGN0eCwgbWFwLCBpdCk7XG4gICAgZWxzZVxuICAgICAgICBtZXJnZVZhbHVlKGN0eCwgbWFwLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBtZXJnZVZhbHVlKGN0eCwgbWFwLCB2YWx1ZSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IGN0eCAmJiBpc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICBpZiAoIWlzTWFwKHNvdXJjZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWVyZ2Ugc291cmNlcyBtdXN0IGJlIG1hcHMgb3IgbWFwIGFsaWFzZXMnKTtcbiAgICBjb25zdCBzcmNNYXAgPSBzb3VyY2UudG9KU09OKG51bGwsIGN0eCwgTWFwKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzcmNNYXApIHtcbiAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIG1hcC5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwga2V5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwga2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5cbmV4cG9ydCB7IGFkZE1lcmdlVG9KU01hcCwgaXNNZXJnZUtleSwgbWVyZ2UgfTtcbiIsICJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vbG9nLmpzJztcbmltcG9ydCB7IGlzTWVyZ2VLZXksIGFkZE1lcmdlVG9KU01hcCB9IGZyb20gJy4uL3NjaGVtYS95YW1sLTEuMS9tZXJnZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdpZnlDb250ZXh0IH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5mdW5jdGlvbiBhZGRQYWlyVG9KU01hcChjdHgsIG1hcCwgeyBrZXksIHZhbHVlIH0pIHtcbiAgICBpZiAoaXNOb2RlKGtleSkgJiYga2V5LmFkZFRvSlNNYXApXG4gICAgICAgIGtleS5hZGRUb0pTTWFwKGN0eCwgbWFwLCB2YWx1ZSk7XG4gICAgLy8gVE9ETzogU2hvdWxkIGRyb3AgdGhpcyBzcGVjaWFsIGNhc2UgZm9yIGJhcmUgPDwgaGFuZGxpbmdcbiAgICBlbHNlIGlmIChpc01lcmdlS2V5KGN0eCwga2V5KSlcbiAgICAgICAgYWRkTWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCB2YWx1ZSk7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGpzS2V5ID0gdG9KUyhrZXksICcnLCBjdHgpO1xuICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGpzS2V5LCB0b0pTKHZhbHVlLCBqc0tleSwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGpzS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ0tleSA9IHN0cmluZ2lmeUtleShrZXksIGpzS2V5LCBjdHgpO1xuICAgICAgICAgICAgY29uc3QganNWYWx1ZSA9IHRvSlModmFsdWUsIHN0cmluZ0tleSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdLZXkgaW4gbWFwKVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIHN0cmluZ0tleSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZToganNWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1hcFtzdHJpbmdLZXldID0ganNWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCkge1xuICAgIGlmIChqc0tleSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICBpZiAodHlwZW9mIGpzS2V5ICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyhqc0tleSk7XG4gICAgaWYgKGlzTm9kZShrZXkpICYmIGN0eD8uZG9jKSB7XG4gICAgICAgIGNvbnN0IHN0ckN0eCA9IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoY3R4LmRvYywge30pO1xuICAgICAgICBzdHJDdHguYW5jaG9ycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGN0eC5hbmNob3JzLmtleXMoKSlcbiAgICAgICAgICAgIHN0ckN0eC5hbmNob3JzLmFkZChub2RlLmFuY2hvcik7XG4gICAgICAgIHN0ckN0eC5pbkZsb3cgPSB0cnVlO1xuICAgICAgICBzdHJDdHguaW5TdHJpbmdpZnlLZXkgPSB0cnVlO1xuICAgICAgICBjb25zdCBzdHJLZXkgPSBrZXkudG9TdHJpbmcoc3RyQ3R4KTtcbiAgICAgICAgaWYgKCFjdHgubWFwS2V5V2FybmVkKSB7XG4gICAgICAgICAgICBsZXQganNvblN0ciA9IEpTT04uc3RyaW5naWZ5KHN0cktleSk7XG4gICAgICAgICAgICBpZiAoanNvblN0ci5sZW5ndGggPiA0MClcbiAgICAgICAgICAgICAgICBqc29uU3RyID0ganNvblN0ci5zdWJzdHJpbmcoMCwgMzYpICsgJy4uLlwiJztcbiAgICAgICAgICAgIHdhcm4oY3R4LmRvYy5vcHRpb25zLmxvZ0xldmVsLCBgS2V5cyB3aXRoIGNvbGxlY3Rpb24gdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQgZHVlIHRvIEpTIE9iamVjdCByZXN0cmljdGlvbnM6ICR7anNvblN0cn0uIFNldCBtYXBBc01hcDogdHJ1ZSB0byB1c2Ugb2JqZWN0IGtleXMuYCk7XG4gICAgICAgICAgICBjdHgubWFwS2V5V2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyS2V5O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNLZXkpO1xufVxuXG5leHBvcnQgeyBhZGRQYWlyVG9KU01hcCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlQYWlyIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVBhaXIuanMnO1xuaW1wb3J0IHsgYWRkUGFpclRvSlNNYXAgfSBmcm9tICcuL2FkZFBhaXJUb0pTTWFwLmpzJztcbmltcG9ydCB7IE5PREVfVFlQRSwgUEFJUiwgaXNOb2RlIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QgayA9IGNyZWF0ZU5vZGUoa2V5LCB1bmRlZmluZWQsIGN0eCk7XG4gICAgY29uc3QgdiA9IGNyZWF0ZU5vZGUodmFsdWUsIHVuZGVmaW5lZCwgY3R4KTtcbiAgICByZXR1cm4gbmV3IFBhaXIoaywgdik7XG59XG5jbGFzcyBQYWlyIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlID0gbnVsbCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiBQQUlSIH0pO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjbG9uZShzY2hlbWEpIHtcbiAgICAgICAgbGV0IHsga2V5LCB2YWx1ZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKGlzTm9kZShrZXkpKVxuICAgICAgICAgICAga2V5ID0ga2V5LmNsb25lKHNjaGVtYSk7XG4gICAgICAgIGlmIChpc05vZGUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZShzY2hlbWEpO1xuICAgICAgICByZXR1cm4gbmV3IFBhaXIoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGN0eD8ubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICAgICAgcmV0dXJuIGFkZFBhaXJUb0pTTWFwKGN0eCwgcGFpciwgdGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICByZXR1cm4gY3R4Py5kb2NcbiAgICAgICAgICAgID8gc3RyaW5naWZ5UGFpcih0aGlzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUGFpciwgY3JlYXRlUGFpciB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgbGluZUNvbW1lbnQsIGluZGVudENvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZsb3cgPSBjdHguaW5GbG93ID8/IGNvbGxlY3Rpb24uZmxvdztcbiAgICBjb25zdCBzdHJpbmdpZnkgPSBmbG93ID8gc3RyaW5naWZ5Rmxvd0NvbGxlY3Rpb24gOiBzdHJpbmdpZnlCbG9ja0NvbGxlY3Rpb247XG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xsZWN0aW9uLCBjdHgsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5QmxvY2tDb2xsZWN0aW9uKHsgY29tbWVudCwgaXRlbXMgfSwgY3R4LCB7IGJsb2NrSXRlbVByZWZpeCwgZmxvd0NoYXJzLCBpdGVtSW5kZW50LCBvbkNob21wS2VlcCwgb25Db21tZW50IH0pIHtcbiAgICBjb25zdCB7IGluZGVudCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSA9IGN0eDtcbiAgICBjb25zdCBpdGVtQ3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGluZGVudDogaXRlbUluZGVudCwgdHlwZTogbnVsbCB9KTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7IC8vIGZsYWcgZm9yIHRoZSBwcmVjZWRpbmcgbm9kZSdzIHN0YXR1c1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGxldCBjb21tZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzTm9kZShpdGVtKSkge1xuICAgICAgICAgICAgaWYgKCFjaG9tcEtlZXAgJiYgaXRlbS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaXRlbS5jb21tZW50QmVmb3JlLCBjaG9tcEtlZXApO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudClcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgaWsgPSBpc05vZGUoaXRlbS5rZXkpID8gaXRlbS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGlrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaG9tcEtlZXAgJiYgaWsuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaWsuY29tbWVudEJlZm9yZSwgY2hvbXBLZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGl0ZW1JbmRlbnQsIGNvbW1lbnRTdHJpbmcoY29tbWVudCkpO1xuICAgICAgICBpZiAoY2hvbXBLZWVwICYmIGNvbW1lbnQpXG4gICAgICAgICAgICBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgICAgbGluZXMucHVzaChibG9ja0l0ZW1QcmVmaXggKyBzdHIpO1xuICAgIH1cbiAgICBsZXQgc3RyO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RyID0gZmxvd0NoYXJzLnN0YXJ0ICsgZmxvd0NoYXJzLmVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGxpbmVzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBzdHIgKz0gbGluZSA/IGBcXG4ke2luZGVudH0ke2xpbmV9YCA6ICdcXG4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIHN0ciArPSAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhjb21tZW50KSwgaW5kZW50KTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaG9tcEtlZXAgJiYgb25DaG9tcEtlZXApXG4gICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUZsb3dDb2xsZWN0aW9uKHsgaXRlbXMgfSwgY3R4LCB7IGZsb3dDaGFycywgaXRlbUluZGVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIGluZGVudFN0ZXAsIGZsb3dDb2xsZWN0aW9uUGFkZGluZzogZmNQYWRkaW5nLCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9ID0gY3R4O1xuICAgIGl0ZW1JbmRlbnQgKz0gaW5kZW50U3RlcDtcbiAgICBjb25zdCBpdGVtQ3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7XG4gICAgICAgIGluZGVudDogaXRlbUluZGVudCxcbiAgICAgICAgaW5GbG93OiB0cnVlLFxuICAgICAgICB0eXBlOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IHJlcU5ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgbGluZXNBdFZhbHVlID0gMDtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBsZXQgY29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChpc05vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpdGVtLmNvbW1lbnRCZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGl0ZW0uY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlrID0gaXNOb2RlKGl0ZW0ua2V5KSA/IGl0ZW0ua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpaykge1xuICAgICAgICAgICAgICAgIGlmIChpay5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpay5jb21tZW50QmVmb3JlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlrLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXYgPSBpc05vZGUoaXRlbS52YWx1ZSkgPyBpdGVtLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgICAgIGlmIChpdi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gaXYuY29tbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoaXYuY29tbWVudEJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLnZhbHVlID09IG51bGwgJiYgaWs/LmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaWsuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICBsZXQgc3RyID0gc3RyaW5naWZ5KGl0ZW0sIGl0ZW1DdHgsICgpID0+IChjb21tZW50ID0gbnVsbCkpO1xuICAgICAgICBpZiAoaSA8IGl0ZW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBzdHIgKz0gJywnO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGl0ZW1JbmRlbnQsIGNvbW1lbnRTdHJpbmcoY29tbWVudCkpO1xuICAgICAgICBpZiAoIXJlcU5ld2xpbmUgJiYgKGxpbmVzLmxlbmd0aCA+IGxpbmVzQXRWYWx1ZSB8fCBzdHIuaW5jbHVkZXMoJ1xcbicpKSlcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICBsaW5lcy5wdXNoKHN0cik7XG4gICAgICAgIGxpbmVzQXRWYWx1ZSA9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBmbG93Q2hhcnM7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBlbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXJlcU5ld2xpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGxpbmVzLnJlZHVjZSgoc3VtLCBsaW5lKSA9PiBzdW0gKyBsaW5lLmxlbmd0aCArIDIsIDIpO1xuICAgICAgICAgICAgcmVxTmV3bGluZSA9IGN0eC5vcHRpb25zLmxpbmVXaWR0aCA+IDAgJiYgbGVuID4gY3R4Lm9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXFOZXdsaW5lKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gc3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpXG4gICAgICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnRTdGVwfSR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3RyfVxcbiR7aW5kZW50fSR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3RhcnR9JHtmY1BhZGRpbmd9JHtsaW5lcy5qb2luKCcgJyl9JHtmY1BhZGRpbmd9JHtlbmR9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZENvbW1lbnRCZWZvcmUoeyBpbmRlbnQsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0sIGxpbmVzLCBjb21tZW50LCBjaG9tcEtlZXApIHtcbiAgICBpZiAoY29tbWVudCAmJiBjaG9tcEtlZXApXG4gICAgICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoL15cXG4rLywgJycpO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGNvbnN0IGljID0gaW5kZW50Q29tbWVudChjb21tZW50U3RyaW5nKGNvbW1lbnQpLCBpbmRlbnQpO1xuICAgICAgICBsaW5lcy5wdXNoKGljLnRyaW1TdGFydCgpKTsgLy8gQXZvaWQgZG91YmxlIGluZGVudCBvbiBmaXJzdCBsaW5lXG4gICAgfVxufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5Q29sbGVjdGlvbiB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGFkZFBhaXJUb0pTTWFwIH0gZnJvbSAnLi9hZGRQYWlyVG9KU01hcC5qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IE1BUCwgaXNQYWlyLCBpc1NjYWxhciB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgUGFpciwgY3JlYXRlUGFpciB9IGZyb20gJy4vUGFpci5qcyc7XG5pbXBvcnQgeyBpc1NjYWxhclZhbHVlIH0gZnJvbSAnLi9TY2FsYXIuanMnO1xuXG5mdW5jdGlvbiBmaW5kUGFpcihpdGVtcywga2V5KSB7XG4gICAgY29uc3QgayA9IGlzU2NhbGFyKGtleSkgPyBrZXkudmFsdWUgOiBrZXk7XG4gICAgZm9yIChjb25zdCBpdCBvZiBpdGVtcykge1xuICAgICAgICBpZiAoaXNQYWlyKGl0KSkge1xuICAgICAgICAgICAgaWYgKGl0LmtleSA9PT0ga2V5IHx8IGl0LmtleSA9PT0gaylcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIoaXQua2V5KSAmJiBpdC5rZXkudmFsdWUgPT09IGspXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBZQU1MTWFwIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihNQVAsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBnZW5lcmljIGNvbGxlY3Rpb24gcGFyc2luZyBtZXRob2QgdGhhdCBjYW4gYmUgZXh0ZW5kZWRcbiAgICAgKiB0byBvdGhlciBub2RlIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gWUFNTE1hcFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBrZWVwVW5kZWZpbmVkLCByZXBsYWNlciB9ID0gY3R4O1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgdGhpcyhzY2hlbWEpO1xuICAgICAgICBjb25zdCBhZGQgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpICYmICFyZXBsYWNlci5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGtlZXBVbmRlZmluZWQpXG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKVxuICAgICAgICAgICAgICAgIGFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpXG4gICAgICAgICAgICAgICAgYWRkKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBJZiBub3Qgc2V0IGB0cnVlYCwgdXNpbmcgYSBrZXkgdGhhdCBpcyBhbHJlYWR5IGluIHRoZVxuICAgICAqICAgY29sbGVjdGlvbiB3aWxsIHRocm93LiBPdGhlcndpc2UsIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgbGV0IF9wYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKHBhaXIpKVxuICAgICAgICAgICAgX3BhaXIgPSBwYWlyO1xuICAgICAgICBlbHNlIGlmICghcGFpciB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgISgna2V5JyBpbiBwYWlyKSkge1xuICAgICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCwgdGhpcyBuZXZlciBoYXBwZW5zLlxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpcihwYWlyLCBwYWlyPy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpcihwYWlyLmtleSwgcGFpci52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHByZXYgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBfcGFpci5rZXkpO1xuICAgICAgICBjb25zdCBzb3J0RW50cmllcyA9IHRoaXMuc2NoZW1hPy5zb3J0TWFwRW50cmllcztcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGlmICghb3ZlcndyaXRlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7X3BhaXIua2V5fSBhbHJlYWR5IHNldGApO1xuICAgICAgICAgICAgLy8gRm9yIHNjYWxhcnMsIGtlZXAgdGhlIG9sZCBub2RlICYgaXRzIGNvbW1lbnRzIGFuZCBhbmNob3JzXG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIocHJldi52YWx1ZSkgJiYgaXNTY2FsYXJWYWx1ZShfcGFpci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgcHJldi52YWx1ZS52YWx1ZSA9IF9wYWlyLnZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHByZXYudmFsdWUgPSBfcGFpci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3J0RW50cmllcykge1xuICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuaXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gc29ydEVudHJpZXMoX3BhaXIsIGl0ZW0pIDwgMCk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKF9wYWlyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAwLCBfcGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goX3BhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICBpZiAoIWl0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YoaXQpLCAxKTtcbiAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGl0Py52YWx1ZTtcbiAgICAgICAgcmV0dXJuICgha2VlcFNjYWxhciAmJiBpc1NjYWxhcihub2RlKSA/IG5vZGUudmFsdWUgOiBub2RlKSA/PyB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZGQobmV3IFBhaXIoa2V5LCB2YWx1ZSksIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKClcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSBUeXBlIC0gSWYgc2V0LCBmb3JjZXMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gdHlwZVxuICAgICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIFR5cGUsIE1hcCwgb3IgT2JqZWN0XG4gICAgICovXG4gICAgdG9KU09OKF8sIGN0eCwgVHlwZSkge1xuICAgICAgICBjb25zdCBtYXAgPSBUeXBlID8gbmV3IFR5cGUoKSA6IGN0eD8ubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICAgICAgaWYgKGN0eD8ub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUobWFwKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBhZGRQYWlyVG9KU01hcChjdHgsIG1hcCwgaXRlbSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghaXNQYWlyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwIGl0ZW1zIG11c3QgYWxsIGJlIHBhaXJzOyBmb3VuZCAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdHguYWxsTnVsbFZhbHVlcyAmJiB0aGlzLmhhc0FsbE51bGxWYWx1ZXMoZmFsc2UpKVxuICAgICAgICAgICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGFsbE51bGxWYWx1ZXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ3snLCBlbmQ6ICd9JyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogY3R4LmluZGVudCB8fCAnJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfTtcbiIsICJpbXBvcnQgeyBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcblxuY29uc3QgbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdtYXAnLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgbm9kZUNsYXNzOiBZQU1MTWFwLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsXG4gICAgcmVzb2x2ZShtYXAsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc01hcChtYXApKVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgb2JqLCBjdHgpID0+IFlBTUxNYXAuZnJvbShzY2hlbWEsIG9iaiwgY3R4KVxufTtcblxuZXhwb3J0IHsgbWFwIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5Q29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IFNFUSwgaXNTY2FsYXIgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IGlzU2NhbGFyVmFsdWUgfSBmcm9tICcuL1NjYWxhci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY2xhc3MgWUFNTFNlcSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIHN0YXRpYyBnZXQgdGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoU0VRLCBzY2hlbWEpO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBpdGVtIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGl0ID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIoaXQpID8gaXQudmFsdWUgOiBpdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjb2xsZWN0aW9uIGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqXG4gICAgICogYGtleWAgbXVzdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciBmb3IgdGhpcyB0byBzdWNjZWVkLlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlkeCA9PT0gJ251bWJlcicgJiYgaWR4IDwgdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGNvbGxlY3Rpb24uIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqXG4gICAgICogSWYgYGtleWAgZG9lcyBub3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSB2YWxpZCBpbmRleCwgbm90ICR7a2V5fS5gKTtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgaWYgKGlzU2NhbGFyKHByZXYpICYmIGlzU2NhbGFyVmFsdWUodmFsdWUpKVxuICAgICAgICAgICAgcHJldi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLml0ZW1zW2lkeF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBjb25zdCBzZXEgPSBbXTtcbiAgICAgICAgaWYgKGN0eD8ub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUoc2VxKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcylcbiAgICAgICAgICAgIHNlcS5wdXNoKHRvSlMoaXRlbSwgU3RyaW5nKGkrKyksIGN0eCkpO1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnLSAnLFxuICAgICAgICAgICAgZmxvd0NoYXJzOiB7IHN0YXJ0OiAnWycsIGVuZDogJ10nIH0sXG4gICAgICAgICAgICBpdGVtSW5kZW50OiAoY3R4LmluZGVudCB8fCAnJykgKyAnICAnLFxuICAgICAgICAgICAgb25DaG9tcEtlZXAsXG4gICAgICAgICAgICBvbkNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzZXEgPSBuZXcgdGhpcyhzY2hlbWEpO1xuICAgICAgICBpZiAob2JqICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaXQgb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvYmogaW5zdGFuY2VvZiBTZXQgPyBpdCA6IFN0cmluZyhpKyspO1xuICAgICAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goY3JlYXRlTm9kZShpdCwgdW5kZWZpbmVkLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzSXRlbUluZGV4KGtleSkge1xuICAgIGxldCBpZHggPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGlmIChpZHggJiYgdHlwZW9mIGlkeCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGlkeCA9IE51bWJlcihpZHgpO1xuICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKGlkeCkgJiYgaWR4ID49IDBcbiAgICAgICAgPyBpZHhcbiAgICAgICAgOiBudWxsO1xufVxuXG5leHBvcnQgeyBZQU1MU2VxIH07XG4iLCAiaW1wb3J0IHsgaXNTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5cbmNvbnN0IHNlcSA9IHtcbiAgICBjb2xsZWN0aW9uOiAnc2VxJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTFNlcSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNTZXEoc2VxKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBvYmosIGN0eCkgPT4gWUFNTFNlcS5mcm9tKHNjaGVtYSwgb2JqLCBjdHgpXG59O1xuXG5leHBvcnQgeyBzZXEgfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzJztcblxuY29uc3Qgc3RyaW5nID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyxcbiAgICByZXNvbHZlOiBzdHIgPT4gc3RyLFxuICAgIHN0cmluZ2lmeShpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7IGFjdHVhbFN0cmluZzogdHJ1ZSB9LCBjdHgpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgc3RyaW5nIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuY29uc3QgbnVsbFRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgICBjcmVhdGVOb2RlOiAoKSA9PiBuZXcgU2NhbGFyKG51bGwpLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsXG4gICAgdGVzdDogL14oPzp+fFtObl11bGx8TlVMTCk/JC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gbmV3IFNjYWxhcihudWxsKSxcbiAgICBzdHJpbmdpZnk6ICh7IHNvdXJjZSB9LCBjdHgpID0+IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIG51bGxUYWcudGVzdC50ZXN0KHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgOiBjdHgub3B0aW9ucy5udWxsU3RyXG59O1xuXG5leHBvcnQgeyBudWxsVGFnIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuY29uc3QgYm9vbFRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/OltUdF1ydWV8VFJVRXxbRmZdYWxzZXxGQUxTRSkkLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gbmV3IFNjYWxhcihzdHJbMF0gPT09ICd0JyB8fCBzdHJbMF0gPT09ICdUJyksXG4gICAgc3RyaW5naWZ5KHsgc291cmNlLCB2YWx1ZSB9LCBjdHgpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiBib29sVGFnLnRlc3QudGVzdChzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBzdiA9IHNvdXJjZVswXSA9PT0gJ3QnIHx8IHNvdXJjZVswXSA9PT0gJ1QnO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBzdilcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGN0eC5vcHRpb25zLnRydWVTdHIgOiBjdHgub3B0aW9ucy5mYWxzZVN0cjtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBib29sVGFnIH07XG4iLCAiZnVuY3Rpb24gc3RyaW5naWZ5TnVtYmVyKHsgZm9ybWF0LCBtaW5GcmFjdGlvbkRpZ2l0cywgdGFnLCB2YWx1ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IG51bSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKVxuICAgICAgICByZXR1cm4gaXNOYU4obnVtKSA/ICcubmFuJyA6IG51bSA8IDAgPyAnLS5pbmYnIDogJy5pbmYnO1xuICAgIGxldCBuID0gT2JqZWN0LmlzKHZhbHVlLCAtMCkgPyAnLTAnIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIGlmICghZm9ybWF0ICYmXG4gICAgICAgIG1pbkZyYWN0aW9uRGlnaXRzICYmXG4gICAgICAgICghdGFnIHx8IHRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JykgJiZcbiAgICAgICAgL15cXGQvLnRlc3QobikpIHtcbiAgICAgICAgbGV0IGkgPSBuLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICBpID0gbi5sZW5ndGg7XG4gICAgICAgICAgICBuICs9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZCA9IG1pbkZyYWN0aW9uRGlnaXRzIC0gKG4ubGVuZ3RoIC0gaSAtIDEpO1xuICAgICAgICB3aGlsZSAoZC0tID4gMClcbiAgICAgICAgICAgIG4gKz0gJzAnO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXig/OlstK10/XFwuKD86aW5mfEluZnxJTkYpfFxcLm5hbnxcXC5OYU58XFwuTkFOKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlxcLlswLTldK3xbMC05XSsoPzpcXC5bMC05XSopPylbZUVdWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gcGFyc2VGbG9hdChzdHIpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIH1cbn07XG5jb25zdCBmbG9hdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldK1xcLlswLTldKikkLyxcbiAgICByZXNvbHZlKHN0cikge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFNjYWxhcihwYXJzZUZsb2F0KHN0cikpO1xuICAgICAgICBjb25zdCBkb3QgPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90ICE9PSAtMSAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gc3RyLmxlbmd0aCAtIGRvdCAtIDE7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5cbmV4cG9ydCB7IGZsb2F0LCBmbG9hdEV4cCwgZmxvYXROYU4gfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5TnVtYmVyLmpzJztcblxuY29uc3QgaW50SWRlbnRpZnkgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5jb25zdCBpbnRSZXNvbHZlID0gKHN0ciwgb2Zmc2V0LCByYWRpeCwgeyBpbnRBc0JpZ0ludCB9KSA9PiAoaW50QXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcob2Zmc2V0KSwgcmFkaXgpKTtcbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDApXG4gICAgICAgIHJldHVybiBwcmVmaXggKyB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlcihub2RlKTtcbn1cbmNvbnN0IGludE9jdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDAsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ09DVCcsXG4gICAgdGVzdDogL14wb1swLTddKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCA4LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgOCwgJzBvJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgaW50SGV4ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnSEVYJyxcbiAgICB0ZXN0OiAvXjB4WzAtOWEtZkEtRl0rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDE2LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59O1xuXG5leHBvcnQgeyBpbnQsIGludEhleCwgaW50T2N0IH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBudWxsVGFnIH0gZnJvbSAnLi4vY29tbW9uL251bGwuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGJvb2xUYWcgfSBmcm9tICcuL2Jvb2wuanMnO1xuaW1wb3J0IHsgZmxvYXROYU4sIGZsb2F0RXhwLCBmbG9hdCB9IGZyb20gJy4vZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50T2N0LCBpbnQsIGludEhleCB9IGZyb20gJy4vaW50LmpzJztcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgc3RyaW5nLFxuICAgIG51bGxUYWcsXG4gICAgYm9vbFRhZyxcbiAgICBpbnRPY3QsXG4gICAgaW50LFxuICAgIGludEhleCxcbiAgICBmbG9hdE5hTixcbiAgICBmbG9hdEV4cCxcbiAgICBmbG9hdFxuXTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi4vY29tbW9uL3NlcS5qcyc7XG5cbmZ1bmN0aW9uIGludElkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5jb25zdCBzdHJpbmdpZnlKU09OID0gKHsgdmFsdWUgfSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuY29uc3QganNvblNjYWxhcnMgPSBbXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyxcbiAgICAgICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICAgICAgICBjcmVhdGVOb2RlOiAoKSA9PiBuZXcgU2NhbGFyKG51bGwpLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgICAgICAgdGVzdDogL15udWxsJC8sXG4gICAgICAgIHJlc29sdmU6ICgpID0+IG51bGwsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgICAgICB0ZXN0OiAvXnRydWUkfF5mYWxzZSQvLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyID09PSAndHJ1ZScsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvLFxuICAgICAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLCAxMCksXG4gICAgICAgIHN0cmluZ2lmeTogKHsgdmFsdWUgfSkgPT4gaW50SWRlbnRpZnkodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgICAgICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikoPzpcXC5bMC05XSopPyg/OltlRV1bLStdP1swLTldKyk/JC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH1cbl07XG5jb25zdCBqc29uRXJyb3IgPSB7XG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICcnLFxuICAgIHRlc3Q6IC9eLyxcbiAgICByZXNvbHZlKHN0ciwgb25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGBVbnJlc29sdmVkIHBsYWluIHNjYWxhciAke0pTT04uc3RyaW5naWZ5KHN0cil9YCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVtYSA9IFttYXAsIHNlcV0uY29uY2F0KGpzb25TY2FsYXJzLCBqc29uRXJyb3IpO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IGJpbmFyeSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5LCAvLyBCdWZmZXIgaW5oZXJpdHMgZnJvbSBVaW50OEFycmF5XG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JyxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQnVmZmVyIGluIG5vZGUgYW5kIGFuIFVpbnQ4QXJyYXkgaW4gYnJvd3NlcnNcbiAgICAgKlxuICAgICAqIFRvIHVzZSB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBhcyBhbiBpbWFnZSwgeW91J2xsIHdhbnQgdG8gZG8gc29tZXRoaW5nIGxpa2U6XG4gICAgICpcbiAgICAgKiAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwaG90bycpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgKi9cbiAgICByZXNvbHZlKHNyYywgb25FcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIE9uIElFIDExLCBhdG9iKCkgY2FuJ3QgaGFuZGxlIG5ld2xpbmVzXG4gICAgICAgICAgICBjb25zdCBzdHIgPSBhdG9iKHNyYy5yZXBsYWNlKC9bXFxuXFxyXS9nLCAnJykpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgcmVhZGluZyBiaW5hcnkgdGFnczsgZWl0aGVyIEJ1ZmZlciBvciBhdG9iIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdHJpbmdpZnkoeyBjb21tZW50LCB0eXBlLCB2YWx1ZSB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY29uc3QgYnVmID0gdmFsdWU7IC8vIGNoZWNrZWQgZWFybGllciBieSBiaW5hcnkuaWRlbnRpZnkoKVxuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgIHN0ciA9IGJ0b2Eocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID8/ICh0eXBlID0gU2NhbGFyLkJMT0NLX0xJVEVSQUwpO1xuICAgICAgICBpZiAodHlwZSAhPT0gU2NhbGFyLlFVT1RFX0RPVUJMRSkge1xuICAgICAgICAgICAgY29uc3QgbGluZVdpZHRoID0gTWF0aC5tYXgoY3R4Lm9wdGlvbnMubGluZVdpZHRoIC0gY3R4LmluZGVudC5sZW5ndGgsIGN0eC5vcHRpb25zLm1pbkNvbnRlbnRXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5jZWlsKHN0ci5sZW5ndGggLyBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbyA9IDA7IGkgPCBuOyArK2ksIG8gKz0gbGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGluZXNbaV0gPSBzdHIuc3Vic3RyKG8sIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBsaW5lcy5qb2luKHR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMID8gJ1xcbicgOiAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcoeyBjb21tZW50LCB0eXBlLCB2YWx1ZTogc3RyIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgYmluYXJ5IH07XG4iLCAiaW1wb3J0IHsgaXNTZXEsIGlzUGFpciwgaXNNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQYWlyLCBQYWlyIH0gZnJvbSAnLi4vLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKSB7XG4gICAgaWYgKGlzU2VxKHNlcSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXEuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gc2VxLml0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGlzUGFpcihpdGVtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTWFwKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcignRWFjaCBwYWlyIG11c3QgaGF2ZSBpdHMgb3duIHNlcXVlbmNlIGluZGljYXRvcicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBpdGVtLml0ZW1zWzBdIHx8IG5ldyBQYWlyKG5ldyBTY2FsYXIobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHBhaXIua2V5LmNvbW1lbnRCZWZvcmUgPSBwYWlyLmtleS5jb21tZW50QmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke2l0ZW0uY29tbWVudEJlZm9yZX1cXG4ke3BhaXIua2V5LmNvbW1lbnRCZWZvcmV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbiA9IHBhaXIudmFsdWUgPz8gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNuLmNvbW1lbnQgPSBjbi5jb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke2l0ZW0uY29tbWVudH1cXG4ke2NuLmNvbW1lbnR9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0gPSBwYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxLml0ZW1zW2ldID0gaXNQYWlyKGl0ZW0pID8gaXRlbSA6IG5ldyBQYWlyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBzZXF1ZW5jZSBmb3IgdGhpcyB0YWcnKTtcbiAgICByZXR1cm4gc2VxO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgIGNvbnN0IHBhaXJzID0gbmV3IFlBTUxTZXEoc2NoZW1hKTtcbiAgICBwYWlycy50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnO1xuICAgIGxldCBpID0gMDtcbiAgICBpZiAoaXRlcmFibGUgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyYWJsZSkpXG4gICAgICAgIGZvciAobGV0IGl0IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIGl0ID0gcmVwbGFjZXIuY2FsbChpdGVyYWJsZSwgU3RyaW5nKGkrKyksIGl0KTtcbiAgICAgICAgICAgIGxldCBrZXksIHZhbHVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBpdFswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBba2V5LCB2YWx1ZV0gdHVwbGU6ICR7aXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdCAmJiBpdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHR1cGxlIHdpdGggb25lIGtleSwgbm90ICR7a2V5cy5sZW5ndGh9IGtleXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhaXJzLml0ZW1zLnB1c2goY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgICByZXNvbHZlOiByZXNvbHZlUGFpcnMsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVBhaXJzLCBwYWlycywgcmVzb2x2ZVBhaXJzIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIsIGlzUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuLi8uLi9ub2Rlcy90b0pTLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVQYWlycywgY3JlYXRlUGFpcnMgfSBmcm9tICcuL3BhaXJzLmpzJztcblxuY2xhc3MgWUFNTE9NYXAgZXh0ZW5kcyBZQU1MU2VxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hZGQgPSBZQU1MTWFwLnByb3RvdHlwZS5hZGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxldGUgPSBZQU1MTWFwLnByb3RvdHlwZS5kZWxldGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXQgPSBZQU1MTWFwLnByb3RvdHlwZS5nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYXMgPSBZQU1MTWFwLnByb3RvdHlwZS5oYXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXQgPSBZQU1MTWFwLnByb3RvdHlwZS5zZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50YWcgPSBZQU1MT01hcC50YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGBjdHhgIGlzIGdpdmVuLCB0aGUgcmV0dXJuIHR5cGUgaXMgYWN0dWFsbHkgYE1hcDx1bmtub3duLCB1bmtub3duPmAsXG4gICAgICogYnV0IFR5cGVTY3JpcHQgd29uJ3QgYWxsb3cgd2lkZW5pbmcgdGhlIHNpZ25hdHVyZSBvZiBhIGNoaWxkIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvSlNPTihfKTtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoY3R4Py5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShtYXApO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgbGV0IGtleSwgdmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNQYWlyKHBhaXIpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUyhwYWlyLmtleSwgJycsIGN0eCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0pTKHBhaXIudmFsdWUsIGtleSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IHRvSlMocGFpciwgJycsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXMnKTtcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgICAgICAgY29uc3Qgb21hcCA9IG5ldyB0aGlzKCk7XG4gICAgICAgIG9tYXAuaXRlbXMgPSBwYWlycy5pdGVtcztcbiAgICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxufVxuWUFNTE9NYXAudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnO1xuY29uc3Qgb21hcCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnc2VxJyxcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBNYXAsXG4gICAgbm9kZUNsYXNzOiBZQU1MT01hcCxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJyxcbiAgICByZXNvbHZlKHNlcSwgb25FcnJvcikge1xuICAgICAgICBjb25zdCBwYWlycyA9IHJlc29sdmVQYWlycyhzZXEsIG9uRXJyb3IpO1xuICAgICAgICBjb25zdCBzZWVuS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsga2V5IH0gb2YgcGFpcnMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpc1NjYWxhcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzLmluY2x1ZGVzKGtleS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihgT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXM6ICR7a2V5LnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlbktleXMucHVzaChrZXkudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTE9NYXAoKSwgcGFpcnMpO1xuICAgIH0sXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkgPT4gWUFNTE9NYXAuZnJvbShzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpXG59O1xuXG5leHBvcnQgeyBZQU1MT01hcCwgb21hcCB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIGJvb2xTdHJpbmdpZnkoeyB2YWx1ZSwgc291cmNlIH0sIGN0eCkge1xuICAgIGNvbnN0IGJvb2xPYmogPSB2YWx1ZSA/IHRydWVUYWcgOiBmYWxzZVRhZztcbiAgICBpZiAoc291cmNlICYmIGJvb2xPYmoudGVzdC50ZXN0KHNvdXJjZSkpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgcmV0dXJuIHZhbHVlID8gY3R4Lm9wdGlvbnMudHJ1ZVN0ciA6IGN0eC5vcHRpb25zLmZhbHNlU3RyO1xufVxuY29uc3QgdHJ1ZVRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT09IHRydWUsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/Oll8eXxbWXldZXN8WUVTfFtUdF1ydWV8VFJVRXxbT29dbnxPTikkLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyKHRydWUpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcbmNvbnN0IGZhbHNlVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gZmFsc2UsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/Ok58bnxbTm5db3xOT3xbRmZdYWxzZXxGQUxTRXxbT29dZmZ8T0ZGKSQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIoZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcblxuZXhwb3J0IHsgZmFsc2VUYWcsIHRydWVUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eKD86Wy0rXT9cXC4oPzppbmZ8SW5mfElORil8XFwubmFufFxcLk5hTnxcXC5OQU4pJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gc3RyLnNsaWNlKC0zKS50b0xvd2VyQ2FzZSgpID09PSAnbmFuJ1xuICAgICAgICA/IE5hTlxuICAgICAgICA6IHN0clswXSA9PT0gJy0nXG4gICAgICAgICAgICA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICAgICAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBmbG9hdEV4cCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdFWFAnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpbMC05XVswLTlfXSopPyg/OlxcLlswLTlfXSopP1tlRV1bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IChzdHIpID0+IHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKSxcbiAgICBzdHJpbmdpZnkobm9kZSkge1xuICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShudW0pID8gbnVtLnRvRXhwb25lbnRpYWwoKSA6IHN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICB9XG59O1xuY29uc3QgZmxvYXQgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/XFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3QgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gc3RyLnN1YnN0cmluZyhkb3QgKyAxKS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgICAgICAgIGlmIChmW2YubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgICAgICBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcblxuZXhwb3J0IHsgZmxvYXQsIGZsb2F0RXhwLCBmbG9hdE5hTiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBpbnRJZGVudGlmeSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmZ1bmN0aW9uIGludFJlc29sdmUoc3RyLCBvZmZzZXQsIHJhZGl4LCB7IGludEFzQmlnSW50IH0pIHtcbiAgICBjb25zdCBzaWduID0gc3RyWzBdO1xuICAgIGlmIChzaWduID09PSAnLScgfHwgc2lnbiA9PT0gJysnKVxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKG9mZnNldCkucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgaWYgKGludEFzQmlnSW50KSB7XG4gICAgICAgIHN3aXRjaCAocmFkaXgpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMGIke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHN0ciA9IGAwbyR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIHN0ciA9IGAweCR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9IEJpZ0ludChzdHIpO1xuICAgICAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gQmlnSW50KC0xKSAqIG4gOiBuO1xuICAgIH1cbiAgICBjb25zdCBuID0gcGFyc2VJbnQoc3RyLCByYWRpeCk7XG4gICAgcmV0dXJuIHNpZ24gPT09ICctJyA/IC0xICogbiA6IG47XG59XG5mdW5jdGlvbiBpbnRTdHJpbmdpZnkobm9kZSwgcmFkaXgsIHByZWZpeCkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgaWYgKGludElkZW50aWZ5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBzdHIgPSB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyAnLScgKyBwcmVmaXggKyBzdHIuc3Vic3RyKDEpIDogcHJlZml4ICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuY29uc3QgaW50QmluID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnQklOJyxcbiAgICB0ZXN0OiAvXlstK10/MGJbMC0xX10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDIsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAyLCAnMGInKVxufTtcbmNvbnN0IGludE9jdCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ09DVCcsXG4gICAgdGVzdDogL15bLStdPzBbMC03X10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDEsIDgsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCA4LCAnMCcpXG59O1xuY29uc3QgaW50ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKiQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAwLCAxMCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGludEhleCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ0hFWCcsXG4gICAgdGVzdDogL15bLStdPzB4WzAtOWEtZkEtRl9dKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCAxNiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDE2LCAnMHgnKVxufTtcblxuZXhwb3J0IHsgaW50LCBpbnRCaW4sIGludEhleCwgaW50T2N0IH07XG4iLCAiaW1wb3J0IHsgaXNNYXAsIGlzUGFpciwgaXNTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBQYWlyLCBjcmVhdGVQYWlyIH0gZnJvbSAnLi4vLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwLCBmaW5kUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuXG5jbGFzcyBZQU1MU2V0IGV4dGVuZHMgWUFNTE1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHNjaGVtYSk7XG4gICAgICAgIHRoaXMudGFnID0gWUFNTFNldC50YWc7XG4gICAgfVxuICAgIGFkZChrZXkpIHtcbiAgICAgICAgbGV0IHBhaXI7XG4gICAgICAgIGlmIChpc1BhaXIoa2V5KSlcbiAgICAgICAgICAgIHBhaXIgPSBrZXk7XG4gICAgICAgIGVsc2UgaWYgKGtleSAmJlxuICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdrZXknIGluIGtleSAmJlxuICAgICAgICAgICAgJ3ZhbHVlJyBpbiBrZXkgJiZcbiAgICAgICAgICAgIGtleS52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHBhaXIgPSBuZXcgUGFpcihrZXkua2V5LCBudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyKGtleSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBwYWlyLmtleSk7XG4gICAgICAgIGlmICghcHJldilcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChwYWlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYGtlZXBQYWlyYCBpcyBgdHJ1ZWAsIHJldHVybnMgdGhlIFBhaXIgbWF0Y2hpbmcgYGtleWAuXG4gICAgICogT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGF0IFBhaXIncyBrZXkuXG4gICAgICovXG4gICAgZ2V0KGtleSwga2VlcFBhaXIpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIHJldHVybiAha2VlcFBhaXIgJiYgaXNQYWlyKHBhaXIpXG4gICAgICAgICAgICA/IGlzU2NhbGFyKHBhaXIua2V5KVxuICAgICAgICAgICAgICAgID8gcGFpci5rZXkudmFsdWVcbiAgICAgICAgICAgICAgICA6IHBhaXIua2V5XG4gICAgICAgICAgICA6IHBhaXI7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiB2YWx1ZSBmb3Igc2V0KGtleSwgdmFsdWUpIGluIGEgWUFNTCBzZXQsIG5vdCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGlmIChwcmV2ICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKHByZXYpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcHJldiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnRvSlNPTihfLCBjdHgsIFNldCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWxsTnVsbFZhbHVlcyh0cnVlKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci50b1N0cmluZyhPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgYWxsTnVsbFZhbHVlczogdHJ1ZSB9KSwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2V0IGl0ZW1zIG11c3QgYWxsIGhhdmUgbnVsbCB2YWx1ZXMnKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2V0Lml0ZW1zLnB1c2goY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufVxuWUFNTFNldC50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6c2V0JztcbmNvbnN0IHNldCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnbWFwJyxcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBTZXQsXG4gICAgbm9kZUNsYXNzOiBZQU1MU2V0LFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkgPT4gWUFNTFNldC5mcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCksXG4gICAgcmVzb2x2ZShtYXAsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzTWFwKG1hcCkpIHtcbiAgICAgICAgICAgIGlmIChtYXAuaGFzQWxsTnVsbFZhbHVlcyh0cnVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTFNldCgpLCBtYXApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxTZXQsIHNldCB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG4vKiogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC4gKi9cbmZ1bmN0aW9uIHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBhc0JpZ0ludCkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgY29uc3QgcGFydHMgPSBzaWduID09PSAnLScgfHwgc2lnbiA9PT0gJysnID8gc3RyLnN1YnN0cmluZygxKSA6IHN0cjtcbiAgICBjb25zdCBudW0gPSAobikgPT4gYXNCaWdJbnQgPyBCaWdJbnQobikgOiBOdW1iZXIobik7XG4gICAgY29uc3QgcmVzID0gcGFydHNcbiAgICAgICAgLnJlcGxhY2UoL18vZywgJycpXG4gICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgIC5yZWR1Y2UoKHJlcywgcCkgPT4gcmVzICogbnVtKDYwKSArIG51bShwKSwgbnVtKDApKTtcbiAgICByZXR1cm4gKHNpZ24gPT09ICctJyA/IG51bSgtMSkgKiByZXMgOiByZXMpO1xufVxuLyoqXG4gKiBoaGhoOm1tOnNzLnNzc1xuICpcbiAqIEludGVybmFsIHR5cGVzIGhhbmRsZSBiaWdpbnQgYXMgbnVtYmVyLCBiZWNhdXNlIFRTIGNhbid0IGZpZ3VyZSBpdCBvdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNleGFnZXNpbWFsKG5vZGUpIHtcbiAgICBsZXQgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBsZXQgbnVtID0gKG4pID0+IG47XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIG51bSA9IG4gPT4gQmlnSW50KG4pO1xuICAgIGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIGxldCBzaWduID0gJyc7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICB2YWx1ZSAqPSBudW0oLTEpO1xuICAgIH1cbiAgICBjb25zdCBfNjAgPSBudW0oNjApO1xuICAgIGNvbnN0IHBhcnRzID0gW3ZhbHVlICUgXzYwXTsgLy8gc2Vjb25kcywgaW5jbHVkaW5nIG1zXG4gICAgaWYgKHZhbHVlIDwgNjApIHtcbiAgICAgICAgcGFydHMudW5zaGlmdCgwKTsgLy8gYXQgbGVhc3Qgb25lIDogaXMgcmVxdWlyZWRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC0gcGFydHNbMF0pIC8gXzYwO1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlICUgXzYwKTsgLy8gbWludXRlc1xuICAgICAgICBpZiAodmFsdWUgPj0gNjApIHtcbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlIC0gcGFydHNbMF0pIC8gXzYwO1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCh2YWx1ZSk7IC8vIGhvdXJzXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChzaWduICtcbiAgICAgICAgcGFydHNcbiAgICAgICAgICAgIC5tYXAobiA9PiBTdHJpbmcobikucGFkU3RhcnQoMiwgJzAnKSlcbiAgICAgICAgICAgIC5qb2luKCc6JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8wMDAwMDBcXGQqJC8sICcnKSAvLyAlIDYwIG1heSBpbnRyb2R1Y2UgZXJyb3JcbiAgICApO1xufVxuY29uc3QgaW50VGltZSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnVElNRScsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIHsgaW50QXNCaWdJbnQgfSkgPT4gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGludEFzQmlnSW50KSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVNleGFnZXNpbWFsXG59O1xuY29uc3QgZmxvYXRUaW1lID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ1RJTUUnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcLlswLTlfXSokLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGZhbHNlKSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVNleGFnZXNpbWFsXG59O1xuY29uc3QgdGltZXN0YW1wID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLFxuICAgIC8vIElmIHRoZSB0aW1lIHpvbmUgaXMgb21pdHRlZCwgdGhlIHRpbWVzdGFtcCBpcyBhc3N1bWVkIHRvIGJlIHNwZWNpZmllZCBpbiBVVEMuIFRoZSB0aW1lIHBhcnRcbiAgICAvLyBtYXkgYmUgb21pdHRlZCBhbHRvZ2V0aGVyLCByZXN1bHRpbmcgaW4gYSBkYXRlIGZvcm1hdC4gSW4gc3VjaCBhIGNhc2UsIHRoZSB0aW1lIHBhcnQgaXNcbiAgICAvLyBhc3N1bWVkIHRvIGJlIDAwOjAwOjAwWiAoc3RhcnQgb2YgZGF5LCBVVEMpLlxuICAgIHRlc3Q6IFJlZ0V4cCgnXihbMC05XXs0fSktKFswLTldezEsMn0pLShbMC05XXsxLDJ9KScgKyAvLyBZWVlZLU1tLURkXG4gICAgICAgICcoPzonICsgLy8gdGltZSBpcyBvcHRpb25hbFxuICAgICAgICAnKD86dHxUfFsgXFxcXHRdKyknICsgLy8gdCB8IFQgfCB3aGl0ZXNwYWNlXG4gICAgICAgICcoWzAtOV17MSwyfSk6KFswLTldezEsMn0pOihbMC05XXsxLDJ9KFxcXFwuWzAtOV0rKT8pJyArIC8vIEhoOk1tOlNzKC5zcyk/XG4gICAgICAgICcoPzpbIFxcXFx0XSooWnxbLStdWzAxMl0/WzAtOV0oPzo6WzAtOV17Mn0pPykpPycgKyAvLyBaIHwgKzUgfCAtMDM6MzBcbiAgICAgICAgJyk/JCcpLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3RyLm1hdGNoKHRpbWVzdGFtcC50ZXN0KTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignISF0aW1lc3RhbXAgZXhwZWN0cyBhIGRhdGUsIHN0YXJ0aW5nIHdpdGggeXl5eS1tbS1kZCcpO1xuICAgICAgICBjb25zdCBbLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBtYXRjaC5tYXAoTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWMgPSBtYXRjaFs3XSA/IE51bWJlcigobWF0Y2hbN10gKyAnMDAnKS5zdWJzdHIoMSwgMykpIDogMDtcbiAgICAgICAgbGV0IGRhdGUgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciB8fCAwLCBtaW51dGUgfHwgMCwgc2Vjb25kIHx8IDAsIG1pbGxpc2VjKTtcbiAgICAgICAgY29uc3QgdHogPSBtYXRjaFs4XTtcbiAgICAgICAgaWYgKHR6ICYmIHR6ICE9PSAnWicpIHtcbiAgICAgICAgICAgIGxldCBkID0gcGFyc2VTZXhhZ2VzaW1hbCh0eiwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGQpIDwgMzApXG4gICAgICAgICAgICAgICAgZCAqPSA2MDtcbiAgICAgICAgICAgIGRhdGUgLT0gNjAwMDAgKiBkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogKHsgdmFsdWUgfSkgPT4gdmFsdWU/LnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvKFQwMDowMDowMCk/XFwuMDAwWiQvLCAnJykgPz8gJydcbn07XG5cbmV4cG9ydCB7IGZsb2F0VGltZSwgaW50VGltZSwgdGltZXN0YW1wIH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBudWxsVGFnIH0gZnJvbSAnLi4vY29tbW9uL251bGwuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGJpbmFyeSB9IGZyb20gJy4vYmluYXJ5LmpzJztcbmltcG9ydCB7IHRydWVUYWcsIGZhbHNlVGFnIH0gZnJvbSAnLi9ib29sLmpzJztcbmltcG9ydCB7IGZsb2F0TmFOLCBmbG9hdEV4cCwgZmxvYXQgfSBmcm9tICcuL2Zsb2F0LmpzJztcbmltcG9ydCB7IGludEJpbiwgaW50T2N0LCBpbnQsIGludEhleCB9IGZyb20gJy4vaW50LmpzJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnLi9tZXJnZS5qcyc7XG5pbXBvcnQgeyBvbWFwIH0gZnJvbSAnLi9vbWFwLmpzJztcbmltcG9ydCB7IHBhaXJzIH0gZnJvbSAnLi9wYWlycy5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3NldC5qcyc7XG5pbXBvcnQgeyBpbnRUaW1lLCBmbG9hdFRpbWUsIHRpbWVzdGFtcCB9IGZyb20gJy4vdGltZXN0YW1wLmpzJztcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgc3RyaW5nLFxuICAgIG51bGxUYWcsXG4gICAgdHJ1ZVRhZyxcbiAgICBmYWxzZVRhZyxcbiAgICBpbnRCaW4sXG4gICAgaW50T2N0LFxuICAgIGludCxcbiAgICBpbnRIZXgsXG4gICAgZmxvYXROYU4sXG4gICAgZmxvYXRFeHAsXG4gICAgZmxvYXQsXG4gICAgYmluYXJ5LFxuICAgIG1lcmdlLFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2V0LFxuICAgIGludFRpbWUsXG4gICAgZmxvYXRUaW1lLFxuICAgIHRpbWVzdGFtcFxuXTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vY29yZS9ib29sLmpzJztcbmltcG9ydCB7IGZsb2F0TmFOLCBmbG9hdEV4cCwgZmxvYXQgfSBmcm9tICcuL2NvcmUvZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50T2N0LCBpbnRIZXgsIGludCB9IGZyb20gJy4vY29yZS9pbnQuanMnO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSAnLi9jb3JlL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgYXMgc2NoZW1hJDEgfSBmcm9tICcuL2pzb24vc2NoZW1hLmpzJztcbmltcG9ydCB7IGJpbmFyeSB9IGZyb20gJy4veWFtbC0xLjEvYmluYXJ5LmpzJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnLi95YW1sLTEuMS9tZXJnZS5qcyc7XG5pbXBvcnQgeyBvbWFwIH0gZnJvbSAnLi95YW1sLTEuMS9vbWFwLmpzJztcbmltcG9ydCB7IHBhaXJzIH0gZnJvbSAnLi95YW1sLTEuMS9wYWlycy5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgYXMgc2NoZW1hJDIgfSBmcm9tICcuL3lhbWwtMS4xL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3lhbWwtMS4xL3NldC5qcyc7XG5pbXBvcnQgeyB0aW1lc3RhbXAsIGludFRpbWUsIGZsb2F0VGltZSB9IGZyb20gJy4veWFtbC0xLjEvdGltZXN0YW1wLmpzJztcblxuY29uc3Qgc2NoZW1hcyA9IG5ldyBNYXAoW1xuICAgIFsnY29yZScsIHNjaGVtYV0sXG4gICAgWydmYWlsc2FmZScsIFttYXAsIHNlcSwgc3RyaW5nXV0sXG4gICAgWydqc29uJywgc2NoZW1hJDFdLFxuICAgIFsneWFtbDExJywgc2NoZW1hJDJdLFxuICAgIFsneWFtbC0xLjEnLCBzY2hlbWEkMl1cbl0pO1xuY29uc3QgdGFnc0J5TmFtZSA9IHtcbiAgICBiaW5hcnksXG4gICAgYm9vbDogYm9vbFRhZyxcbiAgICBmbG9hdCxcbiAgICBmbG9hdEV4cCxcbiAgICBmbG9hdE5hTixcbiAgICBmbG9hdFRpbWUsXG4gICAgaW50LFxuICAgIGludEhleCxcbiAgICBpbnRPY3QsXG4gICAgaW50VGltZSxcbiAgICBtYXAsXG4gICAgbWVyZ2UsXG4gICAgbnVsbDogbnVsbFRhZyxcbiAgICBvbWFwLFxuICAgIHBhaXJzLFxuICAgIHNlcSxcbiAgICBzZXQsXG4gICAgdGltZXN0YW1wXG59O1xuY29uc3QgY29yZUtub3duVGFncyA9IHtcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JzogYmluYXJ5LFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZSc6IG1lcmdlLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJzogb21hcCxcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnOiBwYWlycyxcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6c2V0Jzogc2V0LFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnOiB0aW1lc3RhbXBcbn07XG5mdW5jdGlvbiBnZXRUYWdzKGN1c3RvbVRhZ3MsIHNjaGVtYU5hbWUsIGFkZE1lcmdlVGFnKSB7XG4gICAgY29uc3Qgc2NoZW1hVGFncyA9IHNjaGVtYXMuZ2V0KHNjaGVtYU5hbWUpO1xuICAgIGlmIChzY2hlbWFUYWdzICYmICFjdXN0b21UYWdzKSB7XG4gICAgICAgIHJldHVybiBhZGRNZXJnZVRhZyAmJiAhc2NoZW1hVGFncy5pbmNsdWRlcyhtZXJnZSlcbiAgICAgICAgICAgID8gc2NoZW1hVGFncy5jb25jYXQobWVyZ2UpXG4gICAgICAgICAgICA6IHNjaGVtYVRhZ3Muc2xpY2UoKTtcbiAgICB9XG4gICAgbGV0IHRhZ3MgPSBzY2hlbWFUYWdzO1xuICAgIGlmICghdGFncykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShzY2hlbWFzLmtleXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGtleSA9PiBrZXkgIT09ICd5YW1sMTEnKVxuICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiOyB1c2Ugb25lIG9mICR7a2V5c30gb3IgZGVmaW5lIGN1c3RvbVRhZ3MgYXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBjdXN0b21UYWdzKVxuICAgICAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KHRhZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjdXN0b21UYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRhZ3MgPSBjdXN0b21UYWdzKHRhZ3Muc2xpY2UoKSk7XG4gICAgfVxuICAgIGlmIChhZGRNZXJnZVRhZylcbiAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KG1lcmdlKTtcbiAgICByZXR1cm4gdGFncy5yZWR1Y2UoKHRhZ3MsIHRhZykgPT4ge1xuICAgICAgICBjb25zdCB0YWdPYmogPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJyA/IHRhZ3NCeU5hbWVbdGFnXSA6IHRhZztcbiAgICAgICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBKU09OLnN0cmluZ2lmeSh0YWcpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRhZ3NCeU5hbWUpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjdXN0b20gdGFnICR7dGFnTmFtZX07IHVzZSBvbmUgb2YgJHtrZXlzfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFncy5pbmNsdWRlcyh0YWdPYmopKVxuICAgICAgICAgICAgdGFncy5wdXNoKHRhZ09iaik7XG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgIH0sIFtdKTtcbn1cblxuZXhwb3J0IHsgY29yZUtub3duVGFncywgZ2V0VGFncyB9O1xuIiwgImltcG9ydCB7IE1BUCwgU0NBTEFSLCBTRVEgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBnZXRUYWdzLCBjb3JlS25vd25UYWdzIH0gZnJvbSAnLi90YWdzLmpzJztcblxuY29uc3Qgc29ydE1hcEVudHJpZXNCeUtleSA9IChhLCBiKSA9PiBhLmtleSA8IGIua2V5ID8gLTEgOiBhLmtleSA+IGIua2V5ID8gMSA6IDA7XG5jbGFzcyBTY2hlbWEge1xuICAgIGNvbnN0cnVjdG9yKHsgY29tcGF0LCBjdXN0b21UYWdzLCBtZXJnZSwgcmVzb2x2ZUtub3duVGFncywgc2NoZW1hLCBzb3J0TWFwRW50cmllcywgdG9TdHJpbmdEZWZhdWx0cyB9KSB7XG4gICAgICAgIHRoaXMuY29tcGF0ID0gQXJyYXkuaXNBcnJheShjb21wYXQpXG4gICAgICAgICAgICA/IGdldFRhZ3MoY29tcGF0LCAnY29tcGF0JylcbiAgICAgICAgICAgIDogY29tcGF0XG4gICAgICAgICAgICAgICAgPyBnZXRUYWdzKG51bGwsIGNvbXBhdClcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHRoaXMubmFtZSA9ICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJyAmJiBzY2hlbWEpIHx8ICdjb3JlJztcbiAgICAgICAgdGhpcy5rbm93blRhZ3MgPSByZXNvbHZlS25vd25UYWdzID8gY29yZUtub3duVGFncyA6IHt9O1xuICAgICAgICB0aGlzLnRhZ3MgPSBnZXRUYWdzKGN1c3RvbVRhZ3MsIHRoaXMubmFtZSwgbWVyZ2UpO1xuICAgICAgICB0aGlzLnRvU3RyaW5nT3B0aW9ucyA9IHRvU3RyaW5nRGVmYXVsdHMgPz8gbnVsbDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE1BUCwgeyB2YWx1ZTogbWFwIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU0NBTEFSLCB7IHZhbHVlOiBzdHJpbmcgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTRVEsIHsgdmFsdWU6IHNlcSB9KTtcbiAgICAgICAgLy8gVXNlZCBieSBjcmVhdGVNYXAoKVxuICAgICAgICB0aGlzLnNvcnRNYXBFbnRyaWVzID1cbiAgICAgICAgICAgIHR5cGVvZiBzb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gc29ydE1hcEVudHJpZXNcbiAgICAgICAgICAgICAgICA6IHNvcnRNYXBFbnRyaWVzID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgID8gc29ydE1hcEVudHJpZXNCeUtleVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShTY2hlbWEucHJvdG90eXBlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGNvcHkudGFncyA9IHRoaXMudGFncy5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFNjaGVtYSB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQsIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGluZGVudENvbW1lbnQsIGxpbmVDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5RG9jdW1lbnQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBsZXQgaGFzRGlyZWN0aXZlcyA9IG9wdGlvbnMuZGlyZWN0aXZlcyA9PT0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzICE9PSBmYWxzZSAmJiBkb2MuZGlyZWN0aXZlcykge1xuICAgICAgICBjb25zdCBkaXIgPSBkb2MuZGlyZWN0aXZlcy50b1N0cmluZyhkb2MpO1xuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGRpcik7XG4gICAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuZGlyZWN0aXZlcy5kb2NTdGFydClcbiAgICAgICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzRGlyZWN0aXZlcylcbiAgICAgICAgbGluZXMucHVzaCgnLS0tJyk7XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChkb2MsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHsgY29tbWVudFN0cmluZyB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgaWYgKGRvYy5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICBsaW5lcy51bnNoaWZ0KCcnKTtcbiAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb21tZW50QmVmb3JlKTtcbiAgICAgICAgbGluZXMudW5zaGlmdChpbmRlbnRDb21tZW50KGNzLCAnJykpO1xuICAgIH1cbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IGNvbnRlbnRDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoZG9jLmNvbnRlbnRzKSB7XG4gICAgICAgIGlmIChpc05vZGUoZG9jLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgaWYgKGRvYy5jb250ZW50cy5zcGFjZUJlZm9yZSAmJiBoYXNEaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgaWYgKGRvYy5jb250ZW50cy5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb250ZW50cy5jb21tZW50QmVmb3JlKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b3AtbGV2ZWwgYmxvY2sgc2NhbGFycyBuZWVkIHRvIGJlIGluZGVudGVkIGlmIGZvbGxvd2VkIGJ5IGEgY29tbWVudFxuICAgICAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSAhIWRvYy5jb21tZW50O1xuICAgICAgICAgICAgY29udGVudENvbW1lbnQgPSBkb2MuY29udGVudHMuY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkNob21wS2VlcCA9IGNvbnRlbnRDb21tZW50ID8gdW5kZWZpbmVkIDogKCkgPT4gKGNob21wS2VlcCA9IHRydWUpO1xuICAgICAgICBsZXQgYm9keSA9IHN0cmluZ2lmeShkb2MuY29udGVudHMsIGN0eCwgKCkgPT4gKGNvbnRlbnRDb21tZW50ID0gbnVsbCksIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgaWYgKGNvbnRlbnRDb21tZW50KVxuICAgICAgICAgICAgYm9keSArPSBsaW5lQ29tbWVudChib2R5LCAnJywgY29tbWVudFN0cmluZyhjb250ZW50Q29tbWVudCkpO1xuICAgICAgICBpZiAoKGJvZHlbMF0gPT09ICd8JyB8fCBib2R5WzBdID09PSAnPicpICYmXG4gICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJy0tLScpIHtcbiAgICAgICAgICAgIC8vIFRvcC1sZXZlbCBibG9jayBzY2FsYXJzIHdpdGggYSBwcmVjZWRpbmcgZG9jIG1hcmtlciBvdWdodCB0byB1c2UgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGxpbmUgZm9yIHRoZWlyIGhlYWRlci5cbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID0gYC0tLSAke2JvZHl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnkoZG9jLmNvbnRlbnRzLCBjdHgpKTtcbiAgICB9XG4gICAgaWYgKGRvYy5kaXJlY3RpdmVzPy5kb2NFbmQpIHtcbiAgICAgICAgaWYgKGRvYy5jb21tZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNzLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJy4uLicpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYC4uLiAke2NzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGluZXMucHVzaCgnLi4uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBkYyA9IGRvYy5jb21tZW50O1xuICAgICAgICBpZiAoZGMgJiYgY2hvbXBLZWVwKVxuICAgICAgICAgICAgZGMgPSBkYy5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICAgICAgaWYgKGRjKSB7XG4gICAgICAgICAgICBpZiAoKCFjaG9tcEtlZXAgfHwgY29udGVudENvbW1lbnQpICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9PSAnJylcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goaW5kZW50Q29tbWVudChjb21tZW50U3RyaW5nKGRjKSwgJycpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZXMuam9pbignXFxuJykgKyAnXFxuJztcbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5RG9jdW1lbnQgfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGlzRW1wdHlQYXRoLCBjb2xsZWN0aW9uRnJvbVBhdGggfSBmcm9tICcuLi9ub2Rlcy9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IE5PREVfVFlQRSwgRE9DLCBpc05vZGUsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi4vbm9kZXMvdG9KUy5qcyc7XG5pbXBvcnQgeyBTY2hlbWEgfSBmcm9tICcuLi9zY2hlbWEvU2NoZW1hLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeURvY3VtZW50IH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzJztcbmltcG9ydCB7IGFuY2hvck5hbWVzLCBmaW5kTmV3QW5jaG9yLCBjcmVhdGVOb2RlQW5jaG9ycyB9IGZyb20gJy4vYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBhcHBseVJldml2ZXIgfSBmcm9tICcuL2FwcGx5UmV2aXZlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IERpcmVjdGl2ZXMgfSBmcm9tICcuL2RpcmVjdGl2ZXMuanMnO1xuXG5jbGFzcyBEb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgYmVmb3JlIHRoaXMgRG9jdW1lbnQgKi9cbiAgICAgICAgdGhpcy5jb21tZW50QmVmb3JlID0gbnVsbDtcbiAgICAgICAgLyoqIEEgY29tbWVudCBpbW1lZGlhdGVseSBhZnRlciB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG4gICAgICAgIC8qKiBFcnJvcnMgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIC8qKiBXYXJuaW5ncyBlbmNvdW50ZXJlZCBkdXJpbmcgcGFyc2luZy4gKi9cbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiBET0MgfSk7XG4gICAgICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaW50QXNCaWdJbnQ6IGZhbHNlLFxuICAgICAgICAgICAga2VlcFNvdXJjZVRva2VuczogZmFsc2UsXG4gICAgICAgICAgICBsb2dMZXZlbDogJ3dhcm4nLFxuICAgICAgICAgICAgcHJldHR5RXJyb3JzOiB0cnVlLFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgc3RyaW5nS2V5czogZmFsc2UsXG4gICAgICAgICAgICB1bmlxdWVLZXlzOiB0cnVlLFxuICAgICAgICAgICAgdmVyc2lvbjogJzEuMidcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdDtcbiAgICAgICAgbGV0IHsgdmVyc2lvbiB9ID0gb3B0O1xuICAgICAgICBpZiAob3B0aW9ucz8uX2RpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG9wdGlvbnMuX2RpcmVjdGl2ZXMuYXREb2N1bWVudCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcy55YW1sLmV4cGxpY2l0KVxuICAgICAgICAgICAgICAgIHZlcnNpb24gPSB0aGlzLmRpcmVjdGl2ZXMueWFtbC52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbiB9KTtcbiAgICAgICAgdGhpcy5zZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgIHRoaXMuY29udGVudHMgPVxuICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGlzIERvY3VtZW50IGFuZCBpdHMgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBDdXN0b20gTm9kZSB2YWx1ZXMgdGhhdCBpbmhlcml0IGZyb20gYE9iamVjdGAgc3RpbGwgcmVmZXIgdG8gdGhlaXIgb3JpZ2luYWwgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIFtOT0RFX1RZUEVdOiB7IHZhbHVlOiBET0MgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29weS5jb21tZW50QmVmb3JlID0gdGhpcy5jb21tZW50QmVmb3JlO1xuICAgICAgICBjb3B5LmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICAgIGNvcHkuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoKTtcbiAgICAgICAgY29weS53YXJuaW5ncyA9IHRoaXMud2FybmluZ3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIGNvcHkuZGlyZWN0aXZlcyA9IHRoaXMuZGlyZWN0aXZlcy5jbG9uZSgpO1xuICAgICAgICBjb3B5LnNjaGVtYSA9IHRoaXMuc2NoZW1hLmNsb25lKCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgIGNvcHkuY29udGVudHMgPSBpc05vZGUodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5jbG9uZShjb3B5LnNjaGVtYSlcbiAgICAgICAgICAgIDogdGhpcy5jb250ZW50cztcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSB2YWx1ZSB0byB0aGUgZG9jdW1lbnQuICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGQodmFsdWUpO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuYWRkSW4ocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYEFsaWFzYCBub2RlLCBlbnN1cmluZyB0aGF0IHRoZSB0YXJnZXQgYG5vZGVgIGhhcyB0aGUgcmVxdWlyZWQgYW5jaG9yLlxuICAgICAqXG4gICAgICogSWYgYG5vZGVgIGFscmVhZHkgaGFzIGFuIGFuY2hvciwgYG5hbWVgIGlzIGlnbm9yZWQuXG4gICAgICogT3RoZXJ3aXNlLCB0aGUgYG5vZGUuYW5jaG9yYCB2YWx1ZSB3aWxsIGJlIHNldCB0byBgbmFtZWAsXG4gICAgICogb3IgaWYgYW4gYW5jaG9yIHdpdGggdGhhdCBuYW1lIGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICogYG5hbWVgIHdpbGwgYmUgdXNlZCBhcyBhIHByZWZpeCBmb3IgYSBuZXcgdW5pcXVlIGFuY2hvci5cbiAgICAgKiBJZiBgbmFtZWAgaXMgdW5kZWZpbmVkLCB0aGUgZ2VuZXJhdGVkIGFuY2hvciB3aWxsIHVzZSAnYScgYXMgYSBwcmVmaXguXG4gICAgICovXG4gICAgY3JlYXRlQWxpYXMobm9kZSwgbmFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYW5jaG9yTmFtZXModGhpcyk7XG4gICAgICAgICAgICBub2RlLmFuY2hvciA9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgICAgICAgICAgIW5hbWUgfHwgcHJldi5oYXMobmFtZSkgPyBmaW5kTmV3QW5jaG9yKG5hbWUgfHwgJ2EnLCBwcmV2KSA6IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbGlhcyhub2RlLmFuY2hvcik7XG4gICAgfVxuICAgIGNyZWF0ZU5vZGUodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBfcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVRvU3RyID0gKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB2IGluc3RhbmNlb2YgU3RyaW5nIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCBhc1N0ciA9IHJlcGxhY2VyLmZpbHRlcihrZXlUb1N0cikubWFwKFN0cmluZyk7XG4gICAgICAgICAgICBpZiAoYXNTdHIubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICByZXBsYWNlciA9IHJlcGxhY2VyLmNvbmNhdChhc1N0cik7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzLCBhbmNob3JQcmVmaXgsIGZsb3csIGtlZXBVbmRlZmluZWQsIG9uVGFnT2JqLCB0YWcgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIGNvbnN0IHsgb25BbmNob3IsIHNldEFuY2hvcnMsIHNvdXJjZU9iamVjdHMgfSA9IGNyZWF0ZU5vZGVBbmNob3JzKHRoaXMsIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgYW5jaG9yUHJlZml4IHx8ICdhJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogYWxpYXNEdXBsaWNhdGVPYmplY3RzID8/IHRydWUsXG4gICAgICAgICAgICBrZWVwVW5kZWZpbmVkOiBrZWVwVW5kZWZpbmVkID8/IGZhbHNlLFxuICAgICAgICAgICAgb25BbmNob3IsXG4gICAgICAgICAgICBvblRhZ09iaixcbiAgICAgICAgICAgIHJlcGxhY2VyOiBfcmVwbGFjZXIsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgc291cmNlT2JqZWN0c1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnLCBjdHgpO1xuICAgICAgICBpZiAoZmxvdyAmJiBpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICBub2RlLmZsb3cgPSB0cnVlO1xuICAgICAgICBzZXRBbmNob3JzKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEga2V5IGFuZCBhIHZhbHVlIGludG8gYSBgUGFpcmAgdXNpbmcgdGhlIGN1cnJlbnQgc2NoZW1hLFxuICAgICAqIHJlY3Vyc2l2ZWx5IHdyYXBwaW5nIGFsbCB2YWx1ZXMgYXMgYFNjYWxhcmAgb3IgYENvbGxlY3Rpb25gIG5vZGVzLlxuICAgICAqL1xuICAgIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLmNyZWF0ZU5vZGUoa2V5LCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuZGVsZXRlKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQcmVzdW1lZCBpbXBvc3NpYmxlIGlmIFN0cmljdCBleHRlbmRzIGZhbHNlXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZGVsZXRlSW4ocGF0aClcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZ2V0KGtleSwga2VlcFNjYWxhcilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYHBhdGhgLCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuIEJ5IGRlZmF1bHQgdW53cmFwc1xuICAgICAqIHNjYWxhciB2YWx1ZXMgZnJvbSB0aGVpciBzdXJyb3VuZGluZyBub2RlOyB0byBkaXNhYmxlIHNldCBga2VlcFNjYWxhcmAgdG9cbiAgICAgKiBgdHJ1ZWAgKGNvbGxlY3Rpb25zIGFyZSBhbHdheXMgcmV0dXJuZWQgaW50YWN0KS5cbiAgICAgKi9cbiAgICBnZXRJbihwYXRoLCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHJldHVybiAha2VlcFNjYWxhciAmJiBpc1NjYWxhcih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy52YWx1ZVxuICAgICAgICAgICAgICAgIDogdGhpcy5jb250ZW50cztcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmdldEluKHBhdGgsIGtlZXBTY2FsYXIpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBkb2N1bWVudCBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cykgPyB0aGlzLmNvbnRlbnRzLmhhcyhrZXkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaW5jbHVkZXMgYSB2YWx1ZSBhdCBgcGF0aGAuXG4gICAgICovXG4gICAgaGFzSW4ocGF0aCkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpID8gdGhpcy5jb250ZW50cy5oYXNJbihwYXRoKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBkb2N1bWVudC4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBjYW4ndCByZWFsbHkga25vdyB0aGF0IHRoaXMgbWF0Y2hlcyBDb250ZW50cy5cbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBjYW4ndCByZWFsbHkga25vdyB0aGF0IHRoaXMgbWF0Y2hlcyBDb250ZW50cy5cbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBBcnJheS5mcm9tKHBhdGgpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXRJbihwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBZQU1MIHZlcnNpb24gYW5kIHNjaGVtYSB1c2VkIGJ5IHRoZSBkb2N1bWVudC5cbiAgICAgKiBBIGBudWxsYCB2ZXJzaW9uIGRpc2FibGVzIHN1cHBvcnQgZm9yIGRpcmVjdGl2ZXMsIGV4cGxpY2l0IHRhZ3MsIGFuY2hvcnMsIGFuZCBhbGlhc2VzLlxuICAgICAqIEl0IGFsc28gcmVxdWlyZXMgdGhlIGBzY2hlbWFgIG9wdGlvbiB0byBiZSBnaXZlbiBhcyBhIGBTY2hlbWFgIGluc3RhbmNlIHZhbHVlLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIGFsbCBwcmV2aW91c2x5IHNldCBzY2hlbWEgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuICAgICAgICBsZXQgb3B0O1xuICAgICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbiA9ICcxLjEnO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uOiAnMS4xJyB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IHJlc29sdmVLbm93blRhZ3M6IGZhbHNlLCBzY2hlbWE6ICd5YW1sLTEuMScgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzEuMic6XG4gICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMueWFtbC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbiB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IHJlc29sdmVLbm93blRhZ3M6IHRydWUsIHNjaGVtYTogJ2NvcmUnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgICBvcHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gSlNPTi5zdHJpbmdpZnkodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAnMS4xJywgJzEuMicgb3IgbnVsbCBhcyBmaXJzdCBhcmd1bWVudCwgYnV0IGZvdW5kOiAke3N2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBgaW5zdGFuY2VvZiBTY2hlbWFgIHRvIGFsbG93IGZvciBkdWNrIHR5cGluZ1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuICAgICAgICBlbHNlIGlmIChvcHQpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG5ldyBTY2hlbWEoT2JqZWN0LmFzc2lnbihvcHQsIG9wdGlvbnMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRoIGEgbnVsbCBZQU1MIHZlcnNpb24sIHRoZSB7IHNjaGVtYTogU2NoZW1hIH0gb3B0aW9uIGlzIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIC8vIGpzb24gJiBqc29uQXJnIGFyZSBvbmx5IHVzZWQgZnJvbSB0b0pTT04oKVxuICAgIHRvSlMoeyBqc29uLCBqc29uQXJnLCBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUyh0aGlzLmNvbnRlbnRzLCBqc29uQXJnID8/ICcnLCBjdHgpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGNvdW50LCByZXMgfSBvZiBjdHguYW5jaG9ycy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICBvbkFuY2hvcihyZXMsIGNvdW50KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGBjb250ZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbkFyZyBVc2VkIGJ5IGBKU09OLnN0cmluZ2lmeWAgdG8gaW5kaWNhdGUgdGhlIGFycmF5IGluZGV4IG9yXG4gICAgICogICBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIHRvSlNPTihqc29uQXJnLCBvbkFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTKHsganNvbjogdHJ1ZSwganNvbkFyZywgbWFwQXNNYXA6IGZhbHNlLCBvbkFuY2hvciB9KTtcbiAgICB9XG4gICAgLyoqIEEgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQuICovXG4gICAgdG9TdHJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCB3aXRoIGVycm9ycyBjYW5ub3QgYmUgc3RyaW5naWZpZWQnKTtcbiAgICAgICAgaWYgKCdpbmRlbnQnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmluZGVudCkgfHwgTnVtYmVyKG9wdGlvbnMuaW5kZW50KSA8PSAwKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaW5kZW50KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJpbmRlbnRcIiBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG5vdCAke3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeURvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKGNvbnRlbnRzKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5leHBvcnQgeyBEb2N1bWVudCB9O1xuIiwgImNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxufVxuY2xhc3MgWUFNTFBhcnNlRXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFBhcnNlRXJyb3InLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIFlBTUxXYXJuaW5nIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ1lBTUxXYXJuaW5nJywgcG9zLCBjb2RlLCBtZXNzYWdlKTtcbiAgICB9XG59XG5jb25zdCBwcmV0dGlmeUVycm9yID0gKHNyYywgbGMpID0+IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5wb3NbMF0gPT09IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgZXJyb3IubGluZVBvcyA9IGVycm9yLnBvcy5tYXAocG9zID0+IGxjLmxpbmVQb3MocG9zKSk7XG4gICAgY29uc3QgeyBsaW5lLCBjb2wgfSA9IGVycm9yLmxpbmVQb3NbMF07XG4gICAgZXJyb3IubWVzc2FnZSArPSBgIGF0IGxpbmUgJHtsaW5lfSwgY29sdW1uICR7Y29sfWA7XG4gICAgbGV0IGNpID0gY29sIC0gMTtcbiAgICBsZXQgbGluZVN0ciA9IHNyY1xuICAgICAgICAuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDFdLCBsYy5saW5lU3RhcnRzW2xpbmVdKVxuICAgICAgICAucmVwbGFjZSgvW1xcblxccl0rJC8sICcnKTtcbiAgICAvLyBUcmltIHRvIG1heCA4MCBjaGFycywga2VlcGluZyBjb2wgcG9zaXRpb24gbmVhciB0aGUgbWlkZGxlXG4gICAgaWYgKGNpID49IDYwICYmIGxpbmVTdHIubGVuZ3RoID4gODApIHtcbiAgICAgICAgY29uc3QgdHJpbVN0YXJ0ID0gTWF0aC5taW4oY2kgLSAzOSwgbGluZVN0ci5sZW5ndGggLSA3OSk7XG4gICAgICAgIGxpbmVTdHIgPSAnXHUyMDI2JyArIGxpbmVTdHIuc3Vic3RyaW5nKHRyaW1TdGFydCk7XG4gICAgICAgIGNpIC09IHRyaW1TdGFydCAtIDE7XG4gICAgfVxuICAgIGlmIChsaW5lU3RyLmxlbmd0aCA+IDgwKVxuICAgICAgICBsaW5lU3RyID0gbGluZVN0ci5zdWJzdHJpbmcoMCwgNzkpICsgJ1x1MjAyNic7XG4gICAgLy8gSW5jbHVkZSBwcmV2aW91cyBsaW5lIGluIGNvbnRleHQgaWYgcG9pbnRpbmcgYXQgbGluZSBzdGFydFxuICAgIGlmIChsaW5lID4gMSAmJiAvXiAqJC8udGVzdChsaW5lU3RyLnN1YnN0cmluZygwLCBjaSkpKSB7XG4gICAgICAgIC8vIFJlZ2V4cCB3b24ndCBtYXRjaCBpZiBzdGFydCBpcyB0cmltbWVkXG4gICAgICAgIGxldCBwcmV2ID0gc3JjLnN1YnN0cmluZyhsYy5saW5lU3RhcnRzW2xpbmUgLSAyXSwgbGMubGluZVN0YXJ0c1tsaW5lIC0gMV0pO1xuICAgICAgICBpZiAocHJldi5sZW5ndGggPiA4MClcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnN1YnN0cmluZygwLCA3OSkgKyAnXHUyMDI2XFxuJztcbiAgICAgICAgbGluZVN0ciA9IHByZXYgKyBsaW5lU3RyO1xuICAgIH1cbiAgICBpZiAoL1teIF0vLnRlc3QobGluZVN0cikpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgY29uc3QgZW5kID0gZXJyb3IubGluZVBvc1sxXTtcbiAgICAgICAgaWYgKGVuZD8ubGluZSA9PT0gbGluZSAmJiBlbmQuY29sID4gY29sKSB7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGgubWluKGVuZC5jb2wgLSBjb2wsIDgwIC0gY2kpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludGVyID0gJyAnLnJlcGVhdChjaSkgKyAnXicucmVwZWF0KGNvdW50KTtcbiAgICAgICAgZXJyb3IubWVzc2FnZSArPSBgOlxcblxcbiR7bGluZVN0cn1cXG4ke3BvaW50ZXJ9XFxuYDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBZQU1MRXJyb3IsIFlBTUxQYXJzZUVycm9yLCBZQU1MV2FybmluZywgcHJldHRpZnlFcnJvciB9O1xuIiwgImZ1bmN0aW9uIHJlc29sdmVQcm9wcyh0b2tlbnMsIHsgZmxvdywgaW5kaWNhdG9yLCBuZXh0LCBvZmZzZXQsIG9uRXJyb3IsIHBhcmVudEluZGVudCwgc3RhcnRPbk5ld2xpbmUgfSkge1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCBhdE5ld2xpbmUgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgaGFzU3BhY2UgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBjb21tZW50U2VwID0gJyc7XG4gICAgbGV0IGhhc05ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgdGFiID0gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gbnVsbDtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBsZXQgbmV3bGluZUFmdGVyUHJvcCA9IG51bGw7XG4gICAgbGV0IGNvbW1hID0gbnVsbDtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGxldCBzdGFydCA9IG51bGw7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgaWYgKHJlcVNwYWNlKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3NwYWNlJyAmJlxuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgIT09ICduZXdsaW5lJyAmJlxuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgIT09ICdjb21tYScpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbi5vZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnVGFncyBhbmQgYW5jaG9ycyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIHRoZSBuZXh0IHRva2VuIGJ5IHdoaXRlIHNwYWNlJyk7XG4gICAgICAgICAgICByZXFTcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWIpIHtcbiAgICAgICAgICAgIGlmIChhdE5ld2xpbmUgJiYgdG9rZW4udHlwZSAhPT0gJ2NvbW1lbnQnICYmIHRva2VuLnR5cGUgIT09ICduZXdsaW5lJykge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodGFiLCAnVEFCX0FTX0lOREVOVCcsICdUYWJzIGFyZSBub3QgYWxsb3dlZCBhcyBpbmRlbnRhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFiID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZG9jIGxldmVsLCB0YWJzIGF0IGxpbmUgc3RhcnQgbWF5IGJlIHBhcnNlZFxuICAgICAgICAgICAgICAgIC8vIGFzIGxlYWRpbmcgd2hpdGUgc3BhY2UgcmF0aGVyIHRoYW4gaW5kZW50YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gSW4gYSBmbG93IGNvbGxlY3Rpb24sIG9ubHkgdGhlIHBhcnNlciBoYW5kbGVzIGluZGVudC5cbiAgICAgICAgICAgICAgICBpZiAoIWZsb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgKGluZGljYXRvciAhPT0gJ2RvYy1zdGFydCcgfHwgbmV4dD8udHlwZSAhPT0gJ2Zsb3ctY29sbGVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnNvdXJjZS5pbmNsdWRlcygnXFx0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFiID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNTcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSB0b2tlbi5zb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJztcbiAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjYjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY29tbWVudFNlcCArIGNiO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRTZXAgPSAnJztcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGlmIChhdE5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZvdW5kIHx8IGluZGljYXRvciAhPT0gJ3NlcS1pdGVtLWluZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudFNlcCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yIHx8IHRhZylcbiAgICAgICAgICAgICAgICAgICAgbmV3bGluZUFmdGVyUHJvcCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01VTFRJUExFX0FOQ0hPUlMnLCAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIGFuY2hvcicpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5zb3VyY2UuZW5kc1dpdGgoJzonKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbi5vZmZzZXQgKyB0b2tlbi5zb3VyY2UubGVuZ3RoIC0gMSwgJ0JBRF9BTElBUycsICdBbmNob3IgZW5kaW5nIGluIDogaXMgYW1iaWd1b3VzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gdG9rZW47XG4gICAgICAgICAgICAgICAgc3RhcnQgPz8gKHN0YXJ0ID0gdG9rZW4ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlcVNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6IHtcbiAgICAgICAgICAgICAgICBpZiAodGFnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTVVMVElQTEVfVEFHUycsICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgdGFnJyk7XG4gICAgICAgICAgICAgICAgdGFnID0gdG9rZW47XG4gICAgICAgICAgICAgICAgc3RhcnQgPz8gKHN0YXJ0ID0gdG9rZW4ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlcVNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgaW5kaWNhdG9yOlxuICAgICAgICAgICAgICAgIC8vIENvdWxkIGhlcmUgaGFuZGxlIHByZWNlZGluZyBjb21tZW50cyBkaWZmZXJlbnRseVxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgfHwgdGFnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnQkFEX1BST1BfT1JERVInLCBgQW5jaG9ycyBhbmQgdGFncyBtdXN0IGJlIGFmdGVyIHRoZSAke3Rva2VuLnNvdXJjZX0gaW5kaWNhdG9yYCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dG9rZW4uc291cmNlfSBpbiAke2Zsb3cgPz8gJ2NvbGxlY3Rpb24nfWApO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID1cbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yID09PSAnc2VxLWl0ZW0taW5kJyB8fCBpbmRpY2F0b3IgPT09ICdleHBsaWNpdC1rZXktaW5kJztcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGlmIChmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2Zsb3d9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi50eXBlfSB0b2tlbmApO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZW5kID0gbGFzdCA/IGxhc3Qub2Zmc2V0ICsgbGFzdC5zb3VyY2UubGVuZ3RoIDogb2Zmc2V0O1xuICAgIGlmIChyZXFTcGFjZSAmJlxuICAgICAgICBuZXh0ICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ3NwYWNlJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICduZXdsaW5lJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdjb21tYScgJiZcbiAgICAgICAgKG5leHQudHlwZSAhPT0gJ3NjYWxhcicgfHwgbmV4dC5zb3VyY2UgIT09ICcnKSkge1xuICAgICAgICBvbkVycm9yKG5leHQub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgIH1cbiAgICBpZiAodGFiICYmXG4gICAgICAgICgoYXROZXdsaW5lICYmIHRhYi5pbmRlbnQgPD0gcGFyZW50SW5kZW50KSB8fFxuICAgICAgICAgICAgbmV4dD8udHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHxcbiAgICAgICAgICAgIG5leHQ/LnR5cGUgPT09ICdibG9jay1zZXEnKSlcbiAgICAgICAgb25FcnJvcih0YWIsICdUQUJfQVNfSU5ERU5UJywgJ1RhYnMgYXJlIG5vdCBhbGxvd2VkIGFzIGluZGVudGF0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWEsXG4gICAgICAgIGZvdW5kLFxuICAgICAgICBzcGFjZUJlZm9yZSxcbiAgICAgICAgY29tbWVudCxcbiAgICAgICAgaGFzTmV3bGluZSxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICB0YWcsXG4gICAgICAgIG5ld2xpbmVBZnRlclByb3AsXG4gICAgICAgIGVuZCxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0ID8/IGVuZFxuICAgIH07XG59XG5cbmV4cG9ydCB7IHJlc29sdmVQcm9wcyB9O1xuIiwgImZ1bmN0aW9uIGNvbnRhaW5zTmV3bGluZShrZXkpIHtcbiAgICBpZiAoIWtleSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgaWYgKGtleS5zb3VyY2UuaW5jbHVkZXMoJ1xcbicpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGtleS5lbmQpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBrZXkuZW5kKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIGtleS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgaXQuc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zTmV3bGluZShpdC5rZXkpIHx8IGNvbnRhaW5zTmV3bGluZShpdC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgeyBjb250YWluc05ld2xpbmUgfTtcbiIsICJpbXBvcnQgeyBjb250YWluc05ld2xpbmUgfSBmcm9tICcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyc7XG5cbmZ1bmN0aW9uIGZsb3dJbmRlbnRDaGVjayhpbmRlbnQsIGZjLCBvbkVycm9yKSB7XG4gICAgaWYgKGZjPy50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJykge1xuICAgICAgICBjb25zdCBlbmQgPSBmYy5lbmRbMF07XG4gICAgICAgIGlmIChlbmQuaW5kZW50ID09PSBpbmRlbnQgJiZcbiAgICAgICAgICAgIChlbmQuc291cmNlID09PSAnXScgfHwgZW5kLnNvdXJjZSA9PT0gJ30nKSAmJlxuICAgICAgICAgICAgY29udGFpbnNOZXdsaW5lKGZjKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ0Zsb3cgZW5kIGluZGljYXRvciBzaG91bGQgYmUgbW9yZSBpbmRlbnRlZCB0aGFuIHBhcmVudCc7XG4gICAgICAgICAgICBvbkVycm9yKGVuZCwgJ0JBRF9JTkRFTlQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBmbG93SW5kZW50Q2hlY2sgfTtcbiIsICJpbXBvcnQgeyBpc1NjYWxhciB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcblxuZnVuY3Rpb24gbWFwSW5jbHVkZXMoY3R4LCBpdGVtcywgc2VhcmNoKSB7XG4gICAgY29uc3QgeyB1bmlxdWVLZXlzIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAodW5pcXVlS2V5cyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0VxdWFsID0gdHlwZW9mIHVuaXF1ZUtleXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB1bmlxdWVLZXlzXG4gICAgICAgIDogKGEsIGIpID0+IGEgPT09IGIgfHwgKGlzU2NhbGFyKGEpICYmIGlzU2NhbGFyKGIpICYmIGEudmFsdWUgPT09IGIudmFsdWUpO1xuICAgIHJldHVybiBpdGVtcy5zb21lKHBhaXIgPT4gaXNFcXVhbChwYWlyLmtleSwgc2VhcmNoKSk7XG59XG5cbmV4cG9ydCB7IG1hcEluY2x1ZGVzIH07XG4iLCAiaW1wb3J0IHsgUGFpciB9IGZyb20gJy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcbmltcG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9IGZyb20gJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJztcbmltcG9ydCB7IGZsb3dJbmRlbnRDaGVjayB9IGZyb20gJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcyc7XG5pbXBvcnQgeyBtYXBJbmNsdWRlcyB9IGZyb20gJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnO1xuXG5jb25zdCBzdGFydENvbE1zZyA9ICdBbGwgbWFwcGluZyBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbic7XG5mdW5jdGlvbiByZXNvbHZlQmxvY2tNYXAoeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGJtLCBvbkVycm9yLCB0YWcpIHtcbiAgICBjb25zdCBOb2RlQ2xhc3MgPSB0YWc/Lm5vZGVDbGFzcyA/PyBZQU1MTWFwO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBOb2RlQ2xhc3MoY3R4LnNjaGVtYSk7XG4gICAgaWYgKGN0eC5hdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gYm0ub2Zmc2V0O1xuICAgIGxldCBjb21tZW50RW5kID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNvbGxJdGVtIG9mIGJtLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9ID0gY29sbEl0ZW07XG4gICAgICAgIC8vIGtleSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGtleVByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdleHBsaWNpdC1rZXktaW5kJyxcbiAgICAgICAgICAgIG5leHQ6IGtleSA/PyBzZXA/LlswXSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGJtLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbXBsaWNpdEtleSA9ICFrZXlQcm9wcy5mb3VuZDtcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCTE9DS19BU19JTVBMSUNJVF9LRVknLCAnQSBibG9jayBzZXF1ZW5jZSBtYXkgbm90IGJlIHVzZWQgYXMgYW4gaW1wbGljaXQgbWFwIGtleScpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdpbmRlbnQnIGluIGtleSAmJiBrZXkuaW5kZW50ICE9PSBibS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2V5UHJvcHMuYW5jaG9yICYmICFrZXlQcm9wcy50YWcgJiYgIXNlcCkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnRFbmQgPSBrZXlQcm9wcy5lbmQ7XG4gICAgICAgICAgICAgICAgaWYgKGtleVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgKz0gJ1xcbicgKyBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuY29tbWVudCA9IGtleVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleVByb3BzLm5ld2xpbmVBZnRlclByb3AgfHwgY29udGFpbnNOZXdsaW5lKGtleSkpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSA/PyBzdGFydFtzdGFydC5sZW5ndGggLSAxXSwgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlQcm9wcy5mb3VuZD8uaW5kZW50ICE9PSBibS5pbmRlbnQpIHtcbiAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZXkgdmFsdWVcbiAgICAgICAgY3R4LmF0S2V5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBrZXlQcm9wcy5lbmQ7XG4gICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCBrZXksIGtleVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBrZXlQcm9wcywgb25FcnJvcik7XG4gICAgICAgIGlmIChjdHguc2NoZW1hLmNvbXBhdClcbiAgICAgICAgICAgIGZsb3dJbmRlbnRDaGVjayhibS5pbmRlbnQsIGtleSwgb25FcnJvcik7XG4gICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgICAgICBpZiAobWFwSW5jbHVkZXMoY3R4LCBtYXAuaXRlbXMsIGtleU5vZGUpKVxuICAgICAgICAgICAgb25FcnJvcihrZXlTdGFydCwgJ0RVUExJQ0FURV9LRVknLCAnTWFwIGtleXMgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgLy8gdmFsdWUgcHJvcGVydGllc1xuICAgICAgICBjb25zdCB2YWx1ZVByb3BzID0gcmVzb2x2ZVByb3BzKHNlcCA/PyBbXSwge1xuICAgICAgICAgICAgaW5kaWNhdG9yOiAnbWFwLXZhbHVlLWluZCcsXG4gICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgIG9mZnNldDoga2V5Tm9kZS5yYW5nZVsyXSxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGJtLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiAha2V5IHx8IGtleS50eXBlID09PSAnYmxvY2stc2NhbGFyJ1xuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ID0gdmFsdWVQcm9wcy5lbmQ7XG4gICAgICAgIGlmICh2YWx1ZVByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWU/LnR5cGUgPT09ICdibG9jay1tYXAnICYmICF2YWx1ZVByb3BzLmhhc05ld2xpbmUpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkxPQ0tfQVNfSU1QTElDSVRfS0VZJywgJ05lc3RlZCBtYXBwaW5ncyBhcmUgbm90IGFsbG93ZWQgaW4gY29tcGFjdCBtYXBwaW5ncycpO1xuICAgICAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5zdHJpY3QgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5UHJvcHMuc3RhcnQgPCB2YWx1ZVByb3BzLmZvdW5kLm9mZnNldCAtIDEwMjQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ0tFWV9PVkVSXzEwMjRfQ0hBUlMnLCAnVGhlIDogaW5kaWNhdG9yIG11c3QgYmUgYXQgbW9zdCAxMDI0IGNoYXJzIGFmdGVyIHRoZSBzdGFydCBvZiBhbiBpbXBsaWNpdCBibG9jayBtYXBwaW5nIGtleScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsdWUgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCB2YWx1ZVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIG9mZnNldCwgc2VwLCBudWxsLCB2YWx1ZVByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChjdHguc2NoZW1hLmNvbXBhdClcbiAgICAgICAgICAgICAgICBmbG93SW5kZW50Q2hlY2soYm0uaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUucmFuZ2VbMl07XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIoa2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8ga2V5IHdpdGggbm8gdmFsdWVcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdNSVNTSU5HX0NIQVInLCAnSW1wbGljaXQgbWFwIGtleXMgbmVlZCB0byBiZSBmb2xsb3dlZCBieSBtYXAgdmFsdWVzJyk7XG4gICAgICAgICAgICBpZiAodmFsdWVQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5vZGUuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ICs9ICdcXG4nICsgdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ID0gdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnRFbmQgJiYgY29tbWVudEVuZCA8IG9mZnNldClcbiAgICAgICAgb25FcnJvcihjb21tZW50RW5kLCAnSU1QT1NTSUJMRScsICdNYXAgY29tbWVudCB3aXRoIHRyYWlsaW5nIGNvbnRlbnQnKTtcbiAgICBtYXAucmFuZ2UgPSBbYm0ub2Zmc2V0LCBvZmZzZXQsIGNvbW1lbnRFbmQgPz8gb2Zmc2V0XTtcbiAgICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfTtcbiIsICJpbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2VxKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBicywgb25FcnJvciwgdGFnKSB7XG4gICAgY29uc3QgTm9kZUNsYXNzID0gdGFnPy5ub2RlQ2xhc3MgPz8gWUFNTFNlcTtcbiAgICBjb25zdCBzZXEgPSBuZXcgTm9kZUNsYXNzKGN0eC5zY2hlbWEpO1xuICAgIGlmIChjdHguYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgaWYgKGN0eC5hdEtleSlcbiAgICAgICAgY3R4LmF0S2V5ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGJzLm9mZnNldDtcbiAgICBsZXQgY29tbWVudEVuZCA9IG51bGw7XG4gICAgZm9yIChjb25zdCB7IHN0YXJ0LCB2YWx1ZSB9IG9mIGJzLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdzZXEtaXRlbS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBicy5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmFuY2hvciB8fCBwcm9wcy50YWcgfHwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWU/LnR5cGUgPT09ICdibG9jay1zZXEnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmVuZCwgJ0JBRF9JTkRFTlQnLCAnQWxsIHNlcXVlbmNlIGl0ZW1zIG11c3Qgc3RhcnQgYXQgdGhlIHNhbWUgY29sdW1uJyk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdTZXF1ZW5jZSBpdGVtIHdpdGhvdXQgLSBpbmRpY2F0b3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1lbnRFbmQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5jb21tZW50ID0gcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gdmFsdWVcbiAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBwcm9wcy5lbmQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgIGlmIChjdHguc2NoZW1hLmNvbXBhdClcbiAgICAgICAgICAgIGZsb3dJbmRlbnRDaGVjayhicy5pbmRlbnQsIHZhbHVlLCBvbkVycm9yKTtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5yYW5nZVsyXTtcbiAgICAgICAgc2VxLml0ZW1zLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIHNlcS5yYW5nZSA9IFticy5vZmZzZXQsIG9mZnNldCwgY29tbWVudEVuZCA/PyBvZmZzZXRdO1xuICAgIHJldHVybiBzZXE7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVCbG9ja1NlcSB9O1xuIiwgImZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBvZmZzZXQsIHJlcVNwYWNlLCBvbkVycm9yKSB7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGxldCBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VwID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdHlwZSB9ID0gdG9rZW47XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcVNwYWNlICYmICFoYXNTcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gc2VwICsgY2I7XG4gICAgICAgICAgICAgICAgICAgIHNlcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VwICs9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dHlwZX0gYXQgbm9kZSBlbmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbW1lbnQsIG9mZnNldCB9O1xufVxuXG5leHBvcnQgeyByZXNvbHZlRW5kIH07XG4iLCAiaW1wb3J0IHsgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgUGFpciB9IGZyb20gJy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcbmltcG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9IGZyb20gJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJztcbmltcG9ydCB7IG1hcEluY2x1ZGVzIH0gZnJvbSAnLi91dGlsLW1hcC1pbmNsdWRlcy5qcyc7XG5cbmNvbnN0IGJsb2NrTXNnID0gJ0Jsb2NrIGNvbGxlY3Rpb25zIGFyZSBub3QgYWxsb3dlZCB3aXRoaW4gZmxvdyBjb2xsZWN0aW9ucyc7XG5jb25zdCBpc0Jsb2NrID0gKHRva2VuKSA9PiB0b2tlbiAmJiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHwgdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcScpO1xuZnVuY3Rpb24gcmVzb2x2ZUZsb3dDb2xsZWN0aW9uKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBmYywgb25FcnJvciwgdGFnKSB7XG4gICAgY29uc3QgaXNNYXAgPSBmYy5zdGFydC5zb3VyY2UgPT09ICd7JztcbiAgICBjb25zdCBmY05hbWUgPSBpc01hcCA/ICdmbG93IG1hcCcgOiAnZmxvdyBzZXF1ZW5jZSc7XG4gICAgY29uc3QgTm9kZUNsYXNzID0gKHRhZz8ubm9kZUNsYXNzID8/IChpc01hcCA/IFlBTUxNYXAgOiBZQU1MU2VxKSk7XG4gICAgY29uc3QgY29sbCA9IG5ldyBOb2RlQ2xhc3MoY3R4LnNjaGVtYSk7XG4gICAgY29sbC5mbG93ID0gdHJ1ZTtcbiAgICBjb25zdCBhdFJvb3QgPSBjdHguYXRSb290O1xuICAgIGlmIChhdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBpZiAoY3R4LmF0S2V5KVxuICAgICAgICBjdHguYXRLZXkgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gZmMub2Zmc2V0ICsgZmMuc3RhcnQuc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZjLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvbGxJdGVtID0gZmMuaXRlbXNbaV07XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9ID0gY29sbEl0ZW07XG4gICAgICAgIGNvbnN0IHByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBmbG93OiBmY05hbWUsXG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdleHBsaWNpdC1rZXktaW5kJyxcbiAgICAgICAgICAgIG5leHQ6IGtleSA/PyBzZXA/LlswXSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGZjLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5hbmNob3IgJiYgIXByb3BzLnRhZyAmJiAhc2VwICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IGZjLml0ZW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgZW1wdHkgaXRlbSBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01hcCAmJiBjdHgub3B0aW9ucy5zdHJpY3QgJiYgY29udGFpbnNOZXdsaW5lKGtleSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXksIC8vIGNoZWNrZWQgYnkgY29udGFpbnNOZXdsaW5lKClcbiAgICAgICAgICAgICAgICAnTVVMVElMSU5FX0lNUExJQ0lUX0tFWScsICdJbXBsaWNpdCBrZXlzIG9mIGZsb3cgc2VxdWVuY2UgcGFpcnMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tYSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyAsIGJldHdlZW4gJHtmY05hbWV9IGl0ZW1zYCk7XG4gICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2SXRlbUNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICBsb29wOiBmb3IgKGNvbnN0IHN0IG9mIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkl0ZW1Db21tZW50ID0gc3Quc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2SXRlbUNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSBjb2xsLml0ZW1zW2NvbGwuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhaXIocHJldikpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi52YWx1ZSA/PyBwcmV2LmtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuY29tbWVudCArPSAnXFxuJyArIHByZXZJdGVtQ29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ID0gcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb21tZW50ID0gcHJvcHMuY29tbWVudC5zdWJzdHJpbmcocHJldkl0ZW1Db21tZW50Lmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTWFwICYmICFzZXAgJiYgIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIGEgdmFsdWUgaW4gYSBzZXFcbiAgICAgICAgICAgIC8vIFx1MjE5MiBrZXkgJiBzZXAgYXJlIGVtcHR5LCBzdGFydCBkb2VzIG5vdCBpbmNsdWRlID8gb3IgOlxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc2VwLCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBjb2xsLml0ZW1zLnB1c2godmFsdWVOb2RlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZS5yYW5nZVsyXTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKHZhbHVlKSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlTm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIGEga2V5K3ZhbHVlIHBhaXJcbiAgICAgICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICAgICAgY3R4LmF0S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleVN0YXJ0ID0gcHJvcHMuZW5kO1xuICAgICAgICAgICAgY29uc3Qga2V5Tm9kZSA9IGtleVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCBrZXksIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIGtleVN0YXJ0LCBzdGFydCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2soa2V5KSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdCTE9DS19JTl9GTE9XJywgYmxvY2tNc2cpO1xuICAgICAgICAgICAgY3R4LmF0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCB2YWx1ZVByb3BzID0gcmVzb2x2ZVByb3BzKHNlcCA/PyBbXSwge1xuICAgICAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3I6ICdtYXAtdmFsdWUtaW5kJyxcbiAgICAgICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGZjLmluZGVudCxcbiAgICAgICAgICAgICAgICBzdGFydE9uTmV3bGluZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWFwICYmICFwcm9wcy5mb3VuZCAmJiBjdHgub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Ygc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ID09PSB2YWx1ZVByb3BzLmZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioc3QsICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuc3RhcnQgPCB2YWx1ZVByb3BzLmZvdW5kLm9mZnNldCAtIDEwMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuZm91bmQsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgZmxvdyBzZXF1ZW5jZSBrZXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc291cmNlJyBpbiB2YWx1ZSAmJiB2YWx1ZS5zb3VyY2U/LlswXSA9PT0gJzonKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlLCAnTUlTU0lOR19DSEFSJywgYE1pc3Npbmcgc3BhY2UgYWZ0ZXIgOiBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVQcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgb3IgOiBiZXR3ZWVuICR7ZmNOYW1lfSBpdGVtc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsdWUgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCB2YWx1ZVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogdmFsdWVQcm9wcy5mb3VuZFxuICAgICAgICAgICAgICAgICAgICA/IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCB2YWx1ZVByb3BzLmVuZCwgc2VwLCBudWxsLCB2YWx1ZVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlTm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIoa2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIGlmIChpc01hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IGNvbGw7XG4gICAgICAgICAgICAgICAgaWYgKG1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihrZXlTdGFydCwgJ0RVUExJQ0FURV9LRVknLCAnTWFwIGtleXMgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBZQU1MTWFwKGN0eC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIG1hcC5mbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRSYW5nZSA9ICh2YWx1ZU5vZGUgPz8ga2V5Tm9kZSkucmFuZ2U7XG4gICAgICAgICAgICAgICAgbWFwLnJhbmdlID0gW2tleU5vZGUucmFuZ2VbMF0sIGVuZFJhbmdlWzFdLCBlbmRSYW5nZVsyXV07XG4gICAgICAgICAgICAgICAgY29sbC5pdGVtcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUgPyB2YWx1ZU5vZGUucmFuZ2VbMl0gOiB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZEVuZCA9IGlzTWFwID8gJ30nIDogJ10nO1xuICAgIGNvbnN0IFtjZSwgLi4uZWVdID0gZmMuZW5kO1xuICAgIGxldCBjZVBvcyA9IG9mZnNldDtcbiAgICBpZiAoY2U/LnNvdXJjZSA9PT0gZXhwZWN0ZWRFbmQpXG4gICAgICAgIGNlUG9zID0gY2Uub2Zmc2V0ICsgY2Uuc291cmNlLmxlbmd0aDtcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZjTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgZmNOYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3QgbXNnID0gYXRSb290XG4gICAgICAgICAgICA/IGAke25hbWV9IG11c3QgZW5kIHdpdGggYSAke2V4cGVjdGVkRW5kfWBcbiAgICAgICAgICAgIDogYCR7bmFtZX0gaW4gYmxvY2sgY29sbGVjdGlvbiBtdXN0IGJlIHN1ZmZpY2llbnRseSBpbmRlbnRlZCBhbmQgZW5kIHdpdGggYSAke2V4cGVjdGVkRW5kfWA7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0LCBhdFJvb3QgPyAnTUlTU0lOR19DSEFSJyA6ICdCQURfSU5ERU5UJywgbXNnKTtcbiAgICAgICAgaWYgKGNlICYmIGNlLnNvdXJjZS5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICBlZS51bnNoaWZ0KGNlKTtcbiAgICB9XG4gICAgaWYgKGVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZW5kID0gcmVzb2x2ZUVuZChlZSwgY2VQb3MsIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgICAgIGlmIChlbmQuY29tbWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbGwuY29tbWVudClcbiAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgKz0gJ1xcbicgKyBlbmQuY29tbWVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgPSBlbmQuY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb2xsLnJhbmdlID0gW2ZjLm9mZnNldCwgY2VQb3MsIGVuZC5vZmZzZXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29sbC5yYW5nZSA9IFtmYy5vZmZzZXQsIGNlUG9zLCBjZVBvc107XG4gICAgfVxuICAgIHJldHVybiBjb2xsO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRmxvd0NvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUJsb2NrTWFwIH0gZnJvbSAnLi9yZXNvbHZlLWJsb2NrLW1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tTZXEgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stc2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93Q29sbGVjdGlvbiB9IGZyb20gJy4vcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnTmFtZSwgdGFnKSB7XG4gICAgY29uc3QgY29sbCA9IHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnXG4gICAgICAgID8gcmVzb2x2ZUJsb2NrTWFwKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWcpXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcSdcbiAgICAgICAgICAgID8gcmVzb2x2ZUJsb2NrU2VxKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWcpXG4gICAgICAgICAgICA6IHJlc29sdmVGbG93Q29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnKTtcbiAgICBjb25zdCBDb2xsID0gY29sbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBJZiB3ZSBnb3QgYSB0YWdOYW1lIG1hdGNoaW5nIHRoZSBjbGFzcywgb3IgdGhlIHRhZyBuYW1lIGlzICchJyxcbiAgICAvLyB0aGVuIHVzZSB0aGUgdGFnTmFtZSBmcm9tIHRoZSBub2RlIGNsYXNzIHVzZWQgdG8gY3JlYXRlIGl0LlxuICAgIGlmICh0YWdOYW1lID09PSAnIScgfHwgdGFnTmFtZSA9PT0gQ29sbC50YWdOYW1lKSB7XG4gICAgICAgIGNvbGwudGFnID0gQ29sbC50YWdOYW1lO1xuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB9XG4gICAgaWYgKHRhZ05hbWUpXG4gICAgICAgIGNvbGwudGFnID0gdGFnTmFtZTtcbiAgICByZXR1cm4gY29sbDtcbn1cbmZ1bmN0aW9uIGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBwcm9wcywgb25FcnJvcikge1xuICAgIGNvbnN0IHRhZ1Rva2VuID0gcHJvcHMudGFnO1xuICAgIGNvbnN0IHRhZ05hbWUgPSAhdGFnVG9rZW5cbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogY3R4LmRpcmVjdGl2ZXMudGFnTmFtZSh0YWdUb2tlbi5zb3VyY2UsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSk7XG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKSB7XG4gICAgICAgIGNvbnN0IHsgYW5jaG9yLCBuZXdsaW5lQWZ0ZXJQcm9wOiBubCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGxhc3RQcm9wID0gYW5jaG9yICYmIHRhZ1Rva2VuXG4gICAgICAgICAgICA/IGFuY2hvci5vZmZzZXQgPiB0YWdUb2tlbi5vZmZzZXRcbiAgICAgICAgICAgICAgICA/IGFuY2hvclxuICAgICAgICAgICAgICAgIDogdGFnVG9rZW5cbiAgICAgICAgICAgIDogKGFuY2hvciA/PyB0YWdUb2tlbik7XG4gICAgICAgIGlmIChsYXN0UHJvcCAmJiAoIW5sIHx8IG5sLm9mZnNldCA8IGxhc3RQcm9wLm9mZnNldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBuZXdsaW5lIGFmdGVyIGJsb2NrIHNlcXVlbmNlIHByb3BzJztcbiAgICAgICAgICAgIG9uRXJyb3IobGFzdFByb3AsICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBUeXBlID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLW1hcCdcbiAgICAgICAgPyAnbWFwJ1xuICAgICAgICA6IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnXG4gICAgICAgICAgICA/ICdzZXEnXG4gICAgICAgICAgICA6IHRva2VuLnN0YXJ0LnNvdXJjZSA9PT0gJ3snXG4gICAgICAgICAgICAgICAgPyAnbWFwJ1xuICAgICAgICAgICAgICAgIDogJ3NlcSc7XG4gICAgLy8gc2hvcnRjdXQ6IGNoZWNrIGlmIGl0J3MgYSBnZW5lcmljIFlBTUxNYXAgb3IgWUFNTFNlcVxuICAgIC8vIGJlZm9yZSBqdW1waW5nIGludG8gdGhlIGN1c3RvbSB0YWcgbG9naWMuXG4gICAgaWYgKCF0YWdUb2tlbiB8fFxuICAgICAgICAhdGFnTmFtZSB8fFxuICAgICAgICB0YWdOYW1lID09PSAnIScgfHxcbiAgICAgICAgKHRhZ05hbWUgPT09IFlBTUxNYXAudGFnTmFtZSAmJiBleHBUeXBlID09PSAnbWFwJykgfHxcbiAgICAgICAgKHRhZ05hbWUgPT09IFlBTUxTZXEudGFnTmFtZSAmJiBleHBUeXBlID09PSAnc2VxJykpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lKTtcbiAgICB9XG4gICAgbGV0IHRhZyA9IGN0eC5zY2hlbWEudGFncy5maW5kKHQgPT4gdC50YWcgPT09IHRhZ05hbWUgJiYgdC5jb2xsZWN0aW9uID09PSBleHBUeXBlKTtcbiAgICBpZiAoIXRhZykge1xuICAgICAgICBjb25zdCBrdCA9IGN0eC5zY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgICAgICBpZiAoa3Q/LmNvbGxlY3Rpb24gPT09IGV4cFR5cGUpIHtcbiAgICAgICAgICAgIGN0eC5zY2hlbWEudGFncy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGt0LCB7IGRlZmF1bHQ6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgIHRhZyA9IGt0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGt0KSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0YWdUb2tlbiwgJ0JBRF9DT0xMRUNUSU9OX1RZUEUnLCBgJHtrdC50YWd9IHVzZWQgZm9yICR7ZXhwVHlwZX0gY29sbGVjdGlvbiwgYnV0IGV4cGVjdHMgJHtrdC5jb2xsZWN0aW9uID8/ICdzY2FsYXInfWAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIGBVbnJlc29sdmVkIHRhZzogJHt0YWdOYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb2xsID0gcmVzb2x2ZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZ05hbWUsIHRhZyk7XG4gICAgY29uc3QgcmVzID0gdGFnLnJlc29sdmU/Lihjb2xsLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKSA/PyBjb2xsO1xuICAgIGNvbnN0IG5vZGUgPSBpc05vZGUocmVzKVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICBub2RlLnJhbmdlID0gY29sbC5yYW5nZTtcbiAgICBub2RlLnRhZyA9IHRhZ05hbWU7XG4gICAgaWYgKHRhZz8uZm9ybWF0KVxuICAgICAgICBub2RlLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VDb2xsZWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2NhbGFyKGN0eCwgc2NhbGFyLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzY2FsYXIub2Zmc2V0O1xuICAgIGNvbnN0IGhlYWRlciA9IHBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoc2NhbGFyLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgIGlmICghaGVhZGVyKVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogJycsIHR5cGU6IG51bGwsIGNvbW1lbnQ6ICcnLCByYW5nZTogW3N0YXJ0LCBzdGFydCwgc3RhcnRdIH07XG4gICAgY29uc3QgdHlwZSA9IGhlYWRlci5tb2RlID09PSAnPicgPyBTY2FsYXIuQkxPQ0tfRk9MREVEIDogU2NhbGFyLkJMT0NLX0xJVEVSQUw7XG4gICAgY29uc3QgbGluZXMgPSBzY2FsYXIuc291cmNlID8gc3BsaXRMaW5lcyhzY2FsYXIuc291cmNlKSA6IFtdO1xuICAgIC8vIGRldGVybWluZSB0aGUgZW5kIG9mIGNvbnRlbnQgJiBzdGFydCBvZiBjaG9tcGluZ1xuICAgIGxldCBjaG9tcFN0YXJ0ID0gbGluZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbGluZXNbaV1bMV07XG4gICAgICAgIGlmIChjb250ZW50ID09PSAnJyB8fCBjb250ZW50ID09PSAnXFxyJylcbiAgICAgICAgICAgIGNob21wU3RhcnQgPSBpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gc2hvcnRjdXQgZm9yIGVtcHR5IGNvbnRlbnRzXG4gICAgaWYgKGNob21wU3RhcnQgPT09IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuY2hvbXAgPT09ICcrJyAmJiBsaW5lcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/ICdcXG4nLnJlcGVhdChNYXRoLm1heCgxLCBsaW5lcy5sZW5ndGggLSAxKSlcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCArIGhlYWRlci5sZW5ndGg7XG4gICAgICAgIGlmIChzY2FsYXIuc291cmNlKVxuICAgICAgICAgICAgZW5kICs9IHNjYWxhci5zb3VyY2UubGVuZ3RoO1xuICAgICAgICByZXR1cm4geyB2YWx1ZSwgdHlwZSwgY29tbWVudDogaGVhZGVyLmNvbW1lbnQsIHJhbmdlOiBbc3RhcnQsIGVuZCwgZW5kXSB9O1xuICAgIH1cbiAgICAvLyBmaW5kIHRoZSBpbmRlbnRhdGlvbiBsZXZlbCB0byB0cmltIGZyb20gc3RhcnRcbiAgICBsZXQgdHJpbUluZGVudCA9IHNjYWxhci5pbmRlbnQgKyBoZWFkZXIuaW5kZW50O1xuICAgIGxldCBvZmZzZXQgPSBzY2FsYXIub2Zmc2V0ICsgaGVhZGVyLmxlbmd0aDtcbiAgICBsZXQgY29udGVudFN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNob21wU3RhcnQ7ICsraSkge1xuICAgICAgICBjb25zdCBbaW5kZW50LCBjb250ZW50XSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXIuaW5kZW50ID09PSAwICYmIGluZGVudC5sZW5ndGggPiB0cmltSW5kZW50KVxuICAgICAgICAgICAgICAgIHRyaW1JbmRlbnQgPSBpbmRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluZGVudC5sZW5ndGggPCB0cmltSW5kZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdCbG9jayBzY2FsYXJzIHdpdGggbW9yZS1pbmRlbnRlZCBsZWFkaW5nIGVtcHR5IGxpbmVzIG11c3QgdXNlIGFuIGV4cGxpY2l0IGluZGVudGF0aW9uIGluZGljYXRvcic7XG4gICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQgKyBpbmRlbnQubGVuZ3RoLCAnTUlTU0lOR19DSEFSJywgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRlbnRTdGFydCA9IGk7XG4gICAgICAgICAgICBpZiAodHJpbUluZGVudCA9PT0gMCAmJiAhY3R4LmF0Um9vdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFyIHZhbHVlcyBpbiBjb2xsZWN0aW9ucyBtdXN0IGJlIGluZGVudGVkJztcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9JTkRFTlQnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBpbmRlbnQubGVuZ3RoICsgY29udGVudC5sZW5ndGggKyAxO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIHRyYWlsaW5nIG1vcmUtaW5kZW50ZWQgZW1wdHkgbGluZXMgaW4gY29udGVudFxuICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IGNob21wU3RhcnQ7IC0taSkge1xuICAgICAgICBpZiAobGluZXNbaV1bMF0ubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgIGNob21wU3RhcnQgPSBpICsgMTtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gJyc7XG4gICAgbGV0IHNlcCA9ICcnO1xuICAgIGxldCBwcmV2TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgLy8gbGVhZGluZyB3aGl0ZXNwYWNlIGlzIGtlcHQgaW50YWN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50U3RhcnQ7ICsraSlcbiAgICAgICAgdmFsdWUgKz0gbGluZXNbaV1bMF0uc2xpY2UodHJpbUluZGVudCkgKyAnXFxuJztcbiAgICBmb3IgKGxldCBpID0gY29udGVudFN0YXJ0OyBpIDwgY2hvbXBTdGFydDsgKytpKSB7XG4gICAgICAgIGxldCBbaW5kZW50LCBjb250ZW50XSA9IGxpbmVzW2ldO1xuICAgICAgICBvZmZzZXQgKz0gaW5kZW50Lmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICAgICAgY29uc3QgY3JsZiA9IGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9PT0gJ1xccic7XG4gICAgICAgIGlmIChjcmxmKVxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMCwgLTEpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgYWxyZWFkeSBjYXVnaHQgaW4gbGV4ZXIgKi9cbiAgICAgICAgaWYgKGNvbnRlbnQgJiYgaW5kZW50Lmxlbmd0aCA8IHRyaW1JbmRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IGhlYWRlci5pbmRlbnRcbiAgICAgICAgICAgICAgICA/ICdleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InXG4gICAgICAgICAgICAgICAgOiAnZmlyc3QgbGluZSc7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEJsb2NrIHNjYWxhciBsaW5lcyBtdXN0IG5vdCBiZSBsZXNzIGluZGVudGVkIHRoYW4gdGhlaXIgJHtzcmN9YDtcbiAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0IC0gY29udGVudC5sZW5ndGggLSAoY3JsZiA/IDIgOiAxKSwgJ0JBRF9JTkRFTlQnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIGluZGVudCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gc2VwICsgaW5kZW50LnNsaWNlKHRyaW1JbmRlbnQpICsgY29udGVudDtcbiAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGVudC5sZW5ndGggPiB0cmltSW5kZW50IHx8IGNvbnRlbnRbMF0gPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAvLyBtb3JlLWluZGVudGVkIGNvbnRlbnQgd2l0aGluIGEgZm9sZGVkIGJsb2NrXG4gICAgICAgICAgICBpZiAoc2VwID09PSAnICcpXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgICAgICBlbHNlIGlmICghcHJldk1vcmVJbmRlbnRlZCAmJiBzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG5cXG4nO1xuICAgICAgICAgICAgdmFsdWUgKz0gc2VwICsgaW5kZW50LnNsaWNlKHRyaW1JbmRlbnQpICsgY29udGVudDtcbiAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IGxpbmVcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gc2VwICsgY29udGVudDtcbiAgICAgICAgICAgIHNlcCA9ICcgJztcbiAgICAgICAgICAgIHByZXZNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKGhlYWRlci5jaG9tcCkge1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjaG9tcFN0YXJ0OyBpIDwgbGluZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbicgKyBsaW5lc1tpXVswXS5zbGljZSh0cmltSW5kZW50KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgIH1cbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGhlYWRlci5sZW5ndGggKyBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICByZXR1cm4geyB2YWx1ZSwgdHlwZSwgY29tbWVudDogaGVhZGVyLmNvbW1lbnQsIHJhbmdlOiBbc3RhcnQsIGVuZCwgZW5kXSB9O1xufVxuZnVuY3Rpb24gcGFyc2VCbG9ja1NjYWxhckhlYWRlcih7IG9mZnNldCwgcHJvcHMgfSwgc3RyaWN0LCBvbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgaWYgKHByb3BzWzBdLnR5cGUgIT09ICdibG9jay1zY2FsYXItaGVhZGVyJykge1xuICAgICAgICBvbkVycm9yKHByb3BzWzBdLCAnSU1QT1NTSUJMRScsICdCbG9jayBzY2FsYXIgaGVhZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBzb3VyY2UgfSA9IHByb3BzWzBdO1xuICAgIGNvbnN0IG1vZGUgPSBzb3VyY2VbMF07XG4gICAgbGV0IGluZGVudCA9IDA7XG4gICAgbGV0IGNob21wID0gJyc7XG4gICAgbGV0IGVycm9yID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2ggPSBzb3VyY2VbaV07XG4gICAgICAgIGlmICghY2hvbXAgJiYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykpXG4gICAgICAgICAgICBjaG9tcCA9IGNoO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBOdW1iZXIoY2gpO1xuICAgICAgICAgICAgaWYgKCFpbmRlbnQgJiYgbilcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBuO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09IC0xKVxuICAgICAgICAgICAgICAgIGVycm9yID0gb2Zmc2V0ICsgaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3IgIT09IC0xKVxuICAgICAgICBvbkVycm9yKGVycm9yLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBCbG9jayBzY2FsYXIgaGVhZGVyIGluY2x1ZGVzIGV4dHJhIGNoYXJhY3RlcnM6ICR7c291cmNlfWApO1xuICAgIGxldCBoYXNTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBjb21tZW50ID0gJyc7XG4gICAgbGV0IGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHByb3BzW2ldO1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRva2VuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmICFoYXNTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSB0b2tlbi5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgdG9rZW4ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRva2VuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVW5leHBlY3RlZCB0b2tlbiBpbiBibG9jayBzY2FsYXIgaGVhZGVyOiAke3Rva2VuLnR5cGV9YDtcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRzID0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgIGlmICh0cyAmJiB0eXBlb2YgdHMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gdHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGUsIGluZGVudCwgY2hvbXAsIGNvbW1lbnQsIGxlbmd0aCB9O1xufVxuLyoqIEByZXR1cm5zIEFycmF5IG9mIGxpbmVzIHNwbGl0IHVwIGFzIGBbaW5kZW50LCBjb250ZW50XWAgKi9cbmZ1bmN0aW9uIHNwbGl0TGluZXMoc291cmNlKSB7XG4gICAgY29uc3Qgc3BsaXQgPSBzb3VyY2Uuc3BsaXQoL1xcbiggKikvKTtcbiAgICBjb25zdCBmaXJzdCA9IHNwbGl0WzBdO1xuICAgIGNvbnN0IG0gPSBmaXJzdC5tYXRjaCgvXiggKikvKTtcbiAgICBjb25zdCBsaW5lMCA9IG0/LlsxXVxuICAgICAgICA/IFttWzFdLCBmaXJzdC5zbGljZShtWzFdLmxlbmd0aCldXG4gICAgICAgIDogWycnLCBmaXJzdF07XG4gICAgY29uc3QgbGluZXMgPSBbbGluZTBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3BsaXQubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGxpbmVzLnB1c2goW3NwbGl0W2ldLCBzcGxpdFtpICsgMV1dKTtcbiAgICByZXR1cm4gbGluZXM7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVCbG9ja1NjYWxhciB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVGbG93U2NhbGFyKHNjYWxhciwgc3RyaWN0LCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBvZmZzZXQsIHR5cGUsIHNvdXJjZSwgZW5kIH0gPSBzY2FsYXI7XG4gICAgbGV0IF90eXBlO1xuICAgIGxldCB2YWx1ZTtcbiAgICBjb25zdCBfb25FcnJvciA9IChyZWwsIGNvZGUsIG1zZykgPT4gb25FcnJvcihvZmZzZXQgKyByZWwsIGNvZGUsIG1zZyk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5QTEFJTjtcbiAgICAgICAgICAgIHZhbHVlID0gcGxhaW5WYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5RVU9URV9TSU5HTEU7XG4gICAgICAgICAgICB2YWx1ZSA9IHNpbmdsZVF1b3RlZFZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIF90eXBlID0gU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICAgICAgICAgIHZhbHVlID0gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG9uRXJyb3Ioc2NhbGFyLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBFeHBlY3RlZCBhIGZsb3cgc2NhbGFyIHZhbHVlLCBidXQgZm91bmQ6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY29tbWVudDogJycsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIG9mZnNldCArIHNvdXJjZS5sZW5ndGgsIG9mZnNldCArIHNvdXJjZS5sZW5ndGhdXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZUVuZCA9IG9mZnNldCArIHNvdXJjZS5sZW5ndGg7XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kKGVuZCwgdmFsdWVFbmQsIHN0cmljdCwgb25FcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6IF90eXBlLFxuICAgICAgICBjb21tZW50OiByZS5jb21tZW50LFxuICAgICAgICByYW5nZTogW29mZnNldCwgdmFsdWVFbmQsIHJlLm9mZnNldF1cbiAgICB9O1xufVxuZnVuY3Rpb24gcGxhaW5WYWx1ZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICBsZXQgYmFkQ2hhciA9ICcnO1xuICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICBiYWRDaGFyID0gJ2EgdGFiIGNoYXJhY3Rlcic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICBiYWRDaGFyID0gJ2Zsb3cgaW5kaWNhdG9yIGNoYXJhY3RlciAsJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnZGlyZWN0aXZlIGluZGljYXRvciBjaGFyYWN0ZXIgJSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOiB7XG4gICAgICAgICAgICBiYWRDaGFyID0gYGJsb2NrIHNjYWxhciBpbmRpY2F0b3IgJHtzb3VyY2VbMF19YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0AnOlxuICAgICAgICBjYXNlICdgJzoge1xuICAgICAgICAgICAgYmFkQ2hhciA9IGByZXNlcnZlZCBjaGFyYWN0ZXIgJHtzb3VyY2VbMF19YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiYWRDaGFyKVxuICAgICAgICBvbkVycm9yKDAsICdCQURfU0NBTEFSX1NUQVJUJywgYFBsYWluIHZhbHVlIGNhbm5vdCBzdGFydCB3aXRoICR7YmFkQ2hhcn1gKTtcbiAgICByZXR1cm4gZm9sZExpbmVzKHNvdXJjZSk7XG59XG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRWYWx1ZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICBpZiAoc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPT0gXCInXCIgfHwgc291cmNlLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgb25FcnJvcihzb3VyY2UubGVuZ3RoLCAnTUlTU0lOR19DSEFSJywgXCJNaXNzaW5nIGNsb3NpbmcgJ3F1b3RlXCIpO1xuICAgIHJldHVybiBmb2xkTGluZXMoc291cmNlLnNsaWNlKDEsIC0xKSkucmVwbGFjZSgvJycvZywgXCInXCIpO1xufVxuZnVuY3Rpb24gZm9sZExpbmVzKHNvdXJjZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBuZWdhdGl2ZSBsb29rYmVoaW5kIGhlcmUgYW5kIGluIHRoZSBgcmVgIFJlZ0V4cCBpcyB0b1xuICAgICAqIHByZXZlbnQgY2F1c2luZyBhIHBvbHlub21pYWwgc2VhcmNoIHRpbWUgaW4gY2VydGFpbiBjYXNlcy5cbiAgICAgKlxuICAgICAqIFRoZSB0cnktY2F0Y2ggaXMgZm9yIFNhZmFyaSwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHRoaXMgeWV0OlxuICAgICAqIGh0dHBzOi8vY2FuaXVzZS5jb20vanMtcmVnZXhwLWxvb2tiZWhpbmRcbiAgICAgKi9cbiAgICBsZXQgZmlyc3QsIGxpbmU7XG4gICAgdHJ5IHtcbiAgICAgICAgZmlyc3QgPSBuZXcgUmVnRXhwKCcoLio/KSg/PCFbIFxcdF0pWyBcXHRdKlxccj9cXG4nLCAnc3knKTtcbiAgICAgICAgbGluZSA9IG5ldyBSZWdFeHAoJ1sgXFx0XSooLio/KSg/Oig/PCFbIFxcdF0pWyBcXHRdKik/XFxyP1xcbicsICdzeScpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIGZpcnN0ID0gLyguKj8pWyBcXHRdKlxccj9cXG4vc3k7XG4gICAgICAgIGxpbmUgPSAvWyBcXHRdKiguKj8pWyBcXHRdKlxccj9cXG4vc3k7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGZpcnN0LmV4ZWMoc291cmNlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIGxldCByZXMgPSBtYXRjaFsxXTtcbiAgICBsZXQgc2VwID0gJyAnO1xuICAgIGxldCBwb3MgPSBmaXJzdC5sYXN0SW5kZXg7XG4gICAgbGluZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgd2hpbGUgKChtYXRjaCA9IGxpbmUuZXhlYyhzb3VyY2UpKSkge1xuICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICByZXMgKz0gc2VwO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IHNlcCArIG1hdGNoWzFdO1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGxpbmUubGFzdEluZGV4O1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gL1sgXFx0XSooLiopL3N5O1xuICAgIGxhc3QubGFzdEluZGV4ID0gcG9zO1xuICAgIG1hdGNoID0gbGFzdC5leGVjKHNvdXJjZSk7XG4gICAgcmV0dXJuIHJlcyArIHNlcCArIChtYXRjaD8uWzFdID8/ICcnKTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2ggPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2kgKyAxXSA9PT0gJ1xcbicpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgY29uc3QgeyBmb2xkLCBvZmZzZXQgfSA9IGZvbGROZXdsaW5lKHNvdXJjZSwgaSk7XG4gICAgICAgICAgICByZXMgKz0gZm9sZDtcbiAgICAgICAgICAgIGkgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBzb3VyY2VbKytpXTtcbiAgICAgICAgICAgIGNvbnN0IGNjID0gZXNjYXBlQ29kZXNbbmV4dF07XG4gICAgICAgICAgICBpZiAoY2MpXG4gICAgICAgICAgICAgICAgcmVzICs9IGNjO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGVzY2FwZWQgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBDUkxGIG5ld2xpbmVzLCBidXQgc3RpbGwgdHJpbSB0aGUgZm9sbG93aW5nIGxpbmVcbiAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAneCcgfHwgbmV4dCA9PT0gJ3UnIHx8IG5leHQgPT09ICdVJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHsgeDogMiwgdTogNCwgVTogOCB9W25leHRdO1xuICAgICAgICAgICAgICAgIHJlcyArPSBwYXJzZUNoYXJDb2RlKHNvdXJjZSwgaSArIDEsIGxlbmd0aCwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgaSArPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBzb3VyY2Uuc3Vic3RyKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGkgLSAxLCAnQkFEX0RRX0VTQ0FQRScsIGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSAke3Jhd31gKTtcbiAgICAgICAgICAgICAgICByZXMgKz0gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGNvbnN0IHdzU3RhcnQgPSBpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09ICdcXG4nICYmICEobmV4dCA9PT0gJ1xccicgJiYgc291cmNlW2kgKyAyXSA9PT0gJ1xcbicpKVxuICAgICAgICAgICAgICAgIHJlcyArPSBpID4gd3NTdGFydCA/IHNvdXJjZS5zbGljZSh3c1N0YXJ0LCBpICsgMSkgOiBjaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPT0gJ1wiJyB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBjbG9zaW5nIFwicXVvdGUnKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBGb2xkIGEgc2luZ2xlIG5ld2xpbmUgaW50byBhIHNwYWNlLCBtdWx0aXBsZSBuZXdsaW5lcyB0byBOIC0gMSBuZXdsaW5lcy5cbiAqIFByZXN1bWVzIGBzb3VyY2Vbb2Zmc2V0XSA9PT0gJ1xcbidgXG4gKi9cbmZ1bmN0aW9uIGZvbGROZXdsaW5lKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgbGV0IGZvbGQgPSAnJztcbiAgICBsZXQgY2ggPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2Vbb2Zmc2V0ICsgMl0gIT09ICdcXG4nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICBmb2xkICs9ICdcXG4nO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgY2ggPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIGlmICghZm9sZClcbiAgICAgICAgZm9sZCA9ICcgJztcbiAgICByZXR1cm4geyBmb2xkLCBvZmZzZXQgfTtcbn1cbmNvbnN0IGVzY2FwZUNvZGVzID0ge1xuICAgICcwJzogJ1xcMCcsIC8vIG51bGwgY2hhcmFjdGVyXG4gICAgYTogJ1xceDA3JywgLy8gYmVsbCBjaGFyYWN0ZXJcbiAgICBiOiAnXFxiJywgLy8gYmFja3NwYWNlXG4gICAgZTogJ1xceDFiJywgLy8gZXNjYXBlIGNoYXJhY3RlclxuICAgIGY6ICdcXGYnLCAvLyBmb3JtIGZlZWRcbiAgICBuOiAnXFxuJywgLy8gbGluZSBmZWVkXG4gICAgcjogJ1xccicsIC8vIGNhcnJpYWdlIHJldHVyblxuICAgIHQ6ICdcXHQnLCAvLyBob3Jpem9udGFsIHRhYlxuICAgIHY6ICdcXHYnLCAvLyB2ZXJ0aWNhbCB0YWJcbiAgICBOOiAnXFx1MDA4NScsIC8vIFVuaWNvZGUgbmV4dCBsaW5lXG4gICAgXzogJ1xcdTAwYTAnLCAvLyBVbmljb2RlIG5vbi1icmVha2luZyBzcGFjZVxuICAgIEw6ICdcXHUyMDI4JywgLy8gVW5pY29kZSBsaW5lIHNlcGFyYXRvclxuICAgIFA6ICdcXHUyMDI5JywgLy8gVW5pY29kZSBwYXJhZ3JhcGggc2VwYXJhdG9yXG4gICAgJyAnOiAnICcsXG4gICAgJ1wiJzogJ1wiJyxcbiAgICAnLyc6ICcvJyxcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAnXFx0JzogJ1xcdCdcbn07XG5mdW5jdGlvbiBwYXJzZUNoYXJDb2RlKHNvdXJjZSwgb2Zmc2V0LCBsZW5ndGgsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBjYyA9IHNvdXJjZS5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xuICAgIGNvbnN0IG9rID0gY2MubGVuZ3RoID09PSBsZW5ndGggJiYgL15bMC05YS1mQS1GXSskLy50ZXN0KGNjKTtcbiAgICBjb25zdCBjb2RlID0gb2sgPyBwYXJzZUludChjYywgMTYpIDogTmFOO1xuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgICBjb25zdCByYXcgPSBzb3VyY2Uuc3Vic3RyKG9mZnNldCAtIDIsIGxlbmd0aCArIDIpO1xuICAgICAgICBvbkVycm9yKG9mZnNldCAtIDIsICdCQURfRFFfRVNDQVBFJywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7cmF3fWApO1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSk7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIsIFNDQUxBUiB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJztcblxuZnVuY3Rpb24gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQsIHJhbmdlIH0gPSB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJ1xuICAgICAgICA/IHJlc29sdmVCbG9ja1NjYWxhcihjdHgsIHRva2VuLCBvbkVycm9yKVxuICAgICAgICA6IHJlc29sdmVGbG93U2NhbGFyKHRva2VuLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgIGNvbnN0IHRhZ05hbWUgPSB0YWdUb2tlblxuICAgICAgICA/IGN0eC5kaXJlY3RpdmVzLnRhZ05hbWUodGFnVG9rZW4uc291cmNlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZykpXG4gICAgICAgIDogbnVsbDtcbiAgICBsZXQgdGFnO1xuICAgIGlmIChjdHgub3B0aW9ucy5zdHJpbmdLZXlzICYmIGN0eC5hdEtleSkge1xuICAgICAgICB0YWcgPSBjdHguc2NoZW1hW1NDQUxBUl07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhZ05hbWUpXG4gICAgICAgIHRhZyA9IGZpbmRTY2FsYXJUYWdCeU5hbWUoY3R4LnNjaGVtYSwgdmFsdWUsIHRhZ05hbWUsIHRhZ1Rva2VuLCBvbkVycm9yKTtcbiAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnc2NhbGFyJylcbiAgICAgICAgdGFnID0gZmluZFNjYWxhclRhZ0J5VGVzdChjdHgsIHZhbHVlLCB0b2tlbiwgb25FcnJvcik7XG4gICAgZWxzZVxuICAgICAgICB0YWcgPSBjdHguc2NoZW1hW1NDQUxBUl07XG4gICAgbGV0IHNjYWxhcjtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSB0YWcucmVzb2x2ZSh2YWx1ZSwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4gPz8gdG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpLCBjdHgub3B0aW9ucyk7XG4gICAgICAgIHNjYWxhciA9IGlzU2NhbGFyKHJlcykgPyByZXMgOiBuZXcgU2NhbGFyKHJlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIG9uRXJyb3IodGFnVG9rZW4gPz8gdG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpO1xuICAgICAgICBzY2FsYXIgPSBuZXcgU2NhbGFyKHZhbHVlKTtcbiAgICB9XG4gICAgc2NhbGFyLnJhbmdlID0gcmFuZ2U7XG4gICAgc2NhbGFyLnNvdXJjZSA9IHZhbHVlO1xuICAgIGlmICh0eXBlKVxuICAgICAgICBzY2FsYXIudHlwZSA9IHR5cGU7XG4gICAgaWYgKHRhZ05hbWUpXG4gICAgICAgIHNjYWxhci50YWcgPSB0YWdOYW1lO1xuICAgIGlmICh0YWcuZm9ybWF0KVxuICAgICAgICBzY2FsYXIuZm9ybWF0ID0gdGFnLmZvcm1hdDtcbiAgICBpZiAoY29tbWVudClcbiAgICAgICAgc2NhbGFyLmNvbW1lbnQgPSBjb21tZW50O1xuICAgIHJldHVybiBzY2FsYXI7XG59XG5mdW5jdGlvbiBmaW5kU2NhbGFyVGFnQnlOYW1lKHNjaGVtYSwgdmFsdWUsIHRhZ05hbWUsIHRhZ1Rva2VuLCBvbkVycm9yKSB7XG4gICAgaWYgKHRhZ05hbWUgPT09ICchJylcbiAgICAgICAgcmV0dXJuIHNjaGVtYVtTQ0FMQVJdOyAvLyBub24tc3BlY2lmaWMgdGFnXG4gICAgY29uc3QgbWF0Y2hXaXRoVGVzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHNjaGVtYS50YWdzKSB7XG4gICAgICAgIGlmICghdGFnLmNvbGxlY3Rpb24gJiYgdGFnLnRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICAgICAgaWYgKHRhZy5kZWZhdWx0ICYmIHRhZy50ZXN0KVxuICAgICAgICAgICAgICAgIG1hdGNoV2l0aFRlc3QucHVzaCh0YWcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB0YWcgb2YgbWF0Y2hXaXRoVGVzdClcbiAgICAgICAgaWYgKHRhZy50ZXN0Py50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgY29uc3Qga3QgPSBzY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgIGlmIChrdCAmJiAha3QuY29sbGVjdGlvbikge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUga25vd24gdGFnIGlzIGF2YWlsYWJsZSBmb3Igc3RyaW5naWZ5aW5nLFxuICAgICAgICAvLyBidXQgZG9lcyBub3QgZ2V0IHVzZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSwgdGVzdDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgcmV0dXJuIGt0O1xuICAgIH1cbiAgICBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgYFVucmVzb2x2ZWQgdGFnOiAke3RhZ05hbWV9YCwgdGFnTmFtZSAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicpO1xuICAgIHJldHVybiBzY2hlbWFbU0NBTEFSXTtcbn1cbmZ1bmN0aW9uIGZpbmRTY2FsYXJUYWdCeVRlc3QoeyBhdEtleSwgZGlyZWN0aXZlcywgc2NoZW1hIH0sIHZhbHVlLCB0b2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHRhZyA9IHNjaGVtYS50YWdzLmZpbmQodGFnID0+ICh0YWcuZGVmYXVsdCA9PT0gdHJ1ZSB8fCAoYXRLZXkgJiYgdGFnLmRlZmF1bHQgPT09ICdrZXknKSkgJiZcbiAgICAgICAgdGFnLnRlc3Q/LnRlc3QodmFsdWUpKSB8fCBzY2hlbWFbU0NBTEFSXTtcbiAgICBpZiAoc2NoZW1hLmNvbXBhdCkge1xuICAgICAgICBjb25zdCBjb21wYXQgPSBzY2hlbWEuY29tcGF0LmZpbmQodGFnID0+IHRhZy5kZWZhdWx0ICYmIHRhZy50ZXN0Py50ZXN0KHZhbHVlKSkgPz9cbiAgICAgICAgICAgIHNjaGVtYVtTQ0FMQVJdO1xuICAgICAgICBpZiAodGFnLnRhZyAhPT0gY29tcGF0LnRhZykge1xuICAgICAgICAgICAgY29uc3QgdHMgPSBkaXJlY3RpdmVzLnRhZ1N0cmluZyh0YWcudGFnKTtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gZGlyZWN0aXZlcy50YWdTdHJpbmcoY29tcGF0LnRhZyk7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgVmFsdWUgbWF5IGJlIHBhcnNlZCBhcyBlaXRoZXIgJHt0c30gb3IgJHtjc31gO1xuICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbn1cblxuZXhwb3J0IHsgY29tcG9zZVNjYWxhciB9O1xuIiwgImZ1bmN0aW9uIGVtcHR5U2NhbGFyUG9zaXRpb24ob2Zmc2V0LCBiZWZvcmUsIHBvcykge1xuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgcG9zID8/IChwb3MgPSBiZWZvcmUubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgc3QgPSBiZWZvcmVbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBzdC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5LCBhbiBlbXB0eSBzY2FsYXIgaXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3Qgbm9uLWVtcHR5XG4gICAgICAgICAgICAvLyBub2RlLCBidXQgaXQncyBtb3JlIHVzZWZ1bCB0byBwbGFjZSBpdCBhZnRlciBhbnkgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHN0ID0gYmVmb3JlWysraV07XG4gICAgICAgICAgICB3aGlsZSAoc3Q/LnR5cGUgPT09ICdzcGFjZScpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3Quc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzdCA9IGJlZm9yZVsrK2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZXhwb3J0IHsgZW1wdHlTY2FsYXJQb3NpdGlvbiB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBjb21wb3NlQ29sbGVjdGlvbiB9IGZyb20gJy4vY29tcG9zZS1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGNvbXBvc2VTY2FsYXIgfSBmcm9tICcuL2NvbXBvc2Utc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IGVtcHR5U2NhbGFyUG9zaXRpb24gfSBmcm9tICcuL3V0aWwtZW1wdHktc2NhbGFyLXBvc2l0aW9uLmpzJztcblxuY29uc3QgQ04gPSB7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH07XG5mdW5jdGlvbiBjb21wb3NlTm9kZShjdHgsIHRva2VuLCBwcm9wcywgb25FcnJvcikge1xuICAgIGNvbnN0IGF0S2V5ID0gY3R4LmF0S2V5O1xuICAgIGNvbnN0IHsgc3BhY2VCZWZvcmUsIGNvbW1lbnQsIGFuY2hvciwgdGFnIH0gPSBwcm9wcztcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgaXNTcmNUb2tlbiA9IHRydWU7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIG5vZGUgPSBjb21wb3NlQWxpYXMoY3R4LCB0b2tlbiwgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoYW5jaG9yIHx8IHRhZylcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnQUxJQVNfUFJPUFMnLCAnQW4gYWxpYXMgbm9kZSBtdXN0IG5vdCBzcGVjaWZ5IGFueSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdG9rZW4udHlwZSA9PT0gJ2Vycm9yJ1xuICAgICAgICAgICAgICAgID8gdG9rZW4ubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogYFVuc3VwcG9ydGVkIHRva2VuICh0eXBlOiAke3Rva2VuLnR5cGV9KWA7XG4gICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCB0b2tlbi5vZmZzZXQsIHVuZGVmaW5lZCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaXNTcmNUb2tlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbmNob3IgJiYgbm9kZS5hbmNob3IgPT09ICcnKVxuICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIGlmIChhdEtleSAmJlxuICAgICAgICBjdHgub3B0aW9ucy5zdHJpbmdLZXlzICYmXG4gICAgICAgICghaXNTY2FsYXIobm9kZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBub2RlLnZhbHVlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKG5vZGUudGFnICYmIG5vZGUudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJykpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHN0cmluZ0tleXMsIGFsbCBrZXlzIG11c3QgYmUgc3RyaW5ncyc7XG4gICAgICAgIG9uRXJyb3IodGFnID8/IHRva2VuLCAnTk9OX1NUUklOR19LRVknLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnc2NhbGFyJyAmJiB0b2tlbi5zb3VyY2UgPT09ICcnKVxuICAgICAgICAgICAgbm9kZS5jb21tZW50ID0gY29tbWVudDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbm9kZS5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlIGNoZWNraW5nIG1pc3NlcyBtZWFuaW5nIG9mIGlzU3JjVG9rZW5cbiAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucyAmJiBpc1NyY1Rva2VuKVxuICAgICAgICBub2RlLnNyY1Rva2VuID0gdG9rZW47XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBiZWZvcmUsIHBvcywgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6ICdzY2FsYXInLFxuICAgICAgICBvZmZzZXQ6IGVtcHR5U2NhbGFyUG9zaXRpb24ob2Zmc2V0LCBiZWZvcmUsIHBvcyksXG4gICAgICAgIGluZGVudDogLTEsXG4gICAgICAgIHNvdXJjZTogJydcbiAgICB9O1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb3NlU2NhbGFyKGN0eCwgdG9rZW4sIHRhZywgb25FcnJvcik7XG4gICAgaWYgKGFuY2hvcikge1xuICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAobm9kZS5hbmNob3IgPT09ICcnKVxuICAgICAgICAgICAgb25FcnJvcihhbmNob3IsICdCQURfQUxJQVMnLCAnQW5jaG9yIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHNwYWNlQmVmb3JlKVxuICAgICAgICBub2RlLnNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBub2RlLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICBub2RlLnJhbmdlWzJdID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNvbXBvc2VBbGlhcyh7IG9wdGlvbnMgfSwgeyBvZmZzZXQsIHNvdXJjZSwgZW5kIH0sIG9uRXJyb3IpIHtcbiAgICBjb25zdCBhbGlhcyA9IG5ldyBBbGlhcyhzb3VyY2Uuc3Vic3RyaW5nKDEpKTtcbiAgICBpZiAoYWxpYXMuc291cmNlID09PSAnJylcbiAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfQUxJQVMnLCAnQWxpYXMgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIGlmIChhbGlhcy5zb3VyY2UuZW5kc1dpdGgoJzonKSlcbiAgICAgICAgb25FcnJvcihvZmZzZXQgKyBzb3VyY2UubGVuZ3RoIC0gMSwgJ0JBRF9BTElBUycsICdBbGlhcyBlbmRpbmcgaW4gOiBpcyBhbWJpZ3VvdXMnLCB0cnVlKTtcbiAgICBjb25zdCB2YWx1ZUVuZCA9IG9mZnNldCArIHNvdXJjZS5sZW5ndGg7XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kKGVuZCwgdmFsdWVFbmQsIG9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBhbGlhcy5yYW5nZSA9IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBhbGlhcy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICByZXR1cm4gYWxpYXM7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VFbXB0eU5vZGUsIGNvbXBvc2VOb2RlIH07XG4iLCAiaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSBmcm9tICcuL2NvbXBvc2Utbm9kZS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuXG5mdW5jdGlvbiBjb21wb3NlRG9jKG9wdGlvbnMsIGRpcmVjdGl2ZXMsIHsgb2Zmc2V0LCBzdGFydCwgdmFsdWUsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBfZGlyZWN0aXZlczogZGlyZWN0aXZlcyB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQodW5kZWZpbmVkLCBvcHRzKTtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIGF0S2V5OiBmYWxzZSxcbiAgICAgICAgYXRSb290OiB0cnVlLFxuICAgICAgICBkaXJlY3RpdmVzOiBkb2MuZGlyZWN0aXZlcyxcbiAgICAgICAgb3B0aW9uczogZG9jLm9wdGlvbnMsXG4gICAgICAgIHNjaGVtYTogZG9jLnNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgaW5kaWNhdG9yOiAnZG9jLXN0YXJ0JyxcbiAgICAgICAgbmV4dDogdmFsdWUgPz8gZW5kPy5bMF0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgcGFyZW50SW5kZW50OiAwLFxuICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChwcm9wcy5mb3VuZCkge1xuICAgICAgICBkb2MuZGlyZWN0aXZlcy5kb2NTdGFydCA9IHRydWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgKHZhbHVlLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHZhbHVlLnR5cGUgPT09ICdibG9jay1zZXEnKSAmJlxuICAgICAgICAgICAgIXByb3BzLmhhc05ld2xpbmUpXG4gICAgICAgICAgICBvbkVycm9yKHByb3BzLmVuZCwgJ01JU1NJTkdfQ0hBUicsICdCbG9jayBjb2xsZWN0aW9uIGNhbm5vdCBzdGFydCBvbiBzYW1lIGxpbmUgd2l0aCBkaXJlY3RpdmVzLWVuZCBtYXJrZXInKTtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJZiBDb250ZW50cyBpcyBzZXQsIGxldCdzIHRydXN0IHRoZSB1c2VyXG4gICAgZG9jLmNvbnRlbnRzID0gdmFsdWVcbiAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzdGFydCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgIGNvbnN0IGNvbnRlbnRFbmQgPSBkb2MuY29udGVudHMucmFuZ2VbMl07XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kKGVuZCwgY29udGVudEVuZCwgZmFsc2UsIG9uRXJyb3IpO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBkb2MuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgZG9jLnJhbmdlID0gW29mZnNldCwgY29udGVudEVuZCwgcmUub2Zmc2V0XTtcbiAgICByZXR1cm4gZG9jO1xufVxuXG5leHBvcnQgeyBjb21wb3NlRG9jIH07XG4iLCAiaW1wb3J0IHsgRGlyZWN0aXZlcyB9IGZyb20gJy4uL2RvYy9kaXJlY3RpdmVzLmpzJztcbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IFlBTUxXYXJuaW5nLCBZQU1MUGFyc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBpc0NvbGxlY3Rpb24sIGlzUGFpciB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IGNvbXBvc2VEb2MgfSBmcm9tICcuL2NvbXBvc2UtZG9jLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcblxuZnVuY3Rpb24gZ2V0RXJyb3JQb3Moc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gW3NyYywgc3JjICsgMV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgcmV0dXJuIHNyYy5sZW5ndGggPT09IDIgPyBzcmMgOiBbc3JjWzBdLCBzcmNbMV1dO1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBzb3VyY2UgfSA9IHNyYztcbiAgICByZXR1cm4gW29mZnNldCwgb2Zmc2V0ICsgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gc291cmNlLmxlbmd0aCA6IDEpXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJlbHVkZShwcmVsdWRlKSB7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgbGV0IGFmdGVyRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVsdWRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHByZWx1ZGVbaV07XG4gICAgICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICBjb21tZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIChjb21tZW50ID09PSAnJyA/ICcnIDogYWZ0ZXJFbXB0eUxpbmUgPyAnXFxuXFxuJyA6ICdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlLnN1YnN0cmluZygxKSB8fCAnICcpO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGlmIChwcmVsdWRlW2kgKyAxXT8uWzBdICE9PSAnIycpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgYmUgd3JvbmcgYWZ0ZXIgZG9jLWVuZCwgYnV0IGluIHRoYXQgY2FzZSBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgICAgICAgIGlmICghYXRDb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBhZnRlckVtcHR5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWVudCwgYWZ0ZXJFbXB0eUxpbmUgfTtcbn1cbi8qKlxuICogQ29tcG9zZSBhIHN0cmVhbSBvZiBDU1Qgbm9kZXMgaW50byBhIHN0cmVhbSBvZiBZQU1MIERvY3VtZW50cy5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9zZXIsIFBhcnNlciB9IGZyb20gJ3lhbWwnXG4gKlxuICogY29uc3Qgc3JjOiBzdHJpbmcgPSAuLi5cbiAqIGNvbnN0IHRva2VucyA9IG5ldyBQYXJzZXIoKS5wYXJzZShzcmMpXG4gKiBjb25zdCBkb2NzID0gbmV3IENvbXBvc2VyKCkuY29tcG9zZSh0b2tlbnMpXG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29tcG9zZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmRvYyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgICAgIHRoaXMub25FcnJvciA9IChzb3VyY2UsIGNvZGUsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEVycm9yUG9zKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAod2FybmluZylcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2gobmV3IFlBTUxXYXJuaW5nKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfHwgJzEuMicgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGRlY29yYXRlKGRvYywgYWZ0ZXJEb2MpIHtcbiAgICAgICAgY29uc3QgeyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9ID0gcGFyc2VQcmVsdWRlKHRoaXMucHJlbHVkZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coeyBkYzogZG9jLmNvbW1lbnQsIHByZWx1ZGUsIGNvbW1lbnQgfSlcbiAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRjID0gZG9jLmNvbnRlbnRzO1xuICAgICAgICAgICAgaWYgKGFmdGVyRG9jKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnQgPSBkb2MuY29tbWVudCA/IGAke2RvYy5jb21tZW50fVxcbiR7Y29tbWVudH1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyRW1wdHlMaW5lIHx8IGRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0IHx8ICFkYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbihkYykgJiYgIWRjLmZsb3cgJiYgZGMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpdCA9IGRjLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpc1BhaXIoaXQpKVxuICAgICAgICAgICAgICAgICAgICBpdCA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGl0LmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaXQuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBkYy5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGRjLmNvbW1lbnRCZWZvcmUgPSBjYiA/IGAke2NvbW1lbnR9XFxuJHtjYn1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXJEb2MpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy5lcnJvcnMsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy53YXJuaW5ncywgdGhpcy53YXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MgPSB0aGlzLndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RyZWFtIHN0YXR1cyBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIE1vc3RseSB1c2VmdWwgYXQgdGhlIGVuZCBvZiBpbnB1dCBmb3IgYW4gZW1wdHkgc3RyZWFtLlxuICAgICAqL1xuICAgIHN0cmVhbUluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tZW50OiBwYXJzZVByZWx1ZGUodGhpcy5wcmVsdWRlKS5jb21tZW50LFxuICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLmVycm9ycyxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvc2UgdG9rZW5zIGludG8gZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqY29tcG9zZSh0b2tlbnMsIGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMubmV4dCh0b2tlbik7XG4gICAgICAgIHlpZWxkKiB0aGlzLmVuZChmb3JjZURvYywgZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEFkdmFuY2UgdGhlIGNvbXBvc2VyIGJ5IG9uZSBDU1QgdG9rZW4uICovXG4gICAgKm5leHQodG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RpdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5hZGQodG9rZW4uc291cmNlLCAob2Zmc2V0LCBtZXNzYWdlLCB3YXJuaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEVycm9yUG9zKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zWzBdICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKHBvcywgJ0JBRF9ESVJFQ1RJVkUnLCBtZXNzYWdlLCB3YXJuaW5nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZWx1ZGUucHVzaCh0b2tlbi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IGNvbXBvc2VEb2ModGhpcy5vcHRpb25zLCB0aGlzLmRpcmVjdGl2ZXMsIHRva2VuLCB0aGlzLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0RGlyZWN0aXZlcyAmJiAhZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRvYztcbiAgICAgICAgICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgICAgICAgICB0aGlzLmF0RGlyZWN0aXZlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYnl0ZS1vcmRlci1tYXJrJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVsdWRlLnB1c2godG9rZW4uc291cmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRva2VuLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICA/IGAke3Rva2VuLm1lc3NhZ2V9OiAke0pTT04uc3RyaW5naWZ5KHRva2VuLnNvdXJjZSl9YFxuICAgICAgICAgICAgICAgICAgICA6IHRva2VuLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzIHx8ICF0aGlzLmRvYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzoge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ1VuZXhwZWN0ZWQgZG9jLWVuZCB3aXRob3V0IHByZWNlZGluZyBkb2N1bWVudCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBtc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9jLmRpcmVjdGl2ZXMuZG9jRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kKHRva2VuLmVuZCwgdG9rZW4ub2Zmc2V0ICsgdG9rZW4uc291cmNlLmxlbmd0aCwgdGhpcy5kb2Mub3B0aW9ucy5zdHJpY3QsIHRoaXMub25FcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZSh0aGlzLmRvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZC5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRjID0gdGhpcy5kb2MuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MuY29tbWVudCA9IGRjID8gYCR7ZGN9XFxuJHtlbmQuY29tbWVudH1gIDogZW5kLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9jLnJhbmdlWzJdID0gZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbnN1cHBvcnRlZCB0b2tlbiAke3Rva2VuLnR5cGV9YCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYXQgZW5kIG9mIGlucHV0IHRvIHlpZWxkIGFueSByZW1haW5pbmcgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICplbmQoZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgdGhpcy5kb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlRG9jKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IF9kaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlbmRPZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgZG9jLnJhbmdlID0gWzAsIGVuZE9mZnNldCwgZW5kT2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB5aWVsZCBkb2M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbXBvc2VyIH07XG4iLCAiY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBpdGVtJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhIENTVCBkb2N1bWVudCBvciBpdGVtLlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIHRoZSByb290LCBjYWxsaW5nIGFcbiAqIGB2aXNpdG9yYCBmdW5jdGlvbiB3aXRoIHR3byBhcmd1bWVudHMgd2hlbiBlbnRlcmluZyBlYWNoIGl0ZW06XG4gKiAgIC0gYGl0ZW1gOiBUaGUgY3VycmVudCBpdGVtLCB3aGljaCBpbmNsdWRlZCB0aGUgZm9sbG93aW5nIG1lbWJlcnM6XG4gKiAgICAgLSBgc3RhcnQ6IFNvdXJjZVRva2VuW11gIFx1MjAxMyBTb3VyY2UgdG9rZW5zIGJlZm9yZSB0aGUga2V5IG9yIHZhbHVlLFxuICogICAgICAgcG9zc2libHkgaW5jbHVkaW5nIGl0cyBhbmNob3Igb3IgdGFnLlxuICogICAgIC0gYGtleT86IFRva2VuIHwgbnVsbGAgXHUyMDEzIFNldCBmb3IgcGFpciB2YWx1ZXMuIE1heSB0aGVuIGJlIGBudWxsYCwgaWZcbiAqICAgICAgIHRoZSBrZXkgYmVmb3JlIHRoZSBgOmAgc2VwYXJhdG9yIGlzIGVtcHR5LlxuICogICAgIC0gYHNlcD86IFNvdXJjZVRva2VuW11gIFx1MjAxMyBTb3VyY2UgdG9rZW5zIGJldHdlZW4gdGhlIGtleSBhbmQgdGhlIHZhbHVlLFxuICogICAgICAgd2hpY2ggc2hvdWxkIGluY2x1ZGUgdGhlIGA6YCBtYXAgdmFsdWUgaW5kaWNhdG9yIGlmIGB2YWx1ZWAgaXMgc2V0LlxuICogICAgIC0gYHZhbHVlPzogVG9rZW5gIFx1MjAxMyBUaGUgdmFsdWUgb2YgYSBzZXF1ZW5jZSBpdGVtLCBvciBvZiBhIG1hcCBwYWlyLlxuICogICAtIGBwYXRoYDogVGhlIHN0ZXBzIGZyb20gdGhlIHJvb3QgdG8gdGhlIGN1cnJlbnQgbm9kZSwgYXMgYW4gYXJyYXkgb2ZcbiAqICAgICBgWydrZXknIHwgJ3ZhbHVlJywgbnVtYmVyXWAgdHVwbGVzLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHZpc2l0b3IgbWF5IGJlIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhdmVyc2FsOlxuICogICAtIGB1bmRlZmluZWRgIChkZWZhdWx0KTogRG8gbm90aGluZyBhbmQgY29udGludWVcbiAqICAgLSBgdmlzaXQuU0tJUGA6IERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyB0b2tlbiwgY29udGludWUgd2l0aFxuICogICAgICBuZXh0IHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IGl0ZW0sIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgbnVtYmVyYDogU2V0IHRoZSBpbmRleCBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmXG4gKiAgICAgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHRva2VuIGhhcyBjaGFuZ2VkLlxuICogICAtIGBmdW5jdGlvbmA6IERlZmluZSB0aGUgbmV4dCB2aXNpdG9yIGZvciB0aGlzIGl0ZW0uIEFmdGVyIHRoZSBvcmlnaW5hbFxuICogICAgIHZpc2l0b3IgaXMgY2FsbGVkIG9uIGl0ZW0gZW50cnksIG5leHQgdmlzaXRvcnMgYXJlIGNhbGxlZCBhZnRlciBoYW5kbGluZ1xuICogICAgIGEgbm9uLWVtcHR5IGBrZXlgIGFuZCB3aGVuIGV4aXRpbmcgdGhlIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KGNzdCwgdmlzaXRvcikge1xuICAgIGlmICgndHlwZScgaW4gY3N0ICYmIGNzdC50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICAgICBjc3QgPSB7IHN0YXJ0OiBjc3Quc3RhcnQsIHZhbHVlOiBjc3QudmFsdWUgfTtcbiAgICBfdmlzaXQoT2JqZWN0LmZyZWV6ZShbXSksIGNzdCwgdmlzaXRvcik7XG59XG4vLyBXaXRob3V0IHRoZSBgYXMgc3ltYm9sYCBjYXN0cywgVFMgZGVjbGFyZXMgdGhlc2UgaW4gdGhlIGB2aXNpdGBcbi8vIG5hbWVzcGFjZSB1c2luZyBgdmFyYCwgYnV0IHRoZW4gY29tcGxhaW5zIGFib3V0IHRoYXQgYmVjYXVzZVxuLy8gYHVuaXF1ZSBzeW1ib2xgIG11c3QgYmUgYGNvbnN0YC5cbi8qKiBUZXJtaW5hdGUgdmlzaXQgdHJhdmVyc2FsIGNvbXBsZXRlbHkgKi9cbnZpc2l0LkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBpdGVtICovXG52aXNpdC5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSAqL1xudmlzaXQuUkVNT1ZFID0gUkVNT1ZFO1xuLyoqIEZpbmQgdGhlIGl0ZW0gYXQgYHBhdGhgIGZyb20gYGNzdGAgYXMgdGhlIHJvb3QgKi9cbnZpc2l0Lml0ZW1BdFBhdGggPSAoY3N0LCBwYXRoKSA9PiB7XG4gICAgbGV0IGl0ZW0gPSBjc3Q7XG4gICAgZm9yIChjb25zdCBbZmllbGQsIGluZGV4XSBvZiBwYXRoKSB7XG4gICAgICAgIGNvbnN0IHRvayA9IGl0ZW0/LltmaWVsZF07XG4gICAgICAgIGlmICh0b2sgJiYgJ2l0ZW1zJyBpbiB0b2spIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0b2suaXRlbXNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xufTtcbi8qKlxuICogR2V0IHRoZSBpbW1lZGlhdGUgcGFyZW50IGNvbGxlY3Rpb24gb2YgdGhlIGl0ZW0gYXQgYHBhdGhgIGZyb20gYGNzdGAgYXMgdGhlIHJvb3QuXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb2xsZWN0aW9uIGlzIG5vdCBmb3VuZCwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiBpZiB0aGUgaXRlbSBpdHNlbGYgZXhpc3RzLlxuICovXG52aXNpdC5wYXJlbnRDb2xsZWN0aW9uID0gKGNzdCwgcGF0aCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0Lml0ZW1BdFBhdGgoY3N0LCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgY29uc3QgZmllbGQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1bMF07XG4gICAgY29uc3QgY29sbCA9IHBhcmVudD8uW2ZpZWxkXTtcbiAgICBpZiAoY29sbCAmJiAnaXRlbXMnIGluIGNvbGwpXG4gICAgICAgIHJldHVybiBjb2xsO1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IGNvbGxlY3Rpb24gbm90IGZvdW5kJyk7XG59O1xuZnVuY3Rpb24gX3Zpc2l0KHBhdGgsIGl0ZW0sIHZpc2l0b3IpIHtcbiAgICBsZXQgY3RybCA9IHZpc2l0b3IoaXRlbSwgcGF0aCk7XG4gICAgaWYgKHR5cGVvZiBjdHJsID09PSAnc3ltYm9sJylcbiAgICAgICAgcmV0dXJuIGN0cmw7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBbJ2tleScsICd2YWx1ZSddKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gaXRlbVtmaWVsZF07XG4gICAgICAgIGlmICh0b2tlbiAmJiAnaXRlbXMnIGluIHRva2VuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2kgPSBfdmlzaXQoT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChbW2ZpZWxkLCBpXV0pKSwgdG9rZW4uaXRlbXNbaV0sIHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nICYmIGZpZWxkID09PSAna2V5JylcbiAgICAgICAgICAgICAgICBjdHJsID0gY3RybChpdGVtLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGN0cmwgPT09ICdmdW5jdGlvbicgPyBjdHJsKGl0ZW0sIHBhdGgpIDogY3RybDtcbn1cblxuZXhwb3J0IHsgdmlzaXQgfTtcbiIsICJleHBvcnQgeyBjcmVhdGVTY2FsYXJUb2tlbiwgcmVzb2x2ZUFzU2NhbGFyLCBzZXRTY2FsYXJWYWx1ZSB9IGZyb20gJy4vY3N0LXNjYWxhci5qcyc7XG5leHBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL2NzdC1zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgdmlzaXQgfSBmcm9tICcuL2NzdC12aXNpdC5qcyc7XG5cbi8qKiBUaGUgYnl0ZSBvcmRlciBtYXJrICovXG5jb25zdCBCT00gPSAnXFx1e0ZFRkZ9Jztcbi8qKiBTdGFydCBvZiBkb2MtbW9kZSAqL1xuY29uc3QgRE9DVU1FTlQgPSAnXFx4MDInOyAvLyBDMDogU3RhcnQgb2YgVGV4dFxuLyoqIFVuZXhwZWN0ZWQgZW5kIG9mIGZsb3ctbW9kZSAqL1xuY29uc3QgRkxPV19FTkQgPSAnXFx4MTgnOyAvLyBDMDogQ2FuY2VsXG4vKiogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuY29uc3QgU0NBTEFSID0gJ1xceDFmJzsgLy8gQzA6IFVuaXQgU2VwYXJhdG9yXG4vKiogQHJldHVybnMgYHRydWVgIGlmIGB0b2tlbmAgaXMgYSBmbG93IG9yIGJsb2NrIGNvbGxlY3Rpb24gKi9cbmNvbnN0IGlzQ29sbGVjdGlvbiA9ICh0b2tlbikgPT4gISF0b2tlbiAmJiAnaXRlbXMnIGluIHRva2VuO1xuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBzY2FsYXI7IG5vdCBhbiBhbGlhcyAqL1xuY29uc3QgaXNTY2FsYXIgPSAodG9rZW4pID0+ICEhdG9rZW4gJiZcbiAgICAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnZG91YmxlLXF1b3RlZC1zY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKiogR2V0IGEgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbGV4ZXIgdG9rZW4gKi9cbmZ1bmN0aW9uIHByZXR0eVRva2VuKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnPEJPTT4nO1xuICAgICAgICBjYXNlIERPQ1VNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICc8RE9DPic7XG4gICAgICAgIGNhc2UgRkxPV19FTkQ6XG4gICAgICAgICAgICByZXR1cm4gJzxGTE9XX0VORD4nO1xuICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIHJldHVybiAnPFNDQUxBUj4nO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRva2VuKTtcbiAgICB9XG59XG4vKiogSWRlbnRpZnkgdGhlIHR5cGUgb2YgYSBsZXhlciB0b2tlbi4gTWF5IHJldHVybiBgbnVsbGAgZm9yIHVua25vd24gdG9rZW5zLiAqL1xuZnVuY3Rpb24gdG9rZW5UeXBlKHNvdXJjZSkge1xuICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgIGNhc2UgQk9NOlxuICAgICAgICAgICAgcmV0dXJuICdieXRlLW9yZGVyLW1hcmsnO1xuICAgICAgICBjYXNlIERPQ1VNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtbW9kZSc7XG4gICAgICAgIGNhc2UgRkxPV19FTkQ6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctZXJyb3ItZW5kJztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJ3NjYWxhcic7XG4gICAgICAgIGNhc2UgJy0tLSc6XG4gICAgICAgICAgICByZXR1cm4gJ2RvYy1zdGFydCc7XG4gICAgICAgIGNhc2UgJy4uLic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvYy1lbmQnO1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHJcXG4nOlxuICAgICAgICAgICAgcmV0dXJuICduZXdsaW5lJztcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICByZXR1cm4gJ3NlcS1pdGVtLWluZCc7XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgcmV0dXJuICdleHBsaWNpdC1rZXktaW5kJztcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICByZXR1cm4gJ21hcC12YWx1ZS1pbmQnO1xuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1tYXAtc3RhcnQnO1xuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1tYXAtZW5kJztcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctc2VxLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctc2VxLWVuZCc7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgcmV0dXJuICdjb21tYSc7XG4gICAgfVxuICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgcmV0dXJuICdzcGFjZSc7XG4gICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICByZXR1cm4gJ2RpcmVjdGl2ZS1saW5lJztcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZXR1cm4gJ2FsaWFzJztcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJ2FuY2hvcic7XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgcmV0dXJuICd0YWcnO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuICdzaW5nbGUtcXVvdGVkLXNjYWxhcic7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnZG91YmxlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gJ2Jsb2NrLXNjYWxhci1oZWFkZXInO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgQk9NLCBET0NVTUVOVCwgRkxPV19FTkQsIFNDQUxBUiwgaXNDb2xsZWN0aW9uLCBpc1NjYWxhciwgcHJldHR5VG9rZW4sIHRva2VuVHlwZSB9O1xuIiwgImltcG9ydCB7IEJPTSwgRE9DVU1FTlQsIEZMT1dfRU5ELCBTQ0FMQVIgfSBmcm9tICcuL2NzdC5qcyc7XG5cbi8qXG5TVEFSVCAtPiBzdHJlYW1cblxuc3RyZWFtXG4gIGRpcmVjdGl2ZSAtPiBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgaW5kZW50ICsgbGluZS1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBsaW5lLXN0YXJ0XG5cbmxpbmUtZW5kXG4gIGNvbW1lbnQgLT4gbGluZS1lbmRcbiAgbmV3bGluZSAtPiAuXG4gIGlucHV0LWVuZCAtPiBFTkRcblxubGluZS1zdGFydFxuICBkb2Mtc3RhcnQgLT4gZG9jXG4gIGRvYy1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBpbmRlbnQgLT4gYmxvY2stc3RhcnRcblxuYmxvY2stc3RhcnRcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBibG9jay1zdGFydFxuICBbZWxzZV0gLT4gZG9jXG5cbmRvY1xuICBsaW5lLWVuZCAtPiBsaW5lLXN0YXJ0XG4gIHNwYWNlcyAtPiBkb2NcbiAgYW5jaG9yIC0+IGRvY1xuICB0YWcgLT4gZG9jXG4gIGZsb3ctc3RhcnQgLT4gZmxvdyAtPiBkb2NcbiAgZmxvdy1lbmQgLT4gZXJyb3IgLT4gZG9jXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGRvY1xuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIG1hcC12YWx1ZS1zdGFydCAtPiBkb2NcbiAgYWxpYXMgLT4gZG9jXG4gIHF1b3RlLXN0YXJ0IC0+IHF1b3RlZC1zY2FsYXIgLT4gZG9jXG4gIGJsb2NrLXNjYWxhci1oZWFkZXIgLT4gbGluZS1lbmQgLT4gYmxvY2stc2NhbGFyKG1pbikgLT4gbGluZS1zdGFydFxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKGZhbHNlLCBtaW4pIC0+IGRvY1xuXG5mbG93XG4gIGxpbmUtZW5kIC0+IGZsb3dcbiAgc3BhY2VzIC0+IGZsb3dcbiAgYW5jaG9yIC0+IGZsb3dcbiAgdGFnIC0+IGZsb3dcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGZsb3dcbiAgZmxvdy1lbmQgLT4gLlxuICBzZXEtaXRlbS1zdGFydCAtPiBlcnJvciAtPiBmbG93XG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBmbG93XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBmbG93XG4gIGFsaWFzIC0+IGZsb3dcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBmbG93XG4gIGNvbW1hIC0+IGZsb3dcbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcih0cnVlLCAwKSAtPiBmbG93XG5cbnF1b3RlZC1zY2FsYXJcbiAgcXVvdGUtZW5kIC0+IC5cbiAgW2Vsc2VdIC0+IHF1b3RlZC1zY2FsYXJcblxuYmxvY2stc2NhbGFyKG1pbilcbiAgbmV3bGluZSArIHBlZWsoaW5kZW50IDwgbWluKSAtPiAuXG4gIFtlbHNlXSAtPiBibG9jay1zY2FsYXIobWluKVxuXG5wbGFpbi1zY2FsYXIoaXMtZmxvdywgbWluKVxuICBzY2FsYXItZW5kKGlzLWZsb3cpIC0+IC5cbiAgcGVlayhuZXdsaW5lICsgKGluZGVudCA8IG1pbikpIC0+IC5cbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcihtaW4pXG4qL1xuZnVuY3Rpb24gaXNFbXB0eShjaCkge1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgaGV4RGlnaXRzID0gbmV3IFNldCgnMDEyMzQ1Njc4OUFCQ0RFRmFiY2RlZicpO1xuY29uc3QgdGFnQ2hhcnMgPSBuZXcgU2V0KFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotIzsvPzpAJj0rJF8uIX4qJygpXCIpO1xuY29uc3QgZmxvd0luZGljYXRvckNoYXJzID0gbmV3IFNldCgnLFtde30nKTtcbmNvbnN0IGludmFsaWRBbmNob3JDaGFycyA9IG5ldyBTZXQoJyAsW117fVxcblxcclxcdCcpO1xuY29uc3QgaXNOb3RBbmNob3JDaGFyID0gKGNoKSA9PiAhY2ggfHwgaW52YWxpZEFuY2hvckNoYXJzLmhhcyhjaCk7XG4vKipcbiAqIFNwbGl0cyBhbiBpbnB1dCBzdHJpbmcgaW50byBsZXhpY2FsIHRva2VucywgaS5lLiBzbWFsbGVyIHN0cmluZ3MgdGhhdCBhcmVcbiAqIGVhc2lseSBpZGVudGlmaWFibGUgYnkgYHRva2Vucy50b2tlblR5cGUoKWAuXG4gKlxuICogTGV4aW5nIHN0YXJ0cyBhbHdheXMgaW4gYSBcInN0cmVhbVwiIGNvbnRleHQuIEluY29tcGxldGUgaW5wdXQgbWF5IGJlIGJ1ZmZlcmVkXG4gKiB1bnRpbCBhIGNvbXBsZXRlIHRva2VuIGNhbiBiZSBlbWl0dGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHNsaWNlcyBvZiB0aGUgb3JpZ2luYWwgaW5wdXQsIHRoZSBmb2xsb3dpbmcgY29udHJvbCBjaGFyYWN0ZXJzXG4gKiBtYXkgYWxzbyBiZSBlbWl0dGVkOlxuICpcbiAqIC0gYFxceDAyYCAoU3RhcnQgb2YgVGV4dCk6IEEgZG9jdW1lbnQgc3RhcnRzIHdpdGggdGhlIG5leHQgdG9rZW5cbiAqIC0gYFxceDE4YCAoQ2FuY2VsKTogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlIChpbmRpY2F0ZXMgYW4gZXJyb3IpXG4gKiAtIGBcXHgxZmAgKFVuaXQgU2VwYXJhdG9yKTogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZVxuICogLSBgXFx1e0ZFRkZ9YCAoQnl0ZSBvcmRlciBtYXJrKTogRW1pdHRlZCBzZXBhcmF0ZWx5IG91dHNpZGUgZG9jdW1lbnRzXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIG1hcmtzIHRoZSBlbmQgb2ZcbiAgICAgICAgICogYWxsIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0RW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBsaWNpdCBpbmRlbnQgc2V0IGluIGJsb2NrIHNjYWxhciBoZWFkZXIsIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAqIG1pbmltdW0gaW5kZW50LCBzbyBlLmcuIHNldCB0byAxIGZyb20gYSBoZWFkZXIgYHwyK2AuIFNldCB0byAtMSBpZiBub3RcbiAgICAgICAgICogZXhwbGljaXRseSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCbG9jayBzY2FsYXJzIHRoYXQgaW5jbHVkZSBhICsgKGtlZXApIGNob21waW5nIGluZGljYXRvciBpbiB0aGVpciBoZWFkZXJcbiAgICAgICAgICogaW5jbHVkZSB0cmFpbGluZyBlbXB0eSBsaW5lcywgd2hpY2ggYXJlIG90aGVyd2lzZSBleGNsdWRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBzY2FsYXIncyBjb250ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGlucHV0ICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIG5vdGluZyB3aGV0aGVyIHRoZSBtYXAgdmFsdWUgaW5kaWNhdG9yIDogY2FuIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGlzXG4gICAgICAgICAqIG5vZGUgd2l0aGluIGEgZmxvdyBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBDb3VudCBvZiBzdXJyb3VuZGluZyBmbG93IGNvbGxlY3Rpb24gbGV2ZWxzLiAqL1xuICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIGxldmVsIG9mIGluZGVudGF0aW9uIHJlcXVpcmVkIGZvciBuZXh0IGxpbmVzIHRvIGJlIHBhcnNlZCBhcyBhXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGN1cnJlbnQgc2NhbGFyIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgLyoqIEluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBjdXJyZW50IGxpbmUuICovXG4gICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSAwO1xuICAgICAgICAvKiogUG9zaXRpb24gb2YgdGhlIG5leHQgXFxuIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgLyoqIFN0b3JlcyB0aGUgc3RhdGUgb2YgdGhlIGxleGVyIGlmIHJlYWNoaW5nIHRoZSBlbmQgb2YgaW5jcG9tcGxldGUgaW5wdXQgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIEEgcG9pbnRlciB0byBgYnVmZmVyYDsgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxleGVyLiAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIFlBTUwgdG9rZW5zIGZyb20gdGhlIGBzb3VyY2VgIHN0cmluZy4gSWYgYGluY29tcGxldGVgLFxuICAgICAqIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBnZW5lcmF0b3Igb2YgbGV4aWNhbCB0b2tlbnNcbiAgICAgKi9cbiAgICAqbGV4KHNvdXJjZSwgaW5jb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3NvdXJjZSBpcyBub3QgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlciArIHNvdXJjZSA6IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdEVuZCA9ICFpbmNvbXBsZXRlO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dCA/PyAnc3RyZWFtJztcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgKGluY29tcGxldGUgfHwgdGhpcy5oYXNDaGFycygxKSkpXG4gICAgICAgICAgICBuZXh0ID0geWllbGQqIHRoaXMucGFyc2VOZXh0KG5leHQpO1xuICAgIH1cbiAgICBhdExpbmVFbmQoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmICghY2ggfHwgY2ggPT09ICcjJyB8fCBjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcltpICsgMV0gPT09ICdcXG4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYXJBdChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcyArIG5dO1xuICAgIH1cbiAgICBjb250aW51ZVNjYWxhcihvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbb2Zmc2V0XTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50TmV4dCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2luZGVudCArIG9mZnNldF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2luZGVudCArIG9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJyB8fCAoIW5leHQgJiYgIXRoaXMuYXRFbmQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgaW5kZW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCB8fCAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgID8gb2Zmc2V0ICsgaW5kZW50XG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuYnVmZmVyLnN1YnN0cihvZmZzZXQsIDMpO1xuICAgICAgICAgICAgaWYgKChkdCA9PT0gJy0tLScgfHwgZHQgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuYnVmZmVyW29mZnNldCArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubGluZUVuZFBvcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IChlbmQgIT09IC0xICYmIGVuZCA8IHRoaXMucG9zKSkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRFbmQgPyB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW2VuZCAtIDFdID09PSAnXFxyJylcbiAgICAgICAgICAgIGVuZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zLCBlbmQpO1xuICAgIH1cbiAgICBoYXNDaGFycyhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArIG4gPD0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBzZXROZXh0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICB9XG4gICAgKnBhcnNlTmV4dChuZXh0KSB7XG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VTdHJlYW0oKTtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmUtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUZsb3dDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3BsYWluLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VTdHJlYW0oKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnc3RyZWFtJyk7XG4gICAgICAgIGlmIChsaW5lWzBdID09PSBCT00pIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVswXSA9PT0gJyUnKSB7XG4gICAgICAgICAgICBsZXQgZGlyRW5kID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY3MgPSBsaW5lLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIHdoaWxlIChjcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbY3MgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyRW5kID0gY3MgLSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNzID0gbGluZS5pbmRleE9mKCcjJywgY3MgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gbGluZVtkaXJFbmQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIGRpckVuZCAtPSAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuID0gKHlpZWxkKiB0aGlzLnB1c2hDb3VudChkaXJFbmQpKSArICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pOyAvLyBwb3NzaWJsZSBjb21tZW50XG4gICAgICAgICAgICB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmVhbSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXRMaW5lRW5kKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIHNwKTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmVhbSc7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgRE9DVU1FTlQ7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VMaW5lU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5jaGFyQXQoMCk7XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdsaW5lLXN0YXJ0Jyk7XG4gICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdEVuZCAmJiAhdGhpcy5oYXNDaGFycyg0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdsaW5lLXN0YXJ0Jyk7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5wZWVrKDMpO1xuICAgICAgICAgICAgaWYgKChzID09PSAnLS0tJyB8fCBzID09PSAnLi4uJykgJiYgaXNFbXB0eSh0aGlzLmNoYXJBdCgzKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcyA9PT0gJy0tLScgPyAnZG9jJyA6ICdzdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50TmV4dCA+IHRoaXMuaW5kZW50VmFsdWUgJiYgIWlzRW1wdHkodGhpcy5jaGFyQXQoMSkpKVxuICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gdGhpcy5pbmRlbnRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VCbG9ja1N0YXJ0KCkge1xuICAgICAgICBjb25zdCBbY2gwLCBjaDFdID0gdGhpcy5wZWVrKDIpO1xuICAgICAgICBpZiAoIWNoMSAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXN0YXJ0Jyk7XG4gICAgICAgIGlmICgoY2gwID09PSAnLScgfHwgY2gwID09PSAnPycgfHwgY2gwID09PSAnOicpICYmIGlzRW1wdHkoY2gxKSkge1xuICAgICAgICAgICAgY29uc3QgbiA9ICh5aWVsZCogdGhpcy5wdXNoQ291bnQoMSkpICsgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gdGhpcy5pbmRlbnRWYWx1ZSArIDE7XG4gICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlICs9IG47XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgIH1cbiAgICAqcGFyc2VEb2N1bWVudCgpIHtcbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICBpZiAobGluZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2RvYycpO1xuICAgICAgICBsZXQgbiA9IHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCk7XG4gICAgICAgIHN3aXRjaCAobGluZVtuXSkge1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucGFyc2VCbG9ja1NjYWxhckhlYWRlcigpO1xuICAgICAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlRmxvd0NvbGxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBubCwgc3A7XG4gICAgICAgIGxldCBpbmRlbnQgPSAtMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbmwgPSB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgaWYgKG5sID4gMCkge1xuICAgICAgICAgICAgICAgIHNwID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IGluZGVudCA9IHNwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3AgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3AgKz0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgfSB3aGlsZSAobmwgKyBzcCA+IDApO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnZmxvdycpO1xuICAgICAgICBpZiAoKGluZGVudCAhPT0gLTEgJiYgaW5kZW50IDwgdGhpcy5pbmRlbnROZXh0ICYmIGxpbmVbMF0gIT09ICcjJykgfHxcbiAgICAgICAgICAgIChpbmRlbnQgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAobGluZS5zdGFydHNXaXRoKCctLS0nKSB8fCBsaW5lLnN0YXJ0c1dpdGgoJy4uLicpKSAmJlxuICAgICAgICAgICAgICAgIGlzRW1wdHkobGluZVszXSkpKSB7XG4gICAgICAgICAgICAvLyBBbGxvd2luZyBmb3IgdGhlIHRlcm1pbmFsIF0gb3IgfSBhdCB0aGUgc2FtZSAocmF0aGVyIHRoYW4gZ3JlYXRlcilcbiAgICAgICAgICAgIC8vIGluZGVudCBsZXZlbCBhcyB0aGUgaW5pdGlhbCBbIG9yIHsgaXMgdGVjaG5pY2FsbHkgaW52YWxpZCwgYnV0XG4gICAgICAgICAgICAvLyBmYWlsaW5nIGhlcmUgd291bGQgYmUgc3VycHJpc2luZyB0byB1c2Vycy5cbiAgICAgICAgICAgIGNvbnN0IGF0Rmxvd0VuZE1hcmtlciA9IGluZGVudCA9PT0gdGhpcy5pbmRlbnROZXh0IC0gMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsID09PSAxICYmXG4gICAgICAgICAgICAgICAgKGxpbmVbMF0gPT09ICddJyB8fCBsaW5lWzBdID09PSAnfScpO1xuICAgICAgICAgICAgaWYgKCFhdEZsb3dFbmRNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAwO1xuICAgICAgICAgICAgICAgIHlpZWxkIEZMT1dfRU5EO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgd2hpbGUgKGxpbmVbbl0gPT09ICcsJykge1xuICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCk7XG4gICAgICAgIHN3aXRjaCAobGluZVtuXSkge1xuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0xldmVsID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnOic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5jaGFyQXQoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd0tleSB8fCBpc0VtcHR5KG5leHQpIHx8IG5leHQgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlUXVvdGVkU2NhbGFyKCkge1xuICAgICAgICBjb25zdCBxdW90ZSA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihxdW90ZSwgdGhpcy5wb3MgKyAxKTtcbiAgICAgICAgaWYgKHF1b3RlID09PSBcIidcIikge1xuICAgICAgICAgICAgd2hpbGUgKGVuZCAhPT0gLTEgJiYgdGhpcy5idWZmZXJbZW5kICsgMV0gPT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoXCInXCIsIGVuZCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlXG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZmZXJbZW5kIC0gMSAtIG5dID09PSAnXFxcXCcpXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDIgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1wiJywgZW5kICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBsb29raW5nIGZvciBuZXdsaW5lcyB3aXRoaW4gdGhlIHF1b3Rlc1xuICAgICAgICBjb25zdCBxYiA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZygwLCBlbmQpO1xuICAgICAgICBsZXQgbmwgPSBxYi5pbmRleE9mKCdcXG4nLCB0aGlzLnBvcyk7XG4gICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHFiLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yIGNhdXNlZCBieSBhbiB1bmV4cGVjdGVkIHVuaW5kZW50XG4gICAgICAgICAgICAgICAgZW5kID0gbmwgLSAocWJbbmwgLSAxXSA9PT0gJ1xccicgPyAyIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdxdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFRvSW5kZXgoZW5kICsgMSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKSB7XG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSAtMTtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJysnKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID4gJzAnICYmIGNoIDw9ICc5JylcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gTnVtYmVyKGNoKSAtIDE7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCAhPT0gJy0nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVW50aWwoY2ggPT4gaXNFbXB0eShjaCkgfHwgY2ggPT09ICcjJyk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU2NhbGFyKCkge1xuICAgICAgICBsZXQgbmwgPSB0aGlzLnBvcyAtIDE7IC8vIG1heSBiZSAtMSBpZiB0aGlzLnBvcyA9PT0gMFxuICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBsb29wOiBmb3IgKGxldCBpID0gdGhpcy5wb3M7IChjaCA9IHRoaXMuYnVmZmVyW2ldKTsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICAgICAgICBubCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0ICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc2NhbGFyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgaWYgKGluZGVudCA+PSB0aGlzLmluZGVudE5leHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrU2NhbGFySW5kZW50ID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSBpbmRlbnQ7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ICsgKHRoaXMuaW5kZW50TmV4dCA9PT0gMCA/IDEgOiB0aGlzLmluZGVudE5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfSB3aGlsZSAobmwgIT09IC0xKTtcbiAgICAgICAgICAgIGlmIChubCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWlsaW5nIGluc3VmZmljaWVudGx5IGluZGVudGVkIHRhYnMgYXJlIGludmFsaWQuXG4gICAgICAgIC8vIFRvIGNhdGNoIHRoYXQgZHVyaW5nIHBhcnNpbmcsIHdlIGluY2x1ZGUgdGhlbSBpbiB0aGUgYmxvY2sgc2NhbGFyIHZhbHVlLlxuICAgICAgICBsZXQgaSA9IG5sICsgMTtcbiAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xccicgfHwgY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIG5sID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYmxvY2tTY2FsYXJLZWVwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBubCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gaTsgLy8gRHJvcCB0aGUgbGluZSBpZiBsYXN0IGNoYXIgbm90IG1vcmUgaW5kZW50ZWRcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgaSA+PSB0aGlzLnBvcyAmJiBpICsgMSArIGluZGVudCA+IGxhc3RDaGFyKVxuICAgICAgICAgICAgICAgICAgICBubCA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIFNDQUxBUjtcbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFRvSW5kZXgobmwgKyAxLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZVBsYWluU2NhbGFyKCkge1xuICAgICAgICBjb25zdCBpbkZsb3cgPSB0aGlzLmZsb3dMZXZlbCA+IDA7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIHdoaWxlICgoY2ggPSB0aGlzLmJ1ZmZlclsrK2ldKSkge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG5leHQpIHx8IChpbkZsb3cgJiYgZmxvd0luZGljYXRvckNoYXJzLmhhcyhuZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0VtcHR5KGNoKSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJyMnIHx8IChpbkZsb3cgJiYgZmxvd0luZGljYXRvckNoYXJzLmhhcyhuZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5tYXgoaSwgY3MgLSAyKTsgLy8gdG8gYWR2YW5jZSwgYnV0IHN0aWxsIGFjY291bnQgZm9yICcgIydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdwbGFpbi1zY2FsYXInKTtcbiAgICAgICAgeWllbGQgU0NBTEFSO1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGluRmxvdyA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcHVzaENvdW50KG4pIHtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5wb3MsIG4pO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRvSW5kZXgoaSwgYWxsb3dFbXB0eSkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5wb3MsIGkpO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgeWllbGQgcztcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93RW1wdHkpXG4gICAgICAgICAgICB5aWVsZCAnJztcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoSW5kaWNhdG9ycygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaFRhZygpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgY2FzZSAnLSc6IC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgIGNhc2UgJz8nOiAvLyB0aGlzIGlzIGFuIGVycm9yIG91dHNpZGUgZmxvdyBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgY2FzZSAnOic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbkZsb3cgPSB0aGlzLmZsb3dMZXZlbCA+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2gxID0gdGhpcy5jaGFyQXQoMSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoY2gxKSB8fCAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMoY2gxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbkZsb3cpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mbG93S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRhZygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhckF0KDEpID09PSAnPCcpIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5wb3MgKyAyO1xuICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoIWlzRW1wdHkoY2gpICYmIGNoICE9PSAnPicpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGNoID09PSAnPicgPyBpICsgMSA6IGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnQ2hhcnMuaGFzKGNoKSlcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJScgJiZcbiAgICAgICAgICAgICAgICAgICAgaGV4RGlnaXRzLmhhcyh0aGlzLmJ1ZmZlcltpICsgMV0pICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5oYXModGhpcy5idWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWyhpICs9IDMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnB1c2hOZXdsaW5lKCkge1xuICAgICAgICBjb25zdCBjaCA9IHRoaXMuYnVmZmVyW3RoaXMucG9zXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLmNoYXJBdCgxKSA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaENvdW50KDIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hTcGFjZXMoYWxsb3dUYWJzKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgfSB3aGlsZSAoY2ggPT09ICcgJyB8fCAoYWxsb3dUYWJzICYmIGNoID09PSAnXFx0JykpO1xuICAgICAgICBjb25zdCBuID0gaSAtIHRoaXMucG9zO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgICpwdXNoVW50aWwodGVzdCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKCF0ZXN0KGNoKSlcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExleGVyIH07XG4iLCAiLyoqXG4gKiBUcmFja3MgbmV3bGluZXMgZHVyaW5nIHBhcnNpbmcgaW4gb3JkZXIgdG8gcHJvdmlkZSBhbiBlZmZpY2llbnQgQVBJIGZvclxuICogZGV0ZXJtaW5pbmcgdGhlIG9uZS1pbmRleGVkIGB7IGxpbmUsIGNvbCB9YCBwb3NpdGlvbiBmb3IgYW55IG9mZnNldFxuICogd2l0aGluIHRoZSBpbnB1dC5cbiAqL1xuY2xhc3MgTGluZUNvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpbmVTdGFydHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBjYWxsZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIGNhbGxcbiAgICAgICAgICogYGxpbmVDb3VudGVyLmxpbmVTdGFydHMuc29ydCgpYCBiZWZvcmUgY2FsbGluZyBgbGluZVBvcygpYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkTmV3TGluZSA9IChvZmZzZXQpID0+IHRoaXMubGluZVN0YXJ0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggYW5kIHJldHVybnMgdGhlIDEtaW5kZXhlZCB7IGxpbmUsIGNvbCB9XG4gICAgICAgICAqIHBvc2l0aW9uIG9mIGBvZmZzZXRgLiBJZiBgbGluZSA9PT0gMGAsIGBhZGROZXdMaW5lYCBoYXMgbmV2ZXIgYmVlblxuICAgICAgICAgKiBjYWxsZWQgb3IgYG9mZnNldGAgaXMgYmVmb3JlIHRoZSBmaXJzdCBrbm93biBuZXdsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lUG9zID0gKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgICAgICBsZXQgaGlnaCA9IHRoaXMubGluZVN0YXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxOyAvLyBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0c1ttaWRdIDwgb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTdGFydHNbbG93XSA9PT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxvdyArIDEsIGNvbDogMSB9O1xuICAgICAgICAgICAgaWYgKGxvdyA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5lOiAwLCBjb2w6IG9mZnNldCB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmxpbmVTdGFydHNbbG93IC0gMV07XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lOiBsb3csIGNvbDogb2Zmc2V0IC0gc3RhcnQgKyAxIH07XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBMaW5lQ291bnRlciB9O1xuIiwgImltcG9ydCB7IHRva2VuVHlwZSB9IGZyb20gJy4vY3N0LmpzJztcbmltcG9ydCB7IExleGVyIH0gZnJvbSAnLi9sZXhlci5qcyc7XG5cbmZ1bmN0aW9uIGluY2x1ZGVzVG9rZW4obGlzdCwgdHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGxpc3RbaV0udHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmROb25FbXB0eUluZGV4KGxpc3QpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc3dpdGNoIChsaXN0W2ldLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGlzRmxvd1Rva2VuKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbj8udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldlByb3BzKHBhcmVudCkge1xuICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5zdGFydDtcbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgY29uc3QgaXQgPSBwYXJlbnQuaXRlbXNbcGFyZW50Lml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIGl0LnNlcCA/PyBpdC5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV0uc3RhcnQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuLyoqIE5vdGU6IE1heSBtb2RpZnkgaW5wdXQgYXJyYXkgKi9cbmZ1bmN0aW9uIGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KSB7XG4gICAgaWYgKHByZXYubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGkgPSBwcmV2Lmxlbmd0aDtcbiAgICBsb29wOiB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgc3dpdGNoIChwcmV2W2ldLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6XG4gICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHByZXZbKytpXT8udHlwZSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAvKiBsb29wICovXG4gICAgfVxuICAgIHJldHVybiBwcmV2LnNwbGljZShpLCBwcmV2Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiBmaXhGbG93U2VxSXRlbXMoZmMpIHtcbiAgICBpZiAoZmMuc3RhcnQudHlwZSA9PT0gJ2Zsb3ctc2VxLXN0YXJ0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIGZjLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXQuc2VwICYmXG4gICAgICAgICAgICAgICAgIWl0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJykgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXQua2V5KVxuICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXQua2V5O1xuICAgICAgICAgICAgICAgIGlmIChpc0Zsb3dUb2tlbihpdC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGl0LnZhbHVlLmVuZCwgaXQuc2VwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUuZW5kID0gaXQuc2VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGl0LnN0YXJ0LCBpdC5zZXApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5zZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgWUFNTCBjb25jcmV0ZSBzeW50YXggdHJlZSAoQ1NUKSBwYXJzZXJcbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc3JjOiBzdHJpbmcgPSAuLi5cbiAqIGZvciAoY29uc3QgdG9rZW4gb2YgbmV3IFBhcnNlcigpLnBhcnNlKHNyYykpIHtcbiAqICAgLy8gdG9rZW46IFRva2VuXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUbyB1c2UgdGhlIHBhcnNlciB3aXRoIGEgdXNlci1wcm92aWRlZCBsZXhlcjpcbiAqXG4gKiBgYGB0c1xuICogZnVuY3Rpb24qIHBhcnNlKHNvdXJjZTogc3RyaW5nLCBsZXhlcjogTGV4ZXIpIHtcbiAqICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcigpXG4gKiAgIGZvciAoY29uc3QgbGV4ZW1lIG9mIGxleGVyLmxleChzb3VyY2UpKVxuICogICAgIHlpZWxkKiBwYXJzZXIubmV4dChsZXhlbWUpXG4gKiAgIHlpZWxkKiBwYXJzZXIuZW5kKClcbiAqIH1cbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoKVxuICogZm9yIChjb25zdCB0b2tlbiBvZiBwYXJzZShzcmMsIGxleGVyKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbk5ld0xpbmUgLSBJZiBkZWZpbmVkLCBjYWxsZWQgc2VwYXJhdGVseSB3aXRoIHRoZSBzdGFydCBwb3NpdGlvbiBvZlxuICAgICAqICAgZWFjaCBuZXcgbGluZSAoaW4gYHBhcnNlKClgLCBpbmNsdWRpbmcgdGhlIHN0YXJ0IG9mIGlucHV0KS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihvbk5ld0xpbmUpIHtcbiAgICAgICAgLyoqIElmIHRydWUsIHNwYWNlIGFuZCBzZXF1ZW5jZSBpbmRpY2F0b3JzIGNvdW50IGFzIGluZGVudGF0aW9uICovXG4gICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgLyoqIElmIHRydWUsIG5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbiAgICAgICAgdGhpcy5hdFNjYWxhciA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCAqL1xuICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIC8qKiBDdXJyZW50IG9mZnNldCBzaW5jZSB0aGUgc3RhcnQgb2YgcGFyc2luZyAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBPbiB0aGUgc2FtZSBsaW5lIHdpdGggYSBibG9jayBtYXAga2V5ICovXG4gICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgIC8qKiBUb3AgaW5kaWNhdGVzIHRoZSBub2RlIHRoYXQncyBjdXJyZW50bHkgYmVpbmcgYnVpbHQgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKiogVGhlIHNvdXJjZSBvZiB0aGUgY3VycmVudCB0b2tlbiwgc2V0IGluIHBhcnNlKCkgKi9cbiAgICAgICAgdGhpcy5zb3VyY2UgPSAnJztcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgLy8gTXVzdCBiZSBkZWZpbmVkIGFmdGVyIGBuZXh0KClgXG4gICAgICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgdGhpcy5vbk5ld0xpbmUgPSBvbk5ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGBzb3VyY2VgIGFzIGEgWUFNTCBzdHJlYW0uXG4gICAgICogSWYgYGluY29tcGxldGVgLCBhIHBhcnQgb2YgdGhlIGxhc3QgbGluZSBtYXkgYmUgbGVmdCBhcyBhIGJ1ZmZlciBmb3IgdGhlIG5leHQgY2FsbC5cbiAgICAgKlxuICAgICAqIEVycm9ycyBhcmUgbm90IHRocm93biwgYnV0IHlpZWxkZWQgYXMgYHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZSB9YCB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGdlbmVyYXRvciBvZiB0b2tlbnMgcmVwcmVzZW50aW5nIGVhY2ggZGlyZWN0aXZlLCBkb2N1bWVudCwgYW5kIG90aGVyIHN0cnVjdHVyZS5cbiAgICAgKi9cbiAgICAqcGFyc2Uoc291cmNlLCBpbmNvbXBsZXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lICYmIHRoaXMub2Zmc2V0ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUoMCk7XG4gICAgICAgIGZvciAoY29uc3QgbGV4ZW1lIG9mIHRoaXMubGV4ZXIubGV4KHNvdXJjZSwgaW5jb21wbGV0ZSkpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5uZXh0KGxleGVtZSk7XG4gICAgICAgIGlmICghaW5jb21wbGV0ZSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmVuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBwYXJzZXIgYnkgdGhlIGBzb3VyY2VgIG9mIG9uZSBsZXhpY2FsIHRva2VuLlxuICAgICAqL1xuICAgICpuZXh0KHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHRoaXMuYXRTY2FsYXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHRva2VuVHlwZShzb3VyY2UpO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgTm90IGEgWUFNTCB0b2tlbjogJHtzb3VyY2V9YDtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh7IHR5cGU6ICdlcnJvcicsIG9mZnNldDogdGhpcy5vZmZzZXQsIG1lc3NhZ2UsIHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NjYWxhcicpIHtcbiAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmF0U2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdzY2FsYXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBzb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdE5ld0xpbmUgJiYgc291cmNlWzBdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdE5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkb2MtbW9kZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1lcnJvci1lbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIENhbGwgYXQgZW5kIG9mIGlucHV0IHRvIHB1c2ggb3V0IGFueSByZW1haW5pbmcgY29uc3RydWN0aW9ucyAqL1xuICAgICplbmQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZVRva2VuKCkge1xuICAgICAgICBjb25zdCBzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Q7XG4gICAgfVxuICAgICpzdGVwKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdkb2MtZW5kJyAmJiB0b3A/LnR5cGUgIT09ICdkb2MtZW5kJykge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RvYy1lbmQnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3ApXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc3RyZWFtKCk7XG4gICAgICAgIHN3aXRjaCAodG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnQodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnNjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tTY2FsYXIodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrTWFwKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NlcXVlbmNlKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5mbG93Q29sbGVjdGlvbih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnZG9jLWVuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmRvY3VtZW50RW5kKHRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIG5dO1xuICAgIH1cbiAgICAqcG9wKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZXJyb3IgPz8gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnVHJpZWQgdG8gcG9wIGFuIGVtcHR5IHN0YWNrJztcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc291cmNlOiAnJywgbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJykge1xuICAgICAgICAgICAgICAgIC8vIEJsb2NrIHNjYWxhcnMgdXNlIHRoZWlyIHBhcmVudCByYXRoZXIgdGhhbiBoZWFkZXIgaW5kZW50XG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gJ2luZGVudCcgaW4gdG9wID8gdG9wLmluZGVudCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJyAmJiB0b3AudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgaW5kZW50IGZvciB0b3AtbGV2ZWwgZmxvdyBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHRva2VuLmluZGVudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpXG4gICAgICAgICAgICAgICAgZml4Rmxvd1NlcUl0ZW1zKHRva2VuKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICAgICAgICAgIHRvcC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgICAgICB0b3AucHJvcHMucHVzaCh0b2tlbik7IC8vIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gIWl0LmV4cGxpY2l0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gdG9wLml0ZW1zW3RvcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIHZhbHVlOiB0b2tlbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0b3AudHlwZSA9PT0gJ2RvY3VtZW50JyB8fFxuICAgICAgICAgICAgICAgIHRvcC50eXBlID09PSAnYmxvY2stbWFwJyB8fFxuICAgICAgICAgICAgICAgIHRvcC50eXBlID09PSAnYmxvY2stc2VxJykgJiZcbiAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHwgdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRva2VuLml0ZW1zW3Rva2VuLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmXG4gICAgICAgICAgICAgICAgICAgICFsYXN0LnNlcCAmJlxuICAgICAgICAgICAgICAgICAgICAhbGFzdC52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBsYXN0LnN0YXJ0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmluZE5vbkVtcHR5SW5kZXgobGFzdC5zdGFydCkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi5pbmRlbnQgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQuZXZlcnkoc3QgPT4gc3QudHlwZSAhPT0gJ2NvbW1lbnQnIHx8IHN0LmluZGVudCA8IHRva2VuLmluZGVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AudHlwZSA9PT0gJ2RvY3VtZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5lbmQgPSBsYXN0LnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBsYXN0LnN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pdGVtcy5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqc3RyZWFtKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0aXZlLWxpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ2RpcmVjdGl2ZScsIG9mZnNldDogdGhpcy5vZmZzZXQsIHNvdXJjZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNvdXJjZVRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1zdGFydCcpXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChkb2MpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIHN0cmVhbWAsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgICpkb2N1bWVudChkb2MpIHtcbiAgICAgICAgaWYgKGRvYy52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5saW5lRW5kKGRvYyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmROb25FbXB0eUluZGV4KGRvYy5zdGFydCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKGRvYyk7XG4gICAgICAgIGlmIChidilcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5leHBlY3RlZCAke3RoaXMudHlwZX0gdG9rZW4gaW4gWUFNTCBkb2N1bWVudGAsXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqc2NhbGFyKHNjYWxhcikge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbWFwLXZhbHVlLWluZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHModGhpcy5wZWVrKDIpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgbGV0IHNlcDtcbiAgICAgICAgICAgIGlmIChzY2FsYXIuZW5kKSB7XG4gICAgICAgICAgICAgICAgc2VwID0gc2NhbGFyLmVuZDtcbiAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2NhbGFyLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXAgPSBbdGhpcy5zb3VyY2VUb2tlbl07XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBzY2FsYXIub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGluZGVudDogc2NhbGFyLmluZGVudCxcbiAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogc2NhbGFyLCBzZXAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPSBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgeWllbGQqIHRoaXMubGluZUVuZChzY2FsYXIpO1xuICAgIH1cbiAgICAqYmxvY2tTY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHNjYWxhci5wcm9wcy5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICAgICAgc2NhbGFyLnNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICAgICAgICAgIC8vIGJsb2NrLXNjYWxhciBzb3VyY2UgaW5jbHVkZXMgdHJhaWxpbmcgbmV3bGluZVxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIG5sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJywgbmwpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqYmxvY2tNYXAobWFwKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gbWFwLml0ZW1zW21hcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gaXQuc2VwIGlzIHRydWUtaXNoIGlmIHBhaXIgYWxyZWFkeSBoYXMga2V5IG9yIDogc2VwYXJhdG9yXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiBpdC52YWx1ZSA/IGl0LnZhbHVlLmVuZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5LmlzQXJyYXkoZW5kKSA/IGVuZFtlbmQubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Py50eXBlID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ/LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXRJbmRlbnRlZENvbW1lbnQoaXQuc3RhcnQsIG1hcC5pbmRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gbWFwLml0ZW1zW21hcC5pdGVtcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHByZXY/LnZhbHVlPy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5kLCBpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZW50ID49IG1hcC5pbmRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0TWFwSW5kZW50ID0gIXRoaXMub25LZXlMaW5lICYmIHRoaXMuaW5kZW50ID09PSBtYXAuaW5kZW50O1xuICAgICAgICAgICAgY29uc3QgYXROZXh0SXRlbSA9IGF0TWFwSW5kZW50ICYmXG4gICAgICAgICAgICAgICAgKGl0LnNlcCB8fCBpdC5leHBsaWNpdEtleSkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgIT09ICdzZXEtaXRlbS1pbmQnO1xuICAgICAgICAgICAgLy8gRm9yIGVtcHR5IG5vZGVzLCBhc3NpZ24gbmV3bGluZS1zZXBhcmF0ZWQgbm90IGluZGVudGVkIGVtcHR5IHRva2VucyB0byBmb2xsb3dpbmcgbm9kZVxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gW107XG4gICAgICAgICAgICBpZiAoYXROZXh0SXRlbSAmJiBpdC5zZXAgJiYgIWl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmwgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0LnNlcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdCA9IGl0LnNlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBubC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0LmluZGVudCA+IG1hcC5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5sLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5sLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5sLmxlbmd0aCA+PSAyKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGl0LnNlcC5zcGxpY2UobmxbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdE5leHRJdGVtIHx8IGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQuc2VwICYmICFpdC5leHBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LmV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhdE5leHRJdGVtIHx8IGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCwgZXhwbGljaXRLZXk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSwgZXhwbGljaXRLZXk6IHRydWUgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQuZXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICduZXdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMoaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Zsb3dUb2tlbihpdC5rZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbmV3bGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMoaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXAgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlIGd1YXJkIGlzIHdyb25nIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXQua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZSBndWFyZCBpcyB3cm9uZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXksIHNlcCB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhY3R1YWxseSBhdCBuZXh0IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAgPSBpdC5zZXAuY29uY2F0KHN0YXJ0LCB0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC52YWx1ZSB8fCBhdE5leHRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbWFwLXZhbHVlLWluZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW10sIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQsIGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKG1hcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ2LnR5cGUgPT09ICdibG9jay1zZXEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5leHBsaWNpdEtleSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbmV3bGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVbmV4cGVjdGVkIGJsb2NrLXNlcS1pbmQgb24gc2FtZSBsaW5lIHdpdGgga2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhdE1hcEluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgfVxuICAgICpibG9ja1NlcXVlbmNlKHNlcSkge1xuICAgICAgICBjb25zdCBpdCA9IHNlcS5pdGVtc1tzZXEuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gaXQudmFsdWUgPyBpdC52YWx1ZS5lbmQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmRbZW5kLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdD8udHlwZSA9PT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kPy5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXRJbmRlbnRlZENvbW1lbnQoaXQuc3RhcnQsIHNlcS5pbmRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gc2VxLml0ZW1zW3NlcS5pdGVtcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHByZXY/LnZhbHVlPy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5kLCBpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUgfHwgdGhpcy5pbmRlbnQgPD0gc2VxLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGVudCAhPT0gc2VxLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlIHx8IGluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdzZXEtaXRlbS1pbmQnKSlcbiAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZW50ID4gc2VxLmluZGVudCkge1xuICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShzZXEpO1xuICAgICAgICAgICAgaWYgKGJ2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICB9XG4gICAgKmZsb3dDb2xsZWN0aW9uKGZjKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gZmMuaXRlbXNbZmMuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdmbG93LWVycm9yLWVuZCcpIHtcbiAgICAgICAgICAgIGxldCB0b3A7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICAgICAgfSB3aGlsZSAodG9wPy50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmMuZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmMuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmMuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcyA9IHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmMuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZzKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLWVuZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgZmMuZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoZmMpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2Ugc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGlmIChidilcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wZWVrKDIpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnYmxvY2stbWFwJyAmJlxuICAgICAgICAgICAgICAgICgodGhpcy50eXBlID09PSAnbWFwLXZhbHVlLWluZCcgJiYgcGFyZW50LmluZGVudCA9PT0gZmMuaW5kZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy50eXBlID09PSAnbmV3bGluZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFwYXJlbnQuaXRlbXNbcGFyZW50Lml0ZW1zLmxlbmd0aCAtIDFdLnNlcCkpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAnbWFwLXZhbHVlLWluZCcgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQudHlwZSAhPT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgZml4Rmxvd1NlcUl0ZW1zKGZjKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXAgPSBmYy5lbmQuc3BsaWNlKDEsIGZjLmVuZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogZmMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IGZjLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IGZjLCBzZXAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPSBtYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5saW5lRW5kKGZjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmbG93U2NhbGFyKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lKSB7XG4gICAgICAgICAgICBsZXQgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nKSArIDE7XG4gICAgICAgICAgICB3aGlsZSAobmwgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIG5sKTtcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicsIG5sKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhcnRCbG9ja1ZhbHVlKHBhcmVudCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93U2NhbGFyKHRoaXMudHlwZSk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXItaGVhZGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stc2NhbGFyJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IFt0aGlzLnNvdXJjZVRva2VuXSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdmbG93LW1hcC1zdGFydCc6XG4gICAgICAgICAgICBjYXNlICdmbG93LXNlcS1zdGFydCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zsb3ctY29sbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRva2VuLFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stc2VxJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwgZXhwbGljaXRLZXk6IHRydWUgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhdEluZGVudGVkQ29tbWVudChzdGFydCwgaW5kZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdjb21tZW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50IDw9IGluZGVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmV2ZXJ5KHN0ID0+IHN0LnR5cGUgPT09ICduZXdsaW5lJyB8fCBzdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICB9XG4gICAgKmRvY3VtZW50RW5kKGRvY0VuZCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnZG9jLW1vZGUnKSB7XG4gICAgICAgICAgICBpZiAoZG9jRW5kLmVuZClcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9jRW5kLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqbGluZUVuZCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYXJzZXIgfTtcbiIsICJpbXBvcnQgeyBDb21wb3NlciB9IGZyb20gJy4vY29tcG9zZS9jb21wb3Nlci5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IHByZXR0aWZ5RXJyb3IsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4vbG9nLmpzJztcbmltcG9ydCB7IGlzRG9jdW1lbnQgfSBmcm9tICcuL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IExpbmVDb3VudGVyIH0gZnJvbSAnLi9wYXJzZS9saW5lLWNvdW50ZXIuanMnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZS9wYXJzZXIuanMnO1xuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHByZXR0eUVycm9ycyA9IG9wdGlvbnMucHJldHR5RXJyb3JzICE9PSBmYWxzZTtcbiAgICBjb25zdCBsaW5lQ291bnRlciA9IG9wdGlvbnMubGluZUNvdW50ZXIgfHwgKHByZXR0eUVycm9ycyAmJiBuZXcgTGluZUNvdW50ZXIoKSkgfHwgbnVsbDtcbiAgICByZXR1cm4geyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH07XG59XG4vKipcbiAqIFBhcnNlIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZiBZQU1MIGRvY3VtZW50cy5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIGJlIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgYC4uLmAgb3IgYC0tLWAgbWFya2VyIGxpbmVzLlxuICpcbiAqIEByZXR1cm5zIElmIGFuIGVtcHR5IGBkb2NzYCBhcnJheSBpcyByZXR1cm5lZCwgaXQgd2lsbCBiZSBvZiB0eXBlXG4gKiAgIEVtcHR5U3RyZWFtIGFuZCBjb250YWluIGFkZGl0aW9uYWwgc3RyZWFtIGluZm9ybWF0aW9uLiBJblxuICogICBUeXBlU2NyaXB0LCB5b3Ugc2hvdWxkIHVzZSBgJ2VtcHR5JyBpbiBkb2NzYCBhcyBhIHR5cGUgZ3VhcmQgZm9yIGl0LlxuICovXG5mdW5jdGlvbiBwYXJzZUFsbERvY3VtZW50cyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXI/LmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSkpKTtcbiAgICBpZiAocHJldHR5RXJyb3JzICYmIGxpbmVDb3VudGVyKVxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgfVxuICAgIGlmIChkb2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB7IGVtcHR5OiB0cnVlIH0sIGNvbXBvc2VyLnN0cmVhbUluZm8oKSk7XG59XG4vKiogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYSBzaW5nbGUgWUFNTC5Eb2N1bWVudCAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXI/LmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIC8vIGBkb2NgIGlzIGFsd2F5cyBzZXQgYnkgY29tcG9zZS5lbmQodHJ1ZSkgYXQgdGhlIHZlcnkgbGF0ZXN0XG4gICAgbGV0IGRvYyA9IG51bGw7XG4gICAgZm9yIChjb25zdCBfZG9jIG9mIGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSksIHRydWUsIHNvdXJjZS5sZW5ndGgpKSB7XG4gICAgICAgIGlmICghZG9jKVxuICAgICAgICAgICAgZG9jID0gX2RvYztcbiAgICAgICAgZWxzZSBpZiAoZG9jLm9wdGlvbnMubG9nTGV2ZWwgIT09ICdzaWxlbnQnKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKF9kb2MucmFuZ2Uuc2xpY2UoMCwgMiksICdNVUxUSVBMRV9ET0NTJywgJ1NvdXJjZSBjb250YWlucyBtdWx0aXBsZSBkb2N1bWVudHM7IHBsZWFzZSB1c2UgWUFNTC5wYXJzZUFsbERvY3VtZW50cygpJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcikge1xuICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3JjLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IF9yZXZpdmVyID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfcmV2aXZlciA9IHJldml2ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXZpdmVyICYmIHR5cGVvZiByZXZpdmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gcmV2aXZlcjtcbiAgICB9XG4gICAgY29uc3QgZG9jID0gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpO1xuICAgIGlmICghZG9jKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBkb2Mud2FybmluZ3MuZm9yRWFjaCh3YXJuaW5nID0+IHdhcm4oZG9jLm9wdGlvbnMubG9nTGV2ZWwsIHdhcm5pbmcpKTtcbiAgICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpXG4gICAgICAgICAgICB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJldHVybiBkb2MudG9KUyhPYmplY3QuYXNzaWduKHsgcmV2aXZlcjogX3Jldml2ZXIgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgucm91bmQob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRlbnQgPCAxID8gdW5kZWZpbmVkIDogaW5kZW50ID4gOCA/IHsgaW5kZW50OiA4IH0gOiB7IGluZGVudCB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQgfSA9IG9wdGlvbnMgPz8gcmVwbGFjZXIgPz8ge307XG4gICAgICAgIGlmICgha2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0RvY3VtZW50KHZhbHVlKSAmJiAhX3JlcGxhY2VyKVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudCh2YWx1ZSwgX3JlcGxhY2VyLCBvcHRpb25zKS50b1N0cmluZyhvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgcGFyc2UsIHBhcnNlQWxsRG9jdW1lbnRzLCBwYXJzZURvY3VtZW50LCBzdHJpbmdpZnkgfTtcbiIsICJpbXBvcnQgeyBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xyXG5pbXBvcnQgeyBQYXRoUmVzb2x2ZXIgfSBmcm9tICcuLi8uLi91dGlscy9QYXRoUmVzb2x2ZXInO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wc1xyXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBsdWdpbkNvbmZpZ3VyYXRpb25TdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xyXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1BsdWdpbiBDb25maWd1cmF0aW9uJyB9KTtcclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcclxuICAgICAgICAgICAgdGV4dDogJ1lvdXIgcGx1Z2lucyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29uZmlndXJlZCB1c2luZyB5b3VyIG1hcHBlZCBmcm9udG1hdHRlciBwcm9wZXJ0aWVzLiBSZXZpZXcgdGhlIHNldHRpbmdzIGJlbG93LidcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgZW5hYmxlZFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xyXG5cclxuICAgICAgICBpZiAoZW5hYmxlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcclxuICAgICAgICAgICAgICAgIHRleHQ6ICdObyBjb250ZW50IHR5cGVzIGVuYWJsZWQuIFBsZWFzZSBnbyBiYWNrIGFuZCBlbmFibGUgYXQgbGVhc3Qgb25lIGNvbnRlbnQgdHlwZS4nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gQmFzZSB2aWV3cyBTZWN0aW9uIC0tLVxyXG4gICAgICAgIGNvbnN0IGJhc2VzQ01TRGl2ID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAncGx1Z2luLWNvbmZpZy1zZWN0aW9uJywgYXR0cjogeyBzdHlsZTogJ21hcmdpbi1ib3R0b206IDJyZW07JyB9IH0pO1xyXG4gICAgICAgIGJhc2VzQ01TRGl2LmNyZWF0ZUVsKCdiJywgeyB0ZXh0OiAnQmFzZSB2aWV3cyB0byBiZSBjcmVhdGVkOicsIGF0dHI6IHsgc3R5bGU6ICdkaXNwbGF5OiBibG9jazsgbWFyZ2luLWJvdHRvbTogMC41cmVtOycgfSB9KTtcclxuICAgICAgICBjb25zdCBiYXNlc0xpc3QgPSBiYXNlc0NNU0Rpdi5jcmVhdGVFbCgndWwnLCB7IGF0dHI6IHsgc3R5bGU6ICdtYXJnaW4tdG9wOiAwOycgfSB9KTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBlbmFibGVkVHlwZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF07XHJcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydGllczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy50aXRsZVByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2gocHJvcHMudGl0bGVQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZGF0ZVByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2gocHJvcHMuZGF0ZVByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2gocHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMudGFnc1Byb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2gocHJvcHMudGFnc1Byb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5pbWFnZVByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2gocHJvcHMuaW1hZ2VQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSkgcHJvcGVydGllcy5wdXNoKHByb3BzLmRyYWZ0UHJvcGVydHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXNUZXh0ID0gcHJvcGVydGllcy5sZW5ndGggPiAwID8gcHJvcGVydGllcy5qb2luKCcsICcpIDogJ2RlZmF1bHQgcHJvcGVydGllcyc7XHJcbiAgICAgICAgICAgICAgICBiYXNlc0xpc3QuY3JlYXRlRWwoJ2xpJywge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGAke2NvbnRlbnRUeXBlLm5hbWV9OiAke3Byb3BlcnRpZXNUZXh0fWBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gQ3JlYXRpb24gbG9naWMgU2VjdGlvbiAtLS1cclxuICAgICAgICBjb25zdCBhc3Ryb0NvbXBvc2VyRGl2ID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAncGx1Z2luLWNvbmZpZy1zZWN0aW9uJywgYXR0cjogeyBzdHlsZTogJ21hcmdpbi1ib3R0b206IDJyZW07JyB9IH0pO1xyXG4gICAgICAgIGFzdHJvQ29tcG9zZXJEaXYuY3JlYXRlRWwoJ2InLCB7IHRleHQ6ICdDcmVhdGlvbiBsb2dpYzonLCBhdHRyOiB7IHN0eWxlOiAnZGlzcGxheTogYmxvY2s7IG1hcmdpbi1ib3R0b206IDAuNXJlbTsnIH0gfSk7XHJcbiAgICAgICAgY29uc3QgYXN0cm9MaXN0ID0gYXN0cm9Db21wb3NlckRpdi5jcmVhdGVFbCgndWwnLCB7IGF0dHI6IHsgc3R5bGU6ICdtYXJnaW4tdG9wOiAwOycgfSB9KTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBlbmFibGVkVHlwZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZUxhYmVsID0gY29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbiA9PT0gJ2ZvbGRlcicgPyAnZm9sZGVyLWJhc2VkJyA6ICdmaWxlLWJhc2VkJztcclxuICAgICAgICAgICAgYXN0cm9MaXN0LmNyZWF0ZUVsKCdsaScsIHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IGAke2NvbnRlbnRUeXBlLm5hbWV9ICgke2NvbnRlbnRUeXBlLmZvbGRlcn0pOiAke21vZGVMYWJlbH1gXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIENvbmZpZ3VyYXRpb24gU2VjdGlvbiAtLS1cclxuICAgICAgICBjb25zdCBjb25maWdEaXYgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdwbHVnaW4tY29uZmlnLXNlY3Rpb24nLCBhdHRyOiB7IHN0eWxlOiAnYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKTsgcGFkZGluZy10b3A6IDFyZW07JyB9IH0pO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgcHJvcGVydHkgaW5jb25zaXN0ZW5jaWVzIChTRU8gd2FybmluZylcclxuICAgICAgICBjb25zdCB0aXRsZVByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvblByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIGVuYWJsZWRUeXBlcykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXTtcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkgdGl0bGVQcm9wZXJ0aWVzLmFkZChwcm9wcy50aXRsZVByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSBkZXNjcmlwdGlvblByb3BlcnRpZXMuYWRkKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGl0bGVQcm9wZXJ0aWVzLnNpemUgPiAxIHx8IGRlc2NyaXB0aW9uUHJvcGVydGllcy5zaXplID4gMSkge1xyXG4gICAgICAgICAgICBjb25zdCB3YXJuaW5nRGl2ID0gY29uZmlnRGl2LmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy13YXJuaW5nJyB9KTtcclxuICAgICAgICAgICAgc2V0Q3NzUHJvcHMod2FybmluZ0Rpdiwge1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzEwcHgnLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlckxlZnQ6ICczcHggc29saWQgdmFyKC0tdGV4dC13YXJuaW5nKScsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICcxNXB4J1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgd2FybmluZ0Rpdi5jcmVhdGVFbCgncCcsIHtcclxuICAgICAgICAgICAgICAgIHRleHQ6ICdcdTI2QTBcdUZFMEYgV2FybmluZzogRGlmZmVyZW50IGNvbnRlbnQgdHlwZXMgdXNlIGRpZmZlcmVudCBwcm9wZXJ0aWVzIGZvciB0aXRsZSBvciBkZXNjcmlwdGlvbi4gU0VPIHdpbGwgdXNlIHRoZSBmaXJzdCBjb250ZW50IHR5cGVcXCdzIGRlZmF1bHRzLicsXHJcbiAgICAgICAgICAgICAgICBhdHRyOiB7IHN0eWxlOiAnbWFyZ2luOiAwOyBmb250LXNpemU6IDAuOWVtOycgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgQ29udGVudCBUeXBlIFNldHRpbmdcclxuICAgICAgICBuZXcgU2V0dGluZyhjb25maWdEaXYpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZWZhdWx0IGNvbnRlbnQgdHlwZScpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaG9vc2UgdGhlIGRlZmF1bHQgY29udGVudCB0eXBlIGZvciBuZXcgbm90ZXMgYW5kIEhvbWUgYmFzZScpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkVHlwZXMuZm9yRWFjaChjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKGN0LmlkLCBjdC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUodGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCB8fCAoZW5hYmxlZFR5cGVzWzBdPy5pZCB8fCAnJykpO1xyXG4gICAgICAgICAgICAgICAgZHJvcGRvd24ub25DaGFuZ2UodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU0VPIFNjYW4gRGlyZWN0b3JpZXMgU2V0dGluZ1xyXG4gICAgICAgIGNvbnN0IHBhdGhSZXNvbHZlciA9IG5ldyBQYXRoUmVzb2x2ZXIodGhpcy5hcHApO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTY2FuRGlycyA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZClcclxuICAgICAgICAgICAgLm1hcChjdCA9PiBwYXRoUmVzb2x2ZXIuZ2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoY3QuZm9sZGVyLCB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pKVxyXG4gICAgICAgICAgICAuam9pbignLCcpO1xyXG4gICAgICAgIGNvbnN0IHNhdmVkU2NhbkRpcnMgPSB0aGlzLnN0YXRlLnNlb0NvbmZpZz8uc2NhbkRpcmVjdG9yaWVzO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTY2FuRGlycyA9IHNhdmVkU2NhbkRpcnMgJiYgc2F2ZWRTY2FuRGlycy50cmltKCkgPyBzYXZlZFNjYW5EaXJzIDogZGVmYXVsdFNjYW5EaXJzO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc2VvQ29uZmlnLnNjYW5EaXJlY3RvcmllcyB8fCAhdGhpcy5zdGF0ZS5zZW9Db25maWcuc2NhbkRpcmVjdG9yaWVzLnRyaW0oKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlb0NvbmZpZy5zY2FuRGlyZWN0b3JpZXMgPSBpbml0aWFsU2NhbkRpcnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb25maWdEaXYpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdTRU8gU2NhbiBkaXJlY3RvcmllcycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBkaXJlY3RvcmllcyB0byBzY2FuJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoaW5pdGlhbFNjYW5EaXJzKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZW9Db25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZW9Db25maWcuc2NhbkRpcmVjdG9yaWVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5zb21lKGN0ID0+IGN0LmVuYWJsZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRpdGxlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuICdQbHVnaW4gY29uZmlndXJhdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gJ0NvbmZpZ3VyZSBCYXNlcywgQXN0cm8gQ29tcG9zZXIsIFNFTywgYW5kIERlZmF1bHQgVHlwZSc7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZywgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9QbHVnaW5NYW5hZ2VyJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wc1xuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuXHRcdGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcblx0fVxufVxuXG5pbnRlcmZhY2UgUGx1Z2luSW5mbyB7XG5cdGlkOiBzdHJpbmc7XG5cdG5hbWU6IHN0cmluZztcblx0Y2F0ZWdvcnk6ICdlc3NlbnRpYWwnIHwgJ25pY2UtdG8taGF2ZSc7XG59XG5cbmV4cG9ydCBjbGFzcyBPcHRpb25hbFBsdWdpbnNTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRwcml2YXRlIHBsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXI7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHAsIGNvbnRhaW5lckVsLCBzdGF0ZSwgb25OZXh0LCBvbkJhY2ssIG9uQ2FuY2VsKTtcblx0XHR0aGlzLnBsdWdpbk1hbmFnZXIgPSBuZXcgUGx1Z2luTWFuYWdlcihhcHApO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdQbHVnaW4gZGV0ZWN0aW9uJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcblx0XHRcdHRleHQ6ICdSZXZpZXcgYW5kIGNvbmZpZ3VyZSB5b3VyIGluc3RhbGxlZCBwbHVnaW5zLiBFc3NlbnRpYWwgcGx1Z2lucyBhcmUgcmVjb21tZW5kZWQgZm9yIHRoZSBjb3JlIFZhdWx0IENNUyBleHBlcmllbmNlLidcblx0XHR9KTtcblxuXHRcdC8vIERlZmluZSBhbGwgcGx1Z2lucyB3aXRoIHRoZWlyIGNhdGVnb3JpZXNcblx0XHRjb25zdCBhbGxQbHVnaW5zOiBQbHVnaW5JbmZvW10gPSBbXG5cdFx0XHR7IGlkOiAnYXN0cm8tY29tcG9zZXInLCBuYW1lOiAnQXN0cm8gQ29tcG9zZXInLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdiYXNlcy1jbXMnLCBuYW1lOiAnQmFzZXMgQ01TJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnbmV3LXRhYi1kZWZhdWx0LXBhZ2UnLCBuYW1lOiAnRGVmYXVsdCBOZXcgVGFiIFBhZ2UnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdlZGl0aW5nLXRvb2xiYXInLCBuYW1lOiAnRWRpdGluZyBUb29sYmFyJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnaG9tZS1iYXNlJywgbmFtZTogJ0hvbWUgQmFzZScsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ2hvbWVwYWdlJywgbmFtZTogJ0hvbWVwYWdlJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnaW1hZ2UtbWFuYWdlcicsIG5hbWU6ICdJbWFnZSBNYW5hZ2VyJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnb2JzaWRpYW4tcGFzdGUtaW1hZ2UtcmVuYW1lJywgbmFtZTogJ1Bhc3RlIEltYWdlIFJlbmFtZScsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ3Byb3BlcnR5LW92ZXItZmlsZS1uYW1lJywgbmFtZTogJ1Byb3BlcnR5IE92ZXIgRmlsZSBOYW1lJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnc2VvJywgbmFtZTogJ1NFTycsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ3VpLXR3ZWFrZXInLCBuYW1lOiAnVUkgVHdlYWtlcicsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ3NpbXBsZS1mb2N1cycsIG5hbWU6ICdTaW1wbGUgRm9jdXMnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdzdGF0dXNiYXItb3JnYW5pemVyJywgbmFtZTogJ1N0YXR1cyBCYXIgT3JnYW5pemVyJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnYWxpYXMtZmlsZS1uYW1lLWhpc3RvcnknLCBuYW1lOiAnQWxpYXMgRmlsZSBOYW1lIEhpc3RvcnknLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICdkYXRhLWZpbGVzLWVkaXRvcicsIG5hbWU6ICdEYXRhIEZpbGVzIEVkaXRvcicsIGNhdGVnb3J5OiAnbmljZS10by1oYXZlJyB9LFxuXHRcdFx0eyBpZDogJ2ljb25pYycsIG5hbWU6ICdJY29uaWMnLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICdwYXN0ZS1pbWFnZS1pbnRvLXByb3BlcnR5JywgbmFtZTogJ1Bhc3RlIEltYWdlIEludG8gUHJvcGVydHknLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICdzZXR0aW5ncy1zZWFyY2gnLCBuYW1lOiAnU2V0dGluZ3MgU2VhcmNoJywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAndGFnLXdyYW5nbGVyJywgbmFtZTogJ1RhZyBXcmFuZ2xlcicsIGNhdGVnb3J5OiAnbmljZS10by1oYXZlJyB9LFxuXHRcdFx0eyBpZDogJ3plbm1vZGUnLCBuYW1lOiAnWmVuIE1vZGUnLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICdleHBsb3Jlci1mb2N1cycsIG5hbWU6ICdFeHBsb3JlciBGb2N1cycsIGNhdGVnb3J5OiAnbmljZS10by1oYXZlJyB9XG5cdFx0XTtcblxuXHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogeyBwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47IGVuYWJsZWRQbHVnaW5zPzogU2V0PHN0cmluZz4gfSB9KS5wbHVnaW5zO1xuXHRcdGNvbnN0IGluc3RhbGxlZFBsdWdpbklkcyA9IHBsdWdpbnM/LnBsdWdpbnMgPyBPYmplY3Qua2V5cyhwbHVnaW5zLnBsdWdpbnMpIDogW107XG5cdFx0Y29uc3QgaWdub3JlZFBsdWdpbnMgPSBbJ29ic2lkaWFuNDItYnJhdCcsICdhc3Ryby1tb2R1bGFyLXNldHRpbmdzJywgJ2ZvbGRlci1ub3RlcycsICdkaXNhYmxlLXRhYnMnLCAndmF1bHQtY21zJ107XG5cblx0XHRjb25zdCBlc3NlbnRpYWxQbHVnaW5zID0gYWxsUGx1Z2lucy5maWx0ZXIocCA9PlxuXHRcdFx0cC5jYXRlZ29yeSA9PT0gJ2Vzc2VudGlhbCcgJiYgaW5zdGFsbGVkUGx1Z2luSWRzLmluY2x1ZGVzKHAuaWQpICYmICFpZ25vcmVkUGx1Z2lucy5pbmNsdWRlcyhwLmlkKVxuXHRcdCk7XG5cdFx0Y29uc3QgbmljZVRvSGF2ZVBsdWdpbnMgPSBhbGxQbHVnaW5zLmZpbHRlcihwID0+XG5cdFx0XHRwLmNhdGVnb3J5ID09PSAnbmljZS10by1oYXZlJyAmJiBpbnN0YWxsZWRQbHVnaW5JZHMuaW5jbHVkZXMocC5pZCkgJiYgIWlnbm9yZWRQbHVnaW5zLmluY2x1ZGVzKHAuaWQpXG5cdFx0KS5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcblxuXHRcdC8vIEVzc2VudGlhbCBQbHVnaW5zIERldGFpbHNcblx0XHRpZiAoZXNzZW50aWFsUGx1Z2lucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBkZXRhaWxzID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2RldGFpbHMnLCB7IGF0dHI6IHsgc3R5bGU6ICdtYXJnaW4tYm90dG9tOiAxcmVtOycgfSB9KTtcblx0XHRcdGRldGFpbHMuY3JlYXRlRWwoJ3N1bW1hcnknLCB7XG5cdFx0XHRcdHRleHQ6IGBFc3NlbnRpYWwgcGx1Z2lucyAoJHtlc3NlbnRpYWxQbHVnaW5zLmxlbmd0aH0gZm91bmQpYCxcblx0XHRcdFx0YXR0cjogeyBzdHlsZTogJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjdXJzb3I6IHBvaW50ZXI7IHBhZGRpbmc6IDAuNXJlbSAwOycgfVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBkZXRhaWxzLmNyZWF0ZURpdih7IGF0dHI6IHsgc3R5bGU6ICdwYWRkaW5nOiAwLjVyZW0gMC41cmVtIDAuNXJlbSAxLjVyZW07IGJvcmRlci1sZWZ0OiAycHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpOycgfSB9KTtcblx0XHRcdGZvciAoY29uc3QgcGx1Z2luIG9mIGVzc2VudGlhbFBsdWdpbnMpIHtcblx0XHRcdFx0dGhpcy5yZW5kZXJQbHVnaW5TdGF0dXMoY29udGVudCwgcGx1Z2luLCBwbHVnaW5zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBOaWNlIHRvIEhhdmUgUGx1Z2lucyBEZXRhaWxzXG5cdFx0aWYgKG5pY2VUb0hhdmVQbHVnaW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IGRldGFpbHMgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGV0YWlscycsIHsgYXR0cjogeyBzdHlsZTogJ21hcmdpbi1ib3R0b206IDJyZW07JyB9IH0pO1xuXHRcdFx0ZGV0YWlscy5jcmVhdGVFbCgnc3VtbWFyeScsIHtcblx0XHRcdFx0dGV4dDogYE5pY2UgdG8gaGF2ZSBwbHVnaW5zICgke25pY2VUb0hhdmVQbHVnaW5zLmxlbmd0aH0gZm91bmQpYCxcblx0XHRcdFx0YXR0cjogeyBzdHlsZTogJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjdXJzb3I6IHBvaW50ZXI7IHBhZGRpbmc6IDAuNXJlbSAwOycgfVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBkZXRhaWxzLmNyZWF0ZURpdih7IGF0dHI6IHsgc3R5bGU6ICdwYWRkaW5nOiAwLjVyZW0gMC41cmVtIDAuNXJlbSAxLjVyZW07IGJvcmRlci1sZWZ0OiAycHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpOycgfSB9KTtcblx0XHRcdGZvciAoY29uc3QgcGx1Z2luIG9mIG5pY2VUb0hhdmVQbHVnaW5zKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyUGx1Z2luU3RhdHVzKGNvbnRlbnQsIHBsdWdpbiwgcGx1Z2lucyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGVzc2VudGlhbFBsdWdpbnMubGVuZ3RoID09PSAwICYmIG5pY2VUb0hhdmVQbHVnaW5zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdObyBWYXVsdCBDTVMgcGx1Z2lucyBkZXRlY3RlZC4nIH0pO1xuXHRcdH1cblxuXHRcdC8vIC0tLSBNZXJnZWQgRWRpdGluZyBUb29sYmFyIFNlY3Rpb24gLS0tXG5cdFx0Y29uc3QgdG9vbGJhckRpdiA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7XG5cdFx0XHRhdHRyOiB7IHN0eWxlOiAnbWFyZ2luLXRvcDogMXJlbTsgcGFkZGluZy10b3A6IDFyZW07IGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcik7JyB9XG5cdFx0fSk7XG5cblx0XHRuZXcgU2V0dGluZyh0b29sYmFyRGl2KVxuXHRcdFx0LnNldE5hbWUoJ0VuYWJsZSBFZGl0aW5nIFRvb2xiYXInKVxuXHRcdFx0LnNldERlc2MoJ1Nob3cgdGhlIHZpc3VhbCBlZGl0aW5nIHRvb2xiYXIgZm9yIGZvcm1hdHRpbmcgdGV4dCcpXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXIpXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVFZGl0aW5nVG9vbGJhciA9IHZhbHVlO1xuXHRcdFx0XHR9KSk7XG5cdH1cblxuXHRwcml2YXRlIHJlbmRlclBsdWdpblN0YXR1cyhjb250YWluZXI6IEhUTUxFbGVtZW50LCBwbHVnaW46IFBsdWdpbkluZm8sIHBsdWdpbnM6IGFueSkge1xuXHRcdGNvbnN0IHBsdWdpbkluc3RhbmNlID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbi5pZF07XG5cdFx0Y29uc3QgaXNJbnN0YWxsZWQgPSAhIXBsdWdpbkluc3RhbmNlO1xuXHRcdGNvbnN0IHBsdWdpbkluc3RhbmNlVHlwZWQgPSBwbHVnaW5JbnN0YW5jZSBhcyB7IGVuYWJsZWQ/OiBib29sZWFuIH0gfCB1bmRlZmluZWQ7XG5cdFx0Y29uc3QgaXNDdXJyZW50bHlFbmFibGVkID0gcGx1Z2lucz8uZW5hYmxlZFBsdWdpbnM/Lmhhcz8uKHBsdWdpbi5pZCkgPz8gcGx1Z2luSW5zdGFuY2VUeXBlZD8uZW5hYmxlZCA/PyBmYWxzZTtcblxuXHRcdC8vIFN5bmMgc3RhdGUgd2l0aCBhY3R1YWwgcGx1Z2luIHN0YXRlXG5cdFx0aWYgKGlzSW5zdGFsbGVkICYmIGlzQ3VycmVudGx5RW5hYmxlZCkge1xuXHRcdFx0aWYgKCF0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5pZCkpIHtcblx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5wdXNoKHBsdWdpbi5pZCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucyA9IHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zLmZpbHRlcihwID0+IHAgIT09IHBsdWdpbi5pZCk7XG5cdFx0fSBlbHNlIGlmIChpc0luc3RhbGxlZCAmJiAhaXNDdXJyZW50bHlFbmFibGVkKSB7XG5cdFx0XHR0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zID0gdGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5maWx0ZXIocCA9PiBwICE9PSBwbHVnaW4uaWQpO1xuXHRcdFx0aWYgKCF0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uaWQpKSB7XG5cdFx0XHRcdHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zLnB1c2gocGx1Z2luLmlkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBzZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyKVxuXHRcdFx0LnNldE5hbWUocGx1Z2luLm5hbWUpXG5cdFx0XHQuc2V0RGVzYyhpc0N1cnJlbnRseUVuYWJsZWQgPyAnSW5zdGFsbGVkIGFuZCBlbmFibGVkJyA6ICdJbnN0YWxsZWQgYnV0IGRpc2FibGVkJyk7XG5cblx0XHRzZXR0aW5nLm5hbWVFbC5zdHlsZS5mb250U2l6ZSA9ICcwLjllbSc7XG5cdFx0c2V0dGluZy5kZXNjRWwuc3R5bGUuZm9udFNpemUgPSAnMC44ZW0nO1xuXG5cdFx0Y29uc3QgaWNvbkNvbnRhaW5lciA9IHNldHRpbmcuY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy1wbHVnaW4tc3RhdHVzJyB9KTtcblx0XHRpZiAoaXNDdXJyZW50bHlFbmFibGVkKSB7XG5cdFx0XHRzZXRJY29uKGljb25Db250YWluZXIsICdsdWNpZGUtY2hlY2stY2lyY2xlLTInKTtcblx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgY29sb3I6ICd2YXIoLS10ZXh0LXN1Y2Nlc3MpJyB9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0SWNvbihpY29uQ29udGFpbmVyLCAnbHVjaWRlLXgtY2lyY2xlJyk7XG5cdFx0XHRzZXRDc3NQcm9wcyhpY29uQ29udGFpbmVyLCB7IGNvbG9yOiAndmFyKC0tdGV4dC1lcnJvciknIH0pO1xuXHRcdH1cblx0fVxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ09wdGlvbmFsIFBsdWdpbnMnO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ0NvbmZpZ3VyZSBvcHRpb25hbCBwbHVnaW5zIGFuZCBkZXRlY3Rpb24nO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxuZXhwb3J0IGNsYXNzIFBsdWdpbk1hbmFnZXIge1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGVuYWJsZVBsdWdpbihwbHVnaW5JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHsgZW5hYmxlZD86IGJvb2xlYW4gfT47IGVuYWJsZVBsdWdpbj86IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IH0gfSkucGx1Z2lucztcclxuXHRcdGlmICghcGx1Z2lucykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcGx1Z2luID0gcGx1Z2lucy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0aWYgKHBsdWdpbiAmJiAhcGx1Z2luLmVuYWJsZWQpIHtcclxuXHRcdFx0YXdhaXQgcGx1Z2lucy5lbmFibGVQbHVnaW4/LihwbHVnaW5JZCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRhc3luYyBkaXNhYmxlUGx1Z2luKHBsdWdpbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogeyBwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgeyBlbmFibGVkPzogYm9vbGVhbiB9PjsgZGlzYWJsZVBsdWdpbj86IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IH0gfSkucGx1Z2lucztcclxuXHRcdGlmICghcGx1Z2lucykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcGx1Z2luID0gcGx1Z2lucy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0aWYgKHBsdWdpbiAmJiBwbHVnaW4uZW5hYmxlZCkge1xyXG5cdFx0XHRhd2FpdCBwbHVnaW5zLmRpc2FibGVQbHVnaW4/LihwbHVnaW5JZCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRhc3luYyBzZXRQbHVnaW5TdGF0ZXMoZW5hYmxlZDogc3RyaW5nW10sIGRpc2FibGVkOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Ly8gRmlsdGVyIG91dCBjb3JlIHBsdWdpbnMgZnJvbSBkaXNhYmxlZCBsaXN0IGp1c3QgaW4gY2FzZVxyXG5cdFx0Y29uc3QgY29yZVBsdWdpbnMgPSBbJ2Jhc2VzLWNtcycsICdhc3Ryby1jb21wb3NlcicsICd2YXVsdC1jbXMnXTtcclxuXHRcdGNvbnN0IHNhZmVEaXNhYmxlZCA9IGRpc2FibGVkLmZpbHRlcihwID0+ICFjb3JlUGx1Z2lucy5pbmNsdWRlcyhwKSk7XHJcblxyXG5cdFx0Ly8gRGlzYWJsZSBwbHVnaW5zIGZpcnN0XHJcblx0XHRmb3IgKGNvbnN0IHBsdWdpbklkIG9mIHNhZmVEaXNhYmxlZCkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmRpc2FibGVQbHVnaW4ocGx1Z2luSWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZW4gZW5hYmxlIHBsdWdpbnNcclxuXHRcdGZvciAoY29uc3QgcGx1Z2luSWQgb2YgZW5hYmxlZCkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmVuYWJsZVBsdWdpbihwbHVnaW5JZCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXRQcmVzZXRQbHVnaW5zKHByZXNldDogJ3ZhbmlsbGEnIHwgJ29waW5pb25hdGVkJyB8ICdjdXN0b20nKTogeyBlbmFibGVkOiBzdHJpbmdbXTsgZGlzYWJsZWQ6IHN0cmluZ1tdIH0ge1xyXG5cdFx0Ly8gQ29yZSBwbHVnaW5zIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBlbmFibGVkIChub3Qgb3B0aW9uYWwpXHJcblx0XHRjb25zdCBjb3JlUGx1Z2lucyA9IFtcclxuXHRcdFx0J2FzdHJvLWNvbXBvc2VyJyxcclxuXHRcdFx0J2Jhc2VzLWNtcycsXHJcblx0XHRcdCdob21lcGFnZScsXHJcblx0XHRcdCduZXctdGFiLWRlZmF1bHQtcGFnZScsXHJcblx0XHRcdCdwcm9wZXJ0eS1vdmVyLWZpbGUtbmFtZScsXHJcblx0XHRcdCdzZXR0aW5ncy1zZWFyY2gnLFxyXG5cdFx0XHQnc3RhdHVzYmFyLW9yZ2FuaXplcicsXHJcblx0XHRcdCdzZW8nLFxyXG5cdFx0XHQndWktdHdlYWtlcicsXHJcblx0XHRcdCd6ZW5tb2RlJyxcclxuXHRcdFx0J2NtZHInLFxyXG5cdFx0XHQnc2ltcGxlLWZvY3VzJyxcclxuXHRcdFx0J3RhZy13cmFuZ2xlcidcclxuXHRcdF07XHJcblxyXG5cdFx0Ly8gT3B0aW9uYWwgcGx1Z2lucyB0aGF0IGNhbiBiZSBlbmFibGVkL2Rpc2FibGVkXHJcblx0XHRjb25zdCBvcHRpb25hbFBsdWdpbnMgPSBbXHJcblx0XHRcdCdlZGl0aW5nLXRvb2xiYXInLFxyXG5cdFx0XHQnaW5zZXJ0LXVuc3BsYXNoLWltYWdlJyxcclxuXHRcdFx0J2N1c3RvbS1zYXZlJyxcclxuXHRcdFx0J3RpdGxlLW9ubHktdGFiJyxcclxuXHRcdFx0J29ic2lkaWFuLXBhc3RlLWltYWdlLXJlbmFtZScsXHJcblx0XHRcdCdvYnNpZGlhbjQyLWJyYXQnLFxyXG5cdFx0XHQnb2JzaWRpYW4taGlkZXInLFxyXG5cdFx0XHQnZGlzYWJsZS10YWJzJyxcclxuXHRcdFx0J29ic2lkaWFuLXN0eWxlLXNldHRpbmdzJyxcclxuXHRcdFx0J21keC1hcy1tZC1vYnNpZGlhbicsXHJcblx0XHRcdCdleHBsb3Jlci1mb2N1cydcclxuXHRcdF07XHJcblxyXG5cdFx0Ly8gT3BpbmlvbmF0ZWQtc3BlY2lmaWMgcGx1Z2luc1xyXG5cdFx0Y29uc3Qgb3BpbmlvbmF0ZWRQbHVnaW5zID0gW1xyXG5cdFx0XHQnb2JzaWRpYW4tb3h5Z2VuJyxcclxuXHRcdFx0J29ic2lkaWFuLXN0eWxlLXNldHRpbmdzJ1xyXG5cdFx0XTtcclxuXHJcblx0XHRpZiAocHJlc2V0ID09PSAndmFuaWxsYScpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRlbmFibGVkOiBbLi4uY29yZVBsdWdpbnMsIC4uLm9wdGlvbmFsUGx1Z2lucy5maWx0ZXIocCA9PiAhb3BpbmlvbmF0ZWRQbHVnaW5zLmluY2x1ZGVzKHApKV0sXHJcblx0XHRcdFx0ZGlzYWJsZWQ6IG9waW5pb25hdGVkUGx1Z2luc1xyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmIChwcmVzZXQgPT09ICdvcGluaW9uYXRlZCcpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRlbmFibGVkOiBbLi4uY29yZVBsdWdpbnMsIC4uLm9wdGlvbmFsUGx1Z2luc10sXHJcblx0XHRcdFx0ZGlzYWJsZWQ6IFtdXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBDdXN0b20gLSByZXR1cm4gYWxsIGFzIGF2YWlsYWJsZVxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGVuYWJsZWQ6IFtdLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBbXVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZywgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgUHJvamVjdE9wdGltaXplciB9IGZyb20gJy4uLy4uL3V0aWxzL1Byb2plY3RPcHRpbWl6ZXInO1xuXG5leHBvcnQgY2xhc3MgSWdub3JlU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcblx0cHJpdmF0ZSBvcHRpbWl6ZXI6IFByb2plY3RPcHRpbWl6ZXI7XG5cdHByaXZhdGUgZ2l0U2V0dGluZzogU2V0dGluZztcblx0cHJpdmF0ZSB2aXRlU2V0dGluZzogU2V0dGluZztcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xuXHRcdHN1cGVyKGFwcCwgY29udGFpbmVyRWwsIHN0YXRlLCBvbk5leHQsIG9uQmFjaywgb25DYW5jZWwpO1xuXHRcdHRoaXMub3B0aW1pemVyID0gbmV3IFByb2plY3RPcHRpbWl6ZXIoYXBwLCBzdGF0ZSk7XG5cdH1cblxuXHRhc3luYyBkaXNwbGF5KCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMub3B0aW1pemVyLmdldFN0YXR1cygpO1xuXHRcdHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnLmdpdElnbm9yZUNvbmZpZ3VyZWQgPSBzdGF0dXMuZ2l0SWdub3JlU3RhdHVzID09PSAnY29uZmlndXJlZCc7XG5cdFx0dGhpcy5zdGF0ZS5pZ25vcmVDb25maWcudml0ZUlnbm9yZUNvbmZpZ3VyZWQgPSBzdGF0dXMudml0ZUlnbm9yZVN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUHJvamVjdCBvcHRpbWl6YXRpb24gKG9wdGlvbmFsKScgfSk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG5cdFx0XHR0ZXh0OiAnT3B0aW1pemUgeW91ciBwcm9qZWN0IGJ5IGlnbm9yaW5nIE9ic2lkaWFuLXNwZWNpZmljIGZpbGVzIGluIEdpdCBhbmQgVml0ZS4nXG5cdFx0fSk7XG5cblx0XHQvLyBHaXQgSWdub3JlIFNldHRpbmdcblx0XHR0aGlzLmdpdFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCk7XG5cdFx0dGhpcy51cGRhdGVHaXRTZXR0aW5nKHN0YXR1cy5naXRJZ25vcmVTdGF0dXMpO1xuXG5cdFx0Ly8gVml0ZSBJZ25vcmUgU2V0dGluZ1xuXHRcdHRoaXMudml0ZVNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCk7XG5cdFx0dGhpcy51cGRhdGVWaXRlU2V0dGluZyhzdGF0dXMudml0ZUlnbm9yZVN0YXR1cyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUdpdFNldHRpbmcoc3RhdHVzOiAnY29uZmlndXJlZCcgfCAnbm90LWNvbmZpZ3VyZWQnKSB7XG5cdFx0dGhpcy5naXRTZXR0aW5nLnNldE5hbWUoJ0lnbm9yZSB3b3Jrc3BhY2UgZmlsZXMgaW4gR2l0Jylcblx0XHRcdC5zZXREZXNjKCdBZGQgT2JzaWRpYW4gd29ya3NwYWNlIGZpbGVzIHRvIC5naXRpZ25vcmUgdG8gcHJldmVudCB0aGVtIGZyb20gYmVpbmcgdHJhY2tlZC4nKVxuXHRcdFx0LmNsZWFyKCk7IC8vIENsZWFyIGV4aXN0aW5nIGJ1dHRvbnMgYW5kIHN0YXR1c1xuXG5cdFx0dGhpcy5naXRTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuXHRcdFx0YnV0dG9uLnNldEJ1dHRvblRleHQoc3RhdHVzID09PSAnY29uZmlndXJlZCcgPyAnUmUtY29uZmlndXJlJyA6ICdDb25maWd1cmUnKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMub3B0aW1pemVyLmNvbmZpZ3VyZUdpdElnbm9yZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5pZ25vcmVDb25maWcuZ2l0SWdub3JlQ29uZmlndXJlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCcuZ2l0aWdub3JlIHVwZGF0ZWQnKTtcblx0XHRcdFx0XHRcdGNvbnN0IG5ld1N0YXR1cyA9IGF3YWl0IHRoaXMub3B0aW1pemVyLmdldFN0YXR1cygpO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGVHaXRTZXR0aW5nKG5ld1N0YXR1cy5naXRJZ25vcmVTdGF0dXMpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gdXBkYXRlIC5naXRpZ25vcmU6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9wdGltaXplci5yZW5kZXJTdGF0dXModGhpcy5naXRTZXR0aW5nLmNvbnRyb2xFbCwgc3RhdHVzKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlVml0ZVNldHRpbmcoc3RhdHVzOiAnY29uZmlndXJlZCcgfCAnbm90LWNvbmZpZ3VyZWQnKSB7XG5cdFx0dGhpcy52aXRlU2V0dGluZy5zZXROYW1lKCdJZ25vcmUgd29ya3NwYWNlIGFuZCBIb21lIEJhc2UgZm9sZGVycyBpbiBWaXRlJylcblx0XHRcdC5zZXREZXNjKCdDb25maWd1cmUgVml0ZSB0byBpZ25vcmUgT2JzaWRpYW4gYW5kIEhvbWUgQmFzZSBmb2xkZXJzLicpXG5cdFx0XHQuY2xlYXIoKTsgLy8gQ2xlYXIgZXhpc3RpbmcgYnV0dG9ucyBhbmQgc3RhdHVzXG5cblx0XHR0aGlzLnZpdGVTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuXHRcdFx0YnV0dG9uLnNldEJ1dHRvblRleHQoc3RhdHVzID09PSAnY29uZmlndXJlZCcgPyAnUmUtY29uZmlndXJlJyA6ICdDb25maWd1cmUnKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMub3B0aW1pemVyLmNvbmZpZ3VyZVZpdGVJZ25vcmUoKTtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnLnZpdGVJZ25vcmVDb25maWd1cmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1ZpdGUgb3B0aW1pemF0aW9uIGFwcGxpZWQnKTtcblx0XHRcdFx0XHRcdGNvbnN0IG5ld1N0YXR1cyA9IGF3YWl0IHRoaXMub3B0aW1pemVyLmdldFN0YXR1cygpO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGVWaXRlU2V0dGluZyhuZXdTdGF0dXMudml0ZUlnbm9yZVN0YXR1cyk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byB1cGRhdGUgVml0ZSBjb25maWc6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9wdGltaXplci5yZW5kZXJTdGF0dXModGhpcy52aXRlU2V0dGluZy5jb250cm9sRWwsIHN0YXR1cyk7XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdQcm9qZWN0IG9wdGltaXphdGlvbiAob3B0aW9uYWwpJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb25maWd1cmUgcHJvamVjdC1sZXZlbCBpZ25vcmVzJztcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXMgLS0gTm9kZS5qcyBtb2R1bGUgbmVlZGVkIGZvciBwYXRoIG9wZXJhdGlvbnNcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzIC0tIE5vZGUuanMgbW9kdWxlIG5lZWRlZCBmb3IgZmlsZSBvcGVyYXRpb25zXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpbWl6YXRpb25TdGF0dXMge1xuXHRnaXRJZ25vcmVTdGF0dXM6ICdjb25maWd1cmVkJyB8ICdub3QtY29uZmlndXJlZCc7XG5cdHZpdGVJZ25vcmVTdGF0dXM6ICdjb25maWd1cmVkJyB8ICdub3QtY29uZmlndXJlZCc7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wc1xuICovXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0T3B0aW1pemVyIHtcblx0cHJpdmF0ZSBhcHA6IEFwcDtcblx0cHJpdmF0ZSBzdGF0ZTogV2l6YXJkU3RhdGU7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHN0YXRlOiBXaXphcmRTdGF0ZSkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMuc3RhdGUgPSBzdGF0ZTtcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBnZXRTdGF0dXMoKTogUHJvbWlzZTxPcHRpbWl6YXRpb25TdGF0dXM+IHtcblx0XHRjb25zdCBzdGF0dXM6IE9wdGltaXphdGlvblN0YXR1cyA9IHtcblx0XHRcdGdpdElnbm9yZVN0YXR1czogJ25vdC1jb25maWd1cmVkJyxcblx0XHRcdHZpdGVJZ25vcmVTdGF0dXM6ICdub3QtY29uZmlndXJlZCdcblx0XHR9O1xuXG5cdFx0Y29uc3QgcHJvamVjdFJvb3QgPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290O1xuXHRcdGlmICghcHJvamVjdFJvb3QpIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IE5vIHByb2plY3RSb290IGluIHN0YXRlJyk7XG5cdFx0XHRyZXR1cm4gc3RhdHVzO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcjtcblx0XHRjb25zb2xlLmRlYnVnKCdbVmF1bHQgQ01TXSBQcm9qZWN0T3B0aW1pemVyOiBDaGVja2luZyBzdGF0dXMgZm9yIHJvb3Q6JywgcHJvamVjdFJvb3QsICdjb25maWdEaXI6JywgY29uZmlnRGlyKTtcblxuXHRcdC8vIENoZWNrIC5naXRpZ25vcmVcblx0XHRjb25zdCBnaXRJZ25vcmVQYXRoID0gcGF0aC5qb2luKHByb2plY3RSb290LCAnLmdpdGlnbm9yZScpO1xuXHRcdGlmIChmcy5leGlzdHNTeW5jKGdpdElnbm9yZVBhdGgpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGdpdElnbm9yZVBhdGgsICd1dGY4Jyk7XG5cdFx0XHRjb25zdCBpc0NvbmZpZ3VyZWQgPSBjb250ZW50LmluY2x1ZGVzKGAke2NvbmZpZ0Rpcn0vd29ya3NwYWNlLmpzb25gKSB8fCBjb250ZW50LmluY2x1ZGVzKGAqKi8ke2NvbmZpZ0Rpcn0vd29ya3NwYWNlLmpzb25gKTtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IC5naXRpZ25vcmUgZXhpc3RzLCBjb25maWd1cmVkOicsIGlzQ29uZmlndXJlZCk7XG5cdFx0XHRpZiAoaXNDb25maWd1cmVkKSB7XG5cdFx0XHRcdHN0YXR1cy5naXRJZ25vcmVTdGF0dXMgPSAnY29uZmlndXJlZCc7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IC5naXRpZ25vcmUgTk9UIGZvdW5kIGF0OicsIGdpdElnbm9yZVBhdGgpO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIFZpdGUgY29uZmlnXG5cdFx0Y29uc3QgYXN0cm9Db25maWdOYW1lcyA9IFsnYXN0cm8uY29uZmlnLnRzJywgJ2FzdHJvLmNvbmZpZy5tanMnLCAnYXN0cm8uY29uZmlnLmpzJywgJ2FzdHJvLmNvbmZpZy5tdHMnLCAnYXN0cm8uY29uZmlnLmNqcyddO1xuXHRcdGxldCByZXNvbHZlZFZpdGVDb25maWdQYXRoID0gJyc7XG5cblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgYXN0cm9Db25maWdOYW1lcykge1xuXHRcdFx0Y29uc3QgcCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgbmFtZSk7XG5cdFx0XHRpZiAoZnMuZXhpc3RzU3luYyhwKSkge1xuXHRcdFx0XHRyZXNvbHZlZFZpdGVDb25maWdQYXRoID0gcDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFyZXNvbHZlZFZpdGVDb25maWdQYXRoICYmIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8uY29uZmlnRmlsZVBhdGgpIHtcblx0XHRcdHJlc29sdmVkVml0ZUNvbmZpZ1BhdGggPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGg7XG5cdFx0fVxuXG5cdFx0aWYgKHJlc29sdmVkVml0ZUNvbmZpZ1BhdGggJiYgZnMuZXhpc3RzU3luYyhyZXNvbHZlZFZpdGVDb25maWdQYXRoKSkge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogQ2hlY2tpbmcgVml0ZSBjb25maWcgYXQ6JywgcmVzb2x2ZWRWaXRlQ29uZmlnUGF0aCk7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHJlc29sdmVkVml0ZUNvbmZpZ1BhdGgsICd1dGY4Jyk7XG5cdFx0XHRjb25zdCBoYXNXYXRjaElnbm9yZWQgPSBjb250ZW50LmluY2x1ZGVzKCdzZXJ2ZXIud2F0Y2guaWdub3JlZCcpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ2lnbm9yZWQ6Jyk7XG5cdFx0XHRjb25zdCBoYXNDb25maWdEaXIgPSBjb250ZW50LmluY2x1ZGVzKGNvbmZpZ0Rpcik7XG5cdFx0XHRjb25zdCBoYXNCYXNlc1BhdHRlcm4gPSBjb250ZW50LmluY2x1ZGVzKCdiYXNlcycpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ2hvbWUnKSB8fCBjb250ZW50LmluY2x1ZGVzKCdiYXNlJyk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdbVmF1bHQgQ01TXSBQcm9qZWN0T3B0aW1pemVyOiBWaXRlIGNvbmZpZyBoYXMgcGF0dGVybnM6JywgeyBoYXNXYXRjaElnbm9yZWQsIGhhc0NvbmZpZ0RpciwgaGFzQmFzZXNQYXR0ZXJuIH0pO1xuXHRcdFx0aWYgKGhhc1dhdGNoSWdub3JlZCAmJiAoaGFzQ29uZmlnRGlyIHx8IGhhc0Jhc2VzUGF0dGVybikpIHtcblx0XHRcdFx0c3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMgPSAnY29uZmlndXJlZCc7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IE5vIHZhbGlkIEFzdHJvIGNvbmZpZyBmb3VuZCB0byBjaGVjaycpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdGF0dXM7XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgY29uZmlndXJlR2l0SWdub3JlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGNvbnN0IHByb2plY3RSb290ID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdDtcblx0XHRpZiAoIXByb2plY3RSb290KSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdbVmF1bHQgQ01TXSBQcm9qZWN0T3B0aW1pemVyOiBObyBwcm9qZWN0Um9vdCBmb3IgR2l0IGNvbmZpZ3VyYXRpb24nKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XG5cdFx0Y29uc3QgZ2l0SWdub3JlUGF0aCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgJy5naXRpZ25vcmUnKTtcblx0XHRjb25zdCBydWxlcyA9IGBcXG4jIE9ic2lkaWFuIHdvcmtzcGFjZSBmaWxlc1xcbioqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvblxcbioqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UtbW9iaWxlLmpzb25cXG5gO1xuXG5cdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogQ29uZmlndXJpbmcgR2l0IGlnbm9yZSBhdDonLCBnaXRJZ25vcmVQYXRoKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoZnMuZXhpc3RzU3luYyhnaXRJZ25vcmVQYXRoKSkge1xuXHRcdFx0XHRsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhnaXRJZ25vcmVQYXRoLCAndXRmOCcpO1xuXHRcdFx0XHRjb25zdCBoYXNOZXdQYXR0ZXJuID0gY29udGVudC5pbmNsdWRlcyhgKiovJHtjb25maWdEaXJ9L3dvcmtzcGFjZS5qc29uYCk7XG5cdFx0XHRcdGNvbnN0IGhhc09sZFBhdHRlcm4gPSBjb250ZW50LmluY2x1ZGVzKGAqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvbmApIHx8IGNvbnRlbnQuaW5jbHVkZXMoYCR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvbmApO1xuXG5cdFx0XHRcdGlmIChoYXNPbGRQYXR0ZXJuICYmICFoYXNOZXdQYXR0ZXJuKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogVXBkYXRpbmcgb2xkIEdpdCBwYXR0ZXJucycpO1xuXHRcdFx0XHRcdC8vIFJlcGxhY2Ugb2xkIHBhdHRlcm5zIGlmIHRoZXkgZXhpc3Rcblx0XHRcdFx0XHRjb250ZW50ID0gY29udGVudC5yZXBsYWNlKG5ldyBSZWdFeHAoYFxcXFwqPy8/JHtjb25maWdEaXJ9L3dvcmtzcGFjZVxcXFwuanNvbmAsICdnJyksIGAqKi8ke2NvbmZpZ0Rpcn0vd29ya3NwYWNlLmpzb25gKTtcblx0XHRcdFx0XHRjb250ZW50ID0gY29udGVudC5yZXBsYWNlKG5ldyBSZWdFeHAoYFxcXFwqPy8/JHtjb25maWdEaXJ9L3dvcmtzcGFjZS1tb2JpbGVcXFxcLmpzb25gLCAnZycpLCBgKiovJHtjb25maWdEaXJ9L3dvcmtzcGFjZS1tb2JpbGUuanNvbmApO1xuXHRcdFx0XHRcdGZzLndyaXRlRmlsZVN5bmMoZ2l0SWdub3JlUGF0aCwgY29udGVudCwgJ3V0ZjgnKTtcblx0XHRcdFx0fSBlbHNlIGlmICghaGFzTmV3UGF0dGVybikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IEFkZGluZyBuZXcgR2l0IHBhdHRlcm5zJyk7XG5cdFx0XHRcdFx0Ly8gQWRkIG5ldyBydWxlcyBpZiBuZWl0aGVyIHBhdHRlcm4gZXhpc3RzXG5cdFx0XHRcdFx0Y29udGVudCArPSBydWxlcztcblx0XHRcdFx0XHRmcy53cml0ZUZpbGVTeW5jKGdpdElnbm9yZVBhdGgsIGNvbnRlbnQsICd1dGY4Jyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogR2l0IHBhdHRlcm5zIGFscmVhZHkgcHJlc2VudCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdbVmF1bHQgQ01TXSBQcm9qZWN0T3B0aW1pemVyOiBDcmVhdGluZyBuZXcgLmdpdGlnbm9yZScpO1xuXHRcdFx0XHRmcy53cml0ZUZpbGVTeW5jKGdpdElnbm9yZVBhdGgsIHJ1bGVzLCAndXRmOCcpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1tWYXVsdCBDTVNdIEZhaWxlZCB0byB1cGRhdGUgLmdpdGlnbm9yZTonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgY29uZmlndXJlVml0ZUlnbm9yZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3Q7XG5cdFx0aWYgKCFwcm9qZWN0Um9vdCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXG5cdFx0Y29uc3QgYXN0cm9Db25maWdOYW1lcyA9IFsnYXN0cm8uY29uZmlnLnRzJywgJ2FzdHJvLmNvbmZpZy5tanMnLCAnYXN0cm8uY29uZmlnLmpzJywgJ2FzdHJvLmNvbmZpZy5tdHMnLCAnYXN0cm8uY29uZmlnLmNqcyddO1xuXHRcdGxldCByZXNvbHZlZENvbmZpZ1BhdGggPSAnJztcblx0XHRsZXQgY29uZmlnRmlsZU5hbWUgPSAnJztcblxuXHRcdGZvciAoY29uc3QgbmFtZSBvZiBhc3Ryb0NvbmZpZ05hbWVzKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aC5qb2luKHByb2plY3RSb290LCBuYW1lKTtcblx0XHRcdGlmIChmcy5leGlzdHNTeW5jKHApKSB7XG5cdFx0XHRcdHJlc29sdmVkQ29uZmlnUGF0aCA9IHA7XG5cdFx0XHRcdGNvbmZpZ0ZpbGVOYW1lID0gbmFtZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFyZXNvbHZlZENvbmZpZ1BhdGggJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0cmVzb2x2ZWRDb25maWdQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoO1xuXHRcdFx0Y29uZmlnRmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHJlc29sdmVkQ29uZmlnUGF0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFyZXNvbHZlZENvbmZpZ1BhdGggfHwgIWZzLmV4aXN0c1N5bmMocmVzb2x2ZWRDb25maWdQYXRoKSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignW1ZhdWx0IENNU10gUHJvamVjdE9wdGltaXplcjogVml0ZSBjb25maWcgTk9UIGZvdW5kIGluOicsIHByb2plY3RSb290KTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgQXN0cm8gY29uZmlnIGZpbGUgbm90IGZvdW5kIGluOiAke3Byb2plY3RSb290fWApO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUuZGVidWcoJ1tWYXVsdCBDTVNdIFByb2plY3RPcHRpbWl6ZXI6IENvbmZpZ3VyaW5nIFZpdGUgaWdub3JlIGF0OicsIHJlc29sdmVkQ29uZmlnUGF0aCk7XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhyZXNvbHZlZENvbmZpZ1BhdGgsICd1dGY4Jyk7XG5cblx0XHRcdGlmIChjb250ZW50LmluY2x1ZGVzKCdzZXJ2ZXIud2F0Y2guaWdub3JlZCcpICYmIGNvbnRlbnQuaW5jbHVkZXMoY29uZmlnRGlyKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXhwb3J0SWR4ID0gY29udGVudC5sYXN0SW5kZXhPZignZXhwb3J0IGRlZmF1bHQnKTtcblx0XHRcdGxldCBzdGFydEluZGV4ID0gLTE7XG5cdFx0XHRsZXQgZW5kSW5kZXggPSAtMTtcblx0XHRcdGxldCBjb25maWdCb2R5ID0gJyc7XG5cdFx0XHRsZXQgaXNXaG9sZUZpbGUgPSBmYWxzZTtcblxuXHRcdFx0aWYgKGV4cG9ydElkeCAhPT0gLTEpIHtcblx0XHRcdFx0c3RhcnRJbmRleCA9IGNvbnRlbnQuaW5kZXhPZigneycsIGV4cG9ydElkeCk7XG5cdFx0XHRcdGlmIChzdGFydEluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdGxldCBicmFjZUNvdW50ID0gMDtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChjb250ZW50W2ldID09PSAneycpIGJyYWNlQ291bnQrKztcblx0XHRcdFx0XHRcdGVsc2UgaWYgKGNvbnRlbnRbaV0gPT09ICd9JykgYnJhY2VDb3VudC0tO1xuXG5cdFx0XHRcdFx0XHRpZiAoYnJhY2VDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRlbmRJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlbmRJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdGNvbmZpZ0JvZHkgPSBjb250ZW50LnN1YnN0cmluZyhzdGFydEluZGV4ICsgMSwgZW5kSW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWNvbmZpZ0JvZHkgJiYgKGNvbnRlbnQuaW5jbHVkZXMoJ3ZpdGU6JykgfHwgY29udGVudC5pbmNsdWRlcygnc2VydmVyOicpKSkge1xuXHRcdFx0XHRjb25maWdCb2R5ID0gY29udGVudDtcblx0XHRcdFx0aXNXaG9sZUZpbGUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY29uZmlnQm9keSkge1xuXHRcdFx0XHRpZiAoY29uZmlnQm9keS5pbmNsdWRlcygndml0ZTonKSkge1xuXHRcdFx0XHRcdGlmIChjb25maWdCb2R5LmluY2x1ZGVzKCdzZXJ2ZXI6JykpIHtcblx0XHRcdFx0XHRcdGlmIChjb25maWdCb2R5LmluY2x1ZGVzKCd3YXRjaDonKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY29uZmlnQm9keS5pbmNsdWRlcygnaWdub3JlZDonKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICghY29uZmlnQm9keS5pbmNsdWRlcyhjb25maWdEaXIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBpZ25vcmVQYXR0ZXJucyA9IGAnKiovJHtjb25maWdEaXJ9LyoqJywgJyoqL19iYXNlcy8qKicsICcqKi9iYXNlcy8qKicsICcqKi9faG9tZS8qKicsICcqKi9ob21lLyoqJywgJyoqL19iYXNlLyoqJywgJyoqL2Jhc2UvKionYDtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbmZpZ0JvZHkgPSBjb25maWdCb2R5LnJlcGxhY2UoL2lnbm9yZWQ6XFxzKlxcWyhbXlxcXV0qKVxcXS8sIChfbSwgcDE6IHN0cmluZykgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBleGlzdGluZyA9IHAxLnRyaW0oKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3Qgc2VwYXJhdG9yID0gZXhpc3RpbmcgPyAnLCAnIDogJyc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBgaWdub3JlZDogWyR7ZXhpc3Rpbmd9JHtzZXBhcmF0b3J9JHtpZ25vcmVQYXR0ZXJuc31dYDtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gY29uZmlnQm9keS5yZXBsYWNlKC93YXRjaDpcXHMqXFx7LywgYHdhdGNoOiB7XFxuICAgICAgaWdub3JlZDogWycqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJywgJyoqL19ob21lLyoqJywgJyoqL2hvbWUvKionLCAnKiovX2Jhc2UvKionLCAnKiovYmFzZS8qKiddLGApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gY29uZmlnQm9keS5yZXBsYWNlKC9zZXJ2ZXI6XFxzKlxcey8sIGBzZXJ2ZXI6IHtcXG4gICAgd2F0Y2g6IHtcXG4gICAgICBpZ25vcmVkOiBbJyoqLyR7Y29uZmlnRGlyfS8qKicsICcqKi9fYmFzZXMvKionLCAnKiovYmFzZXMvKionLCAnKiovX2hvbWUvKionLCAnKiovaG9tZS8qKicsICcqKi9fYmFzZS8qKicsICcqKi9iYXNlLyoqJ11cXG4gICAgfSxgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uZmlnQm9keSA9IGNvbmZpZ0JvZHkucmVwbGFjZSgvdml0ZTpcXHMqXFx7LywgYHZpdGU6IHtcXG4gICAgc2VydmVyOiB7XFxuICAgICAgd2F0Y2g6IHtcXG4gICAgICAgIGlnbm9yZWQ6IFsnKiovJHtjb25maWdEaXJ9LyoqJywgJyoqL19iYXNlcy8qKicsICcqKi9iYXNlcy8qKicsICcqKi9faG9tZS8qKicsICcqKi9ob21lLyoqJywgJyoqL19iYXNlLyoqJywgJyoqL2Jhc2UvKionXVxcbiAgICAgIH1cXG4gICAgfSxgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGlzV2hvbGVGaWxlKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29udGVudC5pbmNsdWRlcygnZGVmaW5lQ29uZmlnJykpIHtcblx0XHRcdFx0XHRcdFx0Y29uZmlnQm9keSA9IGNvbmZpZ0JvZHkucmVwbGFjZSgvZGVmaW5lQ29uZmlnXFxzKlxcKFxccypcXHsvLCBgZGVmaW5lQ29uZmlnKHtcXG4gIHZpdGU6IHtcXG4gICAgc2VydmVyOiB7XFxuICAgICAgd2F0Y2g6IHtcXG4gICAgICAgIGlnbm9yZWQ6IFsnKiovJHtjb25maWdEaXJ9LyoqJywgJyoqL19iYXNlcy8qKicsICcqKi9iYXNlcy8qKicsICcqKi9faG9tZS8qKicsICcqKi9ob21lLyoqJywgJyoqL19iYXNlLyoqJywgJyoqL2Jhc2UvKionXVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBjbGVhciBwbGFjZSB0byBpbnNlcnQgVml0ZSBjb25maWcgaW4gJHtjb25maWdGaWxlTmFtZX0uYCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbmZpZ0JvZHkgPSBgXFxuICB2aXRlOiB7XFxuICAgIHNlcnZlcjoge1xcbiAgICAgIHdhdGNoOiB7XFxuICAgICAgICBpZ25vcmVkOiBbJyoqLyR7Y29uZmlnRGlyfS8qKicsICcqKi9fYmFzZXMvKionLCAnKiovYmFzZXMvKionLCAnKiovX2hvbWUvKionLCAnKiovaG9tZS8qKicsICcqKi9fYmFzZS8qKicsICcqKi9iYXNlLyoqJ11cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sYCArIGNvbmZpZ0JvZHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlZENvbnRlbnQgPSBpc1dob2xlRmlsZSA/IGNvbmZpZ0JvZHkgOiAoY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpICsgY29uZmlnQm9keSArIGNvbnRlbnQuc3Vic3RyaW5nKGVuZEluZGV4KSk7XG5cdFx0XHRcdGZzLndyaXRlRmlsZVN5bmMocmVzb2x2ZWRDb25maWdQYXRoLCB1cGRhdGVkQ29udGVudCwgJ3V0ZjgnKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBjb25maWd1cmF0aW9uIGluICR7Y29uZmlnRmlsZU5hbWV9LmApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBQcm9qZWN0T3B0aW1pemVyOiBFcnJvciB1cGRhdGluZyAke2NvbmZpZ0ZpbGVOYW1lfTpgLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgcmVuZGVyU3RhdHVzKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJykge1xuXHRcdGNvbnN0IHN0YXR1c0VsID0gY29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy1wbHVnaW4tc3RhdHVzJyB9KTtcblx0XHRpZiAoc3RhdHVzID09PSAnY29uZmlndXJlZCcpIHtcblx0XHRcdHNldEljb24oc3RhdHVzRWwsICdsdWNpZGUtY2hlY2stY2lyY2xlLTInKTtcblx0XHRcdHNldENzc1Byb3BzKHN0YXR1c0VsLCB7IGNvbG9yOiAndmFyKC0tdGV4dC1zdWNjZXNzKScgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldEljb24oc3RhdHVzRWwsICdsdWNpZGUtYWxlcnQtY2lyY2xlJyk7XG5cdFx0XHRzZXRDc3NQcm9wcyhzdGF0dXNFbCwgeyBjb2xvcjogJ3ZhcigtLXRleHQtd2FybmluZyknIH0pO1xuXHRcdH1cblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZywgTm90aWNlLCBCdXR0b25Db21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCAqIGFzIG9ic2lkaWFuIGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcbmltcG9ydCB7IEdpdE1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9HaXRNYW5hZ2VyJztcclxuaW1wb3J0IHsgQ29uZmlnRmx1c2hTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29uZmlnRmx1c2hTZXJ2aWNlJztcclxuaW1wb3J0IHsgU2FmZUNvbmZpZ1dyaXRlciB9IGZyb20gJy4uLy4uL3V0aWxzL1NhZmVDb25maWdXcml0ZXInO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdpdFNldHVwU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcclxuICAgIHByaXZhdGUgZ2l0TWFuYWdlcjogdHlwZW9mIEdpdE1hbmFnZXI7XHJcbiAgICBwcml2YXRlIGNvbmZpZ0ZsdXNoU2VydmljZTogQ29uZmlnRmx1c2hTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBzYWZlQ29uZmlnV3JpdGVyOiBTYWZlQ29uZmlnV3JpdGVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHN0YXRlOiBXaXphcmRTdGF0ZSwgb25OZXh0OiAoKSA9PiB2b2lkLCBvbkJhY2s6ICgpID0+IHZvaWQsIG9uQ2FuY2VsOiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCBjb250YWluZXJFbCwgc3RhdGUsIG9uTmV4dCwgb25CYWNrLCBvbkNhbmNlbCk7XHJcbiAgICAgICAgdGhpcy5naXRNYW5hZ2VyID0gR2l0TWFuYWdlcjtcclxuICAgICAgICB0aGlzLmNvbmZpZ0ZsdXNoU2VydmljZSA9IG5ldyBDb25maWdGbHVzaFNlcnZpY2UoYXBwKTtcclxuICAgICAgICB0aGlzLnNhZmVDb25maWdXcml0ZXIgPSBuZXcgU2FmZUNvbmZpZ1dyaXRlcihhcHApO1xyXG4gICAgICAgIHRoaXMuc2hvd05leHRCdXR0b24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEFic29sdXRlUHJvamVjdFJvb3QoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVJvb3QgPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290IHx8ICcuJztcclxuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHJlbGF0aXZlUm9vdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlUm9vdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIGFueTtcclxuICAgICAgICBjb25zdCB2YXVsdFJvb3QgPSBhZGFwdGVyLmdldEJhc2VQYXRoID8gYWRhcHRlci5nZXRCYXNlUGF0aCgpIDogJyc7XHJcbiAgICAgICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh2YXVsdFJvb3QsIHJlbGF0aXZlUm9vdCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0dpdCBJbnRlZ3JhdGlvbicgfSk7XHJcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XHJcbiAgICAgICAgICAgIHRleHQ6IFwiQ29ubmVjdCB5b3VyIHByb2plY3QgdG8gR2l0SHViIHRvIGVuYWJsZSBzeW5jIGFuZCBkZXBsb3ltZW50LiBOb3RlOiBpZiB5b3Ugc2tpcCB0aGlzIHN0ZXAsIHRoZSBEZXBsb3ltZW50IHN0ZXAgd2lsbCBhbHNvIGJlIHNraXBwZWQuXCIsXHJcbiAgICAgICAgICAgIGF0dHI6IHsgc3R5bGU6ICdmb250LXN0eWxlOiBpdGFsaWM7IG9wYWNpdHk6IDAuODsgbWFyZ2luLWJvdHRvbTogMnJlbTsnIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdFJvb3QgPSB0aGlzLmdldEFic29sdXRlUHJvamVjdFJvb3QoKTtcclxuXHJcbiAgICAgICAgLy8gMS4gU3RhdGljIExheW91dCBFbGVtZW50cyAoUmVuZGVyZWQgSW1tZWRpYXRlbHkpXHJcbiAgICAgICAgY29uc3Qgcm9vdEluZm8gPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdnaXQtcm9vdC1pbmZvJywgYXR0cjogeyBzdHlsZTogJ21hcmdpbi1ib3R0b206IDFyZW07JyB9IH0pO1xyXG4gICAgICAgIHJvb3RJbmZvLmNyZWF0ZUVsKCdiJywgeyB0ZXh0OiAnUHJvamVjdCBSb290OiAnIH0pO1xyXG4gICAgICAgIHJvb3RJbmZvLmNyZWF0ZVNwYW4oeyB0ZXh0OiBwcm9qZWN0Um9vdCB9KTtcclxuXHJcbiAgICAgICAgLy8gUGxhY2Vob2xkZXIgZm9yIGR5bmFtaWMgc3RhdHVzXHJcbiAgICAgICAgY29uc3Qgc3RhdHVzRWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICBjbHM6ICdnaXQtc3RhdHVzLW1lc3NhZ2UnLFxyXG4gICAgICAgICAgICBhdHRyOiB7IHN0eWxlOiAnbWFyZ2luLWJvdHRvbTogMnJlbTsgcGFkZGluZzogMXJlbTsgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpOyBib3JkZXItcmFkaXVzOiA0cHg7IG1pbi1oZWlnaHQ6IDUwcHg7JyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RhdHVzRWwuY3JlYXRlRWwoJ2knLCB7IHRleHQ6ICdDaGVja2luZyBHaXQgc3RhdHVzLi4uJywgYXR0cjogeyBzdHlsZTogJ29wYWNpdHk6IDAuNTsnIH0gfSk7XHJcblxyXG4gICAgICAgIC8vIDIuIEZldGNoIGRhdGEgKEFzeW5jKVxyXG4gICAgICAgIGxldCBpc1JlcG8gPSBmYWxzZTtcclxuICAgICAgICBsZXQgcmVtb3RlVXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBpZiAocHJvamVjdFJvb3QpIHtcclxuICAgICAgICAgICAgaXNSZXBvID0gYXdhaXQgdGhpcy5naXRNYW5hZ2VyLmlzUmVwbyhwcm9qZWN0Um9vdCk7XHJcbiAgICAgICAgICAgIGlmIChpc1JlcG8pIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVVybCA9IGF3YWl0IHRoaXMuZ2l0TWFuYWdlci5nZXRSZW1vdGVVcmwocHJvamVjdFJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAzLiBVcGRhdGUgRHluYW1pYyBMYXlvdXRcclxuICAgICAgICBzdGF0dXNFbC5lbXB0eSgpO1xyXG4gICAgICAgIGlmIChpc1JlcG8pIHtcclxuICAgICAgICAgICAgc3RhdHVzRWwuY3JlYXRlRWwoJ2InLCB7IHRleHQ6ICdTdGF0dXM6ICcgfSk7XHJcbiAgICAgICAgICAgIHN0YXR1c0VsLmNyZWF0ZVNwYW4oe1xyXG4gICAgICAgICAgICAgICAgdGV4dDogJ0dpdCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicsXHJcbiAgICAgICAgICAgICAgICBhdHRyOiB7IHN0eWxlOiAnY29sb3I6IHZhcigtLXRleHQtc3VjY2Vzcyk7IGZvbnQtd2VpZ2h0OiBib2xkOycgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZW1vdGVVcmwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUVsID0gc3RhdHVzRWwuY3JlYXRlRGl2KHsgYXR0cjogeyBzdHlsZTogJ21hcmdpbi10b3A6IDAuNXJlbTsnIH0gfSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdGVFbC5jcmVhdGVFbCgnYicsIHsgdGV4dDogJ1JlbW90ZTogJyB9KTtcclxuICAgICAgICAgICAgICAgIHJlbW90ZUVsLmNyZWF0ZVNwYW4oeyB0ZXh0OiByZW1vdGVVcmwgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0dXNFbC5jcmVhdGVFbCgnYicsIHsgdGV4dDogJ1N0YXR1czogJyB9KTtcclxuICAgICAgICAgICAgc3RhdHVzRWwuY3JlYXRlU3Bhbih7IHRleHQ6ICdOb3QgYSBHaXQgcmVwb3NpdG9yeS4nIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBDb250YWluZXJcclxuICAgICAgICBjb25zdCBjb25maWdDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdnaXQtY29uZmlnLWNvbnRhaW5lcicgfSk7XHJcblxyXG4gICAgICAgIGxldCBzZXR1cENvbnRlbnQ6IEhUTUxFbGVtZW50ID0gY29uZmlnQ29udGFpbmVyO1xyXG5cclxuICAgICAgICBpZiAoaXNSZXBvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBjb25maWdDb250YWluZXIuY3JlYXRlRWwoJ2RldGFpbHMnLCB7IGF0dHI6IHsgc3R5bGU6ICdtYXJnaW4tYm90dG9tOiAycmVtOycgfSB9KTtcclxuICAgICAgICAgICAgZGV0YWlscy5jcmVhdGVFbCgnc3VtbWFyeScsIHtcclxuICAgICAgICAgICAgICAgIHRleHQ6ICdVcGRhdGUgU2V0dGluZ3MnLFxyXG4gICAgICAgICAgICAgICAgYXR0cjogeyBzdHlsZTogJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjdXJzb3I6IHBvaW50ZXI7IHBhZGRpbmc6IDAuNXJlbSAwOyBvcGFjaXR5OiAwLjg7JyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXR1cENvbnRlbnQgPSBkZXRhaWxzLmNyZWF0ZURpdih7IGF0dHI6IHsgc3R5bGU6ICdwYWRkaW5nOiAxcmVtOyBib3JkZXItbGVmdDogMnB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKTsnIH0gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gc2V0dXBDb250ZW50LmNyZWF0ZURpdih7IGNsczogJ2dpdC1pbnN0cnVjdGlvbnMnIH0pO1xyXG4gICAgICAgIGluc3RydWN0aW9ucy5jcmVhdGVFbCgncCcsIHtcclxuICAgICAgICAgICAgdGV4dDogJ0Nvbm5lY3QgeW91ciBwcm9qZWN0IHRvIEdpdEh1YiB0byBwdWJsaXNoIHlvdXIgc2l0ZS4gQ2xpY2sgXCJTa2lwXCIgdG8gc2tpcCBHaXQgc2V0dXAgbm93IGFuZCBzZXQgaXQgdXAgbGF0ZXIuJ1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBnaXREb3dubG9hZCA9IGluc3RydWN0aW9ucy5jcmVhdGVFbCgncCcpO1xyXG4gICAgICAgIGdpdERvd25sb2FkLmNyZWF0ZVNwYW4oeyB0ZXh0OiAnMS4gJyB9KTtcclxuICAgICAgICBnaXREb3dubG9hZC5jcmVhdGVFbCgnYScsIHtcclxuICAgICAgICAgICAgdGV4dDogJ0Rvd25sb2FkIGFuZCBpbnN0YWxsIEdpdCcsXHJcbiAgICAgICAgICAgIGhyZWY6ICdodHRwczovL2dpdC1zY20uY29tLydcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9rZW5MaW5rID0gaW5zdHJ1Y3Rpb25zLmNyZWF0ZUVsKCdwJyk7XHJcbiAgICAgICAgdG9rZW5MaW5rLmNyZWF0ZVNwYW4oeyB0ZXh0OiAnMi4gJyB9KTtcclxuICAgICAgICB0b2tlbkxpbmsuY3JlYXRlRWwoJ2EnLCB7XHJcbiAgICAgICAgICAgIHRleHQ6ICdHZW5lcmF0ZSBhIG5ldyBHaXRIdWIgUGVyc29uYWwgYWNjZXNzIHRva2VuJyxcclxuICAgICAgICAgICAgaHJlZjogYGh0dHBzOi8vZ2l0aHViLmNvbS9zZXR0aW5ncy90b2tlbnMvbmV3P3Njb3Blcz1yZXBvJmRlc2NyaXB0aW9uPSR7ZW5jb2RlVVJJQ29tcG9uZW50KCh0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvTmFtZSB8fCAnUHJvamVjdCcpICsgJyAoVmF1bHQgQ01TKScpfWBcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9rZW5IZWxwID0gaW5zdHJ1Y3Rpb25zLmNyZWF0ZUVsKCd1bCcpO1xyXG4gICAgICAgIHRva2VuSGVscC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6IGBTZXQgYSBOb3RlIChlLmcuLCBcIiR7dGhpcy5zdGF0ZS5naXRDb25maWcucmVwb05hbWUgfHwgJ1Byb2plY3QnfSAoVmF1bHQgQ01TKVwiKWAgfSk7XHJcbiAgICAgICAgdG9rZW5IZWxwLmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ1NldCBFeHBpcmF0aW9uIHRvIFwiTm8gZXhwaXJhdGlvblwiJyB9KTtcclxuICAgICAgICB0b2tlbkhlbHAuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnQ2hlY2sgdGhlIFwicmVwb1wiIGJveCAoc28gYWxsIHRvcCBvcHRpb25zIGFyZSBzZWxlY3RlZCknIH0pO1xyXG4gICAgICAgIHRva2VuSGVscC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdDbGljayBcIkdlbmVyYXRlIHRva2VuXCIgYXQgdGhlIGJvdHRvbSwgY29weSBpdCwgYW5kIHBhc3RlIGl0IGJlbG93LicgfSk7XHJcblxyXG4gICAgICAgIGlmICghcmVtb3RlVXJsKSB7XHJcbiAgICAgICAgICAgIHNldHVwQ29udGVudC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6IGlzUmVwbyA/ICdDb25uZWN0IHRvIEdpdEh1YicgOiAnQ3JlYXRlIE5ldyBSZXBvc2l0b3J5JyB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXR1cENvbnRlbnQuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnVXBkYXRlIEdpdEh1YiBDb25uZWN0aW9uJyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdpdEh1YiBQQVQgU2V0dGluZ1xyXG4gICAgICAgIGNvbnN0IHBhdFNldHRpbmcgPSBuZXcgU2V0dGluZyhzZXR1cENvbnRlbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdHaXRIdWIgUGVyc29uYWwgQWNjZXNzIFRva2VuJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1N0b3JlZCBzZWN1cmVseSBpbiBPYnNpZGlhbiBTZWNyZXRzLicpXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oJ2xpbmsnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdHZW5lcmF0ZSBhIG5ldyBQZXJzb25hbCBhY2Nlc3MgdG9rZW4gb24gR2l0SHViJylcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KCh0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvTmFtZSB8fCAnUHJvamVjdCcpICsgJyAoVmF1bHQgQ01TKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihgaHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucy9uZXc/c2NvcGVzPXJlcG8mZGVzY3JpcHRpb249JHtkZXNjcmlwdGlvbn1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlY3JldElkID0gJ3ZhdWx0LWNtcy1naXRodWItcGF0JztcclxuICAgICAgICBsZXQgc2VjcmV0VmFsdWUgPSAodGhpcy5hcHAgYXMgYW55KS5zZWNyZXRTdG9yYWdlPy5nZXRTZWNyZXQoc2VjcmV0SWQpO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgc3RhdGUgaXMgc3luY2VkIHdpdGggc2VjcmV0IHN0b3JhZ2Ugb24gbW91bnRcclxuICAgICAgICBpZiAoc2VjcmV0VmFsdWUgJiYgIXRoaXMuc3RhdGUuZ2l0Q29uZmlnLnBhdCkge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIFwiZ2hvc3RcIiBkYXZpZHZraW1iYWxsIGlmIGl0J3Mgc3RhbGVcclxuICAgICAgICAgICAgLy8gQnV0IGlmIGl0J3MgdGhlcmUsIHdlIGtlZXAgaXQgZm9yIHRoZSBTeW5jIGJ1dHRvbi5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhdFNldHRpbmcuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignZ2hwX3h4eHh4eHh4eHh4eCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2VjcmV0VmFsdWUgPyAnKioqKioqKionIDogJycpIC8vIFNob3cgZG90cyBpZiB3ZSBoYXZlIGEgc2F2ZWQgc2VjcmV0XHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnBhdCA9IHZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0ZXh0LmlucHV0RWwudHlwZSA9ICdwYXNzd29yZCc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhdFN0YXR1cyA9IHNldHVwQ29udGVudC5jcmVhdGVEaXYoeyBjbHM6ICdwYXQtc3RhdHVzLWluZm8nLCBhdHRyOiB7IHN0eWxlOiAnbWFyZ2luLWJvdHRvbTogMXJlbTsgZm9udC1zaXplOiAwLjllbTsgY29sb3I6IHZhcigtLXRleHQtbXV0ZWQpOycgfSB9KTtcclxuICAgICAgICBpZiAoc2VjcmV0VmFsdWUpIHtcclxuICAgICAgICAgICAgcGF0U3RhdHVzLmNyZWF0ZVNwYW4oeyB0ZXh0OiAnXHUyNzEzIExpbmtlZCB0byBPYnNpZGlhbiBTZWNyZXQ6ICcsIGF0dHI6IHsgc3R5bGU6ICdjb2xvcjogdmFyKC0tdGV4dC1zdWNjZXNzKTsgZm9udC13ZWlnaHQ6IGJvbGQ7JyB9IH0pO1xyXG4gICAgICAgICAgICBwYXRTdGF0dXMuY3JlYXRlU3Bhbih7IHRleHQ6IHNlY3JldElkIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGF0U2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1ZlcmlmeSBUb2tlbicpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gUmVzb2x2ZSBUb2tlblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHRoaXMuc3RhdGUuZ2l0Q29uZmlnLnBhdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpZWxkIGlzIGJsYW5rLCBjb250YWlucyBkb3RzLCBvciB0aGUgSUQgc3RyaW5nLCBwdWxsIGZyb20gc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4gPT09ICcqKioqKioqKicgfHwgdG9rZW4gPT09ICd2YXVsdC1jbXMtZ2l0aHViLXBhdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAodGhpcy5hcHAgYXMgYW55KS5zZWNyZXRTdG9yYWdlPy5nZXRTZWNyZXQoJ3ZhdWx0LWNtcy1naXRodWItcGF0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBlbnRlciBvciBwYXN0ZSB5b3VyIEdpdEh1YiBQZXJzb25hbCBBY2Nlc3MgVG9rZW4uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdWZXJpZnlpbmcuLi4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0U3RhdHVzLmVtcHR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBhd2FpdCB0aGlzLmdpdE1hbmFnZXIudmVyaWZ5VG9rZW4odG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRva2VuIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseSBhcyAke3VzZXJuYW1lfSFgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdFN0YXR1cy5jcmVhdGVTcGFuKHsgdGV4dDogYFx1MjcxMyBWZXJpZmllZCBhcyBgLCBhdHRyOiB7IHN0eWxlOiAnY29sb3I6IHZhcigtLXRleHQtc3VjY2Vzcyk7JyB9IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0U3RhdHVzLmNyZWF0ZUVsKCdiJywgeyB0ZXh0OiB1c2VybmFtZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuYXBwIGFzIGFueSkuc2VjcmV0U3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0ICh0aGlzLmFwcCBhcyBhbnkpLnNlY3JldFN0b3JhZ2Uuc2V0U2VjcmV0KCd2YXVsdC1jbXMtZ2l0aHViLXBhdCcsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBzdGFuZGFyZCBsb2NhbFN0b3JhZ2UgZGlyZWN0bHkgaWYgdGhpcy5hcHAuc2F2ZUxvY2FsU3RvcmFnZSBpcyBtaXNzaW5nL2Jyb2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5hcHAgYXMgYW55KS5zYXZlTG9jYWxTdG9yYWdlKCdvYnNpZGlhbi1naXQ6dXNlcm5hbWUnLCB1c2VybmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ29ic2lkaWFuLWdpdDp1c2VybmFtZScsIHVzZXJuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1ZlcmlmaWVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uRWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3ZhcigtLWludGVyYWN0aXZlLWFjY2VudCknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnN0eWxlLmNvbG9yID0gJ3ZhcigtLXRleHQtb24tYWNjZW50KSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdJbnZhbGlkIHRva2VuIG9yIEdpdEh1YiBBUEkgZXJyb3IuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRTdGF0dXMuY3JlYXRlU3Bhbih7IHRleHQ6ICdcdTI3MTcgSW52YWxpZCB0b2tlbiBvciBHaXRIdWIgQVBJIGVycm9yLicsIGF0dHI6IHsgc3R5bGU6ICdjb2xvcjogdmFyKC0tdGV4dC1lcnJvcik7JyB9IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1ZlcmlmeSBUb2tlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnVmVyaWZpY2F0aW9uIGZhaWxlZC4gQ2hlY2sgeW91ciBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRTdGF0dXMuY3JlYXRlU3Bhbih7IHRleHQ6ICdcdTI3MTcgVmVyaWZpY2F0aW9uIGZhaWxlZC4gQ2hlY2sgeW91ciBjb25uZWN0aW9uLicsIGF0dHI6IHsgc3R5bGU6ICdjb2xvcjogdmFyKC0tdGV4dC1lcnJvcik7JyB9IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnVmVyaWZ5IFRva2VuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFJlcG8gY3JlYXRpb24gc2V0dGluZ3NcclxuICAgICAgICBuZXcgU2V0dGluZyhzZXR1cENvbnRlbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKHJlbW90ZVVybCA/ICdOZXcgUmVwb3NpdG9yeSBOYW1lJyA6ICdSZXBvc2l0b3J5IE5hbWUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIG5hbWUgb2YgeW91ciBHaXRIdWIgcmVwb3NpdG9yeS4nKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHROYW1lID0gcHJvamVjdFJvb3QgPyBwcm9qZWN0Um9vdC5zcGxpdCgvW1xcXFwvXS8pLnBvcCgpIDogJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSB0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvTmFtZSB8fCBkZWZhdWx0TmFtZSB8fCAnJztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQcm9hY3RpdmVseSBzZXQgdGhlIHN0YXRlIHNvIGl0J3Mgbm90IGVtcHR5IGlmIHRoZSB1c2VyIGRvZXNuJ3QgY2hhbmdlIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZ2l0Q29uZmlnLnJlcG9OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcucmVwb05hbWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignbXktYmxvZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGluaXRpYWxWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvTmFtZSA9IHZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKHNldHVwQ29udGVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0Rlc2NyaXB0aW9uJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0Egc2hvcnQgZGVzY3JpcHRpb24gZm9yIHlvdXIgcmVwb3NpdG9yeS4nKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ015IHBlcnNvbmFsIGJsb2cnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnN0YXRlLmdpdENvbmZpZy5yZXBvRGVzY3JpcHRpb24gfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcucmVwb0Rlc2NyaXB0aW9uID0gdmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoc2V0dXBDb250ZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJpdmF0ZSBSZXBvc2l0b3J5JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0tlZXAgdGhpcyByZXBvc2l0b3J5IHByaXZhdGUgYW5kIGhpZGRlbiBmcm9tIHRoZSBwdWJsaWMuJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmlzUHJpdmF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdpdENvbmZpZy5pc1ByaXZhdGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEJyYW5jaCBOYW1lXHJcbiAgICAgICAgbmV3IFNldHRpbmcoc2V0dXBDb250ZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGVmYXVsdCBCcmFuY2gnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIG5hbWUgb2YgdGhlIGluaXRpYWwgYnJhbmNoIChlLmcuLCBcIm1haW5cIiBvciBcIm1hc3RlclwiKS4nKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxCcmFuY2ggPSB0aGlzLnN0YXRlLmdpdENvbmZpZy5icmFuY2hOYW1lIHx8ICdtYWluJztcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5naXRDb25maWcuYnJhbmNoTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmJyYW5jaE5hbWUgPSBpbml0aWFsQnJhbmNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignbWFpbicpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGluaXRpYWxCcmFuY2gpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcuYnJhbmNoTmFtZSA9IHZhbHVlLnRyaW0oKSB8fCAnbWFpbic7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBdXRvLWNvbmZpZ3VyZSBvYnNpZGlhbi1naXRcclxuICAgICAgICBuZXcgU2V0dGluZyhzZXR1cENvbnRlbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdBdXRvLWNvbmZpZ3VyZSBHaXQgcGx1Z2luJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0F1dG9tYXRpY2FsbHkgc2V0IHVwIHRoZSBcIkdpdFwiIHBsdWdpbiB0byB3b3JrIHdpdGggdGhpcyBwcm9qZWN0LicpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHtcclxuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnN0YXRlLmdpdENvbmZpZy5hdXRvQ29uZmlndXJlT2JzaWRpYW5HaXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5naXRDb25maWcuYXV0b0NvbmZpZ3VyZU9ic2lkaWFuR2l0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBY3Rpb24gQnV0dG9uXHJcbiAgICAgICAgY29uc3QgYWN0aW9uQ29udGFpbmVyID0gc2V0dXBDb250ZW50LmNyZWF0ZURpdih7IGNsczogJ2dpdC1hY3Rpb24tY29udGFpbmVyJywgYXR0cjogeyBzdHlsZTogJ21hcmdpbi10b3A6IDJyZW07JyB9IH0pO1xyXG4gICAgICAgIGxldCBidXR0b25UZXh0ID0gaXNSZXBvID8gKHJlbW90ZVVybCA/ICdVcGRhdGUgUmVtb3RlICYgUHVzaCcgOiAnQ29ubmVjdCB0byBHaXRIdWInKSA6ICdJbml0aWFsaXplICYgUHVzaCB0byBHaXRIdWInO1xyXG5cclxuICAgICAgICBjb25zdCBjcmVhdGVCdG4gPSBuZXcgQnV0dG9uQ29tcG9uZW50KGFjdGlvbkNvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoYnV0dG9uVGV4dClcclxuICAgICAgICAgICAgLnNldEN0YSgpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlR2l0U2V0dXAoY3JlYXRlQnRuLCBpc1JlcG8sICEhcmVtb3RlVXJsKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbmZpZ0NvbnRhaW5lci5jcmVhdGVFbCgncCcsIHtcclxuICAgICAgICAgICAgY2xzOiAnZ2l0LXNraXAtaW5mbycsXHJcbiAgICAgICAgICAgIGF0dHI6IHsgc3R5bGU6ICdmb250LXNpemU6IDAuOGVtOyBjb2xvcjogdmFyKC0tdGV4dC1tdXRlZCk7IG1hcmdpbi10b3A6IDFyZW07IGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcik7IHBhZGRpbmctdG9wOiAxcmVtOycgfSxcclxuICAgICAgICAgICAgdGV4dDogJ0NsaWNrIFwiU2tpcFwiIHRvIHNraXAgR2l0IHNldHVwLidcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBoYXNBZHZhbmNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlR2l0U2V0dXAoYnV0dG9uOiBCdXR0b25Db21wb25lbnQsIGFscmVhZHlSZXBvOiBib29sZWFuLCBhbHJlYWR5SGFzUmVtb3RlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQWR2YW5jZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHsgcGF0IH0gPSB0aGlzLnN0YXRlLmdpdENvbmZpZztcclxuICAgICAgICBjb25zdCB7IHJlcG9OYW1lLCByZXBvRGVzY3JpcHRpb24sIGlzUHJpdmF0ZSwgYnJhbmNoTmFtZSB9ID0gdGhpcy5zdGF0ZS5naXRDb25maWc7XHJcbiAgICAgICAgY29uc3QgcHJvamVjdFJvb3QgPSB0aGlzLmdldEFic29sdXRlUHJvamVjdFJvb3QoKTtcclxuICAgICAgICBjb25zdCBicmFuY2ggPSBicmFuY2hOYW1lIHx8ICdtYWluJztcclxuXHJcbiAgICAgICAgLy8gMS4gUmVzb2x2ZSBUb2tlbjogU3RhdGUgKGZyZXNoIGVudHJ5KSAtPiBTZWNyZXQgU3RvcmFnZSAobWFzay9JRCBjaGVjaykgLT4gTnVsbFxyXG4gICAgICAgIGlmICghcGF0IHx8IHBhdCA9PT0gJyoqKioqKioqJyB8fCBwYXQgPT09ICd2YXVsdC1jbXMtZ2l0aHViLXBhdCcpIHtcclxuICAgICAgICAgICAgcGF0ID0gKHRoaXMuYXBwIGFzIGFueSkuc2VjcmV0U3RvcmFnZT8uZ2V0U2VjcmV0KCd2YXVsdC1jbXMtZ2l0aHViLXBhdCcpIHx8IHBhdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGF0O1xyXG5cclxuICAgICAgICBpZiAoIXRva2VuIHx8IHRva2VuID09PSAnKioqKioqKionIHx8IHRva2VuID09PSAndmF1bHQtY21zLWdpdGh1Yi1wYXQnIHx8ICFwcm9qZWN0Um9vdCkge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIFRva2VuIGFuZCBlbnN1cmUgcHJvamVjdCByb290IGlzIGRldGVjdGVkLicpO1xyXG4gICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWFscmVhZHlIYXNSZW1vdGUgJiYgIXJlcG9OYW1lKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBwcm92aWRlIGEgUmVwb3NpdG9yeSBOYW1lLicpO1xyXG4gICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoYWxyZWFkeUhhc1JlbW90ZSA/ICdVcGRhdGluZy4uLicgOiAnSW5pdGlhbGl6aW5nLi4uJyk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIDEuIEdpdCBJbml0IChvbmx5IGlmIG5vdCBhbHJlYWR5IGEgcmVwbylcclxuICAgICAgICAgICAgaWYgKCFhbHJlYWR5UmVwbykge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5naXRNYW5hZ2VyLmluaXRSZXBvKHByb2plY3RSb290KTtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0xvY2FsIEdpdCByZXBvc2l0b3J5IGluaXRpYWxpemVkLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAyLiBDcmVhdGUgR2l0SHViIFJlcG8gJiBTZXQgUmVtb3RlXHJcbiAgICAgICAgICAgIC8vIElmIGFscmVhZHkgaGFzIHJlbW90ZSwgd2UgY3JlYXRlIGEgTkVXIHJlcG8gYW5kIFVQREFURSB0aGUgcmVtb3RlXHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYWxyZWFkeUhhc1JlbW90ZSA/ICdDcmVhdGluZyBuZXcgR2l0SHViIHJlcG9zaXRvcnkuLi4nIDogJ0NyZWF0aW5nIEdpdEh1YiByZXBvc2l0b3J5Li4uJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcG9JbmZvID0gYXdhaXQgdGhpcy5naXRNYW5hZ2VyLmNyZWF0ZUdpdEh1YlJlcG8odG9rZW4sIHJlcG9OYW1lISwgcmVwb0Rlc2NyaXB0aW9uIHx8ICcnLCBpc1ByaXZhdGUpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5naXRNYW5hZ2VyLnNldFJlbW90ZShwcm9qZWN0Um9vdCwgcmVwb0luZm8uY2xvbmVfdXJsKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgU3VjY2Vzc2Z1bGx5ICR7YWxyZWFkeUhhc1JlbW90ZSA/ICd1cGRhdGVkJyA6ICdjb25uZWN0ZWQnfSB0byAke3JlcG9JbmZvLmh0bWxfdXJsfWApO1xyXG5cclxuICAgICAgICAgICAgLy8gMy4gRWFybHkgRmx1c2g6IFNhdmUgY29uZmlndXJhdGlvbnMgdG8gZGlzayBCRUZPUkUgY29tbWl0dGluZ1xyXG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIGluaXRpYWwgY29tbWl0IGNvbnRhaW5zIHRoZSB1c2VyJ3Mgd2l6YXJkIHNldHRpbmdzXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbmZpZ0ZsdXNoU2VydmljZS5mbHVzaCh0aGlzLnN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdFNldHVwU3RlcDogRWFybHkgY29uZmlndXJhdGlvbiBmbHVzaCBzdWNjZXNzZnVsJyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGZsdXNoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignR2l0U2V0dXBTdGVwOiBFYXJseSBjb25maWd1cmF0aW9uIGZsdXNoIGZhaWxlZCwgYnV0IGNvbnRpbnVpbmcgd2l0aCBzeW5jOicsIGZsdXNoRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5naXRNYW5hZ2VyLmluaXRpYWxDb21taXRBbmRQdXNoKHByb2plY3RSb290LCBicmFuY2gsICdvcmlnaW4nLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdTdWNjZXNzZnVsbHkgc3luY2VkIHdpdGggR2l0SHViIScpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChwdXNoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N5bmMgZmFpbGVkOicsIHB1c2hFcnJvcik7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdJbml0aWFsIHN5bmMgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHlvdSBoYXZlIEdpdCBjb25maWd1cmVkIGxvY2FsbHkgYW5kIHlvdXIgY3JlZGVudGlhbHMgYXJlIHNldCB1cCAoZS5nLiBHaXQgQ3JlZGVudGlhbCBNYW5hZ2VyKS4nKTtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IHRocm93LCBsZXQgdGhlbSBmaW5pc2ggc2V0dXAgYW5kIHN5bmMgbWFudWFsbHkgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDQuIENvbmZpZ3VyZSBPYnNpZGlhbiBHaXRcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmF1dG9Db25maWd1cmVPYnNpZGlhbkdpdCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25maWd1cmVPYnNpZGlhbkdpdCh0b2tlbiwgcHJvamVjdFJvb3QsIGJyYW5jaCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDUuIFNlY3VyZWx5IHNhdmUgdG9rZW4gaWYgaXQgd2FzIGp1c3QgZW50ZXJlZFxyXG4gICAgICAgICAgICBpZiAocGF0ICYmICh0aGlzLmFwcCBhcyBhbnkpLnNlY3JldFN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0ICh0aGlzLmFwcCBhcyBhbnkpLnNlY3JldFN0b3JhZ2Uuc2V0U2VjcmV0KCd2YXVsdC1jbXMtZ2l0aHViLXBhdCcsIHBhdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFyIHBsYWluLXRleHQgUEFUIGZyb20gc3RhdGUgYmVmb3JlIGZpbmlzaGluZ1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmdpdENvbmZpZy5wYXQgPSAnJztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2l0Q29uZmlnLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnU3VjY2VzcyEnKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZSgnR2l0IHNldHVwIGNvbXBsZXRlIScpO1xyXG5cclxuICAgICAgICAgICAgLy8gQXV0by1hZHZhbmNlIGFmdGVyIHNtYWxsIGRlbGF5XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBZHZhbmNlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNBZHZhbmNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25OZXh0KCksIDE1MDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dpdCBpbnRlZ3JhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFNldHVwIGZhaWxlZDogJHtlcnJvck1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KGFscmVhZHlIYXNSZW1vdGUgPyAnVXBkYXRlIFNldHRpbmdzICYgU3luYycgOiAnSW5pdGlhbGl6ZSAmIFB1c2ggdG8gR2l0SHViJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgY29uZmlndXJlT2JzaWRpYW5HaXQocGF0OiBzdHJpbmcsIHByb2plY3RSb290OiBzdHJpbmcsIGJyYW5jaDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnR2l0U2V0dXBTdGVwOiBDb25maWd1cmluZyBPYnNpZGlhbiBHaXQgcGx1Z2luLi4uJyk7XHJcblxyXG4gICAgICAgIC8vIDEuIFNldCBjcmVkZW50aWFscyBpbiBsb2NhbFN0b3JhZ2UgKHN0YW5kYXJkIGZhbGxiYWNrIGZvciBPYnNpZGlhbiBHaXQpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgKHRoaXMuYXBwIGFzIGFueSkuc2F2ZUxvY2FsU3RvcmFnZSgnb2JzaWRpYW4tZ2l0OnBhc3N3b3JkJywgcGF0KTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdvYnNpZGlhbi1naXQ6cGFzc3dvcmQnLCBwYXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgYW55O1xyXG4gICAgICAgIGNvbnN0IHZhdWx0Um9vdCA9IGFkYXB0ZXIuZ2V0QmFzZVBhdGggPyBhZGFwdGVyLmdldEJhc2VQYXRoKCkgOiAnJztcclxuXHJcbiAgICAgICAgaWYgKHZhdWx0Um9vdCAmJiBwcm9qZWN0Um9vdCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgcHJvamVjdFJvb3QgaXMgYWJzb2x1dGUgZm9yIGNvbXBhcmlzb25cclxuICAgICAgICAgICAgY29uc3QgYWJzb2x1dGVQcm9qZWN0Um9vdCA9IHBhdGguaXNBYnNvbHV0ZShwcm9qZWN0Um9vdCkgPyBwcm9qZWN0Um9vdCA6IHBhdGgucmVzb2x2ZSh2YXVsdFJvb3QsIHByb2plY3RSb290KTtcclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZSh2YXVsdFJvb3QsIGFic29sdXRlUHJvamVjdFJvb3QpLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ1VwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlUGF0aDogcmVsYXRpdmVQYXRoIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgZ2l0UmVtb3RlOiAnb3JpZ2luJyxcclxuICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6ICdvcmlnaW4nLCAvLyBTb21lIHZlcnNpb25zIHVzZSB0aGlzXHJcbiAgICAgICAgICAgICAgICBtYWluQnJhbmNoOiBicmFuY2gsXHJcbiAgICAgICAgICAgICAgICBicmFuY2g6IGJyYW5jaCwgICAgICAgLy8gU29tZSB2ZXJzaW9ucyB1c2UgdGhpc1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJlbW90ZTogJ29yaWdpbidcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIDIuIFVwZGF0ZSBzZXR0aW5ncyBpbi1tZW1vcnkgaWYgdGhlIHBsdWdpbiBpcyBhbHJlYWR5IGxvYWRlZFxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBtb3N0IHJlbGlhYmxlIHdheSB0byBwcmV2ZW50IHByb21wdHMgZnJvbSBhIHJ1bm5pbmcgcGx1Z2luXHJcbiAgICAgICAgICAgIGNvbnN0IGdpdFBsdWdpbiA9ICh0aGlzLmFwcCBhcyBhbnkpLnBsdWdpbnM/LmdldFBsdWdpbignb2JzaWRpYW4tZ2l0Jyk7XHJcbiAgICAgICAgICAgIGlmIChnaXRQbHVnaW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0dpdFNldHVwU3RlcDogRm91bmQgcnVubmluZyBPYnNpZGlhbiBHaXQgcGx1Z2luLCB1cGRhdGluZyBpbi1tZW1vcnkgc2V0dGluZ3MnKTtcclxuICAgICAgICAgICAgICAgIGdpdFBsdWdpbi5zZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5naXRQbHVnaW4uc2V0dGluZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnVXBkYXRlc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2l0UGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGdpdFBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMy4gQWx3YXlzIG1lcmdlL3dyaXRlIHRvIGRhdGEuanNvbiBhcyBhIHBlcnNpc3RlbnQgZmFsbGJhY2tcclxuICAgICAgICAgICAgLy8gV2UgdXNlIG1lcmdlQ29uZmlnIHdoaWNoIGhhbmRsZXMgaXQgZXZlbiBpZiBkYXRhLmpzb24gZG9lc24ndCBleGlzdCB5ZXRcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYWZlQ29uZmlnV3JpdGVyLm1lcmdlQ29uZmlnKCdvYnNpZGlhbi1naXQnLCBjb25maWdVcGRhdGVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5ldyBOb3RpY2UoJ09ic2lkaWFuIEdpdCBwbHVnaW4gY29uZmlndXJlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICB2YWxpZGF0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gT3B0aW9uYWwgc3RlcFxyXG4gICAgfVxyXG5cclxuICAgIGdldFRpdGxlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuICdHaXQgSW50ZWdyYXRpb24nO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuICdDb25uZWN0IHRvIEdpdEh1Yic7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBDb250ZW50VHlwZUNvbmZpZywgRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLCBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgeWFtbCBmcm9tICd5YW1sJztcbmltcG9ydCB7IFBhdGhSZXNvbHZlciB9IGZyb20gJy4vUGF0aFJlc29sdmVyJztcblxuZXhwb3J0IGNsYXNzIEJhc2VzQ01TQ29uZmlndXJhdG9yIHtcblx0cHJpdmF0ZSBhcHA6IEFwcDtcblx0cHJpdmF0ZSBwYXRoUmVzb2x2ZXI6IFBhdGhSZXNvbHZlcjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMucGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcihhcHApO1xuXHR9XG5cblx0YXN5bmMgcmVzb2x2ZUJhc2VGaWxlUGF0aCgpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdGNvbnN0IGNhbmRpZGF0ZUZvbGRlcnMgPSBbJ19iYXNlcycsICdiYXNlcycsICdfaG9tZScsICdob21lJywgJ19iYXNlJywgJ2Jhc2UnXTtcblx0XHRjb25zdCBjYW5kaWRhdGVGaWxlcyA9IFsnSG9tZS5iYXNlJywgJ2hvbWUuYmFzZScsICdpbmRleC5iYXNlJ107XG5cblx0XHQvLyAxLiBDaGVjayBmb3IgZXhpc3RpbmcgZmlsZXMgZmlyc3QgKHByZWZlcnJlZCBjb21iaW5hdGlvbnMpXG5cdFx0Zm9yIChjb25zdCBmb2xkZXIgb2YgY2FuZGlkYXRlRm9sZGVycykge1xuXHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGNhbmRpZGF0ZUZpbGVzKSB7XG5cdFx0XHRcdGNvbnN0IGZ1bGxQYXRoID0gYCR7Zm9sZGVyfS8ke2ZpbGV9YDtcblx0XHRcdFx0aWYgKGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZ1bGxQYXRoKSkge1xuXHRcdFx0XHRcdHJldHVybiBmdWxsUGF0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDIuIENoZWNrIGZvciBmb2xkZXJzIGV2ZW4gaWYgZmlsZSBkb2Vzbid0IGV4aXN0ICh0byBkZWNpZGUgd2hlcmUgdG8gY3JlYXRlKVxuXHRcdGZvciAoY29uc3QgZm9sZGVyIG9mIGNhbmRpZGF0ZUZvbGRlcnMpIHtcblx0XHRcdGlmIChhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhmb2xkZXIpKSB7XG5cdFx0XHRcdHJldHVybiBgJHtmb2xkZXJ9L0hvbWUuYmFzZWA7IC8vIERlZmF1bHQgdG8gSG9tZS5iYXNlIGluIGZpcnN0IGV4aXN0aW5nIGZvbGRlciBmb3VuZFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMuIEFic29sdXRlIGRlZmF1bHRcblx0XHRyZXR1cm4gJ19iYXNlcy9Ib21lLmJhc2UnO1xuXHR9XG5cblx0YXN5bmMgY3JlYXRlT3JVcGRhdGVCYXNlRmlsZShcblx0XHRjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10sXG5cdFx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiB7IFtjb250ZW50VHlwZUlkOiBzdHJpbmddOiBGcm9udG1hdHRlclByb3BlcnRpZXMgfSxcblx0XHRkZWZhdWx0Q29udGVudFR5cGVJZD86IHN0cmluZyxcblx0XHRwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCxcblx0XHRlbmFibGVNZHhTdXBwb3J0PzogYm9vbGVhblxuXHQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBiYXNlRmlsZVBhdGggPSBhd2FpdCB0aGlzLnJlc29sdmVCYXNlRmlsZVBhdGgoKTtcblx0XHRjb25zdCBmb2xkZXJQYXRoID0gYmFzZUZpbGVQYXRoLnNwbGl0KCcvJylbMF07XG5cblx0XHQvLyBFbnN1cmUgYmFzZXMgZGlyZWN0b3J5IGV4aXN0c1xuXHRcdGNvbnN0IGJhc2VzRm9sZGVyID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlclBhdGgpO1xuXHRcdGlmICghYmFzZXNGb2xkZXIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihmb2xkZXJQYXRoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRcdC8vIEZvbGRlciBtaWdodCBhbHJlYWR5IGV4aXN0LCBpZ25vcmUgZXJyb3Jcblx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuXHRcdFx0XHRpZiAoIWVycm9yTWVzc2FnZSB8fCAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKGBCYXNlc0NNU0NvbmZpZzogQ291bGQgbm90IGNyZWF0ZSAke2ZvbGRlclBhdGh9IGZvbGRlcjpgLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiBmaWxlIGV4aXN0cyAocmUtY2hlY2sgYWZ0ZXIgZm9sZGVyIGNyZWF0aW9uKVxuXHRcdGNvbnN0IGJhc2VGaWxlQWJzdHJhY3QgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYmFzZUZpbGVQYXRoKTtcblx0XHRsZXQgYmFzZUZpbGU6IFRGaWxlIHwgbnVsbCA9IGJhc2VGaWxlQWJzdHJhY3QgaW5zdGFuY2VvZiBURmlsZSA/IGJhc2VGaWxlQWJzdHJhY3QgOiBudWxsO1xuXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBiYXNlIGZpbGUgaWYgaXQgZXhpc3RzXG5cdFx0bGV0IGV4aXN0aW5nQmFzZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsID0gbnVsbDtcblx0XHRpZiAoYmFzZUZpbGUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGJhc2VGaWxlKTtcblx0XHRcdFx0ZXhpc3RpbmdCYXNlID0geWFtbC5wYXJzZShjb250ZW50KSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Jhc2VzQ01TQ29uZmlnOiBGYWlsZWQgdG8gcGFyc2UgZXhpc3RpbmcgYmFzZSBmaWxlOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBlbmFibGVkVHlwZXMgPSBjb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xuXHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBHZW5lcmF0aW5nIGJhc2UgY29udGVudCBmb3InLCBjb250ZW50VHlwZXMubGVuZ3RoLCAnY29udGVudCB0eXBlcycpO1xuXHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBFbmFibGVkIGNvbnRlbnQgdHlwZXM6JywgZW5hYmxlZFR5cGVzLm1hcChjdCA9PiBjdC5uYW1lKSk7XG5cblx0XHRjb25zdCBiYXNlQ29udGVudCA9IHRoaXMuZ2VuZXJhdGVCYXNlQ29udGVudChjb250ZW50VHlwZXMsIGZyb250bWF0dGVyUHJvcGVydGllcywgZGVmYXVsdENvbnRlbnRUeXBlSWQsIGV4aXN0aW5nQmFzZSwgcHJvamVjdERldGVjdGlvbiwgZW5hYmxlTWR4U3VwcG9ydCk7XG5cblx0XHQvLyBDb3VudCB2aWV3cyBpbiBnZW5lcmF0ZWQgY29udGVudCB0byB2ZXJpZnkgdGhleSdyZSBiZWluZyBjcmVhdGVkXG5cdFx0Y29uc3Qgdmlld01hdGNoZXMgPSBiYXNlQ29udGVudC5tYXRjaCgvXlxccyotXFxzK3R5cGU6XFxzK2Jhc2VzLWNtcy9nbSk7XG5cdFx0Y29uc3Qgdmlld0NvdW50ID0gdmlld01hdGNoZXMgPyB2aWV3TWF0Y2hlcy5sZW5ndGggOiAwO1xuXHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBHZW5lcmF0ZWQnLCB2aWV3Q291bnQsICd2aWV3cyBpbiBiYXNlIGNvbnRlbnQnKTtcblxuXHRcdC8vIEFsd2F5cyB0cnkgdG8gbW9kaWZ5IGZpcnN0IC0gaWYgZmlsZSBkb2Vzbid0IGV4aXN0LCBtb2RpZnkgd2lsbCB0aHJvdywgdGhlbiB3ZSBjcmVhdGVcblx0XHQvLyBUaGlzIGF2b2lkcyByYWNlIGNvbmRpdGlvbnMgd2l0aCBnZXRBYnN0cmFjdEZpbGVCeVBhdGhcblx0XHRjb25zdCBiYXNlRmlsZUFic3RyYWN0MiA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChiYXNlRmlsZVBhdGgpO1xuXHRcdGJhc2VGaWxlID0gYmFzZUZpbGVBYnN0cmFjdDIgaW5zdGFuY2VvZiBURmlsZSA/IGJhc2VGaWxlQWJzdHJhY3QyIDogbnVsbDtcblxuXHRcdGlmIChiYXNlRmlsZSkge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZyhgQmFzZXNDTVNDb25maWc6IE1vZGlmeWluZyBleGlzdGluZyAke2Jhc2VGaWxlUGF0aH0gZmlsZWApO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGJhc2VGaWxlLCBiYXNlQ29udGVudCk7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYEJhc2VzQ01TQ29uZmlnOiBTdWNjZXNzZnVsbHkgbW9kaWZpZWQgJHtiYXNlRmlsZVBhdGh9IGZpbGVgKTtcblx0XHRcdFx0cmV0dXJuOyAvLyBTdWNjZXNzLCBleGl0IGVhcmx5XG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdCYXNlc0NNU0NvbmZpZzogRmFpbGVkIHRvIG1vZGlmeSBmaWxlOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlsZSBkb2Vzbid0IGV4aXN0IChvciBjYW4ndCBiZSBmb3VuZCksIHRyeSB0byBjcmVhdGUgaXRcblx0XHRjb25zb2xlLmRlYnVnKGBCYXNlc0NNU0NvbmZpZzogQ3JlYXRpbmcgbmV3ICR7YmFzZUZpbGVQYXRofSBmaWxlYCk7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShiYXNlRmlsZVBhdGgsIGJhc2VDb250ZW50KTtcblx0XHRcdGNvbnNvbGUuZGVidWcoYEJhc2VzQ01TQ29uZmlnOiBTdWNjZXNzZnVsbHkgY3JlYXRlZCAke2Jhc2VGaWxlUGF0aH0gZmlsZWApO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHQvLyBJZiBjcmVhdGUgZmFpbHMgYmVjYXVzZSBmaWxlIGV4aXN0cywgdGhlIGZpbGUgd2FzIGNyZWF0ZWQgYmV0d2VlbiBjaGVjayBhbmQgY3JlYXRlXG5cdFx0XHQvLyBUcnkgdG8gbW9kaWZ5IGl0IGRpcmVjdGx5IHVzaW5nIHRoZSBwYXRoIHN0cmluZ1xuXHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuXHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpIHx8IGVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSkge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdCYXNlc0NNU0NvbmZpZzogRmlsZSBleGlzdGVkLCBhdHRlbXB0aW5nIGRpcmVjdCBtb2RpZnkgdmlhIHBhdGgnKTtcblx0XHRcdFx0Ly8gVXNlIGFkYXB0ZXIgdG8gd3JpdGUgZGlyZWN0bHkgLSB0aGlzIGJ5cGFzc2VzIHRoZSBpbmRleGluZyBpc3N1ZVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdFx0XHRcdGlmIChhZGFwdGVyICYmIHR5cGVvZiBhZGFwdGVyLndyaXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCBhZGFwdGVyLndyaXRlKGJhc2VGaWxlUGF0aCwgYmFzZUNvbnRlbnQpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQmFzZXNDTVNDb25maWc6IFN1Y2Nlc3NmdWxseSB3cm90ZSBIb21lLmJhc2UgZmlsZSB2aWEgYWRhcHRlcicpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBGYWxsYmFjazogcmV0cnkgZ2V0QWJzdHJhY3RGaWxlQnlQYXRoIHdpdGggbG9uZ2VyIGRlbGF5c1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQmFzZXNDTVNDb25maWc6IEFkYXB0ZXIgd3JpdGUgbm90IGF2YWlsYWJsZSwgcmV0cnlpbmcgZ2V0QWJzdHJhY3RGaWxlQnlQYXRoJyk7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGVBYnN0cmFjdCA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChiYXNlRmlsZVBhdGgpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGUgPSByZXRyeUZpbGVBYnN0cmFjdCBpbnN0YW5jZW9mIFRGaWxlID8gcmV0cnlGaWxlQWJzdHJhY3QgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHRpZiAocmV0cnlGaWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KHJldHJ5RmlsZSwgYmFzZUNvbnRlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoYEJhc2VzQ01TQ29uZmlnOiBTdWNjZXNzZnVsbHkgbW9kaWZpZWQgSG9tZS5iYXNlIGZpbGUgb24gcmV0cnkgJHtpICsgMX1gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Jhc2VzQ01TQ29uZmlnOiBGaWxlIGV4aXN0cyBidXQgY2Fubm90IGJlIGZvdW5kIGFmdGVyIGFsbCByZXRyaWVzJyk7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZpbGUgZXhpc3RzIGJ1dCBjYW5ub3QgYmUgYWNjZXNzZWQuIFBsZWFzZSB0cnkgYWdhaW4gb3IgbWFudWFsbHkgZWRpdCAke2Jhc2VGaWxlUGF0aH1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKHdyaXRlRXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdCYXNlc0NNU0NvbmZpZzogRmFpbGVkIHRvIHdyaXRlIGZpbGUgdmlhIGFkYXB0ZXI6Jywgd3JpdGVFcnJvcik7XG5cdFx0XHRcdFx0dGhyb3cgd3JpdGVFcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignQmFzZXNDTVNDb25maWc6IEZhaWxlZCB0byBjcmVhdGUgYmFzZSBmaWxlOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBnZW5lcmF0ZUJhc2VDb250ZW50KFxuXHRcdGNvbnRlbnRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSxcblx0XHRmcm9udG1hdHRlclByb3BlcnRpZXM6IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEZyb250bWF0dGVyUHJvcGVydGllcyB9LFxuXHRcdGRlZmF1bHRDb250ZW50VHlwZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG5cdFx0ZXhpc3RpbmdCYXNlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IG51bGwsXG5cdFx0cHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQsXG5cdFx0ZW5hYmxlTWR4U3VwcG9ydD86IGJvb2xlYW5cblx0KTogc3RyaW5nIHtcblx0XHQvLyBCYXNlcyB1c2VzIGEgc3BlY2lmaWMgc3ludGF4IC0gd2UgbmVlZCB0byBnZW5lcmF0ZSBpdCBtYW51YWxseSB0byBtYXRjaCB0aGUgZm9ybWF0XG5cdFx0Y29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XG5cblx0XHQvLyBGaW5kIGRlZmF1bHQgY29udGVudCB0eXBlXG5cdFx0Y29uc3QgZGVmYXVsdENvbnRlbnRUeXBlID0gZGVmYXVsdENvbnRlbnRUeXBlSWQgP1xuXHRcdFx0Y29udGVudFR5cGVzLmZpbmQoY3QgPT4gY3QuaWQgPT09IGRlZmF1bHRDb250ZW50VHlwZUlkICYmIGN0LmVuYWJsZWQpIDogbnVsbDtcblxuXHRcdC8vIEFkZCBkZWZhdWx0VmlldyBwcm9wZXJ0eSBhdCB0aGUgdG9wIGxldmVsIGlmIGEgZGVmYXVsdCBjb250ZW50IHR5cGUgaXMgc2VsZWN0ZWRcblx0XHRpZiAoZGVmYXVsdENvbnRlbnRUeXBlKSB7XG5cdFx0XHRsaW5lcy5wdXNoKGBkZWZhdWx0VmlldzogXCIke2RlZmF1bHRDb250ZW50VHlwZS5uYW1lfVwiYCk7XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgZm9ybXVsYXMgaWYgdGhleSBleGlzdFxuXHRcdGlmIChleGlzdGluZ0Jhc2U/LmZvcm11bGFzKSB7XG5cdFx0XHRsaW5lcy5wdXNoKCdmb3JtdWxhczonKTtcblx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGV4aXN0aW5nQmFzZS5mb3JtdWxhcykpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICR7a2V5fTogfC1gKTtcblx0XHRcdFx0XHRjb25zdCBmb3JtdWxhTGluZXMgPSB2YWx1ZS5zcGxpdCgnXFxuJyk7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBmb3JtdWxhTGluZSBvZiBmb3JtdWxhTGluZXMpIHtcblx0XHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICAke2Zvcm11bGFMaW5lfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGluZXMucHVzaCgnJyk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVycyBzZWN0aW9uXG5cdFx0bGluZXMucHVzaCgnZmlsdGVyczonKTtcblx0XHRpZiAoZW5hYmxlTWR4U3VwcG9ydCkge1xuXHRcdFx0bGluZXMucHVzaCgnICBvcjonKTtcblx0XHRcdGxpbmVzLnB1c2goJyAgICAtIGZpbGUuZXh0ID09IFwibWRcIicpO1xuXHRcdFx0bGluZXMucHVzaCgnICAgIC0gZmlsZS5leHQgPT0gXCJtZHhcIicpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaW5lcy5wdXNoKCcgIGFuZDonKTtcblx0XHRcdGxpbmVzLnB1c2goJyAgICAtIGZpbGUuZXh0ID09IFwibWRcIicpO1xuXHRcdH1cblx0XHRsaW5lcy5wdXNoKCcnKTtcblxuXHRcdC8vIFByb3BlcnRpZXMgc2VjdGlvbiAtIGNvbGxlY3QgYWxsIHByb3BlcnRpZXMgZnJvbSBjb250ZW50IHR5cGVzXG5cdFx0Y29uc3QgYWxsUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGZvciAoY29uc3QgY29udGVudFR5cGUgb2YgY29udGVudFR5cGVzKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF07XG5cdFx0XHRpZiAocHJvcHMpIHtcblx0XHRcdFx0aWYgKHByb3BzLnRpdGxlUHJvcGVydHkpIGFsbFByb3BlcnRpZXMuYWRkKGBub3RlLiR7cHJvcHMudGl0bGVQcm9wZXJ0eX1gKTtcblx0XHRcdFx0aWYgKHByb3BzLmRhdGVQcm9wZXJ0eSkgYWxsUHJvcGVydGllcy5hZGQoYG5vdGUuJHtwcm9wcy5kYXRlUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSBhbGxQcm9wZXJ0aWVzLmFkZChgbm90ZS4ke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9YCk7XG5cdFx0XHRcdGlmIChwcm9wcy50YWdzUHJvcGVydHkpIGFsbFByb3BlcnRpZXMuYWRkKGBub3RlLiR7cHJvcHMudGFnc1Byb3BlcnR5fWApO1xuXHRcdFx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSkgYWxsUHJvcGVydGllcy5hZGQoYG5vdGUuJHtwcm9wcy5kcmFmdFByb3BlcnR5fWApO1xuXHRcdFx0XHRpZiAocHJvcHMuaW1hZ2VQcm9wZXJ0eSkgYWxsUHJvcGVydGllcy5hZGQoYG5vdGUuJHtwcm9wcy5pbWFnZVByb3BlcnR5fWApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCBjb21tb24gcHJvcGVydGllc1xuXHRcdGFsbFByb3BlcnRpZXMuYWRkKCdub3RlLnRpdGxlJyk7XG5cdFx0YWxsUHJvcGVydGllcy5hZGQoJ25vdGUuZGF0ZScpO1xuXHRcdGFsbFByb3BlcnRpZXMuYWRkKCdub3RlLnB1YkRhdGUnKTtcblx0XHRhbGxQcm9wZXJ0aWVzLmFkZCgnbm90ZS5kcmFmdCcpO1xuXHRcdGFsbFByb3BlcnRpZXMuYWRkKCdmaWxlLmZ1bGxuYW1lJyk7IC8vIEFsd2F5cyBpbmNsdWRlIGZ1bGwgZmlsZSBuYW1lXG5cdFx0YWxsUHJvcGVydGllcy5hZGQoJ2ZpbGUubmFtZScpOyAvLyBBbHNvIGluY2x1ZGUgZmlsZSBuYW1lIGZvciBjb21wYXRpYmlsaXR5XG5cblx0XHQvLyBQcmVzZXJ2ZSBmb3JtdWxhIHByb3BlcnRpZXMgaWYgdGhleSBleGlzdFxuXHRcdGlmIChleGlzdGluZ0Jhc2U/LnByb3BlcnRpZXMpIHtcblx0XHRcdGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhleGlzdGluZ0Jhc2UucHJvcGVydGllcykpIHtcblx0XHRcdFx0aWYgKHByb3Auc3RhcnRzV2l0aCgnZm9ybXVsYS4nKSkge1xuXHRcdFx0XHRcdGFsbFByb3BlcnRpZXMuYWRkKHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGFsbFByb3BlcnRpZXMuc2l6ZSA+IDApIHtcblx0XHRcdGxpbmVzLnB1c2goJ3Byb3BlcnRpZXM6Jyk7XG5cdFx0XHQvLyBQcmVzZXJ2ZSBleGlzdGluZyBwcm9wZXJ0eSBkaXNwbGF5TmFtZXMsIGVzcGVjaWFsbHkgZm9yIGZpbGUubmFtZS9mdWxsbmFtZVxuXHRcdFx0Y29uc3QgZXhpc3RpbmdQcm9wcyA9IChleGlzdGluZ0Jhc2U/LnByb3BlcnRpZXMgYXMgUmVjb3JkPHN0cmluZywgeyBkaXNwbGF5TmFtZT86IHN0cmluZyB9IHwgdW5kZWZpbmVkPikgfHwge307XG5cdFx0XHRmb3IgKGNvbnN0IHByb3Agb2YgQXJyYXkuZnJvbShhbGxQcm9wZXJ0aWVzKS5zb3J0KCkpIHtcblx0XHRcdFx0bGluZXMucHVzaChgICAke3Byb3B9OmApO1xuXHRcdFx0XHQvLyBQcmVzZXJ2ZSBleGlzdGluZyBkaXNwbGF5TmFtZSBpZiBpdCBleGlzdHMsIGVzcGVjaWFsbHkgZm9yIGZpbGUubmFtZS9mdWxsbmFtZVxuXHRcdFx0XHRjb25zdCBleGlzdGluZ1Byb3AgPSBleGlzdGluZ1Byb3BzW3Byb3BdO1xuXHRcdFx0XHRpZiAoZXhpc3RpbmdQcm9wPy5kaXNwbGF5TmFtZSkge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkaXNwbGF5TmFtZTogJHtleGlzdGluZ1Byb3AuZGlzcGxheU5hbWV9YCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvcCA9PT0gJ2ZpbGUuZnVsbG5hbWUnKSB7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAgIGRpc3BsYXlOYW1lOiBGdWxsIEZpbGUgTmFtZWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHByb3BOYW1lID0gcHJvcC5yZXBsYWNlKCdub3RlLicsICcnKS5yZXBsYWNlKCdmaWxlLicsICcnKTtcblx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgZGlzcGxheU5hbWU6ICR7dGhpcy5jYXBpdGFsaXplRmlyc3QocHJvcE5hbWUpfWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaW5lcy5wdXNoKCcnKTtcblx0XHR9XG5cblx0XHQvLyBWaWV3cyBzZWN0aW9uIC0gcHJlc2VydmUgZXhpc3Rpbmcgdmlld3MgYW5kIGFkZC91cGRhdGUgY29udGVudCB0eXBlIHZpZXdzXG5cdFx0bGluZXMucHVzaCgndmlld3M6Jyk7XG5cblx0XHRjb25zdCBleGlzdGluZ1ZpZXdzID0gKGV4aXN0aW5nQmFzZT8udmlld3MgYXMgQXJyYXk8YW55PikgfHwgW107XG5cdFx0Y29uc3Qgdmlld3NCeU5hbWUgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuXHRcdGZvciAoY29uc3QgdmlldyBvZiBleGlzdGluZ1ZpZXdzKSB7XG5cdFx0XHRpZiAodmlldy5uYW1lKSB2aWV3c0J5TmFtZS5zZXQodmlldy5uYW1lLCB2aWV3KTtcblx0XHR9XG5cblx0XHRjb25zdCBmaW5hbFZpZXdzOiBhbnlbXSA9IFtdO1xuXHRcdGNvbnN0IHByb2Nlc3NlZFZpZXdOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5cdFx0Ly8gMS4gUHJvY2VzcyBDb250ZW50IFR5cGVzIChEZWZhdWx0IEZpcnN0KVxuXHRcdGNvbnN0IGVuYWJsZWRUeXBlcyA9IGNvbnRlbnRUeXBlcy5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZCk7XG5cdFx0Y29uc3QgZGVmYXVsdFR5cGUgPSBkZWZhdWx0Q29udGVudFR5cGVJZCA/IGVuYWJsZWRUeXBlcy5maW5kKGN0ID0+IGN0LmlkID09PSBkZWZhdWx0Q29udGVudFR5cGVJZCkgOiBudWxsO1xuXHRcdGNvbnN0IG90aGVyVHlwZXMgPSBlbmFibGVkVHlwZXMuZmlsdGVyKGN0ID0+IGN0ICE9PSBkZWZhdWx0VHlwZSk7XG5cblx0XHRjb25zdCBwcm9jZXNzVHlwZSA9IChjdDogQ29udGVudFR5cGVDb25maWcpID0+IHtcblx0XHRcdGNvbnN0IHByb3BzID0gZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2N0LmlkXTtcblx0XHRcdGlmICghcHJvcHMpIHJldHVybjtcblxuXHRcdFx0Y29uc3QgZXhpc3RpbmdWaWV3ID0gdmlld3NCeU5hbWUuZ2V0KGN0Lm5hbWUpO1xuXHRcdFx0Y29uc3QgZ2VuZXJhdGVkVmlldyA9IHRoaXMuZ2VuZXJhdGVWaWV3Rm9yQ29udGVudFR5cGUoY3QsIHByb3BzLCBwcm9qZWN0RGV0ZWN0aW9uKTtcblxuXHRcdFx0aWYgKGV4aXN0aW5nVmlldykge1xuXHRcdFx0XHQvLyBPTkxZIHVwZGF0ZSBjb3JlIFwicGx1bWJpbmdcIiBwcm9wZXJ0aWVzIGZyb20gdGhlIHdpemFyZFxuXHRcdFx0XHQvLyBQcmVzZXJ2ZSBhbGwgb3RoZXIgdXNlciBjdXN0b21pemF0aW9ucyAoc29ydCwgbGF5b3V0LCBmb3JtdWxhcywgZXRjLilcblx0XHRcdFx0Y29uc3QgY29yZVVwZGF0ZXMgPSB7XG5cdFx0XHRcdFx0ZmlsdGVyczogZ2VuZXJhdGVkVmlldy5maWx0ZXJzLFxuXHRcdFx0XHRcdG5ld05vdGVMb2NhdGlvbjogZ2VuZXJhdGVkVmlldy5uZXdOb3RlTG9jYXRpb24sXG5cdFx0XHRcdFx0dGl0bGVQcm9wZXJ0eTogZ2VuZXJhdGVkVmlldy50aXRsZVByb3BlcnR5LFxuXHRcdFx0XHRcdGRhdGVQcm9wZXJ0eTogZ2VuZXJhdGVkVmlldy5kYXRlUHJvcGVydHksXG5cdFx0XHRcdFx0ZHJhZnRTdGF0dXNQcm9wZXJ0eTogZ2VuZXJhdGVkVmlldy5kcmFmdFN0YXR1c1Byb3BlcnR5LFxuXHRcdFx0XHRcdHRhZ3NQcm9wZXJ0eTogZ2VuZXJhdGVkVmlldy50YWdzUHJvcGVydHksXG5cdFx0XHRcdFx0c2hvd1RhZ3M6IGdlbmVyYXRlZFZpZXcuc2hvd1RhZ3MsXG5cdFx0XHRcdFx0c2hvd0RyYWZ0U3RhdHVzOiBnZW5lcmF0ZWRWaWV3LnNob3dEcmFmdFN0YXR1cyxcblx0XHRcdFx0XHRkcmFmdFN0YXR1c1JldmVyc2U6IGdlbmVyYXRlZFZpZXcuZHJhZnRTdGF0dXNSZXZlcnNlLFxuXHRcdFx0XHRcdGRyYWZ0U3RhdHVzVXNlRmlsZW5hbWVQcmVmaXg6IGdlbmVyYXRlZFZpZXcuZHJhZnRTdGF0dXNVc2VGaWxlbmFtZVByZWZpeFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRmaW5hbFZpZXdzLnB1c2goeyAuLi5leGlzdGluZ1ZpZXcsIC4uLmNvcmVVcGRhdGVzIH0pO1xuXHRcdFx0XHRwcm9jZXNzZWRWaWV3TmFtZXMuYWRkKGN0Lm5hbWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmluYWxWaWV3cy5wdXNoKGdlbmVyYXRlZFZpZXcpO1xuXHRcdFx0XHRwcm9jZXNzZWRWaWV3TmFtZXMuYWRkKGN0Lm5hbWUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRpZiAoZGVmYXVsdFR5cGUpIHByb2Nlc3NUeXBlKGRlZmF1bHRUeXBlKTtcblx0XHRmb3IgKGNvbnN0IGN0IG9mIG90aGVyVHlwZXMpIHByb2Nlc3NUeXBlKGN0KTtcblxuXHRcdC8vIDIuIEFkZCBvdGhlciB1bmlxdWUgdmlld3MgKHByZXNlcnZpbmcgb3JpZ2luYWwgb3JkZXIgYXMgbXVjaCBhcyBwb3NzaWJsZSlcblx0XHRmb3IgKGNvbnN0IHZpZXcgb2YgZXhpc3RpbmdWaWV3cykge1xuXHRcdFx0aWYgKHZpZXcubmFtZSA9PT0gJ1ZhdWx0IENNUyBHdWlkZScgfHwgdmlldy5uYW1lID09PSAnR3VpZGUnIHx8IHByb2Nlc3NlZFZpZXdOYW1lcy5oYXModmlldy5uYW1lKSkgY29udGludWU7XG5cdFx0XHRmaW5hbFZpZXdzLnB1c2godmlldyk7XG5cdFx0fVxuXG5cdFx0Ly8gMy4gQWRkIFZhdWx0IENNUyBHdWlkZSBsYXN0XG5cdFx0bGV0IGd1aWRlVmlldyA9IHZpZXdzQnlOYW1lLmdldCgnVmF1bHQgQ01TIEd1aWRlJykgfHwgdmlld3NCeU5hbWUuZ2V0KCdHdWlkZScpO1xuXHRcdGlmIChndWlkZVZpZXcpIHtcblx0XHRcdGd1aWRlVmlldyA9IHsgLi4uZ3VpZGVWaWV3LCBuYW1lOiAnVmF1bHQgQ01TIEd1aWRlJyB9O1xuXHRcdFx0ZmluYWxWaWV3cy5wdXNoKGd1aWRlVmlldyk7XG5cdFx0fVxuXG5cdFx0Ly8gU2VyaWFsaXplIGFsbCBmaW5hbCB2aWV3c1xuXHRcdGZvciAoY29uc3QgdmlldyBvZiBmaW5hbFZpZXdzKSB7XG5cdFx0XHRsaW5lcy5wdXNoKC4uLnRoaXMuc2VyaWFsaXplVmlldyh2aWV3KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cHJpdmF0ZSBnZW5lcmF0ZVZpZXdGb3JDb250ZW50VHlwZShcblx0XHRjb250ZW50VHlwZTogQ29udGVudFR5cGVDb25maWcsXG5cdFx0cHJvcHM6IEZyb250bWF0dGVyUHJvcGVydGllcyxcblx0XHRwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdFxuXHQpOiBhbnkge1xuXHRcdGNvbnN0IGZvbGRlclBhdGggPSB0aGlzLnBhdGhSZXNvbHZlci5nZXRCYXNlc0NNU0ZvbGRlclBhdGgoY29udGVudFR5cGUuZm9sZGVyLCBwcm9qZWN0RGV0ZWN0aW9uKTtcblxuXHRcdGNvbnN0IHZpZXc6IGFueSA9IHtcblx0XHRcdHR5cGU6ICdiYXNlcy1jbXMnLFxuXHRcdFx0bmFtZTogY29udGVudFR5cGUubmFtZSxcblx0XHRcdGZpbHRlcnM6IHtcblx0XHRcdFx0YW5kOiBbXG5cdFx0XHRcdFx0Zm9sZGVyUGF0aCA9PT0gJycgfHwgZm9sZGVyUGF0aCA9PT0gJy4nID8gJ2ZpbGUuZm9sZGVyID09IFwiL1wiJyA6IGBmaWxlLmZvbGRlci5zdGFydHNXaXRoKFwiJHtmb2xkZXJQYXRofVwiKWBcblx0XHRcdFx0XVxuXHRcdFx0fSxcblx0XHRcdGltYWdlRm9ybWF0OiAnY292ZXInLFxuXHRcdFx0c2hvd0RhdGU6IHRydWUsXG5cdFx0XHRjdXN0b21pemVOZXdCdXR0b246IHRydWUsXG5cdFx0XHRuZXdOb3RlTG9jYXRpb246IGZvbGRlclBhdGgsXG5cdFx0XHRmYWxsYmFja1RvRW1iZWRzOiAnaWYtZW1wdHknLFxuXHRcdFx0cHJvcGVydHlEaXNwbGF5MTogJ2ZpbGUuZnVsbG5hbWUnLFxuXHRcdFx0c2hvd1RleHRQcmV2aWV3OiB0cnVlLFxuXHRcdFx0cHJvcGVydHlMYWJlbHM6ICdhYm92ZScsXG5cdFx0XHRzb3J0OiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwcm9wZXJ0eTogcHJvcHMuZGF0ZVByb3BlcnR5ID8gYG5vdGUuJHtwcm9wcy5kYXRlUHJvcGVydHl9YCA6ICdmaWxlLmN0aW1lJyxcblx0XHRcdFx0XHRkaXJlY3Rpb246ICdERVNDJ1xuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fTtcblxuXHRcdC8vIEhhbmRsZSBibGFuayB0aXRsZS9kYXRlIHByb3BlcnRpZXNcblx0XHRpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0dmlldy50aXRsZVByb3BlcnR5ID0gYG5vdGUuJHtwcm9wcy50aXRsZVByb3BlcnR5fWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZpZXcudGl0bGVQcm9wZXJ0eSA9IGBmaWxlLmZ1bGxuYW1lYDtcblx0XHR9XG5cblx0XHRpZiAocHJvcHMuZGF0ZVByb3BlcnR5KSB7XG5cdFx0XHR2aWV3LmRhdGVQcm9wZXJ0eSA9IGBub3RlLiR7cHJvcHMuZGF0ZVByb3BlcnR5fWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZpZXcuZGF0ZVByb3BlcnR5ID0gYGZpbGUuY3RpbWVgO1xuXHRcdH1cblxuXHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHR2aWV3LmRlc2NyaXB0aW9uUHJvcGVydHkgPSBgbm90ZS4ke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9YDtcblx0XHR9XG5cblx0XHRpZiAocHJvcHMuaW1hZ2VQcm9wZXJ0eSkge1xuXHRcdFx0dmlldy5pbWFnZVByb3BlcnR5ID0gYG5vdGUuJHtwcm9wcy5pbWFnZVByb3BlcnR5fWA7XG5cdFx0fVxuXG5cdFx0dmlldy5zaG93VGFncyA9ICEhcHJvcHMudGFnc1Byb3BlcnR5O1xuXHRcdGlmIChwcm9wcy50YWdzUHJvcGVydHkpIHtcblx0XHRcdHZpZXcudGFnc1Byb3BlcnR5ID0gYG5vdGUuJHtwcm9wcy50YWdzUHJvcGVydHl9YDtcblx0XHR9XG5cblx0XHR2aWV3LnNob3dEcmFmdFN0YXR1cyA9ICEhcHJvcHMuaGFzRHJhZnRTdGF0dXM7XG5cdFx0aWYgKHByb3BzLmhhc0RyYWZ0U3RhdHVzKSB7XG5cdFx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSkge1xuXHRcdFx0XHR2aWV3LmRyYWZ0U3RhdHVzUHJvcGVydHkgPSBgbm90ZS4ke3Byb3BzLmRyYWZ0UHJvcGVydHl9YDtcblx0XHRcdFx0dmlldy5kcmFmdFN0YXR1c1JldmVyc2UgPSBwcm9wcy5kcmFmdExvZ2ljID09PSAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmlldy5kcmFmdFN0YXR1c1VzZUZpbGVuYW1lUHJlZml4ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldztcblx0fVxuXG5cblx0cHJpdmF0ZSBjYXBpdGFsaXplRmlyc3Qoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VyaWFsaXplIGEgdmlldyBvYmplY3QgdG8gWUFNTCBsaW5lcyAod2l0aCBwcm9wZXIgaW5kZW50YXRpb24pXG5cdCAqL1xuXHRwcml2YXRlIHNlcmlhbGl6ZVZpZXcodmlldzogeyBuYW1lPzogc3RyaW5nOyBmaWx0ZXJzPzogeyBhbmQ/OiBBcnJheTxzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gfTsgZ3JvdXBCeT86IHsgcHJvcGVydHk/OiBzdHJpbmc7IGRpcmVjdGlvbj86IHN0cmluZyB9IHwgc3RyaW5nOyBvcmRlcj86IHN0cmluZ1tdOyBzb3J0PzogQXJyYXk8eyBwcm9wZXJ0eT86IHN0cmluZzsgZGlyZWN0aW9uPzogc3RyaW5nIH0+O1trZXk6IHN0cmluZ106IHVua25vd24gfSk6IHN0cmluZ1tdIHtcblx0XHRjb25zdCB2aWV3TGluZXM6IHN0cmluZ1tdID0gW107XG5cdFx0dmlld0xpbmVzLnB1c2goJyAgLSB0eXBlOiBiYXNlcy1jbXMnKTtcblx0XHR2aWV3TGluZXMucHVzaChgICAgIG5hbWU6IFwiJHt2aWV3Lm5hbWV9XCJgKTtcblxuXHRcdGlmICh2aWV3LmZpbHRlcnMpIHtcblx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgZmlsdGVyczonKTtcblx0XHRcdGlmICh2aWV3LmZpbHRlcnMuYW5kKSB7XG5cdFx0XHRcdGlmICh2aWV3LmZpbHRlcnMuYW5kLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgICBhbmQ6IFtdJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICAgIGFuZDonKTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGZpbHRlciBvZiB2aWV3LmZpbHRlcnMuYW5kKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAgICAgLSAke2ZpbHRlcn1gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG9iamVjdCBmaWx0ZXJzIGxpa2UgeyBcImZpbGUuZm9sZGVyLnN0YXJ0c1dpdGhcIjogXCJwb3N0c1wiIH1cblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlU3RyID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IGBcIiR7dmFsdWV9XCJgIDogU3RyaW5nKHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICAgICAtICR7a2V5fTogJHt2YWx1ZVN0cn1gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh2aWV3Lmdyb3VwQnkpIHtcblx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgZ3JvdXBCeTonKTtcblx0XHRcdGlmICh0eXBlb2Ygdmlldy5ncm91cEJ5ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAodmlldy5ncm91cEJ5LnByb3BlcnR5KSB2aWV3TGluZXMucHVzaChgICAgICAgcHJvcGVydHk6ICR7dmlldy5ncm91cEJ5LnByb3BlcnR5fWApO1xuXHRcdFx0XHRpZiAodmlldy5ncm91cEJ5LmRpcmVjdGlvbikgdmlld0xpbmVzLnB1c2goYCAgICAgIGRpcmVjdGlvbjogJHt2aWV3Lmdyb3VwQnkuZGlyZWN0aW9ufWApO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Ygdmlldy5ncm91cEJ5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICAgJHt2aWV3Lmdyb3VwQnl9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHZpZXcub3JkZXIpIHtcblx0XHRcdGlmICh2aWV3Lm9yZGVyLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHR2aWV3TGluZXMucHVzaCgnICAgIG9yZGVyOiBbXScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICBvcmRlcjonKTtcblx0XHRcdFx0Zm9yIChjb25zdCBvcmRlckl0ZW0gb2Ygdmlldy5vcmRlcikge1xuXHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgICAtICR7b3JkZXJJdGVtfWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHZpZXcuc29ydCkge1xuXHRcdFx0aWYgKHZpZXcuc29ydC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICBzb3J0OiBbXScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICBzb3J0OicpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHNvcnRJdGVtIG9mIHZpZXcuc29ydCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygc29ydEl0ZW0gPT09ICdvYmplY3QnICYmIHNvcnRJdGVtLnByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICAgLSBwcm9wZXJ0eTogJHtzb3J0SXRlbS5wcm9wZXJ0eX1gKTtcblx0XHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgICAgIGRpcmVjdGlvbjogJHtzb3J0SXRlbS5kaXJlY3Rpb24gfHwgJ0FTQyd9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGFsbCBvdGhlciBwcm9wZXJ0aWVzIC0gcHJlc2VydmUgQUxMIHByb3BlcnRpZXMgZnJvbSB0aGUgb3JpZ2luYWwgdmlld1xuXHRcdC8vIFRoaXMgZW5zdXJlcyB3ZSBkb24ndCBsb3NlIGFueSBzZXR0aW5ncyBsaWtlIGhpZGVRdWlja0VkaXRJY29uXG5cdFx0Ly8gU2tpcCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGFscmVhZHkgaGFuZGxlZCBhYm92ZSAodHlwZSwgbmFtZSwgZmlsdGVycywgZ3JvdXBCeSwgb3JkZXIsIHNvcnQpXG5cdFx0Y29uc3Qgc2tpcFByb3BzID0gWyd0eXBlJywgJ25hbWUnLCAnZmlsdGVycycsICdncm91cEJ5JywgJ29yZGVyJywgJ3NvcnQnXTtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhbGwgcmVtYWluaW5nIHByb3BlcnRpZXMgZnJvbSB0aGUgdmlld1xuXHRcdGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyh2aWV3KSkge1xuXHRcdFx0aWYgKHNraXBQcm9wcy5pbmNsdWRlcyhwcm9wKSB8fCB2aWV3W3Byb3BdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZhbHVlID0gdmlld1twcm9wXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06IG51bGxgKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAke3Byb3B9OiAke3ZhbHVlfWApO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgJHtwcm9wfTogJHt2YWx1ZX1gKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09ICcnKSB7XG5cdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAke3Byb3B9OiBcIlwiYCk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRm9yIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90ZS9maWxlIHJlZmVyZW5jZXMsIGRvbid0IHF1b3RlIHRoZW1cblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIHByb3BlcnR5RGlzcGxheU4gYXMgd2VsbCBhcyBhbnl0aGluZyBlbmRpbmcgaW4gUHJvcGVydHlcblx0XHRcdFx0Y29uc3QgaXNQcm9wZXJ0eVJlZiA9IChwcm9wLmluY2x1ZGVzKCdQcm9wZXJ0eScpIHx8IHByb3Auc3RhcnRzV2l0aCgncHJvcGVydHlEaXNwbGF5JykpICYmXG5cdFx0XHRcdFx0KHZhbHVlLnN0YXJ0c1dpdGgoJ25vdGUuJykgfHwgdmFsdWUuc3RhcnRzV2l0aCgnZmlsZS4nKSk7XG5cblx0XHRcdFx0aWYgKGlzUHJvcGVydHlSZWYpIHtcblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06ICR7dmFsdWV9YCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvcCA9PT0gJ25ld05vdGVMb2NhdGlvbicpIHtcblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06IFwiJHt2YWx1ZX1cImApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFF1b3RlIG90aGVyIHN0cmluZ3Ncblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06IFwiJHt2YWx1ZX1cImApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXdMaW5lcztcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBTRU9Db25maWcsIENvbnRlbnRUeXBlQ29uZmlnLCBGcm9udG1hdHRlclByb3BlcnRpZXMsIFByb2plY3REZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IFBhdGhSZXNvbHZlciB9IGZyb20gJy4vUGF0aFJlc29sdmVyJztcclxuaW1wb3J0IHsgU2FmZUNvbmZpZ1dyaXRlciB9IGZyb20gJy4vU2FmZUNvbmZpZ1dyaXRlcic7XHJcblxyXG50eXBlIFNFT1BsdWdpbiA9IHtcclxuXHRzZXR0aW5ncz86IHtcclxuXHRcdHNjYW5EaXJlY3Rvcmllcz86IHN0cmluZztcclxuXHRcdHRpdGxlUHJvcGVydHk/OiBzdHJpbmc7XHJcblx0XHRkZXNjcmlwdGlvblByb3BlcnR5Pzogc3RyaW5nO1xyXG5cdFx0W2tleTogc3RyaW5nXTogdW5rbm93bjtcclxuXHR9O1xyXG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIFNFT1BsdWdpbj47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgU0VPQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cdHByaXZhdGUgcGF0aFJlc29sdmVyOiBQYXRoUmVzb2x2ZXI7XHJcblx0cHJpdmF0ZSBzYWZlV3JpdGVyOiBTYWZlQ29uZmlnV3JpdGVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0XHR0aGlzLnBhdGhSZXNvbHZlciA9IG5ldyBQYXRoUmVzb2x2ZXIoYXBwKTtcclxuXHRcdHRoaXMuc2FmZVdyaXRlciA9IG5ldyBTYWZlQ29uZmlnV3JpdGVyKGFwcCk7XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVNFT0NvbmZpZyhcclxuXHRcdGNvbnRlbnRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSxcclxuXHRcdGZyb250bWF0dGVyUHJvcGVydGllczogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIH0sXHJcblx0XHRwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCxcclxuXHRcdGVuYWJsZU1keFN1cHBvcnQ/OiBib29sZWFuXHJcblx0KTogU0VPQ29uZmlnIHtcclxuXHRcdC8vIFVzZSB0aGUgZmlyc3QgY29udGVudCB0eXBlJ3MgcHJvcGVydGllcyBhcyBkZWZhdWx0c1xyXG5cdFx0Y29uc3QgZmlyc3RUeXBlID0gY29udGVudFR5cGVzLmZpbmQoY3QgPT4gY3QuZW5hYmxlZCk7XHJcblx0XHRjb25zdCBmaXJzdFByb3BzID0gZmlyc3RUeXBlID8gZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2ZpcnN0VHlwZS5pZF0gOiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0Ly8gQnVpbGQgc2NhbiBkaXJlY3RvcmllcyBmcm9tIGFsbCBlbmFibGVkIGNvbnRlbnQgdHlwZXNcclxuXHRcdGNvbnN0IHNjYW5EaXJlY3RvcmllcyA9IGNvbnRlbnRUeXBlc1xyXG5cdFx0XHQuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpXHJcblx0XHRcdC5tYXAoY3QgPT4gdGhpcy5wYXRoUmVzb2x2ZXIuZ2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoY3QuZm9sZGVyLCBwcm9qZWN0RGV0ZWN0aW9uKSlcclxuXHRcdFx0LmpvaW4oJywnKTtcclxuXHJcblx0XHRjb25zdCBjb25maWc6IFNFT0NvbmZpZyA9IHtcclxuXHRcdFx0Ly8gT25seSBzZXQgdGl0bGVQcm9wZXJ0eSBpZiBpdCBleGlzdHMgKG5vdCBibGFuaykgLSB0aGlzIGNvbWVzIGZyb20gdGhlIHdpemFyZFxyXG5cdFx0XHR0aXRsZVByb3BlcnR5OiBmaXJzdFByb3BzPy50aXRsZVByb3BlcnR5ICYmIGZpcnN0UHJvcHMudGl0bGVQcm9wZXJ0eS50cmltKCkgIT09ICcnIFxyXG5cdFx0XHRcdD8gZmlyc3RQcm9wcy50aXRsZVByb3BlcnR5IFxyXG5cdFx0XHRcdDogJ3RpdGxlJywgLy8gRGVmYXVsdCBmYWxsYmFja1xyXG5cdFx0XHQvLyBPbmx5IHNldCBkZXNjcmlwdGlvblByb3BlcnR5IGlmIGl0IGV4aXN0cyAobm90IGJsYW5rKSAtIHRoaXMgY29tZXMgZnJvbSB0aGUgd2l6YXJkXHJcblx0XHRcdGRlc2NyaXB0aW9uUHJvcGVydHk6IGZpcnN0UHJvcHM/LmRlc2NyaXB0aW9uUHJvcGVydHkgJiYgZmlyc3RQcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5LnRyaW0oKSAhPT0gJydcclxuXHRcdFx0XHQ/IGZpcnN0UHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eVxyXG5cdFx0XHRcdDogdW5kZWZpbmVkLFxyXG5cdFx0XHRzY2FuRGlyZWN0b3JpZXM6IHNjYW5EaXJlY3RvcmllcyxcclxuXHRcdFx0Ly8gRG9uJ3Qgc2V0IHRoZXNlIC0gd2UgZG9uJ3QgY29sbGVjdCB0aGVtIGluIHRoZSB3aXphcmRcclxuXHRcdFx0a2V5d29yZFByb3BlcnR5OiB1bmRlZmluZWQsXHJcblx0XHRcdHVzZUZpbGVuYW1lQXNUaXRsZTogZmFsc2UsXHJcblx0XHRcdHVzZUZpbGVuYW1lQXNTbHVnOiB0cnVlLFxyXG5cdFx0XHRlbmFibGVNRFhTdXBwb3J0OiBlbmFibGVNZHhTdXBwb3J0ID8/IGZhbHNlXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBjb25maWc7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlQ29uZmlnKGNvbmZpZzogU0VPQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2QgZmlyc3QgKGxpa2UgQXN0cm8gQ29tcG9zZXIpXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBzZW9QbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bJ3NlbyddO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHNlb1BsdWdpbiAmJiBzZW9QbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHRjb25zdCBwbHVnaW5TZXR0aW5ncyA9IHNlb1BsdWdpbi5zZXR0aW5ncztcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBVcGRhdGUgc2V0dGluZ3MgZnJvbSBjb25maWcgLSBvbmx5IHVwZGF0ZSB3aGF0IHdlIGNvbGxlY3QgaW4gdGhlIHdpemFyZFxyXG5cdFx0XHRcdC8vIDEuIHNjYW5EaXJlY3RvcmllcyAtIGFsd2F5cyB1cGRhdGUgKGdlbmVyYXRlZCBmcm9tIGNvbnRlbnQgdHlwZXMpXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5zY2FuRGlyZWN0b3JpZXMpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLnNjYW5EaXJlY3RvcmllcyA9IGNvbmZpZy5zY2FuRGlyZWN0b3JpZXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIDIuIHRpdGxlUHJvcGVydHkgLSB1cGRhdGUgaWYgcHJvdmlkZWQgKGNvbGxlY3RlZCBpbiB3aXphcmQpXHJcblx0XHRcdFx0aWYgKGNvbmZpZy50aXRsZVByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLnRpdGxlUHJvcGVydHkgPSBjb25maWcudGl0bGVQcm9wZXJ0eTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gMy4gZGVzY3JpcHRpb25Qcm9wZXJ0eSAtIHVwZGF0ZSBpZiBwcm92aWRlZCAoY29sbGVjdGVkIGluIHdpemFyZClcclxuXHRcdFx0XHRpZiAoY29uZmlnLmRlc2NyaXB0aW9uUHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZGVzY3JpcHRpb25Qcm9wZXJ0eSA9IGNvbmZpZy5kZXNjcmlwdGlvblByb3BlcnR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyA0LiBlbmFibGVNRFhTdXBwb3J0IC0gdXBkYXRlIGlmIHByb3ZpZGVkIChjb2xsZWN0ZWQgaW4gd2l6YXJkKVxyXG5cdFx0XHRcdGlmIChjb25maWcuZW5hYmxlTURYU3VwcG9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVNRFhTdXBwb3J0ID0gY29uZmlnLmVuYWJsZU1EWFN1cHBvcnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIERvbid0IHVwZGF0ZSBrZXl3b3JkUHJvcGVydHksIHVzZUZpbGVuYW1lQXNUaXRsZSwgb3IgdXNlRmlsZW5hbWVBc1NsdWdcclxuXHRcdFx0XHQvLyAtIHdlIGRvbid0IGNvbGxlY3QgdGhlc2UgaW4gdGhlIHdpemFyZCwgbGV0IHVzZXIgY29uZmlndXJlIGluIFNFTyBwbHVnaW4gc2V0dGluZ3NcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBTYXZlIHRoZSBzZXR0aW5ncyB1c2luZyBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kXHJcblx0XHRcdFx0aWYgKHR5cGVvZiBzZW9QbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBzZW9QbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdTRU9Db25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZFxyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgU0VPIGNvbmZpZyB2aWEgcGx1Z2luIG1ldGhvZDonLCBlcnJvcik7XHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHNhdmVDb25maWdGYWxsYmFjayhjb25maWc6IFNFT0NvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnc2VvJztcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBSZWFkIGV4aXN0aW5nIGRhdGEgc2FmZWx5XHJcblx0XHRcdGxldCBleGlzdGluZ0RhdGEgPSBhd2FpdCB0aGlzLnNhZmVXcml0ZXIucmVhZENvbmZpZyhwbHVnaW5JZCk7XHJcblx0XHRcdGlmICghZXhpc3RpbmdEYXRhKSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0ge307XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIGV4aXN0aW5nIGRhdGEgKHByZXNlcnZlIGFsbCBleGlzdGluZyBzZXR0aW5ncylcclxuXHRcdFx0Ly8gT25seSB1cGRhdGUgdGhlIHByb3BlcnRpZXMgd2UgY29sbGVjdCBpbiB0aGUgd2l6YXJkOlxyXG5cdFx0XHQvLyAxLiBzY2FuRGlyZWN0b3JpZXMgKGdlbmVyYXRlZCBmcm9tIGNvbnRlbnQgdHlwZXMpXHJcblx0XHRcdC8vIDIuIHRpdGxlUHJvcGVydHkgKGNvbGxlY3RlZCBpbiB3aXphcmQpXHJcblx0XHRcdC8vIDMuIGRlc2NyaXB0aW9uUHJvcGVydHkgKGNvbGxlY3RlZCBpbiB3aXphcmQpXHJcblx0XHRcdC8vIERvbid0IHRvdWNoIGtleXdvcmRQcm9wZXJ0eSwgdXNlRmlsZW5hbWVBc1RpdGxlLCB1c2VGaWxlbmFtZUFzU2x1ZywgZXRjLlxyXG5cdFx0XHRjb25zdCBtZXJnZWREYXRhID0ge1xyXG5cdFx0XHRcdC4uLmV4aXN0aW5nRGF0YSxcclxuXHRcdFx0XHQvLyBBbHdheXMgdXBkYXRlIHNjYW5EaXJlY3Rvcmllc1xyXG5cdFx0XHRcdHNjYW5EaXJlY3RvcmllczogY29uZmlnLnNjYW5EaXJlY3RvcmllcyxcclxuXHRcdFx0XHQvLyBVcGRhdGUgdGl0bGVQcm9wZXJ0eSBpZiBwcm92aWRlZCAoZnJvbSB3aXphcmQpXHJcblx0XHRcdFx0Li4uKGNvbmZpZy50aXRsZVByb3BlcnR5ICE9PSB1bmRlZmluZWQgJiYgeyB0aXRsZVByb3BlcnR5OiBjb25maWcudGl0bGVQcm9wZXJ0eSB9KSxcclxuXHRcdFx0XHQvLyBVcGRhdGUgZGVzY3JpcHRpb25Qcm9wZXJ0eSBpZiBwcm92aWRlZCAoZnJvbSB3aXphcmQpXHJcblx0XHRcdFx0Li4uKGNvbmZpZy5kZXNjcmlwdGlvblByb3BlcnR5ICE9PSB1bmRlZmluZWQgJiYgeyBkZXNjcmlwdGlvblByb3BlcnR5OiBjb25maWcuZGVzY3JpcHRpb25Qcm9wZXJ0eSB9KSxcclxuXHRcdFx0XHQvLyBVcGRhdGUgZW5hYmxlTURYU3VwcG9ydCBpZiBwcm92aWRlZCAoZnJvbSB3aXphcmQpXHJcblx0XHRcdFx0Li4uKGNvbmZpZy5lbmFibGVNRFhTdXBwb3J0ICE9PSB1bmRlZmluZWQgJiYgeyBlbmFibGVNRFhTdXBwb3J0OiBjb25maWcuZW5hYmxlTURYU3VwcG9ydCB9KVxyXG5cdFx0XHRcdC8vIEFsbCBvdGhlciBwcm9wZXJ0aWVzIChrZXl3b3JkUHJvcGVydHksIHVzZUZpbGVuYW1lQXNUaXRsZSwgdXNlRmlsZW5hbWVBc1NsdWcsIGV0Yy4pXHJcblx0XHRcdFx0Ly8gYXJlIHByZXNlcnZlZCBmcm9tIGV4aXN0aW5nRGF0YSAtIHdlIGRvbid0IGNvbGxlY3QgdGhlbSBpbiB0aGUgd2l6YXJkXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBXcml0ZSBjb25maWcgc2FmZWx5IHdpdGggYmFja3VwIGFuZCB2YWxpZGF0aW9uXHJcblx0XHRcdGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnNhZmVXcml0ZXIud3JpdGVDb25maWcocGx1Z2luSWQsIG1lcmdlZERhdGEsIHtcclxuXHRcdFx0XHRzaG93Tm90aWNlOiB0cnVlLFxyXG5cdFx0XHRcdGNyZWF0ZUJhY2t1cDogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmICghc3VjY2Vzcykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgU0VPIGNvbmZpZ3VyYXRpb24nKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnU0VPQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgU0VPIHBsdWdpbiBjb25maWd1cmF0aW9uJyk7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBTRU8gY29uZmlnIChmYWxsYmFjayk6JywgZXJyb3IpO1xyXG5cdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZ3VyYXRvciB7XHJcblx0cHJpdmF0ZSBhcHA6IEFwcDtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZUNvbmZpZyhjb25maWc6IFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2QgZmlyc3QgKGxpa2UgQXN0cm8gQ29tcG9zZXIgYW5kIFNFTylcclxuXHRcdFx0dHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdFx0XHRcdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCB7XHJcblx0XHRcdFx0XHRzZXR0aW5ncz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHRcdFx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuXHRcdFx0XHR9PjtcclxuXHRcdFx0fTtcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IHByb3BlcnR5T3ZlckZpbGVOYW1lUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uWydwcm9wZXJ0eS1vdmVyLWZpbGUtbmFtZSddO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHByb3BlcnR5T3ZlckZpbGVOYW1lUGx1Z2luICYmIHByb3BlcnR5T3ZlckZpbGVOYW1lUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Y29uc3QgcGx1Z2luU2V0dGluZ3MgPSBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbi5zZXR0aW5ncztcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogVXNpbmcgcGx1Z2luLnNhdmVTZXR0aW5ncygpIG1ldGhvZCcpO1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBJbnB1dCBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCA9JywgY29uZmlnLmVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFVwZGF0ZSBwcm9wZXJ0eUtleSBpZiBwcm92aWRlZFxyXG5cdFx0XHRcdGlmIChjb25maWcucHJvcGVydHlLZXkpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLnByb3BlcnR5S2V5ID0gY29uZmlnLnByb3BlcnR5S2V5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBBTFdBWVMgdXBkYXRlIGVuYWJsZU1keFN1cHBvcnQgaWYgcHJvdmlkZWQgKGV2ZW4gaWYgZmFsc2UpXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLmVuYWJsZU1keFN1cHBvcnQgPSBjb25maWcuZW5hYmxlTWR4U3VwcG9ydDtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBTZXQgcGx1Z2luU2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydCB0bycsIGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogY29uZmlnLmVuYWJsZU1keFN1cHBvcnQgaXMgdW5kZWZpbmVkIScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBTYXZlIHRoZSBzZXR0aW5ncyB1c2luZyBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kXHJcblx0XHRcdFx0aWYgKHR5cGVvZiBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGF3YWl0IHByb3BlcnR5T3ZlckZpbGVOYW1lUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IFBsdWdpbiBzYXZlU2V0dGluZ3Mgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2snKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogUGx1Z2luIG5vdCBmb3VuZCBvciBzZXR0aW5ncyBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjaycpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZFxyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgUHJvcGVydHkgT3ZlciBGaWxlIE5hbWUgY29uZmlnIHZpYSBwbHVnaW4gbWV0aG9kOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWcpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ3Byb3BlcnR5LW92ZXItZmlsZS1uYW1lJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblx0XHRcclxuXHRcdHRyeSB7XHJcblx0XHRcdGxldCBleGlzdGluZ0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XHJcblx0XHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IFVzaW5nIGZhbGxiYWNrIGZpbGUgbWV0aG9kJyk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBJbnB1dCBjb25maWcgPScsIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogSW5wdXQgY29uZmlnLmVuYWJsZU1keFN1cHBvcnQgPScsIGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IEV4aXN0aW5nIGRhdGEgPScsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nRGF0YSkpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTWVyZ2UgY29uZmlnLCBwcmVzZXJ2aW5nIGV4aXN0aW5nIHNldHRpbmdzXHJcblx0XHRcdC8vIEZpcnN0IHNwcmVhZCBleGlzdGluZyBkYXRhLCB0aGVuIHNwcmVhZCBjb25maWcgKHdoaWNoIG1heSBpbmNsdWRlIGVuYWJsZU1keFN1cHBvcnQpXHJcblx0XHRcdGNvbnN0IG1lcmdlZERhdGEgPSB7IFxyXG5cdFx0XHRcdC4uLmV4aXN0aW5nRGF0YSwgXHJcblx0XHRcdFx0Li4uY29uZmlnXHJcblx0XHRcdH07XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBBTFdBWVMgZXhwbGljaXRseSBzZXQgZW5hYmxlTWR4U3VwcG9ydCBpZiBpdCdzIHByb3ZpZGVkIGluIGNvbmZpZyAoZXZlbiBpZiBmYWxzZSlcclxuXHRcdFx0Ly8gVGhpcyBlbnN1cmVzIGl0IG92ZXJyaWRlcyBhbnkgZXhpc3RpbmcgdmFsdWVcclxuXHRcdFx0aWYgKGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRtZXJnZWREYXRhLmVuYWJsZU1keFN1cHBvcnQgPSBjb25maWcuZW5hYmxlTWR4U3VwcG9ydDtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogRXhwbGljaXRseSBzZXQgZW5hYmxlTWR4U3VwcG9ydCB0bycsIGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCBpcyB1bmRlZmluZWQhJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBGaW5hbCBtZXJnZWREYXRhLmVuYWJsZU1keFN1cHBvcnQgPScsIG1lcmdlZERhdGEuZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBGaW5hbCBtZXJnZWREYXRhID0nLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhKSk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIEVuc3VyZSBwbHVnaW4gZGlyZWN0b3J5IGV4aXN0c1xyXG5cdFx0XHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EaXIpO1xyXG5cdFx0XHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKHBsdWdpbkRpcik7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdFx0XHQvLyBGb2xkZXIgbWlnaHQgYWxyZWFkeSBleGlzdCAocmFjZSBjb25kaXRpb24pLCBpZ25vcmUgZXJyb3JcclxuXHRcdFx0XHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGZpbGVcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgUHJvcGVydHkgT3ZlciBGaWxlIE5hbWUgY29uZmlnIChmYWxsYmFjayk6JywgZXJyb3IpO1xyXG5cdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVSVR3ZWFrZXJDb21tYW5kIHtcclxuXHRpZDogc3RyaW5nO1xyXG5cdGljb246IHN0cmluZztcclxuXHRuYW1lOiBzdHJpbmc7XHJcblx0ZGlzcGxheU5hbWU6IHN0cmluZztcclxuXHRtb2RlOiBzdHJpbmc7XHJcblx0dG9nZ2xlSWNvbj86IHN0cmluZztcclxuXHRzaG93T25GaWxlVHlwZXM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVUlUd2Vha2VyQ29uZmlnIHtcclxuXHR0YWJCYXJDb21tYW5kcz86IFVJVHdlYWtlckNvbW1hbmRbXTtcclxufVxyXG5cclxudHlwZSBQbHVnaW5XaXRoU2V0dGluZ3MgPSB7XHJcblx0c2V0dGluZ3M/OiBVSVR3ZWFrZXJDb25maWc7XHJcblx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufTtcclxuXHJcbnR5cGUgUGx1Z2luc0FQSSA9IHtcclxuXHRwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgUGx1Z2luV2l0aFNldHRpbmdzPjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBVSVR3ZWFrZXJDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoZW5hYmxlTWR4U3VwcG9ydDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAndWktdHdlYWtlcic7XHJcblx0XHRcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIFRyeSB0byB1c2UgcGx1Z2luJ3MgbGl2ZSBzZXR0aW5ncyBpZiBhdmFpbGFibGVcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IHVpVHdlYWtlclBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LltwbHVnaW5JZF07XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAodWlUd2Vha2VyUGx1Z2luICYmIHVpVHdlYWtlclBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1VJVHdlYWtlckNvbmZpZzogVXNpbmcgcGx1Z2luLnNldHRpbmdzIEFQSScpO1xyXG5cdFx0XHRcdGNvbnN0IHNldHRpbmdzID0gdWlUd2Vha2VyUGx1Z2luLnNldHRpbmdzO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEZvcmNlIHRoZSBNRFggdXBkYXRlXHJcblx0XHRcdFx0dGhpcy5mb3JjZU1keFVwZGF0ZShzZXR0aW5ncywgZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2F2ZSBzZXR0aW5ncyB2aWEgcGx1Z2luIEFQSVxyXG5cdFx0XHRcdGlmICh0eXBlb2YgdWlUd2Vha2VyUGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0YXdhaXQgdWlUd2Vha2VyUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnVUlUd2Vha2VyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2QgaWYgcGx1Z2luIG5vdCBhdmFpbGFibGVcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnVUlUd2Vha2VyQ29uZmlnOiBQbHVnaW4gQVBJIG5vdCBhdmFpbGFibGUsIHVzaW5nIGZhbGxiYWNrIGZpbGUgbWV0aG9kJyk7XHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgVUkgVHdlYWtlciBjb25maWc6JywgZXJyb3IpO1xyXG5cdFx0XHQvLyBUcnkgZmFsbGJhY2sgYW55d2F5XHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBmb3JjZU1keFVwZGF0ZShzZXR0aW5nczogVUlUd2Vha2VyQ29uZmlnLCBlbmFibGVNZHhTdXBwb3J0OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCBtZHhGaWxlVHlwZXMgPSBlbmFibGVNZHhTdXBwb3J0ID8gJ21kLG1keCcgOiAnbWQnO1xyXG5cdFx0XHJcblx0XHRpZiAoIXNldHRpbmdzLnRhYkJhckNvbW1hbmRzIHx8ICFBcnJheS5pc0FycmF5KHNldHRpbmdzLnRhYkJhckNvbW1hbmRzKSkge1xyXG5cdFx0XHRzZXR0aW5ncy50YWJCYXJDb21tYW5kcyA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRhYkJhckNvbW1hbmRzID0gc2V0dGluZ3MudGFiQmFyQ29tbWFuZHMgYXMgdW5rbm93biBhcyBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj47XHJcblx0XHRjb25zdCB0b29sYmFyQ29tbWFuZEluZGV4ID0gdGFiQmFyQ29tbWFuZHMuZmluZEluZGV4KGNtZCA9PiBjbWQuaWQgPT09ICdlZGl0aW5nLXRvb2xiYXI6aGlkZS1zaG93LW1lbnUnKTtcclxuXHJcblx0XHRpZiAodG9vbGJhckNvbW1hbmRJbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0Ly8gT05MWSB1cGRhdGUgc2hvd09uRmlsZVR5cGVzLCBsZWF2ZSBldmVyeXRoaW5nIGVsc2UgYWxvbmUhXHJcblx0XHRcdHRhYkJhckNvbW1hbmRzW3Rvb2xiYXJDb21tYW5kSW5kZXhdID0ge1xyXG5cdFx0XHRcdC4uLnRhYkJhckNvbW1hbmRzW3Rvb2xiYXJDb21tYW5kSW5kZXhdLFxyXG5cdFx0XHRcdFwic2hvd09uRmlsZVR5cGVzXCI6IG1keEZpbGVUeXBlc1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKGBVSVR3ZWFrZXJDb25maWc6IFVwZGF0ZWQgZXhpc3RpbmcgdG9vbGJhciBjb21tYW5kIHNob3dPbkZpbGVUeXBlcyB0byAke21keEZpbGVUeXBlc31gKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIE9ubHkgYWRkIGlmIG1pc3NpbmcsIHVzaW5nIHRoZSB1c2VyJ3MgcHJlZmVycmVkIGRlZmF1bHRzXHJcblx0XHRcdHRhYkJhckNvbW1hbmRzLnB1c2goe1xyXG5cdFx0XHRcdFwiaWRcIjogXCJlZGl0aW5nLXRvb2xiYXI6aGlkZS1zaG93LW1lbnVcIixcclxuXHRcdFx0XHRcImljb25cIjogXCJsdWNpZGUtcGFuZWwtdG9wLW9wZW5cIixcclxuXHRcdFx0XHRcIm5hbWVcIjogXCJUb2dnbGUgZWRpdGluZyB0b29sYmFyXCIsXHJcblx0XHRcdFx0XCJkaXNwbGF5TmFtZVwiOiBcIkVkaXRpbmcgVG9vbGJhcjogSGlkZS9TaG93IFwiLFxyXG5cdFx0XHRcdFwibW9kZVwiOiBcImRlc2t0b3BcIixcclxuXHRcdFx0XHRcInRvZ2dsZUljb25cIjogXCJsdWNpZGUtcGFuZWwtdG9wLWNsb3NlXCIsXHJcblx0XHRcdFx0XCJzaG93T25GaWxlVHlwZXNcIjogbWR4RmlsZVR5cGVzXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKGBVSVR3ZWFrZXJDb25maWc6IEFkZGVkIG1pc3NpbmcgdG9vbGJhciBjb21tYW5kIHdpdGggc2hvd09uRmlsZVR5cGVzPSR7bWR4RmlsZVR5cGVzfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soZW5hYmxlTWR4U3VwcG9ydDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAndWktdHdlYWtlcic7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cdFx0XHJcblx0XHRsZXQgZXhpc3RpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xyXG5cdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHJcblx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIHVpLXR3ZWFrZXIgZGF0YS5qc29uOicsIGVycm9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZvcmNlIHRoZSBNRFggdXBkYXRlIG9uIHRoZSBtZXJnZWQgZGF0YVxyXG5cdFx0dGhpcy5mb3JjZU1keFVwZGF0ZShleGlzdGluZ0RhdGEgYXMgdW5rbm93biBhcyBVSVR3ZWFrZXJDb25maWcsIGVuYWJsZU1keFN1cHBvcnQpO1xyXG5cclxuXHRcdC8vIEVuc3VyZSBwbHVnaW4gZGlyZWN0b3J5IGV4aXN0c1xyXG5cdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZvbGRlciBhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTYXZlIHRvIGZpbGVcclxuXHRcdGNvbnN0IGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEsIG51bGwsIDIpO1xyXG5cdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBjb250ZW50KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShwbHVnaW5EYXRhUGF0aCwgY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRjb25zb2xlLmRlYnVnKCdVSVR3ZWFrZXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB1aS10d2Vha2VyIGNvbmZpZyB2aWEgZmFsbGJhY2snKTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGFGaWxlc0VkaXRvclNldHRpbmdzIHtcclxuICAgIGRvTG9hZFR4dDogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlVHh0OiBib29sZWFuO1xyXG4gICAgZG9Mb2FkWG1sOiBib29sZWFuO1xyXG4gICAgZG9DcmVhdGVYbWw6IGJvb2xlYW47XHJcbiAgICBkb0xvYWRKc29uOiBib29sZWFuO1xyXG4gICAgZG9DcmVhdGVKc29uOiBib29sZWFuO1xyXG4gICAgZG9Mb2FkWWFtbDogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlWWFtbDogYm9vbGVhbjtcclxuICAgIGRvTG9hZEFzdHJvOiBib29sZWFuO1xyXG4gICAgZG9DcmVhdGVBc3RybzogYm9vbGVhbjtcclxuICAgIGRvTG9hZFRzOiBib29sZWFuO1xyXG4gICAgZG9DcmVhdGVUczogYm9vbGVhbjtcclxuICAgIGRvTG9hZENzczogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlQ3NzOiBib29sZWFuO1xyXG4gICAgZG9Mb2FkSHRtbDogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlSHRtbDogYm9vbGVhbjtcclxuICAgIGRvTG9hZEpzOiBib29sZWFuO1xyXG4gICAgZG9DcmVhdGVKczogYm9vbGVhbjtcclxuICAgIGRvTG9hZE1qczogYm9vbGVhbjtcclxuICAgIGRvQ3JlYXRlTWpzOiBib29sZWFuO1xyXG4gICAgZG9BdXRvc2F2ZUZpbGVzOiBib29sZWFuO1xyXG4gICAgbGluZVdyYXBwaW5nOiBib29sZWFuO1xyXG4gICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcclxufVxyXG5cclxudHlwZSBQbHVnaW5XaXRoU2V0dGluZ3MgPSB7XHJcbiAgICBzZXR0aW5ncz86IERhdGFGaWxlc0VkaXRvclNldHRpbmdzO1xyXG4gICAgc2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufTtcclxuXHJcbnR5cGUgUGx1Z2luc0FQSSA9IHtcclxuICAgIHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBQbHVnaW5XaXRoU2V0dGluZ3M+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIERhdGFGaWxlc0VkaXRvckNvbmZpZ3VyYXRvciB7XHJcbiAgICBwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgc2F2ZUNvbmZpZyhlbmFibGVkOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcGx1Z2luSWQgPSAnZGF0YS1maWxlcy1lZGl0b3InO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBUcnkgdG8gdXNlIHBsdWdpbidzIGxpdmUgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG4gICAgICAgICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBsdWdpbiAmJiBwbHVnaW4uc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RhdGFGaWxlc0VkaXRvckNvbmZpZzogVXNpbmcgcGx1Z2luLnNldHRpbmdzIEFQSScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBwbHVnaW4uc2V0dGluZ3M7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVNldHRpbmdzKHNldHRpbmdzLCBlbmFibGVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHNldHRpbmdzIHZpYSBwbHVnaW4gQVBJXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGF0YUZpbGVzRWRpdG9yQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2QgaWYgcGx1Z2luIG5vdCBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGF0YUZpbGVzRWRpdG9yQ29uZmlnOiBQbHVnaW4gQVBJIG5vdCBhdmFpbGFibGUgb3Igc2V0dGluZ3Mgbm90IGxvYWRlZCwgdXNpbmcgZmFsbGJhY2sgZmlsZSBtZXRob2QnKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soZW5hYmxlZCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgRGF0YSBGaWxlcyBFZGl0b3IgY29uZmlnOicsIGVycm9yKTtcclxuICAgICAgICAgICAgLy8gVHJ5IGZhbGxiYWNrIGFueXdheVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhlbmFibGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhcHBseVNldHRpbmdzKHNldHRpbmdzOiBEYXRhRmlsZXNFZGl0b3JTZXR0aW5ncyB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgLy8gU2V0IEpTT04gYW5kIEFzdHJvIGJhc2VkIG9uIHRoZSB0b2dnbGVcclxuICAgICAgICBzZXR0aW5ncy5kb0xvYWRKc29uID0gZW5hYmxlZDtcclxuICAgICAgICBzZXR0aW5ncy5kb0NyZWF0ZUpzb24gPSBlbmFibGVkO1xyXG4gICAgICAgIHNldHRpbmdzLmRvTG9hZEFzdHJvID0gZW5hYmxlZDtcclxuICAgICAgICBzZXR0aW5ncy5kb0NyZWF0ZUFzdHJvID0gZW5hYmxlZDtcclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdCBhbGwgb3RoZXIgXCJsb2FkL2NyZWF0ZVwiIHNldHRpbmdzIHRvIGZhbHNlIGFzIHJlcXVlc3RlZFxyXG4gICAgICAgIHNldHRpbmdzLmRvTG9hZFR4dCA9IGZhbHNlO1xyXG4gICAgICAgIHNldHRpbmdzLmRvQ3JlYXRlVHh0ID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkWG1sID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVYbWwgPSBmYWxzZTtcclxuICAgICAgICBzZXR0aW5ncy5kb0xvYWRZYW1sID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVZYW1sID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkVHMgPSBmYWxzZTtcclxuICAgICAgICBzZXR0aW5ncy5kb0NyZWF0ZVRzID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkQ3NzID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVDc3MgPSBmYWxzZTtcclxuICAgICAgICBzZXR0aW5ncy5kb0xvYWRIdG1sID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVIdG1sID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkSnMgPSBmYWxzZTtcclxuICAgICAgICBzZXR0aW5ncy5kb0NyZWF0ZUpzID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9Mb2FkTWpzID0gZmFsc2U7XHJcbiAgICAgICAgc2V0dGluZ3MuZG9DcmVhdGVNanMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHRoZXNlIGFyZSB0cnVlIGFzIHJlcXVlc3RlZFxyXG4gICAgICAgIHNldHRpbmdzLmRvQXV0b3NhdmVGaWxlcyA9IHRydWU7XHJcbiAgICAgICAgc2V0dGluZ3MubGluZVdyYXBwaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIHNhdmVDb25maWdGYWxsYmFjayhlbmFibGVkOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcGx1Z2luSWQgPSAnZGF0YS1maWxlcy1lZGl0b3InO1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuICAgICAgICBjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cclxuICAgICAgICBsZXQgZXhpc3RpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZXhpc3RpbmcgZGF0YS1maWxlcy1lZGl0b3IgZGF0YS5qc29uOicsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgdGhlIHNldHRpbmdzIHVwZGF0ZVxyXG4gICAgICAgIHRoaXMuYXBwbHlTZXR0aW5ncyhleGlzdGluZ0RhdGEsIGVuYWJsZWQpO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuICAgICAgICBjb25zdCBwbHVnaW5EaXIgPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH1gO1xyXG4gICAgICAgIGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuICAgICAgICBpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGb2xkZXIgYWxyZWFkeSBleGlzdHMnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTYXZlIHRvIGZpbGVcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKTtcclxuICAgICAgICBpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIGNvbnRlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShwbHVnaW5EYXRhUGF0aCwgY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0RhdGFGaWxlc0VkaXRvckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIGRhdGEtZmlsZXMtZWRpdG9yIGNvbmZpZyB2aWEgZmFsbGJhY2snKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgQmFzZXNDTVNDb25maWd1cmF0b3IgfSBmcm9tICcuL0Jhc2VzQ01TQ29uZmlnJztcclxuaW1wb3J0IHsgQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4vQXN0cm9Db21wb3NlckNvbmZpZyc7XHJcbmltcG9ydCB7IFNFT0NvbmZpZ3VyYXRvciB9IGZyb20gJy4vU0VPQ29uZmlnJztcclxuaW1wb3J0IHsgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3IgfSBmcm9tICcuL1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnJztcclxuaW1wb3J0IHsgVUlUd2Vha2VyQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9VSVR3ZWFrZXJDb25maWcnO1xyXG5pbXBvcnQgeyBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3IgfSBmcm9tICcuL0ltYWdlTWFuYWdlckNvbmZpZyc7XHJcbmltcG9ydCB7IEhvbWVCYXNlQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9Ib21lQmFzZUNvbmZpZyc7XHJcbmltcG9ydCB7IEV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3IgfSBmcm9tICcuL0V4cGxvcmVyRm9jdXNDb25maWcnO1xyXG5pbXBvcnQgeyBEYXRhRmlsZXNFZGl0b3JDb25maWd1cmF0b3IgfSBmcm9tICcuL0RhdGFGaWxlc0VkaXRvckNvbmZpZyc7XHJcbmltcG9ydCB7IEVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yIH0gZnJvbSAnLi9FZGl0aW5nVG9vbGJhckNvbmZpZyc7XHJcblxyXG5leHBvcnQgY2xhc3MgQ29uZmlnRmx1c2hTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgYmFzZXNDTVNDb25maWd1cmF0b3I6IEJhc2VzQ01TQ29uZmlndXJhdG9yO1xyXG4gICAgcHJpdmF0ZSBhc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yOiBBc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yO1xyXG4gICAgcHJpdmF0ZSBzZW9Db25maWd1cmF0b3I6IFNFT0NvbmZpZ3VyYXRvcjtcclxuICAgIHByaXZhdGUgcHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3I6IFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlndXJhdG9yO1xyXG4gICAgcHJpdmF0ZSB1aVR3ZWFrZXJDb25maWd1cmF0b3I6IFVJVHdlYWtlckNvbmZpZ3VyYXRvcjtcclxuICAgIHByaXZhdGUgaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yOiBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3I7XHJcbiAgICBwcml2YXRlIGhvbWVCYXNlQ29uZmlndXJhdG9yOiBIb21lQmFzZUNvbmZpZ3VyYXRvcjtcclxuICAgIHByaXZhdGUgZXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvcjogRXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvcjtcclxuICAgIHByaXZhdGUgZGF0YUZpbGVzRWRpdG9yQ29uZmlndXJhdG9yOiBEYXRhRmlsZXNFZGl0b3JDb25maWd1cmF0b3I7XHJcbiAgICBwcml2YXRlIGVkaXRpbmdUb29sYmFyQ29uZmlndXJhdG9yOiBFZGl0aW5nVG9vbGJhckNvbmZpZ3VyYXRvcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwcDogQXBwKSB7XHJcbiAgICAgICAgdGhpcy5iYXNlc0NNU0NvbmZpZ3VyYXRvciA9IG5ldyBCYXNlc0NNU0NvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMuYXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvciA9IG5ldyBBc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yKGFwcCk7XHJcbiAgICAgICAgdGhpcy5zZW9Db25maWd1cmF0b3IgPSBuZXcgU0VPQ29uZmlndXJhdG9yKGFwcCk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZ3VyYXRvciA9IG5ldyBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMudWlUd2Vha2VyQ29uZmlndXJhdG9yID0gbmV3IFVJVHdlYWtlckNvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yID0gbmV3IEltYWdlTWFuYWdlckNvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMuaG9tZUJhc2VDb25maWd1cmF0b3IgPSBuZXcgSG9tZUJhc2VDb25maWd1cmF0b3IoYXBwKTtcclxuICAgICAgICB0aGlzLmV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3IgPSBuZXcgRXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMuZGF0YUZpbGVzRWRpdG9yQ29uZmlndXJhdG9yID0gbmV3IERhdGFGaWxlc0VkaXRvckNvbmZpZ3VyYXRvcihhcHApO1xyXG4gICAgICAgIHRoaXMuZWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3IgPSBuZXcgRWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3IoYXBwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZsdXNoZXMgY3VycmVudCB3aXphcmQgc3RhdGUgdG8gdmFyaW91cyBwbHVnaW4gY29uZmlndXJhdGlvbiBmaWxlcy5cclxuICAgICAqIFRoaXMgZW5zdXJlcyB0aGUgZGlzayByZWZsZWN0cyB0aGUgY3VycmVudCB3aXphcmQgY29uZmlndXJhdGlvbiB3aXRob3V0XHJcbiAgICAgKiBuZWVkaW5nIHRvIHJlYWNoIHRoZSBmaW5hbGl6YXRpb24gc3RlcC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmx1c2goc3RhdGU6IFdpemFyZFN0YXRlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnQ29uZmlnRmx1c2hTZXJ2aWNlOiBTdGFydGluZyBjb25maWd1cmF0aW9uIGZsdXNoJyk7XHJcblxyXG4gICAgICAgIC8vIDEuIENvbmZpZ3VyZSBCYXNlcyBDTVNcclxuICAgICAgICBhd2FpdCB0aGlzLmJhc2VzQ01TQ29uZmlndXJhdG9yLmNyZWF0ZU9yVXBkYXRlQmFzZUZpbGUoXHJcbiAgICAgICAgICAgIHN0YXRlLmNvbnRlbnRUeXBlcyxcclxuICAgICAgICAgICAgc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICBzdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCxcclxuICAgICAgICAgICAgc3RhdGUucHJvamVjdERldGVjdGlvbixcclxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9PT0gdHJ1ZVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIDIuIENvbmZpZ3VyZSBBc3RybyBDb21wb3NlclxyXG4gICAgICAgIGlmIChzdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzdHJvQ29uZmlnID0gYXdhaXQgdGhpcy5hc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yLmNvbmZpZ3VyZUFzdHJvQ29tcG9zZXIoXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb250ZW50VHlwZXMsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290LFxyXG4gICAgICAgICAgICAgICAgc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aCxcclxuICAgICAgICAgICAgICAgIHN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUucHJvamVjdERldGVjdGlvbixcclxuICAgICAgICAgICAgICAgIHN0YXRlLmVuYWJsZU1keFN1cHBvcnRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc3RhdGUuYXN0cm9Db21wb3NlckNvbmZpZyA9IGFzdHJvQ29uZmlnO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3Iuc2F2ZUNvbmZpZyhhc3Ryb0NvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAzLiBDb25maWd1cmUgU0VPXHJcbiAgICAgICAgY29uc3Qgc2VvQ29uZmlnID0gdGhpcy5zZW9Db25maWd1cmF0b3IuZ2VuZXJhdGVTRU9Db25maWcoXHJcbiAgICAgICAgICAgIHN0YXRlLmNvbnRlbnRUeXBlcyxcclxuICAgICAgICAgICAgc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICBzdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVNZHhTdXBwb3J0XHJcbiAgICAgICAgKTtcclxuICAgICAgICBzdGF0ZS5zZW9Db25maWcgPSBzZW9Db25maWc7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zZW9Db25maWd1cmF0b3Iuc2F2ZUNvbmZpZyhzZW9Db25maWcpO1xyXG5cclxuICAgICAgICAvLyA0LiBDb25maWd1cmUgUHJvcGVydHkgT3ZlciBGaWxlIE5hbWVcclxuICAgICAgICBjb25zdCBmaXJzdFR5cGUgPSBzdGF0ZS5jb250ZW50VHlwZXMuZmluZChjdCA9PiBjdC5lbmFibGVkKTtcclxuICAgICAgICBjb25zdCBmaXJzdFByb3BzID0gZmlyc3RUeXBlID8gc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2ZpcnN0VHlwZS5pZF0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGZpcnN0UHJvcHMgJiYgZmlyc3RQcm9wcy50aXRsZVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnByb3BlcnR5T3ZlckZpbGVOYW1lLnByb3BlcnR5S2V5ID0gZmlyc3RQcm9wcy50aXRsZVByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5wcm9wZXJ0eU92ZXJGaWxlTmFtZS5lbmFibGVNZHhTdXBwb3J0ID0gc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9PT0gdHJ1ZTtcclxuICAgICAgICBhd2FpdCB0aGlzLnByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUpO1xyXG5cclxuICAgICAgICAvLyA1LiBDb25maWd1cmUgVUkgVHdlYWtlclxyXG4gICAgICAgIGF3YWl0IHRoaXMudWlUd2Vha2VyQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9PT0gdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIDYuIENvbmZpZ3VyZSBJbWFnZSBNYW5hZ2VyXHJcbiAgICAgICAgaWYgKHN0YXRlLmVuYWJsZWRQbHVnaW5zLmluY2x1ZGVzKCdpbWFnZS1tYW5hZ2VyJykgfHwgT2JqZWN0LmtleXMoc3RhdGUuaW1hZ2VNYW5hZ2VyKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yLnJlc29sdmVBbmRTeW5jSW1hZ2VQcm9wZXJ0eShzdGF0ZSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc3RhdGUuaW1hZ2VNYW5hZ2VyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDcuIENvbmZpZ3VyZSBIb21lIEJhc2VcclxuICAgICAgICBpZiAoc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMoJ2hvbWUtYmFzZScpIHx8IE9iamVjdC5rZXlzKHN0YXRlLmhvbWVCYXNlKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaG9tZUJhc2VDb25maWd1cmF0b3Iuc2F2ZUNvbmZpZyhzdGF0ZS5ob21lQmFzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA4LiBDb25maWd1cmUgRXhwbG9yZXIgRm9jdXNcclxuICAgICAgICBpZiAoc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMoJ2V4cGxvcmVyLWZvY3VzJykgfHwgT2JqZWN0LmtleXMoc3RhdGUuZXhwbG9yZXJGb2N1cykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3Iuc2F2ZUNvbmZpZyhzdGF0ZS5leHBsb3JlckZvY3VzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDkuIENvbmZpZ3VyZSBXWVNJV1lHIFRvb2xiYXIgKHRvZ2dsZSB2aXNpYmlsaXR5IGRpcmVjdGx5KVxyXG4gICAgICAgIGF3YWl0IHRoaXMuZWRpdGluZ1Rvb2xiYXJDb25maWd1cmF0b3IudG9nZ2xlVmlzaWJpbGl0eSh0aGlzLmFwcCwgc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXIpO1xyXG5cclxuICAgICAgICAvLyAxMC4gQ29uZmlndXJlIERhdGEgRmlsZXMgRWRpdG9yXHJcbiAgICAgICAgYXdhaXQgdGhpcy5kYXRhRmlsZXNFZGl0b3JDb25maWd1cmF0b3Iuc2F2ZUNvbmZpZyhzdGF0ZS5lbmFibGVFeHRlbmRlZEZpbGVUeXBlcyA9PT0gdHJ1ZSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0NvbmZpZ0ZsdXNoU2VydmljZTogQ29uZmlndXJhdGlvbiBmbHVzaCBjb21wbGV0ZScpO1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcbmltcG9ydCB7IEdpdE1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9HaXRNYW5hZ2VyJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuXHJcbmV4cG9ydCBjbGFzcyBEZXBsb3ltZW50U3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcclxuICAgIHByaXZhdGUgcmVtb3RlVXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgY29udGFpbmVyRWwsIHN0YXRlLCBvbk5leHQsIG9uQmFjaywgb25DYW5jZWwpO1xyXG4gICAgICAgIHRoaXMuc2hvd05leHRCdXR0b24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFRhaWxvcmVkSW5zdHJ1Y3Rpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IHZhdWx0TG9jYXRpb24gPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnZhdWx0TG9jYXRpb24gfHwgJ3Jvb3QnO1xyXG4gICAgICAgIGNvbnN0IHByb2plY3RSb290ID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdCB8fCAnJztcclxuXHJcbiAgICAgICAgbGV0IHJvb3REaXIgPSAnLyc7XHJcbiAgICAgICAgbGV0IGJ1aWxkQ29tbWFuZCA9ICducG0gcnVuIGJ1aWxkJztcclxuICAgICAgICBsZXQgb3V0cHV0RGlyID0gJ2Rpc3QnO1xyXG5cclxuICAgICAgICAvLyBGb3IgbmVzdGVkLWNvbnRlbnQsIHdlIG5lZWQgdG8gaW5zdHJ1Y3QgdGhlIHVzZXIgYWJvdXQgdGhlIEJ1aWxkIHNldHRpbmdzXHJcbiAgICAgICAgaWYgKHZhdWx0TG9jYXRpb24gPT09ICduZXN0ZWQtY29udGVudCcgfHwgdmF1bHRMb2NhdGlvbiA9PT0gJ2NvbnRlbnQnKSB7XHJcbiAgICAgICAgICAgIC8vIFVzdWFsbHkgaW4gb3VyIHNldHVwcywgdGhlIHByb2plY3RSb290IGlzIHdoZXJlIHRoZSBwYWNrYWdlLmpzb24gaXMsXHJcbiAgICAgICAgICAgIC8vIHNvIGluc3RydWN0aW9ucyByZW1haW4gc3RhbmRhcmQgdW5sZXNzIGl0J3MgYSBtb25vcmVwby5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvb3REaXIsXHJcbiAgICAgICAgICAgIGJ1aWxkQ29tbWFuZCxcclxuICAgICAgICAgICAgb3V0cHV0RGlyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzaG91bGRTa2lwKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIGNvbnN0IHByb2plY3RSb290ID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdDtcclxuICAgICAgICBpZiAocHJvamVjdFJvb3QpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdGVVcmwgPSBhd2FpdCBHaXRNYW5hZ2VyLmdldFJlbW90ZVVybChwcm9qZWN0Um9vdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhdGhpcy5yZW1vdGVVcmw7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0RlcGxveW1lbnQgU2V0dXAnIH0pO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xyXG4gICAgICAgICAgICB0ZXh0OiBcIllvdXIgc2l0ZSBpcyByZWFkeSB0byBiZSBwdWJsaXNoZWQhIENob29zZSBhIGRlcGxveW1lbnQgcGxhdGZvcm0gdG8gaG9zdCB5b3VyIEFzdHJvIHNpdGUuIFNlbGVjdCAnc2tpcCcgaWYgeW91J3ZlIGFscmVhZHkgc2V0IHRoaXMgdXAuXCJcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGhpcy5nZXRUYWlsb3JlZEluc3RydWN0aW9ucygpO1xyXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtQ29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgY2xzOiAnZGVwbG95bWVudC1wbGF0Zm9ybXMnLFxyXG4gICAgICAgICAgICBhdHRyOiB7IHN0eWxlOiAnbWluLWhlaWdodDogNDAwcHg7JyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGxhdGZvcm1Db250YWluZXIuY3JlYXRlRWwoJ2knLCB7XHJcbiAgICAgICAgICAgIHRleHQ6ICdSZXNvbHZpbmcgcmVwb3NpdG9yeSBkZXRhaWxzLi4uJyxcclxuICAgICAgICAgICAgYXR0cjogeyBzdHlsZTogJ29wYWNpdHk6IDAuNTsnIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gMS4gRmV0Y2ggcmVtb3RlIFVSTCAoQXN5bmMpXHJcbiAgICAgICAgY29uc3QgcHJvamVjdFJvb3QgPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290O1xyXG4gICAgICAgIGlmIChwcm9qZWN0Um9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVVybCA9IGF3YWl0IEdpdE1hbmFnZXIuZ2V0UmVtb3RlVXJsKHByb2plY3RSb290KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDIuIENsZWFyIHNrZWxldG9uIGFuZCByZW5kZXIgcGxhdGZvcm1zXHJcbiAgICAgICAgcGxhdGZvcm1Db250YWluZXIuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgLy8gTmV0bGlmeVxyXG4gICAgICAgIHRoaXMucmVuZGVyUGxhdGZvcm0ocGxhdGZvcm1Db250YWluZXIsIHtcclxuICAgICAgICAgICAgbmFtZTogJ05ldGxpZnknLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Zhc3QgYW5kIHJlbGlhYmxlIGhvc3RpbmcuIEdyZWF0IGRldmVsb3BlciBleHBlcmllbmNlLicsXHJcbiAgICAgICAgICAgIHVybDogdGhpcy5nZXROZXRsaWZ5RGVwbG95VXJsKCksXHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgYEJhc2UgZGlyZWN0b3J5OiAke2luc3RydWN0aW9ucy5yb290RGlyID09PSAnLycgPyAnKGxlYXZlIGVtcHR5KScgOiBpbnN0cnVjdGlvbnMucm9vdERpcn1gLFxyXG4gICAgICAgICAgICAgICAgYEJ1aWxkIGNvbW1hbmQ6ICR7aW5zdHJ1Y3Rpb25zLmJ1aWxkQ29tbWFuZH1gLFxyXG4gICAgICAgICAgICAgICAgYFB1Ymxpc2ggZGlyZWN0b3J5OiAke2luc3RydWN0aW9ucy5vdXRwdXREaXJ9YFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFZlcmNlbFxyXG4gICAgICAgIHRoaXMucmVuZGVyUGxhdGZvcm0ocGxhdGZvcm1Db250YWluZXIsIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZlcmNlbCcsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnT3B0aW1pemVkIGZvciBmcm9udGVuZCBmcmFtZXdvcmtzIHdpdGggemVyby1jb25maWcgZGVwbG95bWVudC4nLFxyXG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0VmVyY2VsRGVwbG95VXJsKCksXHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgYEZyYW1ld29yayBQcmVzZXQ6IEFzdHJvYCxcclxuICAgICAgICAgICAgICAgIGBSb290IERpcmVjdG9yeTogJHtpbnN0cnVjdGlvbnMucm9vdERpcn1gLFxyXG4gICAgICAgICAgICAgICAgYEJ1aWxkIENvbW1hbmQ6ICR7aW5zdHJ1Y3Rpb25zLmJ1aWxkQ29tbWFuZH1gXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQ2xvdWRmbGFyZVxyXG4gICAgICAgIHRoaXMucmVuZGVyUGxhdGZvcm0ocGxhdGZvcm1Db250YWluZXIsIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Nsb3VkZmxhcmUnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0hvc3QgeW91ciBzaXRlIG9uIENsb3VkZmxhcmUgUGFnZXMgb3IgV29ya2Vycy4nLFxyXG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0Q2xvdWRmbGFyZURlcGxveVVybCgpLFxyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIGBGcmFtZXdvcmsgUHJlc2V0OiBBc3Ryb2AsXHJcbiAgICAgICAgICAgICAgICBgUm9vdCBEaXJlY3Rvcnk6ICR7aW5zdHJ1Y3Rpb25zLnJvb3REaXJ9YCxcclxuICAgICAgICAgICAgICAgIGBCdWlsZCBDb21tYW5kOiAke2luc3RydWN0aW9ucy5idWlsZENvbW1hbmR9YCxcclxuICAgICAgICAgICAgICAgIGBPdXRwdXQgRGlyZWN0b3J5OiAke2luc3RydWN0aW9ucy5vdXRwdXREaXJ9YFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEdpdEh1YlxyXG4gICAgICAgIHRoaXMucmVuZGVyUGxhdGZvcm0ocGxhdGZvcm1Db250YWluZXIsIHtcclxuICAgICAgICAgICAgbmFtZTogJ0dpdEh1YicsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSG9zdCBkaXJlY3RseSBmcm9tIHlvdXIgR2l0SHViIHJlcG9zaXRvcnkuIChSZXF1aXJlcyBQdWJsaWMgcmVwb3NpdG9yeSBmb3IgZnJlZSBhY2NvdW50cyknLFxyXG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0R2l0SHViUGFnZXNVcmwoKSxcclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBbXHJcbiAgICAgICAgICAgICAgICAnUmVxdWlyZXMgYSBHaXRIdWIgQWN0aW9uIHRvIGJ1aWxkIGFuZCBkZXBsb3kuJyxcclxuICAgICAgICAgICAgICAgICdHbyB0byBSZXBvc2l0b3J5IFNldHRpbmdzID4gUGFnZXMgPiBCdWlsZCBhbmQgZGVwbG95bWVudCA+IFNvdXJjZTogR2l0SHViIEFjdGlvbnMuJyxcclxuICAgICAgICAgICAgICAgICdFbnN1cmUgeW91ciByZXBvc2l0b3J5IGlzIFBVQkxJQyB0byB1c2UgR0ggUGFnZXMgZm9yIGZyZWUuJ1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXROZXRsaWZ5RGVwbG95VXJsKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVtb3RlVXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgaHR0cHM6Ly9hcHAubmV0bGlmeS5jb20vc3RhcnQvZGVwbG95P3JlcG9zaXRvcnk9JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5yZW1vdGVVcmwpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnaHR0cHM6Ly9hcHAubmV0bGlmeS5jb20vJztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFZlcmNlbERlcGxveVVybCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbW90ZVVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vdmVyY2VsLmNvbS9uZXcvY2xvbmU/cmVwb3NpdG9yeS11cmw9JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5yZW1vdGVVcmwpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnaHR0cHM6Ly92ZXJjZWwuY29tL25ldyc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRDbG91ZGZsYXJlRGVwbG95VXJsKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVtb3RlVXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgaHR0cHM6Ly9kZXBsb3kud29ya2Vycy5jbG91ZGZsYXJlLmNvbS8/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMucmVtb3RlVXJsKX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ2h0dHBzOi8vZGFzaC5jbG91ZGZsYXJlLmNvbS8nO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0R2l0SHViUGFnZXNVcmwoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5yZW1vdGVVcmwpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCBodHRwczovL2dpdGh1Yi5jb20vdXNlci9yZXBvLmdpdCB0byBodHRwczovL2dpdGh1Yi5jb20vdXNlci9yZXBvL3NldHRpbmdzL3BhZ2VzXHJcbiAgICAgICAgICAgIGxldCBjbGVhblVybCA9IHRoaXMucmVtb3RlVXJsLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKGNsZWFuVXJsLmVuZHNXaXRoKCcuZ2l0JykpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFuVXJsID0gY2xlYW5Vcmwuc2xpY2UoMCwgLTQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBgJHtjbGVhblVybH0vc2V0dGluZ3MvcGFnZXNgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ2h0dHBzOi8vZ2l0aHViLmNvbS9mZWF0dXJlcy9wYWdlcyc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJQbGF0Zm9ybShjb250YWluZXI6IEhUTUxFbGVtZW50LCBwbGF0Zm9ybTogYW55KSB7XHJcbiAgICAgICAgY29uc3QgcGxhdGZvcm1FbCA9IGNvbnRhaW5lci5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICBjbHM6ICdkZXBsb3ltZW50LXBsYXRmb3JtJyxcclxuICAgICAgICAgICAgYXR0cjogeyBzdHlsZTogJ21hcmdpbi1ib3R0b206IDJyZW07IHBhZGRpbmc6IDFyZW07IGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKTsgYm9yZGVyLXJhZGl1czogOHB4OycgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBoZWFkZXIgPSBwbGF0Zm9ybUVsLmNyZWF0ZUVsKCdoMycsIHsgYXR0cjogeyBzdHlsZTogJ21hcmdpbi10b3A6IDA7JyB9IH0pO1xyXG4gICAgICAgIGhlYWRlci5jcmVhdGVTcGFuKHsgdGV4dDogcGxhdGZvcm0ubmFtZSB9KTtcclxuICAgICAgICBpZiAocGxhdGZvcm0ucmVjb21tZW5kZWQpIHtcclxuICAgICAgICAgICAgaGVhZGVyLmNyZWF0ZVNwYW4oe1xyXG4gICAgICAgICAgICAgICAgdGV4dDogJyBSRUNPTU1FTkRFRCcsXHJcbiAgICAgICAgICAgICAgICBhdHRyOiB7IHN0eWxlOiAnZm9udC1zaXplOiAwLjZlbTsgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgYmFja2dyb3VuZDogdmFyKC0taW50ZXJhY3RpdmUtYWNjZW50KTsgY29sb3I6IHZhcigtLXRleHQtb24tYWNjZW50KTsgcGFkZGluZzogMnB4IDZweDsgYm9yZGVyLXJhZGl1czogNHB4OyBtYXJnaW4tbGVmdDogMTBweDsnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwbGF0Zm9ybUVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBwbGF0Zm9ybS5kZXNjcmlwdGlvbiB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MaXN0ID0gcGxhdGZvcm1FbC5jcmVhdGVFbCgndWwnKTtcclxuICAgICAgICBwbGF0Zm9ybS5pbnN0cnVjdGlvbnMuZm9yRWFjaCgoaW5zdDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uTGlzdC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6IGluc3QgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKHBsYXRmb3JtRWwpXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnRuID0+IGJ0blxyXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoYFNldCB1cCBvbiAke3BsYXRmb3JtLm5hbWV9YClcclxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gd2luZG93Lm9wZW4ocGxhdGZvcm0udXJsKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRpdGxlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuICdEZXBsb3ltZW50JztcclxuICAgIH1cclxuXHJcbiAgICBnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAnUHVibGlzaCB5b3VyIHNpdGUnO1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgV29ya3NwYWNlTGVhZiB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHsgQ29uZmlnRmx1c2hTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29uZmlnRmx1c2hTZXJ2aWNlJztcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9QbHVnaW5NYW5hZ2VyJztcbmltcG9ydCB7IEJhc2VzQ01TQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvQmFzZXNDTVNDb25maWcnO1xuXG5leHBvcnQgY2xhc3MgRmluYWxpemVTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRwcml2YXRlIHBsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXI7XG5cdHByaXZhdGUgYmFzZXNDTVNDb25maWd1cmF0b3I6IEJhc2VzQ01TQ29uZmlndXJhdG9yO1xuXHRwcml2YXRlIGNvbmZpZ0ZsdXNoU2VydmljZTogQ29uZmlnRmx1c2hTZXJ2aWNlO1xuXHRwcml2YXRlIGFwcGxpZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHRpc0FwcGxpZWQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbGllZDtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHN0YXRlOiBXaXphcmRTdGF0ZSwgb25OZXh0OiAoKSA9PiB2b2lkLCBvbkJhY2s6ICgpID0+IHZvaWQsIG9uQ2FuY2VsOiAoKSA9PiB2b2lkKSB7XG5cdFx0c3VwZXIoYXBwLCBjb250YWluZXJFbCwgc3RhdGUsIG9uTmV4dCwgb25CYWNrLCBvbkNhbmNlbCk7XG5cdFx0dGhpcy5wbHVnaW5NYW5hZ2VyID0gbmV3IFBsdWdpbk1hbmFnZXIoYXBwKTtcblx0XHR0aGlzLmJhc2VzQ01TQ29uZmlndXJhdG9yID0gbmV3IEJhc2VzQ01TQ29uZmlndXJhdG9yKGFwcCk7XG5cdFx0dGhpcy5jb25maWdGbHVzaFNlcnZpY2UgPSBuZXcgQ29uZmlnRmx1c2hTZXJ2aWNlKGFwcCk7XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0ZpbmFsaXplIGNvbmZpZ3VyYXRpb24nIH0pO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0dGV4dDogJ1JldmlldyB5b3VyIGNvbmZpZ3VyYXRpb24gYW5kIGNsaWNrIFwiQXBwbHkgYW5kIHJlc3RhcnRcIiBiZWxvdyB0byBzYXZlIGFuZCBhcHBseSBhbGwgc2V0dGluZ3MuJ1xuXHRcdH0pO1xuXG5cdFx0Y29uc3Qgc3VtbWFyeSA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2ZpbmFsaXplLXN1bW1hcnknIH0pO1xuXG5cdFx0c3VtbWFyeS5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdTdW1tYXJ5JyB9KTtcblxuXHRcdC8vIENvbnRlbnQgVHlwZXNcblx0XHRjb25zdCBlbmFibGVkQ29udGVudFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xuXHRcdHN1bW1hcnkuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBDb250ZW50IFR5cGVzOiAke2VuYWJsZWRDb250ZW50VHlwZXMubGVuZ3RofWAgfSk7XG5cblx0XHQvLyBFZGl0aW5nIFRvb2xiYXJcblx0XHRzdW1tYXJ5LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgRWRpdGluZyBUb29sYmFyOiAke3RoaXMuc3RhdGUuZW5hYmxlRWRpdGluZ1Rvb2xiYXIgPyAnRW5hYmxlZCcgOiAnRGlzYWJsZWQnfWAgfSk7XG5cblx0XHQvLyBCYXNlcyBDTVMgVmlld3MgKGNvdW50IGVuYWJsZWQgY29udGVudCB0eXBlcyBhcyB2aWV3cyB0byBiZSBjcmVhdGVkKVxuXHRcdGNvbnN0IGJhc2VzVmlld3NDb3VudCA9IGVuYWJsZWRDb250ZW50VHlwZXMubGVuZ3RoO1xuXHRcdHN1bW1hcnkuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBCYXNlcyBDTVMgVmlld3M6ICR7YmFzZXNWaWV3c0NvdW50fSBuZXcgdmlldyR7YmFzZXNWaWV3c0NvdW50ICE9PSAxID8gJ3MnIDogJyd9IHRvIGJlIGNyZWF0ZWRgIH0pO1xuXG5cdFx0Ly8gU0VPIFNjYW4gRGlyZWN0b3JpZXNcblx0XHRjb25zdCBzZW9EaXJlY3RvcmllcyA9IGVuYWJsZWRDb250ZW50VHlwZXMubWFwKGN0ID0+IGN0LmZvbGRlcik7XG5cdFx0Y29uc3Qgc2VvRGlyZWN0b3JpZXNDb3VudCA9IHNlb0RpcmVjdG9yaWVzLmxlbmd0aDtcblx0XHRzdW1tYXJ5LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgU0VPIFNjYW4gRGlyZWN0b3JpZXM6ICR7c2VvRGlyZWN0b3JpZXNDb3VudH0gZGlyZWN0b3Ike3Nlb0RpcmVjdG9yaWVzQ291bnQgIT09IDEgPyAnaWVzJyA6ICd5J30gKCR7c2VvRGlyZWN0b3JpZXMuam9pbignLCAnKX0pYCB9KTtcblx0fVxuXG5cdGFzeW5jIGFwcGx5Q29uZmlndXJhdGlvbihzaG91bGRSZXN0YXJ0OiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRyZXR1cm4gdGhpcy5hcHBseUNvbmZpZ3VyYXRpb25JbnRlcm5hbChzaG91bGRSZXN0YXJ0KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgYXBwbHlDb25maWd1cmF0aW9uSW50ZXJuYWwoc2hvdWxkUmVzdGFydDogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMuYXBwbGllZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IFN0YXJ0aW5nIGNvbmZpZ3VyYXRpb24gYXBwbGljYXRpb24nKTtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogRW5hYmxlZCBjb250ZW50IHR5cGVzOicsIHRoaXMuc3RhdGUuY29udGVudFR5cGVzLmZpbHRlcihjdCA9PiBjdC5lbmFibGVkKS5tYXAoY3QgPT4gY3QubmFtZSkpO1xuXG5cdFx0XHQvLyBDb25maWd1cmUgcGx1Z2luc1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBDb25maWd1cmluZyBwbHVnaW4gc3RhdGVzJyk7XG5cblx0XHRcdC8vIElmIEV4dGVuZGVkIEZpbGUgVHlwZXMgaXMgZW5hYmxlZCwgZW5zdXJlIERhdGEgRmlsZXMgRWRpdG9yIGlzIGluIGVuYWJsZWRQbHVnaW5zXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5lbmFibGVFeHRlbmRlZEZpbGVUeXBlcykge1xuXHRcdFx0XHRjb25zdCBwbHVnaW5JZCA9ICdkYXRhLWZpbGVzLWVkaXRvcic7XG5cdFx0XHRcdGlmICghdGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW5JZCkpIHtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBGaW5hbGl6ZVN0ZXA6IEVuYWJsaW5nICR7cGx1Z2luSWR9IGJlY2F1c2UgRXh0ZW5kZWQgRmlsZSBUeXBlcyBpcyB0b2dnbGUgb25gKTtcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLnB1c2gocGx1Z2luSWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zID0gdGhpcy5zdGF0ZS5kaXNhYmxlZFBsdWdpbnMuZmlsdGVyKHAgPT4gcCAhPT0gcGx1Z2luSWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRhd2FpdCB0aGlzLnBsdWdpbk1hbmFnZXIuc2V0UGx1Z2luU3RhdGVzKHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMsIHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zKTtcblxuXHRcdFx0Ly8gRmx1c2ggYWxsIGNvbmZpZ3VyYXRpb25zIHVzaW5nIHRoZSBjZW50cmFsaXplZCBzZXJ2aWNlXG5cdFx0XHRhd2FpdCB0aGlzLmNvbmZpZ0ZsdXNoU2VydmljZS5mbHVzaCh0aGlzLnN0YXRlKTtcblxuXHRcdFx0Ly8gQ29uZmlndXJlIGRlZmF1bHQgY29udGVudCB0eXBlIGFuZCBPYnNpZGlhbiBzZXR0aW5ncyAoZm9sbG93aW5nIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgcGF0dGVybilcblx0XHRcdGlmICh0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkKSB7XG5cdFx0XHRcdGNvbnN0IGRlZmF1bHRUeXBlID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmluZChjdCA9PiBjdC5pZCA9PT0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCk7XG5cdFx0XHRcdGlmIChkZWZhdWx0VHlwZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQ29uZmlndXJpbmcgT2JzaWRpYW4gc2V0dGluZ3MgZm9yIGRlZmF1bHQgY29udGVudCB0eXBlOicsIGRlZmF1bHRUeXBlLm5hbWUpO1xuXHRcdFx0XHRcdGNvbnN0IGFwcCA9IHRoaXMuYXBwIGFzIHsgc2V0dGluZz86IHsgc2V0PzogKGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gUHJvbWlzZTx2b2lkPjsgc2F2ZT86ICgpID0+IFByb21pc2U8dm9pZD4gfSB9O1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGF0dGFjaG1lbnRzIGZvbGRlciBiYXNlZCBvbiBnbG9iYWwgYXR0YWNobWVudCBoYW5kbGluZyBtb2RlXG5cdFx0XHRcdFx0bGV0IHRhcmdldFBhdGggPSAnLi8nO1xuXHRcdFx0XHRcdGlmICh0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzYW1lLWZvbGRlcicpIHtcblx0XHRcdFx0XHRcdHRhcmdldFBhdGggPSAnLi8nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc3ViZm9sZGVyJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgfHwgJ2F0dGFjaG1lbnRzJztcblx0XHRcdFx0XHRcdHRhcmdldFBhdGggPSBgLi8ke2ZvbGRlck5hbWV9YDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9PT0gJ3NwZWNpZmllZC1mb2xkZXInKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gdGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSB8fCAnYXR0YWNobWVudHMnO1xuXHRcdFx0XHRcdFx0dGFyZ2V0UGF0aCA9IGZvbGRlck5hbWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTWV0aG9kIDE6IFRyeSB0byB1c2UgdGhlIGFwcCdzIHNldHRpbmdzIG1hbmFnZXIgaWYgYXZhaWxhYmxlIChmb2xsb3dpbmcgYXN0cm8tbW9kdWxhci1zZXR0aW5ncyBwYXR0ZXJuKVxuXHRcdFx0XHRcdGlmIChhcHAuc2V0dGluZyAmJiB0eXBlb2YgYXBwLnNldHRpbmcuc2V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IFVzaW5nIGFwcC5zZXR0aW5nIEFQSScpO1xuXHRcdFx0XHRcdFx0YXdhaXQgYXBwLnNldHRpbmcuc2V0KCduZXdGaWxlTG9jYXRpb24nLCAnZm9sZGVyJyk7XG5cdFx0XHRcdFx0XHRhd2FpdCBhcHAuc2V0dGluZy5zZXQoJ25ld0ZpbGVGb2xkZXJQYXRoJywgZGVmYXVsdFR5cGUuZm9sZGVyKTtcblx0XHRcdFx0XHRcdGF3YWl0IGFwcC5zZXR0aW5nLnNldCgnYXR0YWNobWVudEZvbGRlclBhdGgnLCB0YXJnZXRQYXRoKTtcblx0XHRcdFx0XHRcdGF3YWl0IGFwcC5zZXR0aW5nLnNldCgnbmV3TGlua0Zvcm1hdCcsICdyZWxhdGl2ZScpO1xuXG5cdFx0XHRcdFx0XHQvLyBTYXZlIHRoZSBzZXR0aW5nc1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBhcHAuc2V0dGluZy5zYXZlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IGFwcC5zZXR0aW5nLnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBPYnNpZGlhbiBzZXR0aW5ncyBzYXZlZCB2aWEgYXBwLnNldHRpbmcuc2F2ZSgpJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE1ldGhvZCAyOiBGYWxsYmFjayB0byB2YXVsdCBjb25maWcgKGZvbGxvd2luZyBhc3Ryby1tb2R1bGFyLXNldHRpbmdzIHBhdHRlcm4pXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IFVzaW5nIHZhdWx0LmNvbmZpZyBBUEknKTtcblx0XHRcdFx0XHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQgYXMgeyBjb25maWc/OiB7IG5ld0ZpbGVMb2NhdGlvbj86IHN0cmluZzsgbmV3RmlsZUZvbGRlclBhdGg/OiBzdHJpbmc7IGF0dGFjaG1lbnRGb2xkZXJQYXRoPzogc3RyaW5nOyBuZXdMaW5rRm9ybWF0Pzogc3RyaW5nIH07IHNhdmVDb25maWc/OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH07XG5cdFx0XHRcdFx0XHRjb25zdCBvYnNpZGlhblNldHRpbmdzID0gdmF1bHQuY29uZmlnO1xuXG5cdFx0XHRcdFx0XHRpZiAoIW9ic2lkaWFuU2V0dGluZ3MpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRmluYWxpemVTdGVwOiB2YXVsdC5jb25maWcgaXMgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0b2JzaWRpYW5TZXR0aW5ncy5uZXdGaWxlTG9jYXRpb24gPSAnZm9sZGVyJztcblx0XHRcdFx0XHRcdFx0b2JzaWRpYW5TZXR0aW5ncy5uZXdGaWxlRm9sZGVyUGF0aCA9IGRlZmF1bHRUeXBlLmZvbGRlcjtcblx0XHRcdFx0XHRcdFx0b2JzaWRpYW5TZXR0aW5ncy5hdHRhY2htZW50Rm9sZGVyUGF0aCA9IHRhcmdldFBhdGg7XG5cdFx0XHRcdFx0XHRcdG9ic2lkaWFuU2V0dGluZ3MubmV3TGlua0Zvcm1hdCA9ICdyZWxhdGl2ZSc7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiB2YXVsdC5zYXZlQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXdhaXQgdmF1bHQuc2F2ZUNvbmZpZygpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogT2JzaWRpYW4gc2V0dGluZ3Mgc2F2ZWQgdmlhIHZhdWx0LnNhdmVDb25maWcoKScpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZpbmFsaXplU3RlcDogdmF1bHQuc2F2ZUNvbmZpZygpIGlzIG5vdCBhdmFpbGFibGUnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmFwcGxpZWQgPSB0cnVlO1xuXHRcdFx0Ly8gQ3JlYXRlIGEgbm90aWNlIGJhc2VkIG9uIHdoZXRoZXIgd2UncmUgcmVzdGFydGluZ1xuXHRcdFx0aWYgKHNob3VsZFJlc3RhcnQpIHtcblx0XHRcdFx0bmV3IE5vdGljZSgnQ29uZmlndXJhdGlvbiBhcHBsaWVkLiBPYnNpZGlhbiB3aWxsIG5vdyByZXN0YXJ0Li4uJywgMzAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXcgTm90aWNlKCdDb25maWd1cmF0aW9uIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5ISBZb3UgbWF5IG5lZWQgdG8gcmVzdGFydCBPYnNpZGlhbiB0byBzZWUgYWxsIGNoYW5nZXMuJywgODAwMCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhcHBseSBjb25maWd1cmF0aW9uOicsIGVycm9yKTtcblx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBhcHBseSBjb25maWd1cmF0aW9uLiBQbGVhc2UgY2hlY2sgdGhlIGNvbnNvbGUgZm9yIGRldGFpbHMuJywgNjAwMCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmQgYW55IGFjdGl2ZSBCYXNlcyB2aWV3cyBhbmQgc3dpdGNoIHRoZW0gdG8gdGhlIG5ldyBkZWZhdWx0IHZpZXcuXG5cdCAqIENsb3NlcyBvbGQgdGFicyBhbmQgcmVvcGVucyB0aGVtIHRvIGZvcmNlIGEgY2xlYW4gcmVsb2FkIGlmIG5vdCByZXN0YXJ0aW5nLlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyB1cGRhdGVBY3RpdmVCYXNlc1ZpZXdzKGRlZmF1bHRWaWV3TmFtZTogc3RyaW5nLCBzaG91bGRSZXN0YXJ0OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYmFzZUZpbGVQYXRoID0gYXdhaXQgdGhpcy5iYXNlc0NNU0NvbmZpZ3VyYXRvci5yZXNvbHZlQmFzZUZpbGVQYXRoKCk7XG5cdFx0bGV0IHVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIEZpbmQgYW55IGFjdGl2ZSBCYXNlcyB2aWV3cyBhbmQgdXBkYXRlIHRoZW0gaW5zdGVhZCBvZiBkZXRhY2hpbmdcblx0XHRpbnRlcmZhY2UgQmFzZXNMZWFmU3RhdGUge1xuXHRcdFx0bGVhZjogV29ya3NwYWNlTGVhZjtcblx0XHRcdHN0YXRlOiB7XG5cdFx0XHRcdHR5cGU6IHN0cmluZztcblx0XHRcdFx0YWN0aXZlOiBib29sZWFuO1xuXHRcdFx0XHRzdGF0ZToge1xuXHRcdFx0XHRcdGZpbGU6IHN0cmluZztcblx0XHRcdFx0XHR2aWV3Pzogc3RyaW5nO1xuXHRcdFx0XHRcdHZpZXdOYW1lPzogc3RyaW5nO1xuXHRcdFx0XHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XG5cdFx0XHRcdH07XG5cdFx0XHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRjb25zdCBsZWF2ZXNUb1VwZGF0ZTogQmFzZXNMZWFmU3RhdGVbXSA9IFtdO1xuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5pdGVyYXRlQWxsTGVhdmVzKChsZWFmKSA9PiB7XG5cdFx0XHRjb25zdCB2aWV3VHlwZSA9IGxlYWYudmlldy5nZXRWaWV3VHlwZSgpO1xuXHRcdFx0aWYgKHZpZXdUeXBlID09PSAnYmFzZXMnIHx8IHZpZXdUeXBlID09PSAnYmFzZXMtY21zJykge1xuXHRcdFx0XHRjb25zdCBzdGF0ZSA9IGxlYWYuZ2V0Vmlld1N0YXRlKCk7XG5cdFx0XHRcdGlmIChzdGF0ZS5zdGF0ZT8uZmlsZSA9PT0gYmFzZUZpbGVQYXRoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgRmluYWxpemVTdGVwOiBGb3VuZCBCYXNlcyBsZWFmIHRvIHVwZGF0ZSAodHlwZTogJHt2aWV3VHlwZX0pYCk7XG5cdFx0XHRcdFx0bGVhdmVzVG9VcGRhdGUucHVzaCh7IGxlYWYsIHN0YXRlOiBzdGF0ZSBhcyBCYXNlc0xlYWZTdGF0ZVsnc3RhdGUnXSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gVXBkYXRlIGV4aXN0aW5nIGxlYXZlc1xuXHRcdGZvciAoY29uc3QgeyBsZWFmLCBzdGF0ZSB9IG9mIGxlYXZlc1RvVXBkYXRlKSB7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IFVwZGF0aW5nIGV4aXN0aW5nIEJhc2VzIGxlYWYgc3RhdGUnKTtcblx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZyBsZWFmIHN0YXRlIHRvIHN3aXRjaCB0byB0aGUgbmV3IGRlZmF1bHQgdmlld1xuXHRcdFx0Ly8gU2V0IGJvdGggJ3ZpZXcnIGFuZCAndmlld05hbWUnIGZvciBjb21wYXRpYmlsaXR5IGFjcm9zcyBCYXNlcyB2ZXJzaW9uc1xuXHRcdFx0YXdhaXQgbGVhZi5zZXRWaWV3U3RhdGUoe1xuXHRcdFx0XHQuLi5zdGF0ZSxcblx0XHRcdFx0c3RhdGU6IHtcblx0XHRcdFx0XHQuLi5zdGF0ZS5zdGF0ZSxcblx0XHRcdFx0XHR2aWV3OiBkZWZhdWx0Vmlld05hbWUsXG5cdFx0XHRcdFx0dmlld05hbWU6IGRlZmF1bHRWaWV3TmFtZVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vIEJhc2VzIHZpZXdzIHdlcmUgZm91bmQvdXBkYXRlZCwgb3BlbiBhIG5ldyBvbmVcblx0XHRpZiAoIXVwZGF0ZWQpIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogT3BlbmluZyBuZXcgQmFzZXMgbGVhZiB3aXRoIGZyZXNoIHN0YXRlJyk7XG5cblx0XHRcdC8vIFVzZSAnYmFzZXMtY21zJyBhcyB0aGUgcHJlZmVycmVkIHR5cGUgZm9yIG5ldyBsZWF2ZXNcblx0XHRcdGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZigndGFiJyk7XG5cdFx0XHRhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7XG5cdFx0XHRcdHR5cGU6ICdiYXNlcy1jbXMnLFxuXHRcdFx0XHRhY3RpdmU6IHRydWUsXG5cdFx0XHRcdHN0YXRlOiB7XG5cdFx0XHRcdFx0ZmlsZTogYmFzZUZpbGVQYXRoLFxuXHRcdFx0XHRcdHZpZXc6IGRlZmF1bHRWaWV3TmFtZSxcblx0XHRcdFx0XHR2aWV3TmFtZTogZGVmYXVsdFZpZXdOYW1lXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLnNldEFjdGl2ZUxlYWYobGVhZiwgeyBmb2N1czogdHJ1ZSB9KTtcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFNQRUNJQUwgQ0FTRTogSWYgcmVzdGFydGluZywgYWxzbyB0cnkgdG8gbW9kaWZ5IHdvcmtzcGFjZS5qc29uIGRpcmVjdGx5XG5cdFx0Ly8gVGhpcyBpcyBhIFwiYmVsdCBhbmQgc3VzcGVuZGVyc1wiIGFwcHJvYWNoIGJlY2F1c2UgT2JzaWRpYW4gbWlnaHQgb3ZlcndyaXRlXG5cdFx0Ly8gdGhlIGluLW1lbW9yeSBjaGFuZ2VzIHdoZW4gaXQgY2xvc2VzIGlmIHRoZSB2aWV3IGhhc24ndCBmdWxseSBzeW5jZWQgeWV0LlxuXHRcdGlmIChzaG91bGRSZXN0YXJ0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRcdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXHRcdFx0XHRjb25zdCB3b3Jrc3BhY2VQYXRoID0gYCR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvbmA7XG5cblx0XHRcdFx0aWYgKGF3YWl0IGFkYXB0ZXIuZXhpc3RzKHdvcmtzcGFjZVBhdGgpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBBdHRlbXB0aW5nIGRpcmVjdCB3b3Jrc3BhY2UuanNvbiBtb2RpZmljYXRpb24nKTtcblx0XHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgYWRhcHRlci5yZWFkKHdvcmtzcGFjZVBhdGgpO1xuXG5cdFx0XHRcdFx0aW50ZXJmYWNlIFdvcmtzcGFjZU5vZGUge1xuXHRcdFx0XHRcdFx0dHlwZT86IHN0cmluZztcblx0XHRcdFx0XHRcdHN0YXRlPzoge1xuXHRcdFx0XHRcdFx0XHR0eXBlPzogc3RyaW5nO1xuXHRcdFx0XHRcdFx0XHRzdGF0ZT86IHtcblx0XHRcdFx0XHRcdFx0XHRmaWxlPzogc3RyaW5nO1xuXHRcdFx0XHRcdFx0XHRcdHZpZXc/OiBzdHJpbmc7XG5cdFx0XHRcdFx0XHRcdFx0dmlld05hbWU/OiBzdHJpbmc7XG5cdFx0XHRcdFx0XHRcdFx0W2tleTogc3RyaW5nXTogdW5rbm93bjtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRjaGlsZHJlbj86IFdvcmtzcGFjZU5vZGVbXSB8IFdvcmtzcGFjZU5vZGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW50ZXJmYWNlIFdvcmtzcGFjZURhdGEge1xuXHRcdFx0XHRcdFx0bWFpbj86IFdvcmtzcGFjZU5vZGU7XG5cdFx0XHRcdFx0XHRsZWZ0PzogV29ya3NwYWNlTm9kZTtcblx0XHRcdFx0XHRcdHJpZ2h0PzogV29ya3NwYWNlTm9kZTtcblx0XHRcdFx0XHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3Qgd29ya3NwYWNlID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyBXb3Jrc3BhY2VEYXRhO1xuXG5cdFx0XHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBSZWN1cnNpdmUgZnVuY3Rpb24gdG8gZmluZCBhbmQgdXBkYXRlIEJhc2VzIGxlYXZlcyBpbiB3b3Jrc3BhY2UuanNvblxuXHRcdFx0XHRcdGNvbnN0IHVwZGF0ZU5vZGUgPSAobm9kZTogV29ya3NwYWNlTm9kZSB8IHVuZGVmaW5lZCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCFub2RlKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdGlmIChub2RlLnR5cGUgPT09ICdsZWFmJyAmJiBub2RlLnN0YXRlKSB7XG5cdFx0XHRcdFx0XHRcdGlmICgobm9kZS5zdGF0ZS50eXBlID09PSAnYmFzZXMnIHx8IG5vZGUuc3RhdGUudHlwZSA9PT0gJ2Jhc2VzLWNtcycpICYmXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5zdGF0ZS5zdGF0ZT8uZmlsZSA9PT0gYmFzZUZpbGVQYXRoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgRmluYWxpemVTdGVwOiBGb3VuZCBCYXNlcyBsZWFmIGluIHdvcmtzcGFjZS5qc29uLCB1cGRhdGluZyB0byAke2RlZmF1bHRWaWV3TmFtZX1gKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobm9kZS5zdGF0ZS5zdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5zdGF0ZS5zdGF0ZS52aWV3ID0gZGVmYXVsdFZpZXdOYW1lO1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5zdGF0ZS5zdGF0ZS52aWV3TmFtZSA9IGRlZmF1bHRWaWV3TmFtZTtcblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB1cGRhdGVOb2RlKGNoaWxkKSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dXBkYXRlTm9kZShub2RlLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHR1cGRhdGVOb2RlKHdvcmtzcGFjZS5tYWluKTtcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHdvcmtzcGFjZS5sZWZ0KTtcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHdvcmtzcGFjZS5yaWdodCk7XG5cblx0XHRcdFx0XHRpZiAobW9kaWZpZWQpIHtcblx0XHRcdFx0XHRcdGF3YWl0IGFkYXB0ZXIud3JpdGUod29ya3NwYWNlUGF0aCwgSlNPTi5zdHJpbmdpZnkod29ya3NwYWNlLCBudWxsLCAyKSk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IFN1Y2Nlc3NmdWxseSBtb2RpZmllZCB3b3Jrc3BhY2UuanNvbicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGaW5hbGl6ZVN0ZXA6IEZhaWxlZCB0byBtb2RpZnkgd29ya3NwYWNlLmpzb24gZGlyZWN0bHk6JywgZXJyb3IpO1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdywgd2Ugc3RpbGwgaGF2ZSB0aGUgaW4tbWVtb3J5IHVwZGF0ZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdC8vIEFsd2F5cyByZXR1cm4gdHJ1ZSBmb3IgZmluYWxpemUgc3RlcCAtIHZhbGlkYXRpb24gaGFwcGVucyB3aGVuIEFwcGx5IGlzIGNsaWNrZWRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdGaW5hbGl6ZSc7XG5cdH1cblxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnUmV2aWV3IGFuZCBhcHBseSBjb25maWd1cmF0aW9uJztcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuaW1wb3J0IHsgV2VsY29tZVN0ZXAgfSBmcm9tICcuL1dlbGNvbWVTdGVwJztcbmltcG9ydCB7IFByb2plY3REZXRlY3Rpb25TdGVwIH0gZnJvbSAnLi9Qcm9qZWN0RGV0ZWN0aW9uU3RlcCc7XG5pbXBvcnQgeyBDb250ZW50VHlwZVN0ZXAgfSBmcm9tICcuL0NvbnRlbnRUeXBlU3RlcCc7XG5pbXBvcnQgeyBGcm9udG1hdHRlclByb3BlcnRpZXNTdGVwIH0gZnJvbSAnLi9Gcm9udG1hdHRlclByb3BlcnRpZXNTdGVwJztcbmltcG9ydCB7IFBsdWdpbkNvbmZpZ3VyYXRpb25TdGVwIH0gZnJvbSAnLi9QbHVnaW5Db25maWd1cmF0aW9uU3RlcCc7XG5pbXBvcnQgeyBPcHRpb25hbFBsdWdpbnNTdGVwIH0gZnJvbSAnLi9PcHRpb25hbFBsdWdpbnNTdGVwJztcbmltcG9ydCB7IElnbm9yZVN0ZXAgfSBmcm9tICcuL0lnbm9yZVN0ZXAnO1xuaW1wb3J0IHsgR2l0U2V0dXBTdGVwIH0gZnJvbSAnLi9HaXRTZXR1cFN0ZXAnO1xuaW1wb3J0IHsgRGVwbG95bWVudFN0ZXAgfSBmcm9tICcuL0RlcGxveW1lbnRTdGVwJztcbmltcG9ydCB7IEZpbmFsaXplU3RlcCB9IGZyb20gJy4vRmluYWxpemVTdGVwJztcblxuLyoqXG4gKiBXaXphcmQgc3RhdGUgbWFjaGluZSBzdGF0ZXNcbiAqIEVhY2ggc3RhdGUgcmVwcmVzZW50cyBhIGxvZ2ljYWwgcGhhc2UgaW4gdGhlIHNldHVwIHByb2Nlc3NcbiAqL1xuZXhwb3J0IHR5cGUgV2l6YXJkTWFjaGluZVN0YXRlID1cblx0fCAnd2VsY29tZSdcblx0fCAnZGV0ZWN0J1xuXHR8ICdjb250ZW50LXR5cGVzJ1xuXHR8ICdmcm9udG1hdHRlcidcblx0fCAncGx1Z2lucydcblx0fCAnY29tcGxldGUnO1xuXG4vKipcbiAqIFN0ZXAgY29uc3RydWN0b3IgdHlwZSBmb3IgY3JlYXRpbmcgd2l6YXJkIHN0ZXBzXG4gKi9cbnR5cGUgU3RlcENvbnN0cnVjdG9yID0gbmV3IChcblx0YXBwOiBBcHAsXG5cdGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcblx0c3RhdGU6IFdpemFyZFN0YXRlLFxuXHRvbk5leHQ6ICgpID0+IHZvaWQsXG5cdG9uQmFjazogKCkgPT4gdm9pZCxcblx0b25DYW5jZWw6ICgpID0+IHZvaWRcbikgPT4gQmFzZVdpemFyZFN0ZXA7XG5cbi8qKlxuICogU3RhdGUgbWFjaGluZSBmb3IgbWFuYWdpbmcgd2l6YXJkIGZsb3dcbiAqIE1ha2VzIHRyYW5zaXRpb25zIGV4cGxpY2l0IGFuZCBlYXNpZXIgdG8gZGVidWdcbiAqL1xuZXhwb3J0IGNsYXNzIFdpemFyZFN0YXRlTWFjaGluZSB7XG5cdHByaXZhdGUgY3VycmVudFN0YXRlOiBXaXphcmRNYWNoaW5lU3RhdGU7XG5cdHByaXZhdGUgc3RlcEluZGV4OiBudW1iZXI7XG5cdHByaXZhdGUgc3RlcHM6IFN0ZXBDb25zdHJ1Y3RvcltdO1xuXG5cdC8vIFN0YXRlIHRvIHN0ZXAgaW5kZXggbWFwcGluZ1xuXHRwcml2YXRlIHJlYWRvbmx5IHN0YXRlU3RlcE1hcDogTWFwPFdpemFyZE1hY2hpbmVTdGF0ZSwgbnVtYmVyPiA9IG5ldyBNYXAoW1xuXHRcdFsnd2VsY29tZScsIDBdLFxuXHRcdFsnZGV0ZWN0JywgMV0sXG5cdFx0Wydjb250ZW50LXR5cGVzJywgMl0sXG5cdFx0Wydmcm9udG1hdHRlcicsIDNdLFxuXHRcdFsncGx1Z2lucycsIDRdLFxuXHRcdFsnY29tcGxldGUnLCA5XVxuXHRdKTtcblxuXHQvLyBSZXZlcnNlIG1hcHBpbmc6IHN0ZXAgaW5kZXggdG8gc3RhdGVcblx0cHJpdmF0ZSByZWFkb25seSBzdGVwU3RhdGVNYXA6IE1hcDxudW1iZXIsIFdpemFyZE1hY2hpbmVTdGF0ZT4gPSBuZXcgTWFwKFtcblx0XHRbMCwgJ3dlbGNvbWUnXSxcblx0XHRbMSwgJ2RldGVjdCddLFxuXHRcdFsyLCAnY29udGVudC10eXBlcyddLFxuXHRcdFszLCAnZnJvbnRtYXR0ZXInXSxcblx0XHRbNCwgJ3BsdWdpbnMnXSwgLy8gUGx1Z2luQ29uZmlndXJhdGlvblN0ZXBcblx0XHRbNSwgJ3BsdWdpbnMnXSwgLy8gT3B0aW9uYWxQbHVnaW5zU3RlcFxuXHRcdFs2LCAncGx1Z2lucyddLCAvLyBJZ25vcmVTdGVwXG5cdFx0WzcsICdwbHVnaW5zJ10sIC8vIEdpdFNldHVwU3RlcFxuXHRcdFs4LCAncGx1Z2lucyddLCAvLyBEZXBsb3ltZW50U3RlcFxuXHRcdFs5LCAnY29tcGxldGUnXSAvLyBGaW5hbGl6ZVN0ZXBcblx0XSk7XG5cblx0Ly8gU3RhdGUgdHJhbnNpdGlvbiBydWxlc1xuXHRwcml2YXRlIHJlYWRvbmx5IHRyYW5zaXRpb25zOiBNYXA8V2l6YXJkTWFjaGluZVN0YXRlLCBXaXphcmRNYWNoaW5lU3RhdGVbXT4gPSBuZXcgTWFwKFtcblx0XHRbJ3dlbGNvbWUnLCBbJ2RldGVjdCddXSxcblx0XHRbJ2RldGVjdCcsIFsnY29udGVudC10eXBlcyddXSxcblx0XHRbJ2NvbnRlbnQtdHlwZXMnLCBbJ2Zyb250bWF0dGVyJ11dLFxuXHRcdFsnZnJvbnRtYXR0ZXInLCBbJ3BsdWdpbnMnXV0sXG5cdFx0WydwbHVnaW5zJywgWydjb21wbGV0ZSddXSxcblx0XHRbJ2NvbXBsZXRlJywgW11dIC8vIFRlcm1pbmFsIHN0YXRlXG5cdF0pO1xuXG5cdGNvbnN0cnVjdG9yKHN0ZXBzPzogU3RlcENvbnN0cnVjdG9yW10pIHtcblx0XHR0aGlzLmN1cnJlbnRTdGF0ZSA9ICd3ZWxjb21lJztcblx0XHR0aGlzLnN0ZXBJbmRleCA9IDA7XG5cdFx0dGhpcy5zdGVwcyA9IHN0ZXBzIHx8IFtcblx0XHRcdFdlbGNvbWVTdGVwLFxuXHRcdFx0UHJvamVjdERldGVjdGlvblN0ZXAsXG5cdFx0XHRDb250ZW50VHlwZVN0ZXAsXG5cdFx0XHRGcm9udG1hdHRlclByb3BlcnRpZXNTdGVwLFxuXHRcdFx0UGx1Z2luQ29uZmlndXJhdGlvblN0ZXAsXG5cdFx0XHRPcHRpb25hbFBsdWdpbnNTdGVwLFxuXHRcdFx0SWdub3JlU3RlcCxcblx0XHRcdEdpdFNldHVwU3RlcCxcblx0XHRcdERlcGxveW1lbnRTdGVwLFxuXHRcdFx0RmluYWxpemVTdGVwXG5cdFx0XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGVcblx0ICovXG5cdGdldFN0YXRlKCk6IFdpemFyZE1hY2hpbmVTdGF0ZSB7XG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudFN0YXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBzdGVwIGluZGV4XG5cdCAqL1xuXHRnZXRTdGVwSW5kZXgoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5zdGVwSW5kZXg7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSB0b3RhbCBudW1iZXIgb2Ygc3RlcHNcblx0ICovXG5cdGdldFRvdGFsU3RlcHMoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5zdGVwcy5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBzdGVwIGNvbnN0cnVjdG9yIGZvciBhIGdpdmVuIGluZGV4XG5cdCAqL1xuXHRnZXRTdGVwQ29uc3RydWN0b3IoaW5kZXg6IG51bWJlcik6IFN0ZXBDb25zdHJ1Y3RvciB8IHVuZGVmaW5lZCB7XG5cdFx0cmV0dXJuIHRoaXMuc3RlcHNbaW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGNhbiB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0ZXAvc3RhdGVcblx0ICovXG5cdGNhbkdvTmV4dCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5zdGVwSW5kZXggPCB0aGlzLnN0ZXBzLmxlbmd0aCAtIDE7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgd2UgY2FuIGdvIGJhY2sgdG8gdGhlIHByZXZpb3VzIHN0ZXAvc3RhdGVcblx0ICovXG5cdGNhbkdvQmFjaygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5zdGVwSW5kZXggPiAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1vdmUgdG8gdGhlIG5leHQgc3RlcFxuXHQgKiBVcGRhdGVzIGJvdGggc3RlcCBpbmRleCBhbmQgc3RhdGVcblx0ICovXG5cdG5leHQoKTogdm9pZCB7XG5cdFx0aWYgKCF0aGlzLmNhbkdvTmV4dCgpKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1dpemFyZFN0YXRlTWFjaGluZTogQ2Fubm90IGdvIHRvIG5leHQgc3RlcCAtIGFscmVhZHkgYXQgZmluYWwgc3RlcCcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG5leHRTdGVwSW5kZXggPSB0aGlzLnN0ZXBJbmRleCArIDE7XG5cdFx0Y29uc3QgbmV4dFN0YXRlID0gdGhpcy5zdGVwU3RhdGVNYXAuZ2V0KG5leHRTdGVwSW5kZXgpO1xuXG5cdFx0aWYgKCFuZXh0U3RhdGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYFdpemFyZFN0YXRlTWFjaGluZTogTm8gc3RhdGUgbWFwcGluZyBmb3Igc3RlcCBpbmRleCAke25leHRTdGVwSW5kZXh9YCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gVmFsaWRhdGUgdHJhbnNpdGlvblxuXHRcdGNvbnN0IGFsbG93ZWRUcmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbnMuZ2V0KHRoaXMuY3VycmVudFN0YXRlKSB8fCBbXTtcblx0XHRpZiAoIWFsbG93ZWRUcmFuc2l0aW9ucy5pbmNsdWRlcyhuZXh0U3RhdGUpICYmIG5leHRTdGF0ZSAhPT0gdGhpcy5jdXJyZW50U3RhdGUpIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0YFdpemFyZFN0YXRlTWFjaGluZTogSW52YWxpZCB0cmFuc2l0aW9uIGZyb20gJHt0aGlzLmN1cnJlbnRTdGF0ZX0gdG8gJHtuZXh0U3RhdGV9YFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLnN0ZXBJbmRleCA9IG5leHRTdGVwSW5kZXg7XG5cdFx0dGhpcy5jdXJyZW50U3RhdGUgPSBuZXh0U3RhdGU7XG5cblx0XHRjb25zb2xlLmRlYnVnKFxuXHRcdFx0YFdpemFyZFN0YXRlTWFjaGluZTogVHJhbnNpdGlvbmVkIHRvIHN0ZXAgJHt0aGlzLnN0ZXBJbmRleH0gKHN0YXRlOiAke3RoaXMuY3VycmVudFN0YXRlfSlgXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNb3ZlIHRvIHRoZSBwcmV2aW91cyBzdGVwXG5cdCAqIFVwZGF0ZXMgYm90aCBzdGVwIGluZGV4IGFuZCBzdGF0ZVxuXHQgKi9cblx0cHJldmlvdXMoKTogdm9pZCB7XG5cdFx0aWYgKCF0aGlzLmNhbkdvQmFjaygpKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1dpemFyZFN0YXRlTWFjaGluZTogQ2Fubm90IGdvIHRvIHByZXZpb3VzIHN0ZXAgLSBhbHJlYWR5IGF0IGZpcnN0IHN0ZXAnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBwcmV2U3RlcEluZGV4ID0gdGhpcy5zdGVwSW5kZXggLSAxO1xuXHRcdGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RlcFN0YXRlTWFwLmdldChwcmV2U3RlcEluZGV4KTtcblxuXHRcdGlmICghcHJldlN0YXRlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBXaXphcmRTdGF0ZU1hY2hpbmU6IE5vIHN0YXRlIG1hcHBpbmcgZm9yIHN0ZXAgaW5kZXggJHtwcmV2U3RlcEluZGV4fWApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RlcEluZGV4ID0gcHJldlN0ZXBJbmRleDtcblx0XHR0aGlzLmN1cnJlbnRTdGF0ZSA9IHByZXZTdGF0ZTtcblxuXHRcdGNvbnNvbGUuZGVidWcoXG5cdFx0XHRgV2l6YXJkU3RhdGVNYWNoaW5lOiBXZW50IGJhY2sgdG8gc3RlcCAke3RoaXMuc3RlcEluZGV4fSAoc3RhdGU6ICR7dGhpcy5jdXJyZW50U3RhdGV9KWBcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEp1bXAgdG8gYSBzcGVjaWZpYyBzdGVwIGluZGV4XG5cdCAqIFVwZGF0ZXMgYm90aCBzdGVwIGluZGV4IGFuZCBzdGF0ZVxuXHQgKi9cblx0anVtcFRvU3RlcChpbmRleDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Ly8gQ2xhbXAgaW5kZXggdG8gdmFsaWQgcmFuZ2Vcblx0XHRjb25zdCBjbGFtcGVkSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5zdGVwcy5sZW5ndGggLSAxKSk7XG5cblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMuc3RlcFN0YXRlTWFwLmdldChjbGFtcGVkSW5kZXgpO1xuXHRcdGlmICghc3RhdGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYFdpemFyZFN0YXRlTWFjaGluZTogTm8gc3RhdGUgbWFwcGluZyBmb3Igc3RlcCBpbmRleCAke2NsYW1wZWRJbmRleH1gKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnN0ZXBJbmRleCA9IGNsYW1wZWRJbmRleDtcblx0XHR0aGlzLmN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXG5cdFx0Y29uc29sZS5kZWJ1Zyhcblx0XHRcdGBXaXphcmRTdGF0ZU1hY2hpbmU6IEp1bXBlZCB0byBzdGVwICR7dGhpcy5zdGVwSW5kZXh9IChzdGF0ZTogJHt0aGlzLmN1cnJlbnRTdGF0ZX0pYFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogSnVtcCB0byBhIHNwZWNpZmljIHN0YXRlXG5cdCAqIFRoaXMgd2lsbCBtb3ZlIHRvIHRoZSBmaXJzdCBzdGVwIG9mIHRoYXQgc3RhdGVcblx0ICovXG5cdGp1bXBUb1N0YXRlKHN0YXRlOiBXaXphcmRNYWNoaW5lU3RhdGUpOiB2b2lkIHtcblx0XHRjb25zdCBzdGVwSW5kZXggPSB0aGlzLnN0YXRlU3RlcE1hcC5nZXQoc3RhdGUpO1xuXG5cdFx0aWYgKHN0ZXBJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBXaXphcmRTdGF0ZU1hY2hpbmU6IE5vIHN0ZXAgbWFwcGluZyBmb3Igc3RhdGUgJHtzdGF0ZX1gKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmp1bXBUb1N0ZXAoc3RlcEluZGV4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcHJvZ3Jlc3MgYXMgYSBwZXJjZW50YWdlXG5cdCAqL1xuXHRnZXRQcm9ncmVzcygpOiBudW1iZXIge1xuXHRcdGlmICh0aGlzLnN0ZXBzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG5cdFx0cmV0dXJuICgodGhpcy5zdGVwSW5kZXggKyAxKSAvIHRoaXMuc3RlcHMubGVuZ3RoKSAqIDEwMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgY3VycmVudCBzdGF0ZVxuXHQgKi9cblx0Z2V0U3RhdGVEZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuXHRcdHN3aXRjaCAodGhpcy5jdXJyZW50U3RhdGUpIHtcblx0XHRcdGNhc2UgJ3dlbGNvbWUnOlxuXHRcdFx0XHRyZXR1cm4gJ1dlbGNvbWUnO1xuXHRcdFx0Y2FzZSAnZGV0ZWN0Jzpcblx0XHRcdFx0cmV0dXJuICdQcm9qZWN0IERldGVjdGlvbic7XG5cdFx0XHRjYXNlICdjb250ZW50LXR5cGVzJzpcblx0XHRcdFx0cmV0dXJuICdDb250ZW50IFR5cGUgU2V0dXAnO1xuXHRcdFx0Y2FzZSAnZnJvbnRtYXR0ZXInOlxuXHRcdFx0XHRyZXR1cm4gJ0Zyb250bWF0dGVyIENvbmZpZ3VyYXRpb24nO1xuXHRcdFx0Y2FzZSAncGx1Z2lucyc6XG5cdFx0XHRcdHJldHVybiAnUGx1Z2luIENvbmZpZ3VyYXRpb24nO1xuXHRcdFx0Y2FzZSAnY29tcGxldGUnOlxuXHRcdFx0XHRyZXR1cm4gJ0ZpbmFsaXphdGlvbic7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gJ1Vua25vd24gU3RhdGUnO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWJ1ZzogR2V0IGEgc3VtbWFyeSBvZiB0aGUgY3VycmVudCBzdGF0ZSBtYWNoaW5lIHN0YXR1c1xuXHQgKi9cblx0Z2V0RGVidWdJbmZvKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIGBTdGF0ZTogJHt0aGlzLmN1cnJlbnRTdGF0ZX0gKCR7dGhpcy5nZXRTdGF0ZURlc2NyaXB0aW9uKCl9KSB8IGAgK1xuXHRcdFx0YFN0ZXA6ICR7dGhpcy5zdGVwSW5kZXggKyAxfS8ke3RoaXMuc3RlcHMubGVuZ3RofSB8IGAgK1xuXHRcdFx0YFByb2dyZXNzOiAke3RoaXMuZ2V0UHJvZ3Jlc3MoKS50b0ZpeGVkKDEpfSVgO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCwgVEZpbGUsIHNldEljb24gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgVmF1bHRDTVNQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBQcm9qZWN0RGV0ZWN0b3IgfSBmcm9tICcuLi91dGlscy9Qcm9qZWN0RGV0ZWN0b3InO1xuaW1wb3J0IHsgQmFzZXNDTVNDb25maWd1cmF0b3IgfSBmcm9tICcuLi91dGlscy9CYXNlc0NNU0NvbmZpZyc7XG5cbmludGVyZmFjZSBIZWFsdGhDaGVja1Jlc3VsdCB7XG5cdGNhdGVnb3J5OiBzdHJpbmc7XG5cdGNoZWNrczoge1xuXHRcdG5hbWU6IHN0cmluZztcblx0XHRzdGF0dXM6ICdwYXNzJyB8ICdmYWlsJyB8ICd3YXJuaW5nJztcblx0XHRtZXNzYWdlPzogc3RyaW5nO1xuXHR9W107XG59XG5cbmV4cG9ydCBjbGFzcyBIZWFsdGhDaGVja01vZGFsIGV4dGVuZHMgTW9kYWwge1xuXHRwcml2YXRlIHBsdWdpbjogVmF1bHRDTVNQbHVnaW47XG5cdHByaXZhdGUgcmVzdWx0czogSGVhbHRoQ2hlY2tSZXN1bHRbXSA9IFtdO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFZhdWx0Q01TUGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0fVxuXG5cdGFzeW5jIG9uT3BlbigpIHtcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcblx0XHRjb250ZW50RWwuYWRkQ2xhc3MoJ3ZhdWx0LWNtcy1oZWFsdGgtY2hlY2snKTtcblxuXHRcdC8vIEFkZCB0aXRsZVxuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdWYXVsdCBDTVMgSGVhbHRoIENoZWNrJyB9KTtcblxuXHRcdC8vIFJ1biBhbGwgaGVhbHRoIGNoZWNrc1xuXHRcdGF3YWl0IHRoaXMucnVuSGVhbHRoQ2hlY2tzKCk7XG5cblx0XHQvLyBEaXNwbGF5IHJlc3VsdHNcblx0XHR0aGlzLmRpc3BsYXlSZXN1bHRzKGNvbnRlbnRFbCk7XG5cblx0XHQvLyBBZGQgY2xvc2UgYnV0dG9uXG5cdFx0Y29uc3QgZm9vdGVyID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogJ2hlYWx0aC1jaGVjay1mb290ZXInIH0pO1xuXHRcdGNvbnN0IGNsb3NlQnRuID0gZm9vdGVyLmNyZWF0ZUVsKCdidXR0b24nLCB7XG5cdFx0XHR0ZXh0OiAnQ2xvc2UnLFxuXHRcdFx0Y2xzOiAnbW9kLWN0YSdcblx0XHR9KTtcblx0XHRjbG9zZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuY2xvc2UoKSk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHJ1bkhlYWx0aENoZWNrcygpIHtcblx0XHR0aGlzLnJlc3VsdHMgPSBbXTtcblxuXHRcdC8vIENoZWNrIDE6IENvbXBhbmlvbiBQbHVnaW5zIEluc3RhbGxhdGlvblxuXHRcdGF3YWl0IHRoaXMuY2hlY2tDb21wYW5pb25QbHVnaW5zSW5zdGFsbGVkKCk7XG5cblx0XHQvLyBDaGVjayAyOiBDb21wYW5pb24gUGx1Z2lucyBFbmFibGVkXG5cdFx0YXdhaXQgdGhpcy5jaGVja0NvbXBhbmlvblBsdWdpbnNFbmFibGVkKCk7XG5cblx0XHQvLyBDaGVjayAzOiBBc3RybyBQcm9qZWN0IERldGVjdGlvblxuXHRcdGF3YWl0IHRoaXMuY2hlY2tBc3Ryb1Byb2plY3REZXRlY3Rpb24oKTtcblxuXHRcdC8vIENoZWNrIDQ6IFBsdWdpbiBDb25maWd1cmF0aW9uXG5cdFx0YXdhaXQgdGhpcy5jaGVja1BsdWdpbkNvbmZpZ3VyYXRpb24oKTtcblxuXHRcdC8vIENoZWNrIDU6IEdpdCBJbnRlZ3JhdGlvblxuXHRcdGF3YWl0IHRoaXMuY2hlY2tHaXRJbnRlZ3JhdGlvbigpO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBjaGVja0NvbXBhbmlvblBsdWdpbnNJbnN0YWxsZWQoKSB7XG5cdFx0Y29uc3QgcmVxdWlyZWRQbHVnaW5zID0gW1xuXHRcdFx0eyBpZDogJ2FzdHJvLWNvbXBvc2VyJywgbmFtZTogJ0FzdHJvIENvbXBvc2VyJyB9LFxuXHRcdFx0eyBpZDogJ2Jhc2VzLWNtcycsIG5hbWU6ICdCYXNlcyBDTVMnIH0sXG5cdFx0XHR7IGlkOiAnaG9tZS1iYXNlJywgbmFtZTogJ0hvbWUgQmFzZScgfSxcblx0XHRcdHsgaWQ6ICdzZW8nLCBuYW1lOiAnU0VPJyB9XG5cdFx0XTtcblxuXHRcdGNvbnN0IG9wdGlvbmFsUGx1Z2lucyA9IFtcblx0XHRcdHsgaWQ6ICdwcm9wZXJ0eS1vdmVyLWZpbGUtbmFtZScsIG5hbWU6ICdQcm9wZXJ0eSBPdmVyIEZpbGUgTmFtZScgfSxcblx0XHRcdHsgaWQ6ICdpbWFnZS1tYW5hZ2VyJywgbmFtZTogJ0ltYWdlIE1hbmFnZXInIH1cblx0XHRdO1xuXG5cdFx0Y29uc3QgY2hlY2tzOiBIZWFsdGhDaGVja1Jlc3VsdFsnY2hlY2tzJ10gPSBbXTtcblxuXHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogeyBwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfSB9KS5wbHVnaW5zPy5wbHVnaW5zIHx8IHt9O1xuXG5cdFx0Ly8gQ2hlY2sgcmVxdWlyZWQgcGx1Z2luc1xuXHRcdGZvciAoY29uc3QgcGx1Z2luIG9mIHJlcXVpcmVkUGx1Z2lucykge1xuXHRcdFx0Y29uc3QgaXNJbnN0YWxsZWQgPSAhIXBsdWdpbnNbcGx1Z2luLmlkXTtcblx0XHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdFx0bmFtZTogYCR7cGx1Z2luLm5hbWV9IGluc3RhbGxlZGAsXG5cdFx0XHRcdHN0YXR1czogaXNJbnN0YWxsZWQgPyAncGFzcycgOiAnZmFpbCcsXG5cdFx0XHRcdG1lc3NhZ2U6IGlzSW5zdGFsbGVkID8gdW5kZWZpbmVkIDogJ1BsdWdpbiBub3QgaW5zdGFsbGVkJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgb3B0aW9uYWwgcGx1Z2luc1xuXHRcdGZvciAoY29uc3QgcGx1Z2luIG9mIG9wdGlvbmFsUGx1Z2lucykge1xuXHRcdFx0Y29uc3QgaXNJbnN0YWxsZWQgPSAhIXBsdWdpbnNbcGx1Z2luLmlkXTtcblx0XHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdFx0bmFtZTogYCR7cGx1Z2luLm5hbWV9IGluc3RhbGxlZGAsXG5cdFx0XHRcdHN0YXR1czogaXNJbnN0YWxsZWQgPyAncGFzcycgOiAnd2FybmluZycsXG5cdFx0XHRcdG1lc3NhZ2U6IGlzSW5zdGFsbGVkID8gdW5kZWZpbmVkIDogJ09wdGlvbmFsIHBsdWdpbiBub3QgaW5zdGFsbGVkJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZXN1bHRzLnB1c2goe1xuXHRcdFx0Y2F0ZWdvcnk6ICdQbHVnaW4gSW5zdGFsbGF0aW9uJyxcblx0XHRcdGNoZWNrc1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBjaGVja0NvbXBhbmlvblBsdWdpbnNFbmFibGVkKCkge1xuXHRcdGNvbnN0IHJlcXVpcmVkUGx1Z2lucyA9IFtcblx0XHRcdHsgaWQ6ICdhc3Ryby1jb21wb3NlcicsIG5hbWU6ICdBc3RybyBDb21wb3NlcicgfSxcblx0XHRcdHsgaWQ6ICdiYXNlcy1jbXMnLCBuYW1lOiAnQmFzZXMgQ01TJyB9LFxuXHRcdFx0eyBpZDogJ2hvbWUtYmFzZScsIG5hbWU6ICdIb21lIEJhc2UnIH0sXG5cdFx0XHR7IGlkOiAnc2VvJywgbmFtZTogJ1NFTycgfVxuXHRcdF07XG5cblx0XHRjb25zdCBjaGVja3M6IEhlYWx0aENoZWNrUmVzdWx0WydjaGVja3MnXSA9IFtdO1xuXG5cdFx0Y29uc3QgcGx1Z2luc0FQSSA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiB7IGVuYWJsZWRQbHVnaW5zPzogU2V0PHN0cmluZz4gfSB9KS5wbHVnaW5zO1xuXHRcdGNvbnN0IGVuYWJsZWRQbHVnaW5zID0gcGx1Z2luc0FQST8uZW5hYmxlZFBsdWdpbnMgfHwgbmV3IFNldDxzdHJpbmc+KCk7XG5cblx0XHRmb3IgKGNvbnN0IHBsdWdpbiBvZiByZXF1aXJlZFBsdWdpbnMpIHtcblx0XHRcdGNvbnN0IGlzRW5hYmxlZCA9IGVuYWJsZWRQbHVnaW5zLmhhcyhwbHVnaW4uaWQpO1xuXHRcdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiBgJHtwbHVnaW4ubmFtZX0gZW5hYmxlZGAsXG5cdFx0XHRcdHN0YXR1czogaXNFbmFibGVkID8gJ3Bhc3MnIDogJ2ZhaWwnLFxuXHRcdFx0XHRtZXNzYWdlOiBpc0VuYWJsZWQgPyB1bmRlZmluZWQgOiAnUGx1Z2luIGlzIGluc3RhbGxlZCBidXQgbm90IGVuYWJsZWQnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLnJlc3VsdHMucHVzaCh7XG5cdFx0XHRjYXRlZ29yeTogJ1BsdWdpbiBTdGF0dXMnLFxuXHRcdFx0Y2hlY2tzXG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNoZWNrQXN0cm9Qcm9qZWN0RGV0ZWN0aW9uKCkge1xuXHRcdGNvbnN0IGNoZWNrczogSGVhbHRoQ2hlY2tSZXN1bHRbJ2NoZWNrcyddID0gW107XG5cblx0XHQvLyBDaGVjayBpZiBwcm9qZWN0IGlzIGRldGVjdGVkIGluIHNldHRpbmdzXG5cdFx0Y29uc3QgaGFzUHJvamVjdFJvb3QgPSAhIXRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290O1xuXHRcdGNvbnN0IGhhc0NvbmZpZ0ZpbGUgPSAhIXRoaXMucGx1Z2luLnNldHRpbmdzLmNvbmZpZ0ZpbGVQYXRoO1xuXG5cdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0bmFtZTogJ1Byb2plY3Qgcm9vdCBjb25maWd1cmVkJyxcblx0XHRcdHN0YXR1czogaGFzUHJvamVjdFJvb3QgPyAncGFzcycgOiAnZmFpbCcsXG5cdFx0XHRtZXNzYWdlOiBoYXNQcm9qZWN0Um9vdCA/IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RSb290IDogJ1Byb2plY3Qgcm9vdCBub3Qgc2V0J1xuXHRcdH0pO1xuXG5cdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0bmFtZTogJ0NvbmZpZyBmaWxlIGRldGVjdGVkJyxcblx0XHRcdHN0YXR1czogaGFzQ29uZmlnRmlsZSA/ICdwYXNzJyA6ICdmYWlsJyxcblx0XHRcdG1lc3NhZ2U6IGhhc0NvbmZpZ0ZpbGUgPyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb25maWdGaWxlUGF0aCA6ICdDb25maWcgZmlsZSBub3QgZm91bmQnXG5cdFx0fSk7XG5cblx0XHQvLyBUcnkgdG8gZGV0ZWN0IHByb2plY3Qgc3RydWN0dXJlXG5cdFx0aWYgKGhhc1Byb2plY3RSb290ICYmIGhhc0NvbmZpZ0ZpbGUpIHtcblx0XHRcdGNvbnN0IGRldGVjdG9yID0gbmV3IFByb2plY3REZXRlY3Rvcih0aGlzLmFwcCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBkZXRlY3Rpb24gPSBhd2FpdCBkZXRlY3Rvci5kZXRlY3RQcm9qZWN0KCk7XG5cdFx0XHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdFx0XHRuYW1lOiAnUHJvamVjdCBzdHJ1Y3R1cmUgdmFsaWQnLFxuXHRcdFx0XHRcdHN0YXR1czogZGV0ZWN0aW9uID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGRldGVjdGlvbiA/IGBGb3VuZCAke2RldGVjdGlvbi5jb25maWdGaWxlUGF0aH1gIDogJ0NvdWxkIG5vdCB2YWxpZGF0ZSBwcm9qZWN0IHN0cnVjdHVyZSdcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuXHRcdFx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRcdFx0bmFtZTogJ1Byb2plY3Qgc3RydWN0dXJlIHZhbGlkJyxcblx0XHRcdFx0XHRzdGF0dXM6ICd3YXJuaW5nJyxcblx0XHRcdFx0XHRtZXNzYWdlOiBgRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWBcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgY29udGVudCB0eXBlc1xuXHRcdGNvbnN0IGhhc0NvbnRlbnRUeXBlcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbnRlbnRUeXBlcyAmJiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb250ZW50VHlwZXMubGVuZ3RoID4gMDtcblx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRuYW1lOiAnQ29udGVudCB0eXBlcyBjb25maWd1cmVkJyxcblx0XHRcdHN0YXR1czogaGFzQ29udGVudFR5cGVzID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0bWVzc2FnZTogaGFzQ29udGVudFR5cGVzID8gYCR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuY29udGVudFR5cGVzLmxlbmd0aH0gY29udGVudCB0eXBlKHMpIGNvbmZpZ3VyZWRgIDogJ05vIGNvbnRlbnQgdHlwZXMgY29uZmlndXJlZCdcblx0XHR9KTtcblxuXHRcdHRoaXMucmVzdWx0cy5wdXNoKHtcblx0XHRcdGNhdGVnb3J5OiAnQXN0cm8gUHJvamVjdCcsXG5cdFx0XHRjaGVja3Ncblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY2hlY2tQbHVnaW5Db25maWd1cmF0aW9uKCkge1xuXHRcdGNvbnN0IGNoZWNrczogSGVhbHRoQ2hlY2tSZXN1bHRbJ2NoZWNrcyddID0gW107XG5cblx0XHQvLyBSZWFkIGFjdHVhbCBwbHVnaW4gY29uZmlncyBmcm9tIHRoZWlyIGRhdGEuanNvbiBmaWxlc1xuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcblxuXHRcdC8vIENoZWNrIEFzdHJvIENvbXBvc2VyIGNvbmZpZ3VyYXRpb24gKHRyeSBwbHVnaW4gQVBJIGZpcnN0LCB0aGVuIGZpbGUpXG5cdFx0bGV0IGFzdHJvQ29tcG9zZXJDb250ZW50VHlwZXMgPSAwO1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBUcnkgcGx1Z2luIEFQSSBmaXJzdCAobW9yZSByZWxpYWJsZSlcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogeyBwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgeyBzZXR0aW5ncz86IHsgY29udGVudFR5cGVzPzogdW5rbm93bltdIH0gfT4gfSB9KS5wbHVnaW5zO1xuXHRcdFx0Y29uc3QgYXN0cm9Db21wb3NlclBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LlsnYXN0cm8tY29tcG9zZXInXTtcblx0XHRcdGlmIChhc3Ryb0NvbXBvc2VyUGx1Z2luPy5zZXR0aW5ncz8uY29udGVudFR5cGVzKSB7XG5cdFx0XHRcdGFzdHJvQ29tcG9zZXJDb250ZW50VHlwZXMgPSBhc3Ryb0NvbXBvc2VyUGx1Z2luLnNldHRpbmdzLmNvbnRlbnRUeXBlcy5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIHJlYWRpbmdcblx0XHRcdFx0Y29uc3QgYXN0cm9Db21wb3NlclBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvYXN0cm8tY29tcG9zZXIvZGF0YS5qc29uYDtcblx0XHRcdFx0Y29uc3QgYXN0cm9GaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGFzdHJvQ29tcG9zZXJQYXRoKTtcblx0XHRcdFx0aWYgKGFzdHJvRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoYXN0cm9GaWxlKTtcblx0XHRcdFx0XHRjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyB7IGNvbnRlbnRUeXBlcz86IHVua25vd25bXSB9O1xuXHRcdFx0XHRcdGFzdHJvQ29tcG9zZXJDb250ZW50VHlwZXMgPSBkYXRhLmNvbnRlbnRUeXBlcz8ubGVuZ3RoIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIHtcblx0XHRcdC8vIFBsdWdpbiBub3QgY29uZmlndXJlZCBvciBmaWxlIGRvZXNuJ3QgZXhpc3Rcblx0XHR9XG5cblx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRuYW1lOiAnQXN0cm8gQ29tcG9zZXIgY29uZmlndXJlZCcsXG5cdFx0XHRzdGF0dXM6IGFzdHJvQ29tcG9zZXJDb250ZW50VHlwZXMgPiAwID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0bWVzc2FnZTogYXN0cm9Db21wb3NlckNvbnRlbnRUeXBlcyA+IDAgP1xuXHRcdFx0XHRgJHthc3Ryb0NvbXBvc2VyQ29udGVudFR5cGVzfSBjb250ZW50IHR5cGUocylgIDpcblx0XHRcdFx0J05vIGNvbnRlbnQgdHlwZXMgY29uZmlndXJlZCdcblx0XHR9KTtcblxuXHRcdC8vIENoZWNrIEJhc2VzIENNUyBjb25maWd1cmF0aW9uIChjaGVjayBmb3IgYmFzZSBmaWxlIGV4aXN0ZW5jZSlcblx0XHRsZXQgYmFzZXNDb25maWd1cmVkID0gZmFsc2U7XG5cdFx0bGV0IGJhc2VzTWVzc2FnZSA9ICdObyBiYXNlIGZpbGUgZm91bmQnO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb25maWd1cmF0b3IgPSBuZXcgQmFzZXNDTVNDb25maWd1cmF0b3IodGhpcy5hcHApO1xuXHRcdFx0Y29uc3QgYmFzZUZpbGVQYXRoID0gYXdhaXQgY29uZmlndXJhdG9yLnJlc29sdmVCYXNlRmlsZVBhdGgoKTtcblx0XHRcdGlmIChhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhiYXNlRmlsZVBhdGgpKSB7XG5cdFx0XHRcdGJhc2VzQ29uZmlndXJlZCA9IHRydWU7XG5cdFx0XHRcdGJhc2VzTWVzc2FnZSA9IGAke2Jhc2VGaWxlUGF0aH0gZm91bmRgO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2gge1xuXHRcdFx0Ly8gRmlsZSBkb2Vzbid0IGV4aXN0XG5cdFx0fVxuXG5cdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0bmFtZTogJ0Jhc2VzIENNUyBjb25maWd1cmVkJyxcblx0XHRcdHN0YXR1czogYmFzZXNDb25maWd1cmVkID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0bWVzc2FnZTogYmFzZXNNZXNzYWdlXG5cdFx0fSk7XG5cblx0XHQvLyBDaGVjayBTRU8gY29uZmlndXJhdGlvbiAodHJ5IHBsdWdpbiBBUEkgZmlyc3QsIHRoZW4gZmlsZSlcblx0XHRsZXQgc2VvU2NhbkRpcnMgPSAnJztcblx0XHR0cnkge1xuXHRcdFx0Ly8gVHJ5IHBsdWdpbiBBUEkgZmlyc3QgKG1vcmUgcmVsaWFibGUpXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHsgc2V0dGluZ3M/OiB7IHNjYW5EaXJlY3Rvcmllcz86IHN0cmluZyB9IH0+IH0gfSkucGx1Z2lucztcblx0XHRcdGNvbnN0IHNlb1BsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/Llsnc2VvJ107XG5cdFx0XHRpZiAoc2VvUGx1Z2luPy5zZXR0aW5ncz8uc2NhbkRpcmVjdG9yaWVzKSB7XG5cdFx0XHRcdHNlb1NjYW5EaXJzID0gc2VvUGx1Z2luLnNldHRpbmdzLnNjYW5EaXJlY3Rvcmllcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgcmVhZGluZ1xuXHRcdFx0XHRjb25zdCBzZW9QYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zL3Nlby9kYXRhLmpzb25gO1xuXHRcdFx0XHRjb25zdCBzZW9GaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNlb1BhdGgpO1xuXHRcdFx0XHRpZiAoc2VvRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoc2VvRmlsZSk7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgeyBzY2FuRGlyZWN0b3JpZXM/OiBzdHJpbmcgfTtcblx0XHRcdFx0XHRzZW9TY2FuRGlycyA9IGRhdGEuc2NhbkRpcmVjdG9yaWVzIHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCB7XG5cdFx0XHQvLyBQbHVnaW4gbm90IGNvbmZpZ3VyZWQgb3IgZmlsZSBkb2Vzbid0IGV4aXN0XG5cdFx0fVxuXG5cdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0bmFtZTogJ1NFTyBwbHVnaW4gY29uZmlndXJlZCcsXG5cdFx0XHRzdGF0dXM6IHNlb1NjYW5EaXJzLmxlbmd0aCA+IDAgPyAncGFzcycgOiAnd2FybmluZycsXG5cdFx0XHRtZXNzYWdlOiBzZW9TY2FuRGlycy5sZW5ndGggPiAwID9cblx0XHRcdFx0YFNjYW5uaW5nOiAke3Nlb1NjYW5EaXJzfWAgOlxuXHRcdFx0XHQnTm8gc2NhbiBkaXJlY3RvcmllcyBjb25maWd1cmVkJ1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ2hlY2sgZGVmYXVsdCBjb250ZW50IHR5cGUgLSBzaG93IGRpc3BsYXkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0Y29uc3QgaGFzRGVmYXVsdENvbnRlbnRUeXBlID0gISF0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0Q29udGVudFR5cGVJZDtcblx0XHRsZXQgZGVmYXVsdENvbnRlbnRUeXBlTmFtZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmRlZmF1bHRDb250ZW50VHlwZUlkIHx8ICcnO1xuXHRcdGlmIChoYXNEZWZhdWx0Q29udGVudFR5cGUpIHtcblx0XHRcdC8vIFRyeSB0byBsb29rIHVwIHRoZSBkaXNwbGF5IG5hbWUgZnJvbSBBc3RybyBDb21wb3NlcidzIGNvbnRlbnQgdHlwZXNcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogeyBwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgeyBzZXR0aW5ncz86IHsgY29udGVudFR5cGVzPzogQXJyYXk8eyBpZD86IHN0cmluZzsgbmFtZT86IHN0cmluZyB9PiB9IH0+IH0gfSkucGx1Z2lucztcblx0XHRcdFx0Y29uc3QgYXN0cm9Db21wb3NlclBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LlsnYXN0cm8tY29tcG9zZXInXTtcblx0XHRcdFx0Y29uc3QgY29udGVudFR5cGVzID0gYXN0cm9Db21wb3NlclBsdWdpbj8uc2V0dGluZ3M/LmNvbnRlbnRUeXBlcztcblx0XHRcdFx0aWYgKGNvbnRlbnRUeXBlcykge1xuXHRcdFx0XHRcdGNvbnN0IG1hdGNoaW5nVHlwZSA9IGNvbnRlbnRUeXBlcy5maW5kKGN0ID0+IGN0LmlkID09PSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0Q29udGVudFR5cGVJZCk7XG5cdFx0XHRcdFx0aWYgKG1hdGNoaW5nVHlwZT8ubmFtZSkge1xuXHRcdFx0XHRcdFx0ZGVmYXVsdENvbnRlbnRUeXBlTmFtZSA9IG1hdGNoaW5nVHlwZS5uYW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdC8vIEtlZXAgdGhlIElEIGFzIGZhbGxiYWNrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdG5hbWU6ICdEZWZhdWx0IGNvbnRlbnQgdHlwZSBzZXQnLFxuXHRcdFx0c3RhdHVzOiBoYXNEZWZhdWx0Q29udGVudFR5cGUgPyAncGFzcycgOiAnd2FybmluZycsXG5cdFx0XHRtZXNzYWdlOiBoYXNEZWZhdWx0Q29udGVudFR5cGUgPyBkZWZhdWx0Q29udGVudFR5cGVOYW1lIDogJ05vIGRlZmF1bHQgY29udGVudCB0eXBlJ1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZXN1bHRzLnB1c2goe1xuXHRcdFx0Y2F0ZWdvcnk6ICdQbHVnaW4gQ29uZmlndXJhdGlvbicsXG5cdFx0XHRjaGVja3Ncblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY2hlY2tHaXRJbnRlZ3JhdGlvbigpIHtcblx0XHRjb25zdCBjaGVja3M6IEhlYWx0aENoZWNrUmVzdWx0WydjaGVja3MnXSA9IFtdO1xuXHRcdGNvbnN0IHsgZ2l0Q29uZmlnLCBwcm9qZWN0Um9vdCB9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG5cblx0XHQvLyAxLiBDaGVjayBpZiBHaXQgaXMgYSByZXBvXG5cdFx0aWYgKHByb2plY3RSb290KSB7XG5cdFx0XHRjb25zdCB7IEdpdE1hbmFnZXIgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXRpbHMvR2l0TWFuYWdlcicpO1xuXHRcdFx0Y29uc3QgaXNSZXBvID0gYXdhaXQgR2l0TWFuYWdlci5pc1JlcG8ocHJvamVjdFJvb3QpO1xuXHRcdFx0Y29uc3QgcmVtb3RlVXJsID0gaXNSZXBvID8gYXdhaXQgR2l0TWFuYWdlci5nZXRSZW1vdGVVcmwocHJvamVjdFJvb3QpIDogbnVsbDtcblxuXHRcdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiAnR2l0IHJlcG9zaXRvcnkgaW5pdGlhbGl6ZWQnLFxuXHRcdFx0XHRzdGF0dXM6IGlzUmVwbyA/ICdwYXNzJyA6ICdmYWlsJyxcblx0XHRcdFx0bWVzc2FnZTogaXNSZXBvID8gJ1JlcG9zaXRvcnkgZGV0ZWN0ZWQgYXQgcHJvamVjdCByb290JyA6ICdObyByZXBvc2l0b3J5IGZvdW5kIGF0IHByb2plY3Qgcm9vdCdcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoaXNSZXBvKSB7XG5cdFx0XHRcdC8vIDIuIENoZWNrIFJlbW90ZSAvIENvbmZpZ1xuXHRcdFx0XHRjb25zdCBpc0NvbmZpZ3VyZWQgPSBnaXRDb25maWcuZW5hYmxlZCB8fCAhIXJlbW90ZVVybDtcblxuXHRcdFx0XHRjaGVja3MucHVzaCh7XG5cdFx0XHRcdFx0bmFtZTogJ0dpdCBpbnRlZ3JhdGlvbiBzdGF0dXMnLFxuXHRcdFx0XHRcdHN0YXR1czogaXNDb25maWd1cmVkID8gJ3Bhc3MnIDogJ3dhcm5pbmcnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IHJlbW90ZVVybFxuXHRcdFx0XHRcdFx0PyBgQ29ubmVjdGVkIHRvICR7cmVtb3RlVXJsfWBcblx0XHRcdFx0XHRcdDogKGdpdENvbmZpZy5lbmFibGVkID8gJ0ludGVncmF0aW9uIGFjdGl2ZScgOiAnTm90IGNvbmZpZ3VyZWQgKE9wdGlvbmFsKScpXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIDMuIENoZWNrIEdpdEh1YiBQQVRcblx0XHRcdFx0Y29uc3Qgc2F2ZWRTZWNyZXQgPSAodGhpcy5hcHAgYXMgYW55KS5zZWNyZXRTdG9yYWdlPy5nZXRTZWNyZXQoJ3ZhdWx0LWNtcy1naXRodWItcGF0Jyk7XG5cdFx0XHRcdGNvbnN0IGhhc1BhdCA9ICEhKGdpdENvbmZpZy5wYXQgfHwgc2F2ZWRTZWNyZXQpO1xuXG5cdFx0XHRcdC8vIE9ubHkgc2hvdyBQQVQgY2hlY2sgaWYgdGhleSd2ZSBleHBsaWNpdGx5IGVuYWJsZWQgaW50ZWdyYXRpb24gT1IgaWYgaXQncyBtaXNzaW5nIGJ1dCB0aGV5IHN0YXJ0ZWQgdGhlIHNldHVwXG5cdFx0XHRcdGlmIChnaXRDb25maWcuZW5hYmxlZCkge1xuXHRcdFx0XHRcdGNoZWNrcy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6ICdHaXRIdWIgUEFUIGNvbmZpZ3VyZWQnLFxuXHRcdFx0XHRcdFx0c3RhdHVzOiBoYXNQYXQgPyAncGFzcycgOiAnd2FybmluZycsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBoYXNQYXQgPyAnVG9rZW4gcHJlc2VudCcgOiAnTm8gdG9rZW4gZm91bmQgaW4gc2V0dGluZ3MnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hlY2tzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiAnR2l0IHJlcG9zaXRvcnkgY2hlY2snLFxuXHRcdFx0XHRzdGF0dXM6ICdmYWlsJyxcblx0XHRcdFx0bWVzc2FnZTogJ1Byb2plY3Qgcm9vdCBub3QgY29uZmlndXJlZCdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMucmVzdWx0cy5wdXNoKHtcblx0XHRcdGNhdGVnb3J5OiAnR2l0IEludGVncmF0aW9uJyxcblx0XHRcdGNoZWNrc1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBkaXNwbGF5UmVzdWx0cyhjb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3QgcmVzdWx0c0NvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdoZWFsdGgtY2hlY2stcmVzdWx0cycgfSk7XG5cblx0XHRmb3IgKGNvbnN0IHJlc3VsdCBvZiB0aGlzLnJlc3VsdHMpIHtcblx0XHRcdGNvbnN0IGNhdGVnb3J5U2VjdGlvbiA9IHJlc3VsdHNDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnaGVhbHRoLWNoZWNrLWNhdGVnb3J5JyB9KTtcblx0XHRcdGNhdGVnb3J5U2VjdGlvbi5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6IHJlc3VsdC5jYXRlZ29yeSB9KTtcblxuXHRcdFx0Y29uc3QgY2hlY2tzTGlzdCA9IGNhdGVnb3J5U2VjdGlvbi5jcmVhdGVEaXYoeyBjbHM6ICdoZWFsdGgtY2hlY2stbGlzdCcgfSk7XG5cblx0XHRcdGZvciAoY29uc3QgY2hlY2sgb2YgcmVzdWx0LmNoZWNrcykge1xuXHRcdFx0XHRjb25zdCBjaGVja0l0ZW0gPSBjaGVja3NMaXN0LmNyZWF0ZURpdih7IGNsczogJ2hlYWx0aC1jaGVjay1pdGVtJyB9KTtcblxuXHRcdFx0XHQvLyBBZGQgc3RhdHVzIGljb25cblx0XHRcdFx0Y29uc3Qgc3RhdHVzSWNvbiA9IGNoZWNrSXRlbS5jcmVhdGVTcGFuKHsgY2xzOiAnaGVhbHRoLWNoZWNrLWljb24nIH0pO1xuXHRcdFx0XHRpZiAoY2hlY2suc3RhdHVzID09PSAncGFzcycpIHtcblx0XHRcdFx0XHRzZXRJY29uKHN0YXR1c0ljb24sICdsdWNpZGUtY2hlY2stY2lyY2xlLTInKTtcblx0XHRcdFx0XHRzdGF0dXNJY29uLmFkZENsYXNzKCdoZWFsdGgtY2hlY2stcGFzcycpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNoZWNrLnN0YXR1cyA9PT0gJ2ZhaWwnKSB7XG5cdFx0XHRcdFx0c2V0SWNvbihzdGF0dXNJY29uLCAnbHVjaWRlLWFsZXJ0LWNpcmNsZScpO1xuXHRcdFx0XHRcdHN0YXR1c0ljb24uYWRkQ2xhc3MoJ2hlYWx0aC1jaGVjay1mYWlsJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0SWNvbihzdGF0dXNJY29uLCAnbHVjaWRlLWhlbHAtY2lyY2xlJyk7XG5cdFx0XHRcdFx0c3RhdHVzSWNvbi5hZGRDbGFzcygnaGVhbHRoLWNoZWNrLXdhcm5pbmcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBjaGVjayBuYW1lXG5cdFx0XHRcdGNvbnN0IGNoZWNrTmFtZSA9IGNoZWNrSXRlbS5jcmVhdGVTcGFuKHtcblx0XHRcdFx0XHR0ZXh0OiBjaGVjay5uYW1lLFxuXHRcdFx0XHRcdGNsczogJ2hlYWx0aC1jaGVjay1uYW1lJ1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBBZGQgbWVzc2FnZSBpZiBwcmVzZW50XG5cdFx0XHRcdGlmIChjaGVjay5tZXNzYWdlKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2hlY2tNZXNzYWdlID0gY2hlY2tJdGVtLmNyZWF0ZURpdih7XG5cdFx0XHRcdFx0XHR0ZXh0OiBjaGVjay5tZXNzYWdlLFxuXHRcdFx0XHRcdFx0Y2xzOiAnaGVhbHRoLWNoZWNrLW1lc3NhZ2UnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgQ1NTIHN0eWxlc1xuXHRcdHRoaXMuYWRkU3R5bGVzKGNvbnRhaW5lcik7XG5cdH1cblxuXHRwcml2YXRlIGFkZFN0eWxlcyhjb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3Qgc3R5bGUgPSBjb250YWluZXIuY3JlYXRlRWwoJ3N0eWxlJyk7XG5cdFx0c3R5bGUudGV4dENvbnRlbnQgPSBgXG5cdFx0XHQudmF1bHQtY21zLWhlYWx0aC1jaGVjayB7XG5cdFx0XHRcdHBhZGRpbmc6IDIwcHg7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2stcmVzdWx0cyB7XG5cdFx0XHRcdG1hcmdpbjogMjBweCAwO1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLWNhdGVnb3J5IHtcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogMzBweDtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1jYXRlZ29yeSBoMyB7XG5cdFx0XHRcdG1hcmdpbi1ib3R0b206IDEwcHg7XG5cdFx0XHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcik7XG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiA1cHg7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2stbGlzdCB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdGdhcDogMTBweDtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1pdGVtIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0YWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG5cdFx0XHRcdGdhcDogMTBweDtcblx0XHRcdFx0cGFkZGluZzogOHB4O1xuXHRcdFx0XHRiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLXNlY29uZGFyeSk7XG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IDRweDtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1pY29uIHtcblx0XHRcdFx0Zm9udC1zaXplOiAxOHB4O1xuXHRcdFx0XHRmb250LXdlaWdodDogYm9sZDtcblx0XHRcdFx0bWluLXdpZHRoOiAyNHB4O1xuXHRcdFx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2stcGFzcyB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10ZXh0LXN1Y2Nlc3MpO1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLWZhaWwge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGV4dC1lcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2std2FybmluZyB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10ZXh0LXdhcm5pbmcpO1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLWljb24gc3ZnIHtcblx0XHRcdFx0d2lkdGg6IDE4cHg7XG5cdFx0XHRcdGhlaWdodDogMThweDtcblx0XHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHR9XG5cblx0XHRcdC5oZWFsdGgtY2hlY2staWNvbiB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdFx0XHRtaW4td2lkdGg6IDI0cHg7XG5cdFx0XHRcdGhlaWdodDogMjRweDtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1uYW1lIHtcblx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0Zm9udC13ZWlnaHQ6IDUwMDtcblx0XHRcdH1cblxuXHRcdFx0LmhlYWx0aC1jaGVjay1tZXNzYWdlIHtcblx0XHRcdFx0Zm9udC1zaXplOiAwLjllbTtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRleHQtbXV0ZWQpO1xuXHRcdFx0XHRtYXJnaW4tbGVmdDogMzRweDtcblx0XHRcdFx0bWFyZ2luLXRvcDogNHB4O1xuXHRcdFx0fVxuXG5cdFx0XHQuaGVhbHRoLWNoZWNrLWZvb3RlciB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG5cdFx0XHRcdG1hcmdpbi10b3A6IDIwcHg7XG5cdFx0XHRcdHBhZGRpbmctdG9wOiAxNXB4O1xuXHRcdFx0XHRib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRvbkNsb3NlKCkge1xuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgU2V0dGluZywgcmVxdWlyZUFwaVZlcnNpb24gfSBmcm9tICdvYnNpZGlhbic7XHJcblxyXG4vKipcclxuICogVHlwZSBkZWZpbml0aW9uIGZvciBTZXR0aW5nR3JvdXAgY29uc3RydWN0b3JcclxuICogTm90ZTogU2V0dGluZ0dyb3VwIG1heSBleGlzdCBhdCBydW50aW1lIGluIDEuMTEuMCsgYnV0IG1heSBub3QgYmUgaW4gVHlwZVNjcmlwdCBkZWZpbml0aW9uc1xyXG4gKiBcclxuICogSU1QT1JUQU5UOiBUaGlzIHR5cGUgc2lnbmF0dXJlIGlzIGluZmVycmVkIGZyb20gdXNhZ2UgcGF0dGVybnMuIFdoZW4gLnJlZi9vYnNpZGlhbi1hcGkvb2JzaWRpYW4uZC50c1xyXG4gKiBpcyBhdmFpbGFibGUsIHZlcmlmeSB0aGUgYWN0dWFsIHNpZ25hdHVyZSB0aGVyZS4gVGhlIHNpZ25hdHVyZSBzaG93biBoZXJlIG1hdGNoZXMgdGhlIGV4cGVjdGVkXHJcbiAqIGJlaGF2aW9yIGJhc2VkIG9uIE9ic2lkaWFuJ3MgQVBJIGRlc2lnbiBwYXR0ZXJucy5cclxuICovXHJcbnR5cGUgU2V0dGluZ0dyb3VwQ29uc3RydWN0b3IgPSBuZXcgKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkgPT4ge1xyXG5cdHNldEhlYWRpbmcoaGVhZGluZzogc3RyaW5nKToge1xyXG5cdFx0YWRkU2V0dGluZyhjYjogKHNldHRpbmc6IFNldHRpbmcpID0+IHZvaWQpOiB2b2lkO1xyXG5cdH07XHJcblx0YWRkU2V0dGluZyhjYjogKHNldHRpbmc6IFNldHRpbmcpID0+IHZvaWQpOiB2b2lkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVyZmFjZSB0aGF0IHdvcmtzIHdpdGggYm90aCBTZXR0aW5nR3JvdXAgYW5kIGZhbGxiYWNrIGNvbnRhaW5lclxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5nc0NvbnRhaW5lciB7XHJcblx0YWRkU2V0dGluZyhjYjogKHNldHRpbmc6IFNldHRpbmcpID0+IHZvaWQpOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldHRpbmdzIGNvbnRhaW5lciB0aGF0IHVzZXMgU2V0dGluZ0dyb3VwIGlmIGF2YWlsYWJsZSAoQVBJIDEuMTEuMCspLFxyXG4gKiBvdGhlcndpc2UgZmFsbHMgYmFjayB0byBjcmVhdGluZyBhIGhlYWRpbmcgYW5kIHVzaW5nIHRoZSBjb250YWluZXIgZGlyZWN0bHkuXHJcbiAqIFxyXG4gKiBVc2VzIHJlcXVpcmVBcGlWZXJzaW9uKCcxLjExLjAnKSB0byBjaGVjayBpZiBTZXR0aW5nR3JvdXAgaXMgYXZhaWxhYmxlLlxyXG4gKiBUaGlzIGlzIHRoZSBvZmZpY2lhbCBPYnNpZGlhbiBBUEkgbWV0aG9kIGZvciB2ZXJzaW9uIGNoZWNraW5nLlxyXG4gKiBcclxuICogSU1QT1JUQU5UOiBXZSB1c2UgZHluYW1pYyByZXF1aXJlKCkgaW5zdGVhZCBvZiBkaXJlY3QgaW1wb3J0IGJlY2F1c2UgU2V0dGluZ0dyb3VwXHJcbiAqIG1heSBub3QgYmUgaW4gVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIGV2ZW4gaWYgaXQgZXhpc3RzIGF0IHJ1bnRpbWUgaW4gMS4xMS4wKy5cclxuICogVGhpcyBhdm9pZHMgY29tcGlsZS10aW1lIFR5cGVTY3JpcHQgZXJyb3JzIHdoaWxlIHN0aWxsIHdvcmtpbmcgYXQgcnVudGltZS5cclxuICogXHJcbiAqIEBwYXJhbSBjb250YWluZXJFbCAtIFRoZSBjb250YWluZXIgZWxlbWVudCBmb3Igc2V0dGluZ3NcclxuICogQHBhcmFtIGhlYWRpbmcgLSBPcHRpb25hbCBoZWFkaW5nIHRleHQgZm9yIHRoZSBzZXR0aW5ncyBncm91cC4gSWYgb21pdHRlZCwgbm8gaGVhZGluZyBpcyBjcmVhdGVkLlxyXG4gKiBAcGFyYW0gbWFuaWZlc3RJZCAtIFRoZSBwbHVnaW4ncyBtYW5pZmVzdCBJRCBmb3IgQ1NTIHNjb3BpbmcgKHJlcXVpcmVkIGZvciBmYWxsYmFjayBtb2RlKVxyXG4gKiBAcmV0dXJucyBBIGNvbnRhaW5lciB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBzZXR0aW5nc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNldHRpbmdzR3JvdXAoXHJcblx0Y29udGFpbmVyRWw6IEhUTUxFbGVtZW50LFxyXG5cdGhlYWRpbmc/OiBzdHJpbmcsXHJcblx0bWFuaWZlc3RJZD86IHN0cmluZ1xyXG4pOiBTZXR0aW5nc0NvbnRhaW5lciB7XHJcblx0Ly8gQ2hlY2sgaWYgU2V0dGluZ0dyb3VwIGlzIGF2YWlsYWJsZSAoQVBJIDEuMTEuMCspXHJcblx0Ly8gcmVxdWlyZUFwaVZlcnNpb24gaXMgdGhlIG9mZmljaWFsIE9ic2lkaWFuIEFQSSBtZXRob2QgZm9yIHZlcnNpb24gY2hlY2tpbmdcclxuXHRpZiAocmVxdWlyZUFwaVZlcnNpb24oJzEuMTEuMCcpKSB7XHJcblx0XHQvLyBVc2UgZHluYW1pYyByZXF1aXJlKCkgdG8gYWNjZXNzIFNldHRpbmdHcm91cCBhdCBydW50aW1lXHJcblx0XHQvLyBUaGlzIGF2b2lkcyBUeXBlU2NyaXB0IGVycm9ycyB3aGVuIFNldHRpbmdHcm91cCBpc24ndCBpbiB0eXBlIGRlZmluaXRpb25zXHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgbm8tdW5kZWYgLS0gZHluYW1pYyByZXF1aXJlIGZvciBPYnNpZGlhbiBBUElcclxuXHRcdGNvbnN0IG9ic2lkaWFuID0gcmVxdWlyZSgnb2JzaWRpYW4nKSBhcyB7IFNldHRpbmdHcm91cD86IFNldHRpbmdHcm91cENvbnN0cnVjdG9yIH07XHJcblx0XHRjb25zdCBTZXR0aW5nR3JvdXAgPSBvYnNpZGlhbi5TZXR0aW5nR3JvdXAgYXMgU2V0dGluZ0dyb3VwQ29uc3RydWN0b3I7XHJcblx0XHRcclxuXHRcdC8vIFVzZSBTZXR0aW5nR3JvdXAgLSBpdCdzIGd1YXJhbnRlZWQgdG8gZXhpc3QgaWYgcmVxdWlyZUFwaVZlcnNpb24gcmV0dXJucyB0cnVlXHJcblx0XHQvLyBJZiBoZWFkaW5nIGlzIHByb3ZpZGVkLCB1c2Ugc2V0SGVhZGluZygpOyBvdGhlcndpc2UgdXNlIFNldHRpbmdHcm91cCBkaXJlY3RseVxyXG5cdFx0Y29uc3QgZ3JvdXAgPSBoZWFkaW5nIFxyXG5cdFx0XHQ/IG5ldyBTZXR0aW5nR3JvdXAoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoaGVhZGluZylcclxuXHRcdFx0OiBuZXcgU2V0dGluZ0dyb3VwKGNvbnRhaW5lckVsKTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWRkU2V0dGluZyhjYjogKHNldHRpbmc6IFNldHRpbmcpID0+IHZvaWQpIHtcclxuXHRcdFx0XHRncm91cC5hZGRTZXR0aW5nKGNiKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gRmFsbGJhY2sgcGF0aCAoZWl0aGVyIEFQSSA8IDEuMTEuMCBvciBTZXR0aW5nR3JvdXAgbm90IGZvdW5kKVxyXG5cdFx0Ly8gQWRkIHNjb3BpbmcgY2xhc3MgdG8gY29udGFpbmVyRWwgdG8gc2NvcGUgQ1NTIHRvIG9ubHkgdGhpcyBwbHVnaW4ncyBzZXR0aW5nc1xyXG5cdFx0aWYgKG1hbmlmZXN0SWQpIHtcclxuXHRcdFx0Y29udGFpbmVyRWwuYWRkQ2xhc3MoYCR7bWFuaWZlc3RJZH0tc2V0dGluZ3MtY29tcGF0YCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIEZhbGxiYWNrOiBDcmVhdGUgYSBoZWFkaW5nIG1hbnVhbGx5IChpZiBwcm92aWRlZCkgYW5kIHVzZSBjb250YWluZXIgZGlyZWN0bHlcclxuXHRcdGlmIChoZWFkaW5nKSB7XHJcblx0XHRcdGNvbnN0IGhlYWRpbmdFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdignc2V0dGluZy1ncm91cC1oZWFkaW5nJyk7XHJcblx0XHRcdGhlYWRpbmdFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6IGhlYWRpbmcgfSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFkZFNldHRpbmcoY2I6IChzZXR0aW5nOiBTZXR0aW5nKSA9PiB2b2lkKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKTtcclxuXHRcdFx0XHRjYihzZXR0aW5nKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIHJlcXVlc3RVcmwsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEFwcGx5UHJlc2V0TW9kYWwgfSBmcm9tICcuLi91aS9BcHBseVByZXNldE1vZGFsJztcblxuZXhwb3J0IGludGVyZmFjZSBHaXRIdWJGaWxlIHtcblx0cGF0aDogc3RyaW5nO1xuXHR0eXBlOiAnZmlsZScgfCAnZGlyJztcblx0ZG93bmxvYWRfdXJsOiBzdHJpbmcgfCBudWxsO1xuXHR1cmw6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE9ic2lkaWFuQXBwV2l0aENvbW1hbmRzIGV4dGVuZHMgQXBwIHtcblx0Y29tbWFuZHM6IHtcblx0XHRleGVjdXRlQ29tbWFuZEJ5SWQ6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xuXHR9O1xufVxuXG5leHBvcnQgY2xhc3MgUHJlc2V0TWFuYWdlciB7XG5cdHByaXZhdGUgYXBwOiBBcHA7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcblx0XHR0aGlzLmFwcCA9IGFwcDtcblx0fVxuXG5cdGFzeW5jIGFwcGx5UHJlc2V0KHJlcG86IHN0cmluZywgcHJlc2V0TmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCFyZXBvIHx8ICFwcmVzZXROYW1lKSB7XG5cdFx0XHRuZXcgTm90aWNlKCdQbGVhc2UgY29uZmlndXJlIGJvdGggcmVwb3NpdG9yeSBhbmQgcHJlc2V0IG5hbWUgaW4gc2V0dGluZ3MuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdG5ldyBOb3RpY2UoYEZldGNoaW5nIHByZXNldCBcIiR7cHJlc2V0TmFtZX1cIiBmcm9tICR7cmVwb30uLi5gKTtcblx0XHRcdGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy5mZXRjaFByZXNldEZpbGVzUmVjdXJzaXZlKHJlcG8sIHByZXNldE5hbWUpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYE5vIGZpbGVzIGZvdW5kIGZvciBwcmVzZXQgXCIke3ByZXNldE5hbWV9XCIgaW4gcmVwbyAke3JlcG99LmApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG5ldyBOb3RpY2UoJ0JhY2tpbmcgdXAgY29uZmlndXJhdGlvbiBmb2xkZXIuLi4nKTtcblx0XHRcdGNvbnN0IGJhY2t1cFBhdGggPSBhd2FpdCB0aGlzLmJhY2t1cE9ic2lkaWFuRm9sZGVyKCk7XG5cblx0XHRcdG5ldyBOb3RpY2UoYERvd25sb2FkaW5nIGFuZCBhcHBseWluZyAke2ZpbGVzLmxlbmd0aH0gZmlsZXMuLi5gKTtcblx0XHRcdGxldCBzdWNjZXNzQ291bnQgPSAwO1xuXHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG5cdFx0XHRcdGlmIChmaWxlLmRvd25sb2FkX3VybCkge1xuXHRcdFx0XHRcdC8vIE1hcCBwYXRoOiByZW1vdmUgXCJwcmVzZXROYW1lL1wiIHByZWZpeFxuXHRcdFx0XHRcdGNvbnN0IHJlbGF0aXZlUGF0aCA9IGZpbGUucGF0aC5zdWJzdHJpbmcocHJlc2V0TmFtZS5sZW5ndGggKyAxKTtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5kb3dubG9hZEFuZFdyaXRlRmlsZShmaWxlLmRvd25sb2FkX3VybCwgcmVsYXRpdmVQYXRoKTtcblx0XHRcdFx0XHRcdHN1Y2Nlc3NDb3VudCsrO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBkb3dubG9hZCAke3JlbGF0aXZlUGF0aH06YCwgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG5ldyBOb3RpY2UoYEFwcGxpZWQgJHtzdWNjZXNzQ291bnR9IGZpbGVzLmApO1xuXG5cdFx0XHRuZXcgQXBwbHlQcmVzZXRNb2RhbCh0aGlzLmFwcCwgYmFja3VwUGF0aCwgKGRlbGV0ZUJhY2t1cCkgPT4ge1xuXHRcdFx0XHR2b2lkIChhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGRlbGV0ZUJhY2t1cCkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5ybWRpcihiYWNrdXBQYXRoLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnQmFja3VwIGRlbGV0ZWQuJyk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgYmFja3VwOicsIGUpO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gZGVsZXRlIGJhY2t1cCBmb2xkZXIuIFlvdSBtYXkgbmVlZCB0byByZW1vdmUgaXQgbWFudWFsbHkuJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgcmVsb2FkXG5cdFx0XHRcdFx0Y29uc3QgYXBwV2l0aENvbW1hbmRzID0gdGhpcy5hcHAgYXMgT2JzaWRpYW5BcHBXaXRoQ29tbWFuZHM7XG5cdFx0XHRcdFx0aWYgKGFwcFdpdGhDb21tYW5kcy5jb21tYW5kcyAmJiB0eXBlb2YgYXBwV2l0aENvbW1hbmRzLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0YXBwV2l0aENvbW1hbmRzLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZCgnYXBwOnJlbG9hZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkoKTtcblx0XHRcdH0pLm9wZW4oKTtcblxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYXBwbHkgcHJlc2V0OicsIGVycm9yKTtcblx0XHRcdGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gYXBwbHkgcHJlc2V0OiAke21lc3NhZ2V9YCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBmZXRjaFByZXNldEZpbGVzUmVjdXJzaXZlKHJlcG86IHN0cmluZywgcGF0aDogc3RyaW5nKTogUHJvbWlzZTxHaXRIdWJGaWxlW10+IHtcblx0XHRjb25zdCB1cmwgPSBgaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy8ke3JlcG99L2NvbnRlbnRzLyR7cGF0aH1gO1xuXHRcdFxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoeyB1cmwgfSk7XG5cdFx0XHRcblx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEdpdEh1YiBBUEkgcmV0dXJuZWQgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpdGVtcyA9IHJlc3BvbnNlLmpzb24gYXMgR2l0SHViRmlsZVtdO1xuXHRcdFx0bGV0IGFsbEZpbGVzOiBHaXRIdWJGaWxlW10gPSBbXTtcblxuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG5cdFx0XHRcdGlmIChpdGVtLnR5cGUgPT09ICdkaXInKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3ViRmlsZXMgPSBhd2FpdCB0aGlzLmZldGNoUHJlc2V0RmlsZXNSZWN1cnNpdmUocmVwbywgaXRlbS5wYXRoKTtcblx0XHRcdFx0XHRhbGxGaWxlcyA9IGFsbEZpbGVzLmNvbmNhdChzdWJGaWxlcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnZmlsZScpIHtcblx0XHRcdFx0XHRhbGxGaWxlcy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhbGxGaWxlcztcblx0XHR9IGNhdGNoIChlOiB1bmtub3duKSB7XG5cdFx0XHRpZiAoZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ3N0YXR1cycgaW4gZSAmJiBlLnN0YXR1cyA9PT0gNDA0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgUHJlc2V0IGZvbGRlciBcIiR7cGF0aH1cIiBub3QgZm91bmQgaW4gcmVwb3NpdG9yeSBcIiR7cmVwb31cIi5gKTtcblx0XHRcdH1cblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBiYWNrdXBPYnNpZGlhbkZvbGRlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOi5dL2csICctJykuc3BsaXQoJ1QnKVswXSArICctJyArIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcjtcblx0XHRjb25zdCBiYWNrdXBQYXRoID0gYCR7Y29uZmlnRGlyfV9iYWNrdXBfJHt0aW1lc3RhbXB9YDtcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRcblx0XHQvLyBDcmVhdGUgYmFja3VwIGRpcmVjdG9yeVxuXHRcdGF3YWl0IGFkYXB0ZXIubWtkaXIoYmFja3VwUGF0aCk7XG5cdFx0XG5cdFx0Ly8gQ29weSBjb25maWd1cmF0aW9uIGRpcmVjdG9yeSByZWN1cnNpdmVseVxuXHRcdGF3YWl0IHRoaXMuY29weVJlY3Vyc2l2ZShjb25maWdEaXIsIGAke2JhY2t1cFBhdGh9LyR7Y29uZmlnRGlyfWApO1xuXHRcdFxuXHRcdHJldHVybiBiYWNrdXBQYXRoO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBjb3B5UmVjdXJzaXZlKHNvdXJjZTogc3RyaW5nLCBkZXN0aW5hdGlvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0XG5cdFx0aWYgKCEoYXdhaXQgYWRhcHRlci5leGlzdHMoc291cmNlKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBzdGF0cyA9IGF3YWl0IGFkYXB0ZXIubGlzdChzb3VyY2UpO1xuXHRcdFxuXHRcdGlmICghKGF3YWl0IGFkYXB0ZXIuZXhpc3RzKGRlc3RpbmF0aW9uKSkpIHtcblx0XHRcdGF3YWl0IGFkYXB0ZXIubWtkaXIoZGVzdGluYXRpb24pO1xuXHRcdH1cblx0XHRcblx0XHQvLyBDb3B5IGZpbGVzXG5cdFx0Zm9yIChjb25zdCBmaWxlIG9mIHN0YXRzLmZpbGVzKSB7XG5cdFx0XHRjb25zdCBmaWxlTmFtZSA9IGZpbGUuc3BsaXQoJy8nKS5wb3AoKTtcblx0XHRcdGlmIChmaWxlTmFtZSkge1xuXHRcdFx0XHRjb25zdCBkZXN0RmlsZSA9IGRlc3RpbmF0aW9uICsgJy8nICsgZmlsZU5hbWU7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgYWRhcHRlci5jb3B5KGZpbGUsIGRlc3RGaWxlKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjb3B5IGZpbGUgJHtmaWxlfSB0byAke2Rlc3RGaWxlfTpgLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBSZWN1cnNlIGludG8gZm9sZGVyc1xuXHRcdGZvciAoY29uc3QgZm9sZGVyIG9mIHN0YXRzLmZvbGRlcnMpIHtcblx0XHRcdGNvbnN0IGZvbGRlck5hbWUgPSBmb2xkZXIuc3BsaXQoJy8nKS5wb3AoKTtcblx0XHRcdGlmIChmb2xkZXJOYW1lKSB7XG5cdFx0XHRcdGNvbnN0IGRlc3RGb2xkZXIgPSBkZXN0aW5hdGlvbiArICcvJyArIGZvbGRlck5hbWU7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY29weVJlY3Vyc2l2ZShmb2xkZXIsIGRlc3RGb2xkZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZG93bmxvYWRBbmRXcml0ZUZpbGUodXJsOiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7IHVybCB9KTtcblx0XHRcblx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRvd25sb2FkICR7cGF0aH0gZnJvbSAke3VybH1gKTtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgcGFyZW50IGRpcmVjdG9yeSBleGlzdHNcblx0XHRjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBkaXIgPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcvJyk7XG5cdFx0XHRcdGlmICghKGF3YWl0IGFkYXB0ZXIuZXhpc3RzKGRpcikpKSB7XG5cdFx0XHRcdFx0YXdhaXQgYWRhcHRlci5ta2RpcihkaXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV3JpdGUgdGhlIGZpbGUgKHVzaW5nIGFycmF5QnVmZmVyIHRvIGhhbmRsZSBiaW5hcnkgZmlsZXMgc2FmZWx5KVxuXHRcdGF3YWl0IGFkYXB0ZXIud3JpdGVCaW5hcnkocGF0aCwgcmVzcG9uc2UuYXJyYXlCdWZmZXIpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGNsYXNzIEFwcGx5UHJlc2V0TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cdHByaXZhdGUgb25Db25maXJtOiAoZGVsZXRlQmFja3VwOiBib29sZWFuKSA9PiB2b2lkO1xuXHRwcml2YXRlIGJhY2t1cFBhdGg6IHN0cmluZztcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgYmFja3VwUGF0aDogc3RyaW5nLCBvbkNvbmZpcm06IChkZWxldGVCYWNrdXA6IGJvb2xlYW4pID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHApO1xuXHRcdHRoaXMuYmFja3VwUGF0aCA9IGJhY2t1cFBhdGg7XG5cdFx0dGhpcy5vbkNvbmZpcm0gPSBvbkNvbmZpcm07XG5cdH1cblxuXHRvbk9wZW4oKSB7XG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XG5cblx0XHRjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUHJlc2V0IGFwcGxpZWQgc3VjY2Vzc2Z1bGx5JyB9KTtcblx0XHRjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdUaGUgcHJlc2V0IGhhcyBiZWVuIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LiBZb3UgbmVlZCB0byByZWxvYWQgT2JzaWRpYW4gZm9yIGFsbCBjaGFuZ2VzIHRvIHRha2UgZWZmZWN0LicgfSk7XG5cdFx0Y29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgQSBiYWNrdXAgb2YgeW91ciBvcmlnaW5hbCBjb25maWd1cmF0aW9uIGZvbGRlciB3YXMgY3JlYXRlZCBhdDogJHt0aGlzLmJhY2t1cFBhdGh9YCB9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcblx0XHRcdC5zZXROYW1lKCdEZWxldGUgYmFja3VwIGFuZCByZWxvYWQnKVxuXHRcdFx0LnNldERlc2MoJ1JlbW92ZSB0aGUgYmFja3VwIGZvbGRlciBhbmQgcmVsb2FkIE9ic2lkaWFuLiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBcImNsZWFuXCIgb3B0aW9uLicpXG5cdFx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0RlbGV0ZSBhbmQgcmVsb2FkJylcblx0XHRcdFx0LnNldEN0YSgpXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHRcdFx0dGhpcy5vbkNvbmZpcm0odHJ1ZSk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcblx0XHRcdC5zZXROYW1lKCdLZWVwIGJhY2t1cCBhbmQgcmVsb2FkJylcblx0XHRcdC5zZXREZXNjKCdLZWVwIHRoZSBiYWNrdXAgZm9sZGVyIGZvciBzYWZldHkgYW5kIHJlbG9hZCBPYnNpZGlhbi4nKVxuXHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdLZWVwIGFuZCByZWxvYWQnKVxuXHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0XHRcdHRoaXMub25Db25maXJtKGZhbHNlKTtcblx0XHRcdFx0fSkpO1xuXHR9XG5cblx0b25DbG9zZSgpIHtcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcblx0fVxufVxuIiwgImltcG9ydCB7IFNldHVwV2l6YXJkTW9kYWwgfSBmcm9tICcuLi91aS9TZXR1cFdpemFyZE1vZGFsJztcclxuaW1wb3J0IHsgSGVhbHRoQ2hlY2tNb2RhbCB9IGZyb20gJy4uL3VpL0hlYWx0aENoZWNrTW9kYWwnO1xyXG5pbXBvcnQgVmF1bHRDTVNQbHVnaW4gZnJvbSAnLi4vbWFpbic7XHJcbmltcG9ydCB7IFByZXNldE1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9QcmVzZXRNYW5hZ2VyJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbW1hbmRzKHBsdWdpbjogVmF1bHRDTVNQbHVnaW4pOiB2b2lkIHtcclxuXHRwbHVnaW4uYWRkQ29tbWFuZCh7XHJcblx0XHRpZDogJ29wZW4td2l6YXJkJyxcclxuXHRcdG5hbWU6ICdPcGVuIHNldHVwIHdpemFyZCcsXHJcblx0XHRjYWxsYmFjazogKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB3aXphcmQgPSBuZXcgU2V0dXBXaXphcmRNb2RhbChwbHVnaW4uYXBwLCBwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbik7XHJcblx0XHRcdC8vIE5vdGU6IHNldFNhdmVDYWxsYmFjayBpcyBkZXByZWNhdGVkIC0gc3RhdGUgaXMgbm93IG1hbmFnZWQgYXV0b21hdGljYWxseSBieSBTZXR1cFdpemFyZE1vZGFsXHJcblx0XHRcdHdpemFyZC5vcGVuKCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHBsdWdpbi5hZGRDb21tYW5kKHtcclxuXHRcdGlkOiAnaGVhbHRoLWNoZWNrJyxcclxuXHRcdG5hbWU6ICdDaGVjayBWYXVsdCBDTVMgc2V0dXAnLFxyXG5cdFx0Y2FsbGJhY2s6ICgpID0+IHtcclxuXHRcdFx0Y29uc3QgaGVhbHRoQ2hlY2sgPSBuZXcgSGVhbHRoQ2hlY2tNb2RhbChwbHVnaW4uYXBwLCBwbHVnaW4pO1xyXG5cdFx0XHRoZWFsdGhDaGVjay5vcGVuKCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHBsdWdpbi5hZGRDb21tYW5kKHtcclxuXHRcdGlkOiAnZG93bmxvYWQtYXBwbHktcHJlc2V0JyxcclxuXHRcdG5hbWU6ICdEb3dubG9hZCBhbmQgYXBwbHkgcHJlc2V0JyxcclxuXHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgUHJlc2V0TWFuYWdlcihwbHVnaW4uYXBwKTtcclxuXHRcdFx0YXdhaXQgbWFuYWdlci5hcHBseVByZXNldChwbHVnaW4uc2V0dGluZ3MucHJlc2V0c1JlcG8sIHBsdWdpbi5zZXR0aW5ncy5wcmVzZXROYW1lKTtcclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQ0Esc0JBQ0EsYUFDQUMsT0FDQUMsS0FFTSxXQU9PO0FBYmI7QUFBQTtBQUFBLElBQUFGLG9CQUE0QztBQUM1QywyQkFBcUI7QUFDckIsa0JBQTBCO0FBQzFCLElBQUFDLFFBQXNCO0FBQ3RCLElBQUFDLE1BQW9CO0FBRXBCLElBQU0sZ0JBQVksdUJBQVUseUJBQUk7QUFPekIsSUFBTSxhQUFOLE1BQWlC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QWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbEM7QUFDRDsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiZnMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicmVzb2x2ZSIsICJyZWxhdGl2ZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJmcyIsICJwYXRoIiwgImZzIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgImZzIiwgInNldENzc1Byb3BzIiwgInJlc29sdmUiLCAiX2EiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiaW1wb3J0X29ic2lkaWFuIiwgInRpbWVzdGFtcCIsICJyZWxhdGl2ZSIsICJzZXRDc3NQcm9wcyIsICJwYXRoIiwgImltcG9ydGVkVHlwZXMiLCAiY29udGVudCIsICJkYXRhIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJyZXMiLCAicmVzIiwgIl9hIiwgIm1hcCIsICJzY2hlbWEiLCAibm9kZSIsICJzY2hlbWEiLCAicGF0aCIsICJpIiwgImVuZCIsICJpc0Jsb2NrIiwgIl9hIiwgIm1hcCIsICJ2YWx1ZSIsICJtYXAiLCAic2NoZW1hIiwgInN0cmluZ2lmeSIsICJjb21tZW50IiwgInN0ciIsICJzY2hlbWEiLCAibWFwIiwgIm1hcCIsICJzY2hlbWEiLCAic2NoZW1hIiwgInNlcSIsICJzZXEiLCAic2NoZW1hIiwgImludElkZW50aWZ5IiwgInNjaGVtYSIsICJzZXEiLCAic2NoZW1hIiwgInBhaXJzIiwgIm1hcCIsICJzY2hlbWEiLCAicGFpcnMiLCAib21hcCIsICJzZXEiLCAiZmxvYXROYU4iLCAiZmxvYXRFeHAiLCAiZmxvYXQiLCAiaW50SWRlbnRpZnkiLCAiaW50UmVzb2x2ZSIsICJuIiwgImludFN0cmluZ2lmeSIsICJpbnRPY3QiLCAiaW50IiwgImludEhleCIsICJzY2hlbWEiLCAic2V0IiwgIm1hcCIsICJyZXMiLCAic2NoZW1hIiwgImludE9jdCIsICJpbnQiLCAiaW50SGV4IiwgImZsb2F0TmFOIiwgImZsb2F0RXhwIiwgImZsb2F0IiwgInNjaGVtYSIsICJ0YWdzIiwgIm1lcmdlIiwgInNjaGVtYSIsICJwYXRoIiwgInJlcyIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgIm1hcCIsICJzZXAiLCAiY29tcG9zZU5vZGUiLCAiY29tcG9zZUVtcHR5Tm9kZSIsICJzZXEiLCAic2VwIiwgImNvbXBvc2VOb2RlIiwgImNvbXBvc2VFbXB0eU5vZGUiLCAiaXNNYXAiLCAic2VwIiwgIm1hcCIsICJDTiIsICJ2YWx1ZSIsICJlbmQiLCAic2VwIiwgInNlcCIsICJzY2hlbWEiLCAidGFnIiwgIl9hIiwgIkJSRUFLIiwgIlNLSVAiLCAiUkVNT1ZFIiwgInZpc2l0IiwgInBhdGgiLCAiU0NBTEFSIiwgIlNDQUxBUiIsICJpIiwgImNoIiwgIlNDQUxBUiIsICJzZXAiLCAibWFwIiwgInN0YXJ0IiwgImZzIiwgInNlcSIsICJwYXJzZSIsICJwYXJzZSIsICJzZXRDc3NQcm9wcyIsICJleGFtcGxlIiwgInZhbHVlIiwgImRldGVjdGVkIiwgInBhdGhSZXNvbHZlciIsICJmb2xkZXJQYXRoIiwgImFnZ3JlZ2F0ZVByb3BzIiwgImltcG9ydF9vYnNpZGlhbiIsICJzZXRDc3NQcm9wcyIsICJfYSIsICJpbXBvcnRfb2JzaWRpYW4iLCAic2V0Q3NzUHJvcHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgImZzIiwgInNldENzc1Byb3BzIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGFyc2UiLCAicmVzb2x2ZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgIl9hIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAic2V0Q3NzUHJvcHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgIkdpdE1hbmFnZXIiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJ0aW1lc3RhbXAiLCAiR2l0TWFuYWdlciIsICJwYXRoIl0KfQo=
