/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZenMode
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  zenMode: false,
  leftSidebar: false,
  rightSidebar: false,
  fullscreen: false,
  exitButtonVisibility: "always",
  autoHideButtonOnDesktop: false,
  hideProperties: false,
  hideInlineTitle: false,
  topPadding: 0,
  bottomPadding: 0,
  focusedFileMode: false,
  hideStatusBar: false,
  hideLinkedMentions: false,
  hideScrollBar: false
};

// src/settings-tab.ts
var import_obsidian2 = require("obsidian");

// src/utils/settings-compat.ts
var import_obsidian = require("obsidian");
var ObsidianModule = __toESM(require("obsidian"), 1);
function createSettingsGroup(containerEl, heading, manifestId) {
  if ((0, import_obsidian.requireApiVersion)("1.11.0")) {
    const SettingGroupClass = ObsidianModule.SettingGroup;
    if (SettingGroupClass) {
      const group = heading ? new SettingGroupClass(containerEl).setHeading(heading) : new SettingGroupClass(containerEl);
      return {
        addSetting(cb) {
          group.addSetting(cb);
        }
      };
    }
  }
  if (manifestId) {
    containerEl.addClass(`${manifestId}-settings-compat`);
  }
  {
    if (heading) {
      const headingEl = containerEl.createDiv("setting-group-heading");
      headingEl.createEl("h3", { text: heading });
    }
    return {
      addSetting(cb) {
        const setting = new import_obsidian.Setting(containerEl);
        cb(setting);
      }
    };
  }
}

// src/settings-tab.ts
var ZenModeSettingTab = class extends import_obsidian2.PluginSettingTab {
  /**
   * Creates a new settings tab instance.
   * @param app - The Obsidian app instance
   * @param plugin - The Zen Mode plugin instance
   */
  constructor(app, plugin) {
    super(app, plugin);
    this.icon = "lucide-expand";
    this.plugin = plugin;
  }
  /**
   * Displays the settings tab UI.
   * Creates all setting controls and registers change handlers.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const generalGroup = createSettingsGroup(
      containerEl,
      void 0,
      "zenmode"
    );
    generalGroup.addSetting((setting) => {
      setting.setName("Full screen").setDesc(
        "Automatically enter fullscreen when enabling zen mode."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.fullscreen).onChange((value) => {
          this.plugin.settings.fullscreen = value;
          void this.plugin.saveSettings();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Show zen mode exit button").setDesc(
        "When to show the exit button in zen mode. You can also exit via the command palette, by pressing esc, or by assigning a hotkey to the 'toggle zen mode' command."
      ).addDropdown(
        (dropdown) => dropdown.addOption("always", "Always show").addOption("mobile-only", "Mobile only").addOption("never", "Never show").setValue(this.plugin.settings.exitButtonVisibility).onChange((value) => {
          this.plugin.settings.exitButtonVisibility = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Auto-hide zen mode exit button on desktop").setDesc(
        "When enabled, the exit button is hidden on desktop but reveals itself on hover as long as the zen mode exit button is on."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.autoHideButtonOnDesktop).onChange((value) => {
          this.plugin.settings.autoHideButtonOnDesktop = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Hide properties in zen mode").setDesc("Hide properties when zen mode is active.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.hideProperties).onChange((value) => {
          this.plugin.settings.hideProperties = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Hide inline title in zen mode").setDesc(
        "Hide the inline title (note title) when zen mode is active."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.hideInlineTitle).onChange((value) => {
          this.plugin.settings.hideInlineTitle = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Hide status bar in zen mode").setDesc("Hide the status bar when zen mode is active.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.hideStatusBar).onChange((value) => {
          this.plugin.settings.hideStatusBar = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Hide linked mentions in zen mode").setDesc("Hide linked mentions when zen mode is active.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.hideLinkedMentions).onChange((value) => {
          this.plugin.settings.hideLinkedMentions = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Hide scroll bar in zen mode").setDesc("Hide scroll bar when zen mode is active.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.hideScrollBar).onChange((value) => {
          this.plugin.settings.hideScrollBar = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Top padding").setDesc("Top padding in pixels (0-100).").addSlider(
        (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.topPadding).setDynamicTooltip().onChange((value) => {
          this.plugin.settings.topPadding = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Bottom padding").setDesc("Bottom padding in pixels (0-100).").addSlider(
        (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.bottomPadding).setDynamicTooltip().onChange((value) => {
          this.plugin.settings.bottomPadding = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Focused file mode").setDesc(
        "Only show the active file in zen mode, hide all other panes."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.focusedFileMode).onChange((value) => {
          this.plugin.settings.focusedFileMode = value;
          void this.plugin.saveSettings();
          this.plugin.refresh();
        })
      );
    });
  }
};

// src/utils/helpers.ts
function setCssProps(element, props) {
  Object.entries(props).forEach(([key, value]) => {
    const cssKey = key.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    element.style.setProperty(cssKey, value);
  });
}

// src/main.ts
var ZenMode = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    // Safe: always initialized in onload
    this.hasButton = false;
    this._isTogglingZen = false;
    this.visualViewportResizeHandler = null;
    this._hasShownInitialHighlight = false;
    this._highlightTimeouts = [];
    this._wasZenMode = false;
    this._tabContainersCache = null;
    /**
     * Refreshes the plugin state after settings changes.
     * Updates styles, sidebar visibility, button visibility, and focused file mode.
     */
    this.refresh = () => {
      this.updateStyle();
      this.setSidebarVisibility();
      this.setButtonVisibility();
      void this.updateFocusedFileMode();
    };
    /**
     * Updates CSS classes and data attributes based on current zen mode settings.
     * Applies zen mode styling, padding, and feature flags to the document body.
     */
    this.updateStyle = () => {
      document.body.classList.toggle("zenmode-active", this.settings.zenMode);
      document.documentElement.style.setProperty(
        "--zen-mode-top-padding",
        `${this.settings.topPadding}px`
      );
      document.documentElement.style.setProperty(
        "--zen-mode-bottom-padding",
        `${this.settings.bottomPadding}px`
      );
      if (this.settings.zenMode) {
        document.body.classList.toggle(
          "zenmode-hide-properties",
          this.settings.hideProperties
        );
        document.body.classList.toggle(
          "zenmode-hide-status-bar",
          this.settings.hideStatusBar
        );
        document.body.classList.toggle(
          "zenmode-hide-linked-mentions",
          this.settings.hideLinkedMentions
        );
        document.body.classList.toggle(
          "zenmode-hide-scroll-bar",
          this.settings.hideScrollBar
        );
      } else {
        document.body.classList.remove("zenmode-hide-properties");
        document.body.classList.remove("zenmode-hide-status-bar");
        document.body.classList.remove("zenmode-hide-linked-mentions");
        document.body.classList.remove("zenmode-hide-scroll-bar");
      }
      if (this.settings.zenMode) {
        document.body.setAttribute(
          "data-zen-hide-inline-title",
          this.settings.hideInlineTitle.toString()
        );
        document.body.setAttribute(
          "data-zen-focused-file",
          this.settings.focusedFileMode.toString()
        );
      } else {
        document.body.removeAttribute("data-zen-hide-inline-title");
        document.body.removeAttribute("data-zen-focused-file");
      }
    };
  }
  /**
   * Called when the plugin is loaded.
   * Initializes settings, registers commands, ribbon icon, and event handlers.
   */
  async onload() {
    await this.loadSettings();
    this._wasZenMode = this.settings.zenMode;
    this.addSettingTab(new ZenModeSettingTab(this.app, this));
    this.addCommand({
      id: "toggle-zen-mode",
      name: "Toggle",
      callback: () => {
        void this.toggleZenMode();
      }
    });
    this.addRibbonIcon("expand", "Toggle zen mode", () => {
      void this.toggleZenMode();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        if (this.settings.zenMode && this.settings.focusedFileMode) {
          void this.updateFocusedFileMode();
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this._tabContainersCache = null;
        if (this.settings.zenMode && this.settings.focusedFileMode) {
          void this.updateFocusedFileMode();
        }
      })
    );
    this.registerDomEvent(document, "keydown", (evt) => {
      var _a;
      if (evt.key === "Escape" && this.settings.zenMode) {
        const target = evt.target;
        if (target) {
          const cmEditor = target.closest(".cm-editor");
          if (cmEditor) {
            const vault = this.app.vault;
            if (((_a = vault.config) == null ? void 0 : _a.vimMode) === true) {
              return;
            }
          }
          if (target instanceof HTMLTextAreaElement && target.className && target.className.includes("excalidraw")) {
            return;
          }
        }
        const activeModal = document.querySelector(".modal");
        if (!activeModal) {
          void this.toggleZenMode();
          evt.preventDefault();
        }
      }
    });
    this.refresh();
  }
  /**
   * Called when the plugin is unloaded.
   * Cleans up event listeners, timeouts, and removes the exit button.
   */
  onunload() {
    this._highlightTimeouts.forEach((id) => clearTimeout(id));
    if (this.buttonContainer) {
      this.buttonContainer.remove();
    }
    if (this.visualViewportResizeHandler && window.visualViewport) {
      window.visualViewport.removeEventListener(
        "resize",
        this.visualViewportResizeHandler
      );
    }
    if (this.settings.zenMode) {
      this.settings.zenMode = false;
      this.updateStyle();
      this.setSidebarVisibility();
      window.dispatchEvent(new Event("resize"));
    }
  }
  /**
   * Loads settings from disk, merging with default settings.
   */
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...loadedData };
  }
  /**
   * Saves current settings to disk.
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Manages sidebar visibility based on zen mode state.
   * When entering zen mode, saves current sidebar state and collapses sidebars.
   * When exiting zen mode, restores sidebars to their previous state.
   */
  setSidebarVisibility() {
    if (this.settings.zenMode === this._wasZenMode) {
      return;
    }
    const app = this.app;
    if (app.workspace.leftSplit == void 0 || app.workspace.rightSplit == void 0) {
      return;
    }
    if (!this.settings.zenMode) {
      if (!this.settings.leftSidebar) {
        app.workspace.leftSplit.expand();
      }
      if (!this.settings.rightSidebar) {
        app.workspace.rightSplit.expand();
      }
    } else {
      this.settings.rightSidebar = this.app.workspace.rightSplit.collapsed;
      this.settings.leftSidebar = this.app.workspace.leftSplit.collapsed;
      if (app.workspace.leftSplit.collapsed != this.settings.zenMode) {
        app.workspace.leftSplit.collapse();
      }
      if (app.workspace.rightSplit.collapsed != this.settings.zenMode) {
        app.workspace.rightSplit.collapse();
      }
    }
    this._wasZenMode = this.settings.zenMode;
  }
  /**
   * Creates the zen mode exit button and registers event listeners for positioning.
   * The button allows users to exit zen mode and adjusts position for mobile navigation bars.
   */
  createButton() {
    this.buttonContainer = document.createElement("div");
    this.buttonContainer.classList.add("zenmode-button");
    this.button = new import_obsidian3.ButtonComponent(this.buttonContainer);
    this.button.setIcon("shrink");
    this.button.onClick(() => {
      void this.toggleZenMode();
    });
    document.body.appendChild(this.buttonContainer);
    this.adjustButtonPosition();
    this.registerDomEvent(window, "resize", () => {
      this.adjustButtonPosition();
    });
    if (window.visualViewport) {
      this.visualViewportResizeHandler = () => {
        this.adjustButtonPosition();
      };
      window.visualViewport.addEventListener(
        "resize",
        this.visualViewportResizeHandler
      );
    }
  }
  /**
   * Adjusts the exit button position on mobile devices to account for navigation bars.
   * Calculates safe bottom offset using visual viewport API to handle Android navigation bars
   * that may not be detected by CSS safe-area-inset.
   */
  adjustButtonPosition() {
    var _a;
    if (!this.buttonContainer || !document.body.classList.contains("is-mobile")) {
      return;
    }
    const viewportHeight = ((_a = window.visualViewport) == null ? void 0 : _a.height) || window.innerHeight;
    const windowHeight = window.outerHeight;
    const navigationBarHeight = Math.max(0, windowHeight - viewportHeight);
    const minBottomOffset = 60;
    const calculatedOffset = Math.max(
      minBottomOffset,
      navigationBarHeight + 10
    );
    setCssProps(this.buttonContainer, { bottom: `${calculatedOffset}px` });
  }
  /**
   * Controls the visibility of the zen mode exit button based on settings.
   * Handles button creation, auto-hide behavior on desktop, and initial highlight animation.
   */
  setButtonVisibility() {
    const isMobile = document.body.classList.contains("is-mobile");
    const shouldShow = this.settings.zenMode && (this.settings.exitButtonVisibility === "always" || this.settings.exitButtonVisibility === "mobile-only" && isMobile);
    if (shouldShow) {
      if (!this.hasButton) {
        this.createButton();
        this.hasButton = true;
      }
      this.buttonContainer.classList.add("zenmode-button-visible");
      this.buttonContainer.classList.toggle(
        "zenmode-button-moved-up",
        !isMobile
      );
      if (this.settings.autoHideButtonOnDesktop && !isMobile && this.settings.exitButtonVisibility === "always") {
        this.buttonContainer.classList.add("zenmode-button-auto-hide");
        if (!this._hasShownInitialHighlight) {
          this.buttonContainer.classList.add(
            "zenmode-button-initial-highlight"
          );
          this._hasShownInitialHighlight = true;
          const timeout1 = window.setTimeout(() => {
            if (this.buttonContainer) {
              this.buttonContainer.classList.remove(
                "zenmode-button-initial-highlight"
              );
              const timeout2 = window.setTimeout(() => {
                if (this.buttonContainer) {
                  this.buttonContainer.classList.add(
                    "zenmode-button-fade-out"
                  );
                }
              }, 300);
              this._highlightTimeouts.push(timeout2);
            }
          }, 1500);
          this._highlightTimeouts.push(timeout1);
        }
      } else {
        this.buttonContainer.classList.remove(
          "zenmode-button-auto-hide"
        );
        this.buttonContainer.classList.remove(
          "zenmode-button-initial-highlight"
        );
        this.buttonContainer.classList.remove(
          "zenmode-button-fade-out"
        );
      }
      this.adjustButtonPosition();
    } else {
      if (this.hasButton) {
        this.buttonContainer.classList.remove(
          "zenmode-button-visible"
        );
      }
    }
  }
  /**
   * Helper function to get the tab container from a workspace leaf.
   * Returns null if the leaf doesn't have a valid container or tab container.
   */
  getTabContainerFromLeaf(leaf) {
    var _a;
    if (!leaf) return null;
    const leafWithContainer = leaf;
    const leafContainer = (_a = leafWithContainer.containerEl) != null ? _a : null;
    if (!leafContainer) return null;
    const tabContainer = leafContainer.closest(".workspace-tabs");
    if (!tabContainer || !(tabContainer instanceof HTMLElement))
      return null;
    return tabContainer;
  }
  /**
   * Finds and reveals a pinned tab if one exists.
   * This should be called BEFORE entering zen mode to prevent new tabs from being created.
   */
  async revealPinnedTabIfExists() {
    var _a;
    try {
      const markdownLeaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of markdownLeaves) {
        const leafWithPinned = leaf;
        let isPinned = false;
        if (leafWithPinned.pinned === true) {
          isPinned = true;
        } else if ((_a = leafWithPinned.view) == null ? void 0 : _a.getState) {
          const state = leafWithPinned.view.getState();
          if (state.pinned === true) {
            isPinned = true;
          }
        }
        const leafWithContainer = leaf;
        if (leafWithContainer.containerEl) {
          const tabHeader = leafWithContainer.containerEl.querySelector(
            ".workspace-tab-header"
          );
          if (tabHeader && tabHeader instanceof HTMLElement) {
            if (tabHeader.classList.contains("is-pinned") || tabHeader.hasAttribute("data-pinned")) {
              isPinned = true;
            }
          }
        }
        if (isPinned) {
          void this.app.workspace.revealLeaf(leaf);
          await new Promise((resolve) => {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => resolve());
            });
          });
          return;
        }
      }
    } catch (e) {
    }
  }
  /**
   * Helper function to find the active tab container by checking the DOM.
   * Looks for tabs with the 'is-active' class or visible active tab headers.
   */
  findActiveTabContainerFromDOM() {
    const activeTabHeader = document.querySelector(
      ".workspace-tab-header.is-active"
    );
    if (activeTabHeader) {
      const tabContainer = activeTabHeader.closest(".workspace-tabs");
      if (tabContainer && tabContainer instanceof HTMLElement) {
        return tabContainer;
      }
    }
    const allTabContainers = Array.from(
      document.querySelectorAll(".workspace-tabs")
    );
    for (const container of allTabContainers) {
      const el = container;
      if (el.offsetParent !== null && !el.classList.contains("zenmode-tab-hidden")) {
        return el;
      }
    }
    return null;
  }
  /**
   * Updates focused file mode visibility.
   * When enabled, hides all workspace tab containers except the one containing the active leaf,
   * showing only the currently focused file. When disabled, restores all tab containers.
   *
   * This method uses several fallback strategies to identify the active tab container:
   * 1. Pinned Tab Check (Method 0): Obsidian creates new tabs if the active one is pinned.
   *    We first check all containers for any pinned tabs to ensure we track the intended workspace.
   * 2. Recent Leaf (Method 1): Uses `getMostRecentLeaf()` to find where the user is currently working.
   * 3. DOM Detection (Method 1b): If API methods fail, scans the DOM for `.workspace-tab-header.is-active`.
   * 4. Visibility Fallback: If no active status is found, falls back to the first visible tab container.
   *
   * Uses caching for tab container DOM elements to avoid expensive re-scans on every leaf change.
   */
  async updateFocusedFileMode() {
    if (!this.settings.zenMode || !this.settings.focusedFileMode) {
      const allTabContainers2 = document.querySelectorAll(".workspace-tabs");
      allTabContainers2.forEach((container) => {
        const el = container;
        el.classList.remove("zenmode-tab-hidden");
        el.classList.remove("zenmode-tab-active");
        setCssProps(el, { display: "", width: "", flex: "" });
      });
      return;
    }
    await this.revealPinnedTabIfExists();
    if (!this._tabContainersCache) {
      this._tabContainersCache = Array.from(
        document.querySelectorAll(".workspace-tabs")
      );
    }
    const allTabContainers = this._tabContainersCache;
    let activeTabContainer = null;
    for (const container of allTabContainers) {
      const el = container;
      const pinnedTabs = Array.from(
        el.querySelectorAll(
          ".workspace-tab-header.is-pinned, .workspace-tab-header[data-pinned='true']"
        )
      );
      if (pinnedTabs.length > 0) {
        activeTabContainer = el;
        break;
      }
    }
    if (!activeTabContainer) {
      const mostRecentLeaf = this.app.workspace.getMostRecentLeaf();
      if (mostRecentLeaf) {
        activeTabContainer = this.getTabContainerFromLeaf(mostRecentLeaf);
      }
    }
    if (!activeTabContainer) {
      const activeTabFromDOM = this.findActiveTabContainerFromDOM();
      if (activeTabFromDOM) {
        activeTabContainer = activeTabFromDOM;
      }
    }
    if (!activeTabContainer) {
      return;
    }
    allTabContainers.forEach((tabContainer) => {
      const el = tabContainer;
      if (tabContainer === activeTabContainer) {
        el.classList.remove("zenmode-tab-hidden");
        setCssProps(el, {
          display: "",
          width: "100%",
          flex: "1 1 100%"
        });
      } else {
        el.classList.add("zenmode-tab-hidden");
        setCssProps(el, { display: "none" });
      }
    });
  }
  /**
   * Toggles zen mode on or off.
   * Handles fullscreen entry/exit if enabled, updates settings, and refreshes the UI.
   * Includes guard against concurrent invocations to prevent race conditions.
   */
  async toggleZenMode() {
    if (this._isTogglingZen) {
      return;
    }
    this._isTogglingZen = true;
    try {
      const enteringZenMode = !this.settings.zenMode;
      if (!enteringZenMode) {
        this._hasShownInitialHighlight = false;
      }
      if (enteringZenMode) {
        if (this.settings.focusedFileMode) {
          await this.revealPinnedTabIfExists();
        }
        if (this.settings.fullscreen && document.documentElement.requestFullscreen) {
          try {
            await document.documentElement.requestFullscreen();
            await new Promise(
              (resolve) => requestAnimationFrame(resolve)
            );
          } catch (e) {
          }
        }
        this.settings.zenMode = true;
        await this.saveSettings();
        this.refresh();
      } else {
        if (document.fullscreenElement && document.exitFullscreen) {
          try {
            await document.exitFullscreen();
            await new Promise(
              (resolve) => requestAnimationFrame(resolve)
            );
          } catch (e) {
          }
        }
        this.settings.zenMode = false;
        await this.saveSettings();
        this.refresh();
      }
    } finally {
      this._isTogglingZen = false;
    }
  }
};


/* nosourcemap */